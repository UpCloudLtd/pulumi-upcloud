{
    "name": "upcloud",
    "displayName": "UpCloud",
    "description": "A Pulumi package for creating and managing UpCloud resources.",
    "keywords": [
        "pulumi",
        "upcloud",
        "category/cloud"
    ],
    "homepage": "https://upcloud.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`upcloud` Terraform Provider](https://github.com/UpCloudLtd/terraform-provider-upcloud).",
    "repository": "https://github.com/UpCloudLtd/pulumi-upcloud",
    "logoUrl": "https://raw.githubusercontent.com/UpCloudLtd/pulumi-upcloud/refs/heads/main/provider/upcloud.png",
    "pluginDownloadURL": "github://api.github.com/UpCloudLtd/pulumi-upcloud",
    "publisher": "UpCloudLtd",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "upcloud": "UpCloud"
            },
            "compatibility": "tfbridge20",
            "rootNamespace": "UpCloud.Pulumi",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageName": "@upcloud/pulumi-upcloud",
            "packageDescription": "A Pulumi package for creating and managing UpCloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/UpCloudLtd/terraform-provider-upcloud)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-upcloud` repo](https://github.com/UpCloudLtd/pulumi-upcloud/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-upcloud` repo](https://github.com/UpCloudLtd/terraform-provider-upcloud/issues).",
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/UpCloudLtd/terraform-provider-upcloud)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-upcloud` repo](https://github.com/UpCloudLtd/pulumi-upcloud/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-upcloud` repo](https://github.com/UpCloudLtd/terraform-provider-upcloud/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "password": {
                "type": "string",
                "description": "Password for UpCloud API user. Can also be configured using the `UPCLOUD_PASSWORD` environment variable.\n"
            },
            "requestTimeoutSec": {
                "type": "integer",
                "description": "The duration (in seconds) that the provider waits for an HTTP request towards UpCloud API to complete. Defaults to 120\nseconds\n"
            },
            "retryMax": {
                "type": "integer",
                "description": "Maximum number of retries\n"
            },
            "retryWaitMaxSec": {
                "type": "integer",
                "description": "Maximum time to wait between retries\n"
            },
            "retryWaitMinSec": {
                "type": "integer",
                "description": "Minimum time to wait between retries\n"
            },
            "token": {
                "type": "string",
                "description": "Token for authenticating to UpCloud API. Can also be configured using the `UPCLOUD_TOKEN` environment variable.\n(EXPERIMENTAL)\n"
            },
            "username": {
                "type": "string",
                "description": "UpCloud username with API access. Can also be configured using the `UPCLOUD_USERNAME` environment variable.\n"
            }
        }
    },
    "types": {
        "upcloud:index/GatewayAddress:GatewayAddress": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "IP addresss\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the IP address\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "address",
                        "name"
                    ]
                }
            }
        },
        "upcloud:index/GatewayConnectionLocalRoute:GatewayConnectionLocalRoute": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the route\n"
                },
                "staticNetwork": {
                    "type": "string",
                    "description": "Destination prefix of the route; needs to be a valid IPv4 prefix\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of route; currently the only supported type is 'static'\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "staticNetwork"
            ]
        },
        "upcloud:index/GatewayConnectionRemoteRoute:GatewayConnectionRemoteRoute": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the route\n"
                },
                "staticNetwork": {
                    "type": "string",
                    "description": "Destination prefix of the route; needs to be a valid IPv4 prefix\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of route; currently the only supported type is 'static'\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "staticNetwork"
            ]
        },
        "upcloud:index/GatewayConnectionTunnelIpsecAuthPsk:GatewayConnectionTunnelIpsecAuthPsk": {
            "properties": {
                "psk": {
                    "type": "string",
                    "description": "The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "psk"
            ]
        },
        "upcloud:index/GatewayConnectionTunnelIpsecProperties:GatewayConnectionTunnelIpsecProperties": {
            "properties": {
                "childRekeyTime": {
                    "type": "integer",
                    "description": "IKE child SA rekey time in seconds.\n"
                },
                "dpdDelay": {
                    "type": "integer",
                    "description": "Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.\n"
                },
                "dpdTimeout": {
                    "type": "integer",
                    "description": "Timeout period for DPD reply before considering the peer to be dead, in seconds.\n"
                },
                "ikeLifetime": {
                    "type": "integer",
                    "description": "Maximum IKE SA lifetime in seconds.\n"
                },
                "phase1Algorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Phase 1: Proposal algorithms.\n"
                },
                "phase1DhGroupNumbers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of Phase 1 Diffie-Hellman group numbers.\n"
                },
                "phase1IntegrityAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Phase 1 integrity algorithms.\n"
                },
                "phase2Algorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Phase 2: Security Association algorithms.\n"
                },
                "phase2DhGroupNumbers": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of Phase 2 Diffie-Hellman group numbers.\n"
                },
                "phase2IntegrityAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Phase 2 integrity algorithms.\n"
                },
                "rekeyTime": {
                    "type": "integer",
                    "description": "IKE SA rekey time in seconds.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "childRekeyTime",
                        "dpdDelay",
                        "dpdTimeout",
                        "ikeLifetime",
                        "phase1Algorithms",
                        "phase1DhGroupNumbers",
                        "phase1IntegrityAlgorithms",
                        "phase2Algorithms",
                        "phase2DhGroupNumbers",
                        "phase2IntegrityAlgorithms",
                        "rekeyTime"
                    ]
                }
            }
        },
        "upcloud:index/GatewayRouter:GatewayRouter": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "ID of the router attached to the gateway.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "upcloud:index/KubernetesNodeGroupCustomPlan:KubernetesNodeGroupCustomPlan": {
            "properties": {
                "cores": {
                    "type": "integer",
                    "description": "The number of CPU cores dedicated to individual node group nodes when using custom plan\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.\n"
                },
                "storageSize": {
                    "type": "integer",
                    "description": "The size of the storage device in gigabytes.\n"
                },
                "storageTier": {
                    "type": "string",
                    "description": "The storage tier to use. Defaults to maxiops\n"
                }
            },
            "type": "object",
            "required": [
                "cores",
                "memory",
                "storageSize"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cores",
                        "memory",
                        "storageSize",
                        "storageTier"
                    ]
                }
            }
        },
        "upcloud:index/KubernetesNodeGroupKubeletArg:KubernetesNodeGroupKubeletArg": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Kubelet argument key.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Kubelet argument value.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "upcloud:index/KubernetesNodeGroupTaint:KubernetesNodeGroupTaint": {
            "properties": {
                "effect": {
                    "type": "string",
                    "description": "Taint effect.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Taint key.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Taint value.\n"
                }
            },
            "type": "object",
            "required": [
                "effect",
                "key",
                "value"
            ]
        },
        "upcloud:index/LoadbalancerBackendProperties:LoadbalancerBackendProperties": {
            "properties": {
                "healthCheckExpectedStatus": {
                    "type": "integer",
                    "description": "Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.\n"
                },
                "healthCheckFall": {
                    "type": "integer",
                    "description": "Sets how many failed health checks are allowed until the backend member is taken off from the rotation.\n"
                },
                "healthCheckInterval": {
                    "type": "integer",
                    "description": "Interval between health checks in seconds.\n"
                },
                "healthCheckRise": {
                    "type": "integer",
                    "description": "Sets how many successful health checks are required to put the backend member back into rotation.\n"
                },
                "healthCheckTlsVerify": {
                    "type": "boolean",
                    "description": "Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.\n"
                },
                "healthCheckType": {
                    "type": "string",
                    "description": "Health check type.\n"
                },
                "healthCheckUrl": {
                    "type": "string",
                    "description": "Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.\n"
                },
                "http2Enabled": {
                    "type": "boolean",
                    "description": "Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.\n"
                },
                "outboundProxyProtocol": {
                    "type": "string",
                    "description": "Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.\n"
                },
                "stickySessionCookieName": {
                    "type": "string",
                    "description": "Sets sticky session cookie name. Empty string disables sticky session.\n"
                },
                "timeoutServer": {
                    "type": "integer",
                    "description": "Backend server timeout in seconds.\n"
                },
                "timeoutTunnel": {
                    "type": "integer",
                    "description": "Maximum inactivity time on the client and server side for tunnels in seconds.\n"
                },
                "tlsEnabled": {
                    "type": "boolean",
                    "description": "Enables TLS connection from the load balancer to backend servers.\n"
                },
                "tlsUseSystemCa": {
                    "type": "boolean",
                    "description": "If enabled, then the system CA certificate bundle will be used for the certificate verification.\n"
                },
                "tlsVerify": {
                    "type": "boolean",
                    "description": "Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "healthCheckExpectedStatus",
                        "healthCheckFall",
                        "healthCheckInterval",
                        "healthCheckRise",
                        "healthCheckTlsVerify",
                        "healthCheckType",
                        "healthCheckUrl",
                        "http2Enabled",
                        "outboundProxyProtocol",
                        "stickySessionCookieName",
                        "timeoutServer",
                        "timeoutTunnel",
                        "tlsEnabled",
                        "tlsUseSystemCa",
                        "tlsVerify"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendNetwork:LoadbalancerFrontendNetwork": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the load balancer network.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "upcloud:index/LoadbalancerFrontendProperties:LoadbalancerFrontendProperties": {
            "properties": {
                "http2Enabled": {
                    "type": "boolean",
                    "description": "Enable or disable HTTP/2 support.\n"
                },
                "inboundProxyProtocol": {
                    "type": "boolean",
                    "description": "Enable or disable inbound proxy protocol support.\n"
                },
                "timeoutClient": {
                    "type": "integer",
                    "description": "Client request timeout in seconds.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "http2Enabled",
                        "inboundProxyProtocol",
                        "timeoutClient"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleActions:LoadbalancerFrontendRuleActions": {
            "properties": {
                "httpRedirects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActionsHttpRedirect:LoadbalancerFrontendRuleActionsHttpRedirect"
                    },
                    "description": "Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.\n"
                },
                "httpReturns": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActionsHttpReturn:LoadbalancerFrontendRuleActionsHttpReturn"
                    },
                    "description": "Returns HTTP response with specified HTTP status.\n"
                },
                "setForwardedHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActionsSetForwardedHeader:LoadbalancerFrontendRuleActionsSetForwardedHeader"
                    },
                    "description": "Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests\n"
                },
                "setRequestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActionsSetRequestHeader:LoadbalancerFrontendRuleActionsSetRequestHeader"
                    },
                    "description": "Set request header\n"
                },
                "setResponseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActionsSetResponseHeader:LoadbalancerFrontendRuleActionsSetResponseHeader"
                    },
                    "description": "Set response header\n"
                },
                "tcpRejects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActionsTcpReject:LoadbalancerFrontendRuleActionsTcpReject"
                    },
                    "description": "Terminates a connection.\n"
                },
                "useBackends": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActionsUseBackend:LoadbalancerFrontendRuleActionsUseBackend"
                    },
                    "description": "Routes traffic to specified `backend`.\n"
                }
            },
            "type": "object"
        },
        "upcloud:index/LoadbalancerFrontendRuleActionsHttpRedirect:LoadbalancerFrontendRuleActionsHttpRedirect": {
            "properties": {
                "location": {
                    "type": "string",
                    "description": "Target location.\n"
                },
                "scheme": {
                    "type": "string",
                    "description": "Target scheme.\n"
                },
                "status": {
                    "type": "integer",
                    "description": "HTTP status code.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "status"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleActionsHttpReturn:LoadbalancerFrontendRuleActionsHttpReturn": {
            "properties": {
                "contentType": {
                    "type": "string",
                    "description": "Content type.\n"
                },
                "payload": {
                    "type": "string",
                    "description": "The payload.\n"
                },
                "status": {
                    "type": "integer",
                    "description": "HTTP status code.\n"
                }
            },
            "type": "object",
            "required": [
                "contentType",
                "payload",
                "status"
            ]
        },
        "upcloud:index/LoadbalancerFrontendRuleActionsSetForwardedHeader:LoadbalancerFrontendRuleActionsSetForwardedHeader": {
            "properties": {
                "active": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "active"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleActionsSetRequestHeader:LoadbalancerFrontendRuleActionsSetRequestHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "Header name.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Header value.\n"
                }
            },
            "type": "object",
            "required": [
                "header"
            ]
        },
        "upcloud:index/LoadbalancerFrontendRuleActionsSetResponseHeader:LoadbalancerFrontendRuleActionsSetResponseHeader": {
            "properties": {
                "header": {
                    "type": "string",
                    "description": "Header name.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Header value.\n"
                }
            },
            "type": "object",
            "required": [
                "header"
            ]
        },
        "upcloud:index/LoadbalancerFrontendRuleActionsTcpReject:LoadbalancerFrontendRuleActionsTcpReject": {
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Indicates if the rule is active.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "active"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleActionsUseBackend:LoadbalancerFrontendRuleActionsUseBackend": {
            "properties": {
                "backendName": {
                    "type": "string",
                    "description": "The name of the backend where traffic will be routed.\n"
                }
            },
            "type": "object",
            "required": [
                "backendName"
            ]
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchers:LoadbalancerFrontendRuleMatchers": {
            "properties": {
                "bodySizeRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersBodySizeRange:LoadbalancerFrontendRuleMatchersBodySizeRange"
                    },
                    "description": "Matches by range of HTTP request body sizes.\n"
                },
                "bodySizes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersBodySize:LoadbalancerFrontendRuleMatchersBodySize"
                    },
                    "description": "Matches by HTTP request body size.\n"
                },
                "cookies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersCookie:LoadbalancerFrontendRuleMatchersCookie"
                    },
                    "description": "Matches by HTTP cookie value. Cookie name must be provided.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersHeader:LoadbalancerFrontendRuleMatchersHeader"
                    },
                    "description": "Matches by HTTP header value. Header name must be provided.\n",
                    "deprecationMessage": "Use `request_header` instead."
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersHost:LoadbalancerFrontendRuleMatchersHost"
                    },
                    "description": "Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.\n"
                },
                "httpMethods": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersHttpMethod:LoadbalancerFrontendRuleMatchersHttpMethod"
                    },
                    "description": "Matches by HTTP method.\n"
                },
                "httpStatusRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersHttpStatusRange:LoadbalancerFrontendRuleMatchersHttpStatusRange"
                    },
                    "description": "Matches by range of HTTP statuses.\n"
                },
                "httpStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersHttpStatus:LoadbalancerFrontendRuleMatchersHttpStatus"
                    },
                    "description": "Matches by HTTP status.\n"
                },
                "numMembersUps": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersNumMembersUp:LoadbalancerFrontendRuleMatchersNumMembersUp"
                    },
                    "description": "Matches by number of healthy backend members.\n"
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersPath:LoadbalancerFrontendRuleMatchersPath"
                    },
                    "description": "Matches by URL path.\n"
                },
                "requestHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersRequestHeader:LoadbalancerFrontendRuleMatchersRequestHeader"
                    },
                    "description": "Matches by HTTP request header value. Header name must be provided.\n"
                },
                "responseHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersResponseHeader:LoadbalancerFrontendRuleMatchersResponseHeader"
                    },
                    "description": "Matches by HTTP response header value. Header name must be provided.\n"
                },
                "srcIps": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersSrcIp:LoadbalancerFrontendRuleMatchersSrcIp"
                    },
                    "description": "Matches by source IP address.\n"
                },
                "srcPortRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersSrcPortRange:LoadbalancerFrontendRuleMatchersSrcPortRange"
                    },
                    "description": "Matches by range of source port numbers.\n"
                },
                "srcPorts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersSrcPort:LoadbalancerFrontendRuleMatchersSrcPort"
                    },
                    "description": "Matches by source port number.\n"
                },
                "urlParams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersUrlParam:LoadbalancerFrontendRuleMatchersUrlParam"
                    },
                    "description": "Matches by URL query parameter value. Query parameter name must be provided\n"
                },
                "urlQueries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersUrlQuery:LoadbalancerFrontendRuleMatchersUrlQuery"
                    },
                    "description": "Matches by URL query string.\n"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchersUrl:LoadbalancerFrontendRuleMatchersUrl"
                    },
                    "description": "Matches by URL without schema, e.g. `example.com/dashboard`.\n"
                }
            },
            "type": "object"
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersBodySize:LoadbalancerFrontendRuleMatchersBodySize": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Integer value.\n"
                }
            },
            "type": "object",
            "required": [
                "method",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "method",
                        "value"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersBodySizeRange:LoadbalancerFrontendRuleMatchersBodySizeRange": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "rangeEnd": {
                    "type": "integer",
                    "description": "Integer value.\n"
                },
                "rangeStart": {
                    "type": "integer",
                    "description": "Integer value.\n"
                }
            },
            "type": "object",
            "required": [
                "rangeEnd",
                "rangeStart"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "rangeEnd",
                        "rangeStart"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersCookie:LoadbalancerFrontendRuleMatchersCookie": {
            "properties": {
                "ignoreCase": {
                    "type": "boolean",
                    "description": "Defines if case should be ignored. Defaults to `false`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the argument.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "method",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ignoreCase",
                        "inverse",
                        "method",
                        "name"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersHeader:LoadbalancerFrontendRuleMatchersHeader": {
            "properties": {
                "ignoreCase": {
                    "type": "boolean",
                    "description": "Defines if case should be ignored. Defaults to `false`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the argument.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "method",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ignoreCase",
                        "inverse",
                        "method",
                        "name"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersHost:LoadbalancerFrontendRuleMatchersHost": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "value"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersHttpMethod:LoadbalancerFrontendRuleMatchersHttpMethod": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).\n"
                }
            },
            "type": "object",
            "required": [
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "value"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersHttpStatus:LoadbalancerFrontendRuleMatchersHttpStatus": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Integer value.\n"
                }
            },
            "type": "object",
            "required": [
                "method",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "method",
                        "value"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersHttpStatusRange:LoadbalancerFrontendRuleMatchersHttpStatusRange": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "rangeEnd": {
                    "type": "integer",
                    "description": "Integer value.\n"
                },
                "rangeStart": {
                    "type": "integer",
                    "description": "Integer value.\n"
                }
            },
            "type": "object",
            "required": [
                "rangeEnd",
                "rangeStart"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "rangeEnd",
                        "rangeStart"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersNumMembersUp:LoadbalancerFrontendRuleMatchersNumMembersUp": {
            "properties": {
                "backendName": {
                    "type": "string",
                    "description": "The name of the `backend`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Integer value.\n"
                }
            },
            "type": "object",
            "required": [
                "backendName",
                "method",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "backendName",
                        "inverse",
                        "method",
                        "value"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersPath:LoadbalancerFrontendRuleMatchersPath": {
            "properties": {
                "ignoreCase": {
                    "type": "boolean",
                    "description": "Defines if case should be ignored. Defaults to `false`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "method"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ignoreCase",
                        "inverse",
                        "method"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersRequestHeader:LoadbalancerFrontendRuleMatchersRequestHeader": {
            "properties": {
                "ignoreCase": {
                    "type": "boolean",
                    "description": "Defines if case should be ignored. Defaults to `false`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the argument.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "method",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ignoreCase",
                        "inverse",
                        "method",
                        "name"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersResponseHeader:LoadbalancerFrontendRuleMatchersResponseHeader": {
            "properties": {
                "ignoreCase": {
                    "type": "boolean",
                    "description": "Defines if case should be ignored. Defaults to `false`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the argument.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "method",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ignoreCase",
                        "inverse",
                        "method",
                        "name"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersSrcIp:LoadbalancerFrontendRuleMatchersSrcIp": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "value": {
                    "type": "string",
                    "description": "IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.\n"
                }
            },
            "type": "object",
            "required": [
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "value"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersSrcPort:LoadbalancerFrontendRuleMatchersSrcPort": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Integer value.\n"
                }
            },
            "type": "object",
            "required": [
                "method",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "method",
                        "value"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersSrcPortRange:LoadbalancerFrontendRuleMatchersSrcPortRange": {
            "properties": {
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "rangeEnd": {
                    "type": "integer",
                    "description": "Integer value.\n"
                },
                "rangeStart": {
                    "type": "integer",
                    "description": "Integer value.\n"
                }
            },
            "type": "object",
            "required": [
                "rangeEnd",
                "rangeStart"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "inverse",
                        "rangeEnd",
                        "rangeStart"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersUrl:LoadbalancerFrontendRuleMatchersUrl": {
            "properties": {
                "ignoreCase": {
                    "type": "boolean",
                    "description": "Defines if case should be ignored. Defaults to `false`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "method"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ignoreCase",
                        "inverse",
                        "method"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersUrlParam:LoadbalancerFrontendRuleMatchersUrlParam": {
            "properties": {
                "ignoreCase": {
                    "type": "boolean",
                    "description": "Defines if case should be ignored. Defaults to `false`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the argument.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "method",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ignoreCase",
                        "inverse",
                        "method",
                        "name"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerFrontendRuleMatchersUrlQuery:LoadbalancerFrontendRuleMatchersUrlQuery": {
            "properties": {
                "ignoreCase": {
                    "type": "boolean",
                    "description": "Defines if case should be ignored. Defaults to `false`.\n"
                },
                "inverse": {
                    "type": "boolean",
                    "description": "Defines if the condition should be inverted. Works similarly to logical NOT operator.\n"
                },
                "method": {
                    "type": "string",
                    "description": "Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.\n"
                },
                "value": {
                    "type": "string",
                    "description": "String value.\n"
                }
            },
            "type": "object",
            "required": [
                "method"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ignoreCase",
                        "inverse",
                        "method"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerNetwork:LoadbalancerNetwork": {
            "properties": {
                "dnsName": {
                    "type": "string",
                    "description": "DNS name of the load balancer network\n"
                },
                "family": {
                    "type": "string",
                    "description": "Network family. Currently only `IPv4` is supported.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique identifier of the network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network. Must be unique within the service.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network. Only one public network can be attached and at least one private network must be attached.\n"
                }
            },
            "type": "object",
            "required": [
                "family",
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dnsName",
                        "family",
                        "id",
                        "name",
                        "type"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerNode:LoadbalancerNode": {
            "properties": {
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerNodeNetwork:LoadbalancerNodeNetwork"
                    },
                    "description": "Networks attached to the node\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "Node's operational state. Managed by the system.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "networks",
                        "operationalState"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerNodeNetwork:LoadbalancerNodeNetwork": {
            "properties": {
                "ipAddresses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerNodeNetworkIpAddress:LoadbalancerNodeNetworkIpAddress"
                    },
                    "description": "IP addresses attached to the network\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ipAddresses",
                        "name",
                        "type"
                    ]
                }
            }
        },
        "upcloud:index/LoadbalancerNodeNetworkIpAddress:LoadbalancerNodeNetworkIpAddress": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Node's IP address\n"
                },
                "listen": {
                    "type": "boolean",
                    "description": "Whether the node listens to the traffic\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "address",
                        "listen"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseMysqlComponent:ManagedDatabaseMysqlComponent": {
            "properties": {
                "component": {
                    "type": "string",
                    "description": "Type of the component\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname of the component\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the component\n"
                },
                "route": {
                    "type": "string",
                    "description": "Component network route type\n"
                },
                "usage": {
                    "type": "string",
                    "description": "Usage of the component\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "component",
                        "host",
                        "port",
                        "route",
                        "usage"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseMysqlNetwork:ManagedDatabaseMysqlNetwork": {
            "properties": {
                "family": {
                    "type": "string",
                    "description": "Network family. Currently only `IPv4` is supported.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network. Must be unique within the service.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network. Must be private.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Private network UUID. Must reside in the same zone as the database.\n"
                }
            },
            "type": "object",
            "required": [
                "family",
                "name",
                "type",
                "uuid"
            ]
        },
        "upcloud:index/ManagedDatabaseMysqlNodeState:ManagedDatabaseMysqlNodeState": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name plus a node iteration\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role of the node\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the node\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "role",
                        "state"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseMysqlProperties:ManagedDatabaseMysqlProperties": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "adminUsername": {
                    "type": "string",
                    "description": "Custom username for admin user. This must be set only when a new service is being created.\n",
                    "willReplaceOnChanges": true
                },
                "automaticUtilityNetworkIpFilter": {
                    "type": "boolean",
                    "description": "Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.\n"
                },
                "backupHour": {
                    "type": "integer",
                    "description": "The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.\n"
                },
                "backupMinute": {
                    "type": "integer",
                    "description": "The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.\n"
                },
                "binlogRetentionPeriod": {
                    "type": "integer",
                    "description": "The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.\n"
                },
                "connectTimeout": {
                    "type": "integer",
                    "description": "The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.\n"
                },
                "defaultTimeZone": {
                    "type": "string",
                    "description": "Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.\n"
                },
                "groupConcatMaxLen": {
                    "type": "integer",
                    "description": "The maximum permitted result length in bytes for the GROUP_CONCAT() function.\n"
                },
                "informationSchemaStatsExpiry": {
                    "type": "integer",
                    "description": "The time, in seconds, before cached statistics expire.\n"
                },
                "innodbChangeBufferMaxSize": {
                    "type": "integer",
                    "description": "Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.\n"
                },
                "innodbFlushNeighbors": {
                    "type": "integer",
                    "description": "Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.\n"
                },
                "innodbFtMinTokenSize": {
                    "type": "integer",
                    "description": "Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.\n"
                },
                "innodbFtServerStopwordTable": {
                    "type": "string",
                    "description": "This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.\n"
                },
                "innodbLockWaitTimeout": {
                    "type": "integer",
                    "description": "The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.\n"
                },
                "innodbLogBufferSize": {
                    "type": "integer",
                    "description": "The size in bytes of the buffer that InnoDB uses to write to the log files on disk.\n"
                },
                "innodbOnlineAlterLogMaxSize": {
                    "type": "integer",
                    "description": "The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.\n"
                },
                "innodbPrintAllDeadlocks": {
                    "type": "boolean",
                    "description": "When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.\n"
                },
                "innodbReadIoThreads": {
                    "type": "integer",
                    "description": "The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.\n"
                },
                "innodbRollbackOnTimeout": {
                    "type": "boolean",
                    "description": "When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.\n"
                },
                "innodbThreadConcurrency": {
                    "type": "integer",
                    "description": "Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).\n"
                },
                "innodbWriteIoThreads": {
                    "type": "integer",
                    "description": "The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.\n"
                },
                "interactiveTimeout": {
                    "type": "integer",
                    "description": "The number of seconds the server waits for activity on an interactive connection before closing it.\n"
                },
                "internalTmpMemStorageEngine": {
                    "type": "string",
                    "description": "The storage engine for in-memory internal temporary tables.\n"
                },
                "ipFilters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.\n"
                },
                "logOutput": {
                    "type": "string",
                    "description": "The slow log output destination when slow_query_log is ON. To enable MySQL AI Insights, choose INSIGHTS. To use MySQL AI Insights and the mysql.slow_log table at the same time, choose INSIGHTS,TABLE. To only use the mysql.slow_log table, choose TABLE. To silence slow logs, choose NONE.\n"
                },
                "longQueryTime": {
                    "type": "number",
                    "description": "The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute.\n"
                },
                "maxAllowedPacket": {
                    "type": "integer",
                    "description": "Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).\n"
                },
                "maxHeapTableSize": {
                    "type": "integer",
                    "description": "Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).\n"
                },
                "migration": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlPropertiesMigration:ManagedDatabaseMysqlPropertiesMigration",
                    "description": "Migrate data from existing server.\n"
                },
                "netBufferLength": {
                    "type": "integer",
                    "description": "Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.\n"
                },
                "netReadTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to wait for more data from a connection before aborting the read.\n"
                },
                "netWriteTimeout": {
                    "type": "integer",
                    "description": "The number of seconds to wait for a block to be written to a connection before aborting the write.\n"
                },
                "publicAccess": {
                    "type": "boolean",
                    "description": "Public Access. Allow access to the service from the public Internet.\n"
                },
                "serviceLog": {
                    "type": "boolean",
                    "description": "Service logging. Store logs for the service so that they are available in the HTTP API and console.\n"
                },
                "slowQueryLog": {
                    "type": "boolean",
                    "description": "Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table.\n"
                },
                "sortBufferSize": {
                    "type": "integer",
                    "description": "Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).\n"
                },
                "sqlMode": {
                    "type": "string",
                    "description": "Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.\n"
                },
                "sqlRequirePrimaryKey": {
                    "type": "boolean",
                    "description": "Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.\n"
                },
                "tmpTableSize": {
                    "type": "integer",
                    "description": "Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).\n"
                },
                "version": {
                    "type": "string",
                    "description": "MySQL major version.\n"
                },
                "waitTimeout": {
                    "type": "integer",
                    "description": "The number of seconds the server waits for activity on a noninteractive connection before closing it.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "adminPassword",
                        "adminUsername",
                        "backupHour",
                        "backupMinute",
                        "binlogRetentionPeriod",
                        "connectTimeout",
                        "defaultTimeZone",
                        "groupConcatMaxLen",
                        "informationSchemaStatsExpiry",
                        "innodbChangeBufferMaxSize",
                        "innodbFlushNeighbors",
                        "innodbFtMinTokenSize",
                        "innodbFtServerStopwordTable",
                        "innodbLockWaitTimeout",
                        "innodbLogBufferSize",
                        "innodbOnlineAlterLogMaxSize",
                        "innodbPrintAllDeadlocks",
                        "innodbReadIoThreads",
                        "innodbRollbackOnTimeout",
                        "innodbThreadConcurrency",
                        "innodbWriteIoThreads",
                        "interactiveTimeout",
                        "internalTmpMemStorageEngine",
                        "ipFilters",
                        "logOutput",
                        "longQueryTime",
                        "maxAllowedPacket",
                        "maxHeapTableSize",
                        "migration",
                        "netBufferLength",
                        "netReadTimeout",
                        "netWriteTimeout",
                        "serviceLog",
                        "slowQueryLog",
                        "sortBufferSize",
                        "sqlRequirePrimaryKey",
                        "tmpTableSize",
                        "version",
                        "waitTimeout"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseMysqlPropertiesMigration:ManagedDatabaseMysqlPropertiesMigration": {
            "properties": {
                "dbname": {
                    "type": "string",
                    "description": "Database name for bootstrapping the initial connection.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname or IP address of the server where to migrate data from.\n"
                },
                "ignoreDbs": {
                    "type": "string",
                    "description": "Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).\n"
                },
                "ignoreRoles": {
                    "type": "string",
                    "description": "Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).\n"
                },
                "method": {
                    "type": "string",
                    "description": "The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for authentication with the server where to migrate data from.\n",
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the server where to migrate data from.\n"
                },
                "ssl": {
                    "type": "boolean",
                    "description": "The server where to migrate data from is secured with SSL.\n"
                },
                "username": {
                    "type": "string",
                    "description": "User name for authentication with the server where to migrate data from.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dbname",
                        "host",
                        "ignoreDbs",
                        "ignoreRoles",
                        "method",
                        "password",
                        "port",
                        "ssl",
                        "username"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchComponent:ManagedDatabaseOpensearchComponent": {
            "properties": {
                "component": {
                    "type": "string",
                    "description": "Type of the component\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname of the component\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the component\n"
                },
                "route": {
                    "type": "string",
                    "description": "Component network route type\n"
                },
                "usage": {
                    "type": "string",
                    "description": "Usage of the component\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "component",
                        "host",
                        "port",
                        "route",
                        "usage"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchNetwork:ManagedDatabaseOpensearchNetwork": {
            "properties": {
                "family": {
                    "type": "string",
                    "description": "Network family. Currently only `IPv4` is supported.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network. Must be unique within the service.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network. Must be private.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Private network UUID. Must reside in the same zone as the database.\n"
                }
            },
            "type": "object",
            "required": [
                "family",
                "name",
                "type",
                "uuid"
            ]
        },
        "upcloud:index/ManagedDatabaseOpensearchNodeState:ManagedDatabaseOpensearchNodeState": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name plus a node iteration\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role of the node\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the node\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "role",
                        "state"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchProperties:ManagedDatabaseOpensearchProperties": {
            "properties": {
                "actionAutoCreateIndexEnabled": {
                    "type": "boolean",
                    "description": "action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.\n"
                },
                "actionDestructiveRequiresName": {
                    "type": "boolean",
                    "description": "Require explicit index names when deleting.\n"
                },
                "authFailureListeners": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesAuthFailureListeners:ManagedDatabaseOpensearchPropertiesAuthFailureListeners",
                    "description": "Opensearch Security Plugin Settings.\n"
                },
                "automaticUtilityNetworkIpFilter": {
                    "type": "boolean",
                    "description": "Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.\n"
                },
                "clusterMaxShardsPerNode": {
                    "type": "integer",
                    "description": "Controls the number of shards allowed in the cluster per data node.\n"
                },
                "clusterRoutingAllocationBalancePreferPrimary": {
                    "type": "boolean",
                    "description": "When set to true, OpenSearch attempts to evenly distribute the primary shards between the cluster nodes. Enabling this setting does not always guarantee an equal number of primary shards on each node, especially in the event of a failover. Changing this setting to false after it was set to true does not invoke redistribution of primary shards. Default is false.\n"
                },
                "clusterRoutingAllocationNodeConcurrentRecoveries": {
                    "type": "integer",
                    "description": "Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to node cpu count * 2.\n"
                },
                "clusterSearchRequestSlowlog": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlog:ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlog"
                },
                "customDomain": {
                    "type": "string",
                    "description": "Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.\n"
                },
                "diskWatermarks": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesDiskWatermarks:ManagedDatabaseOpensearchPropertiesDiskWatermarks",
                    "description": "Watermark settings.\n"
                },
                "elasticsearchVersion": {
                    "type": "string",
                    "description": "Elasticsearch major version.\n"
                },
                "emailSenderName": {
                    "type": "string",
                    "description": "Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.\n"
                },
                "emailSenderPassword": {
                    "type": "string",
                    "description": "Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.\n",
                    "secret": true
                },
                "emailSenderUsername": {
                    "type": "string",
                    "description": "Sender username for Opensearch alerts.\n"
                },
                "enableRemoteBackedStorage": {
                    "type": "boolean",
                    "description": "Enable remote-backed storage.\n"
                },
                "enableSearchableSnapshots": {
                    "type": "boolean",
                    "description": "Enable searchable snapshots.\n"
                },
                "enableSecurityAudit": {
                    "type": "boolean",
                    "description": "Enable/Disable security audit.\n"
                },
                "httpMaxContentLength": {
                    "type": "integer",
                    "description": "Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.\n"
                },
                "httpMaxHeaderSize": {
                    "type": "integer",
                    "description": "The max size of allowed headers, in bytes.\n"
                },
                "httpMaxInitialLineLength": {
                    "type": "integer",
                    "description": "The max length of an HTTP URL, in bytes.\n"
                },
                "indexPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Index patterns.\n"
                },
                "indexRollup": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesIndexRollup:ManagedDatabaseOpensearchPropertiesIndexRollup",
                    "description": "Index rollup settings.\n"
                },
                "indexTemplate": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesIndexTemplate:ManagedDatabaseOpensearchPropertiesIndexTemplate",
                    "description": "Template settings for all new indexes.\n"
                },
                "indicesFielddataCacheSize": {
                    "type": "integer",
                    "description": "Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.\n"
                },
                "indicesMemoryIndexBufferSize": {
                    "type": "integer",
                    "description": "Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.\n"
                },
                "indicesMemoryMaxIndexBufferSize": {
                    "type": "integer",
                    "description": "Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.\n"
                },
                "indicesMemoryMinIndexBufferSize": {
                    "type": "integer",
                    "description": "Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.\n"
                },
                "indicesQueriesCacheSize": {
                    "type": "integer",
                    "description": "Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.\n"
                },
                "indicesQueryBoolMaxClauseCount": {
                    "type": "integer",
                    "description": "Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.\n"
                },
                "indicesRecoveryMaxBytesPerSec": {
                    "type": "integer",
                    "description": "Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.\n"
                },
                "indicesRecoveryMaxConcurrentFileChunks": {
                    "type": "integer",
                    "description": "Number of file chunks sent in parallel for each recovery. Defaults to 2.\n"
                },
                "ipFilters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.\n"
                },
                "ismEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether ISM is enabled or not.\n"
                },
                "ismHistoryEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.\n"
                },
                "ismHistoryMaxAge": {
                    "type": "integer",
                    "description": "The maximum age before rolling over the audit history index in hours.\n"
                },
                "ismHistoryMaxDocs": {
                    "type": "integer",
                    "description": "The maximum number of documents before rolling over the audit history index.\n"
                },
                "ismHistoryRolloverCheckPeriod": {
                    "type": "integer",
                    "description": "The time between rollover checks for the audit history index in hours.\n"
                },
                "ismHistoryRolloverRetentionPeriod": {
                    "type": "integer",
                    "description": "How long audit history indices are kept in days.\n"
                },
                "keepIndexRefreshInterval": {
                    "type": "boolean",
                    "description": "Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.\n"
                },
                "knnMemoryCircuitBreakerEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable KNN memory circuit breaker. Defaults to true.\n"
                },
                "knnMemoryCircuitBreakerLimit": {
                    "type": "integer",
                    "description": "Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.\n"
                },
                "openid": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesOpenid:ManagedDatabaseOpensearchPropertiesOpenid",
                    "description": "OpenSearch OpenID Connect Configuration.\n"
                },
                "opensearchDashboards": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesOpensearchDashboards:ManagedDatabaseOpensearchPropertiesOpensearchDashboards",
                    "description": "OpenSearch Dashboards settings.\n"
                },
                "overrideMainResponseVersion": {
                    "type": "boolean",
                    "description": "Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.\n"
                },
                "pluginsAlertingFilterByBackendRoles": {
                    "type": "boolean",
                    "description": "Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.\n"
                },
                "publicAccess": {
                    "type": "boolean",
                    "description": "Public Access. Allow access to the service from the public Internet.\n"
                },
                "reindexRemoteWhitelists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.\n"
                },
                "saml": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSaml:ManagedDatabaseOpensearchPropertiesSaml",
                    "description": "OpenSearch SAML configuration.\n"
                },
                "scriptMaxCompilationsRate": {
                    "type": "string",
                    "description": "Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.\n"
                },
                "searchBackpressure": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSearchBackpressure:ManagedDatabaseOpensearchPropertiesSearchBackpressure",
                    "description": "Search Backpressure Settings.\n"
                },
                "searchInsightsTopQueries": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueries:ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueries"
                },
                "searchMaxBuckets": {
                    "type": "integer",
                    "description": "Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.\n"
                },
                "segrep": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSegrep:ManagedDatabaseOpensearchPropertiesSegrep",
                    "description": "Segment Replication Backpressure Settings.\n"
                },
                "serviceLog": {
                    "type": "boolean",
                    "description": "Service logging. Store logs for the service so that they are available in the HTTP API and console.\n"
                },
                "shardIndexingPressure": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressure:ManagedDatabaseOpensearchPropertiesShardIndexingPressure",
                    "description": "Shard indexing back pressure settings.\n"
                },
                "threadPoolAnalyzeQueueSize": {
                    "type": "integer",
                    "description": "analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.\n"
                },
                "threadPoolAnalyzeSize": {
                    "type": "integer",
                    "description": "analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.\n"
                },
                "threadPoolForceMergeSize": {
                    "type": "integer",
                    "description": "force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.\n"
                },
                "threadPoolGetQueueSize": {
                    "type": "integer",
                    "description": "get thread pool queue size. Size for the thread pool queue. See documentation for exact details.\n"
                },
                "threadPoolGetSize": {
                    "type": "integer",
                    "description": "get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.\n"
                },
                "threadPoolSearchQueueSize": {
                    "type": "integer",
                    "description": "search thread pool queue size. Size for the thread pool queue. See documentation for exact details.\n"
                },
                "threadPoolSearchSize": {
                    "type": "integer",
                    "description": "search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.\n"
                },
                "threadPoolSearchThrottledQueueSize": {
                    "type": "integer",
                    "description": "search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.\n"
                },
                "threadPoolSearchThrottledSize": {
                    "type": "integer",
                    "description": "search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.\n"
                },
                "threadPoolWriteQueueSize": {
                    "type": "integer",
                    "description": "write thread pool queue size. Size for the thread pool queue. See documentation for exact details.\n"
                },
                "threadPoolWriteSize": {
                    "type": "integer",
                    "description": "write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.\n"
                },
                "version": {
                    "type": "string",
                    "description": "OpenSearch major version.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "actionAutoCreateIndexEnabled",
                        "actionDestructiveRequiresName",
                        "authFailureListeners",
                        "clusterMaxShardsPerNode",
                        "clusterRoutingAllocationNodeConcurrentRecoveries",
                        "clusterSearchRequestSlowlog",
                        "customDomain",
                        "diskWatermarks",
                        "elasticsearchVersion",
                        "emailSenderName",
                        "emailSenderPassword",
                        "emailSenderUsername",
                        "enableRemoteBackedStorage",
                        "enableSearchableSnapshots",
                        "enableSecurityAudit",
                        "httpMaxContentLength",
                        "httpMaxHeaderSize",
                        "httpMaxInitialLineLength",
                        "indexPatterns",
                        "indexRollup",
                        "indexTemplate",
                        "indicesFielddataCacheSize",
                        "indicesMemoryIndexBufferSize",
                        "indicesMemoryMaxIndexBufferSize",
                        "indicesMemoryMinIndexBufferSize",
                        "indicesQueriesCacheSize",
                        "indicesQueryBoolMaxClauseCount",
                        "indicesRecoveryMaxBytesPerSec",
                        "indicesRecoveryMaxConcurrentFileChunks",
                        "ipFilters",
                        "ismEnabled",
                        "ismHistoryEnabled",
                        "ismHistoryMaxAge",
                        "ismHistoryMaxDocs",
                        "ismHistoryRolloverCheckPeriod",
                        "ismHistoryRolloverRetentionPeriod",
                        "keepIndexRefreshInterval",
                        "knnMemoryCircuitBreakerEnabled",
                        "knnMemoryCircuitBreakerLimit",
                        "openid",
                        "opensearchDashboards",
                        "overrideMainResponseVersion",
                        "pluginsAlertingFilterByBackendRoles",
                        "reindexRemoteWhitelists",
                        "saml",
                        "searchBackpressure",
                        "searchInsightsTopQueries",
                        "searchMaxBuckets",
                        "segrep",
                        "serviceLog",
                        "shardIndexingPressure",
                        "threadPoolAnalyzeQueueSize",
                        "threadPoolAnalyzeSize",
                        "threadPoolForceMergeSize",
                        "threadPoolGetQueueSize",
                        "threadPoolGetSize",
                        "threadPoolSearchQueueSize",
                        "threadPoolSearchSize",
                        "threadPoolSearchThrottledQueueSize",
                        "threadPoolSearchThrottledSize",
                        "threadPoolWriteQueueSize",
                        "threadPoolWriteSize",
                        "version"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesAuthFailureListeners:ManagedDatabaseOpensearchPropertiesAuthFailureListeners": {
            "properties": {
                "internalAuthenticationBackendLimiting": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting:ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "internalAuthenticationBackendLimiting"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting:ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting": {
            "properties": {
                "allowedTries": {
                    "type": "integer",
                    "description": "The number of login attempts allowed before login is blocked.\n"
                },
                "authenticationBackend": {
                    "type": "string",
                    "description": "The internal backend. Enter `internal`.\n"
                },
                "blockExpirySeconds": {
                    "type": "integer",
                    "description": "The duration of time that login remains blocked after a failed login.\n"
                },
                "maxBlockedClients": {
                    "type": "integer",
                    "description": "The maximum number of blocked IP addresses.\n"
                },
                "maxTrackedClients": {
                    "type": "integer",
                    "description": "The maximum number of tracked IP addresses that have failed login.\n"
                },
                "timeWindowSeconds": {
                    "type": "integer",
                    "description": "The window of time in which the value for `allowed_tries` is enforced.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of rate limiting.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allowedTries",
                        "authenticationBackend",
                        "blockExpirySeconds",
                        "maxBlockedClients",
                        "maxTrackedClients",
                        "timeWindowSeconds",
                        "type"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlog:ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlog": {
            "properties": {
                "level": {
                    "type": "string",
                    "description": "Log level.\n"
                },
                "threshold": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThreshold:ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThreshold"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "level",
                        "threshold"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThreshold:ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThreshold": {
            "properties": {
                "debug": {
                    "type": "string",
                    "description": "Debug threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.\n"
                },
                "info": {
                    "type": "string",
                    "description": "Info threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.\n"
                },
                "trace": {
                    "type": "string",
                    "description": "Trace threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.\n"
                },
                "warn": {
                    "type": "string",
                    "description": "Warning threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.\n"
                }
            },
            "type": "object"
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesDiskWatermarks:ManagedDatabaseOpensearchPropertiesDiskWatermarks": {
            "properties": {
                "floodStage": {
                    "type": "integer",
                    "description": "Flood stage watermark (percentage). The flood stage watermark for disk usage.\n"
                },
                "high": {
                    "type": "integer",
                    "description": "High watermark (percentage). The high watermark for disk usage.\n"
                },
                "low": {
                    "type": "integer",
                    "description": "Low watermark (percentage). The low watermark for disk usage.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "floodStage",
                        "high",
                        "low"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesIndexRollup:ManagedDatabaseOpensearchPropertiesIndexRollup": {
            "properties": {
                "rollupDashboardsEnabled": {
                    "type": "boolean",
                    "description": "plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.\n"
                },
                "rollupEnabled": {
                    "type": "boolean",
                    "description": "plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.\n"
                },
                "rollupSearchBackoffCount": {
                    "type": "integer",
                    "description": "plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.\n"
                },
                "rollupSearchBackoffMillis": {
                    "type": "integer",
                    "description": "plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.\n"
                },
                "rollupSearchSearchAllJobs": {
                    "type": "boolean",
                    "description": "plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "rollupDashboardsEnabled",
                        "rollupEnabled",
                        "rollupSearchBackoffCount",
                        "rollupSearchBackoffMillis",
                        "rollupSearchSearchAllJobs"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesIndexTemplate:ManagedDatabaseOpensearchPropertiesIndexTemplate": {
            "properties": {
                "mappingNestedObjectsLimit": {
                    "type": "integer",
                    "description": "index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.\n"
                },
                "numberOfReplicas": {
                    "type": "integer",
                    "description": "The number of replicas each primary shard has.\n"
                },
                "numberOfShards": {
                    "type": "integer",
                    "description": "The number of primary shards that an index should have.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "mappingNestedObjectsLimit",
                        "numberOfReplicas",
                        "numberOfShards"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesOpenid:ManagedDatabaseOpensearchPropertiesOpenid": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.\n"
                },
                "connectUrl": {
                    "type": "string",
                    "description": "OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.\n"
                },
                "header": {
                    "type": "string",
                    "description": "HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.\n"
                },
                "jwtHeader": {
                    "type": "string",
                    "description": "The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer \u003ctoken\u003e. Optional. Default is Authorization.\n"
                },
                "jwtUrlParameter": {
                    "type": "string",
                    "description": "URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.\n"
                },
                "refreshRateLimitCount": {
                    "type": "integer",
                    "description": "The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.\n"
                },
                "refreshRateLimitTimeWindowMs": {
                    "type": "integer",
                    "description": "The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).\n"
                },
                "rolesKey": {
                    "type": "string",
                    "description": "The key in the JSON payload that stores the user’s roles. The key in the JSON payload that stores the user’s roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.\n"
                },
                "scope": {
                    "type": "string",
                    "description": "The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.\n"
                },
                "subjectKey": {
                    "type": "string",
                    "description": "The key in the JSON payload that stores the user’s name. The key in the JSON payload that stores the user’s name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "clientId",
                        "clientSecret",
                        "enabled",
                        "header",
                        "jwtHeader",
                        "jwtUrlParameter",
                        "refreshRateLimitCount",
                        "refreshRateLimitTimeWindowMs",
                        "rolesKey",
                        "scope",
                        "subjectKey"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesOpensearchDashboards:ManagedDatabaseOpensearchPropertiesOpensearchDashboards": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable OpenSearch Dashboards.\n"
                },
                "maxOldSpaceSize": {
                    "type": "integer",
                    "description": "Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.\n"
                },
                "multipleDataSourceEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable multiple data sources in OpenSearch Dashboards.\n"
                },
                "opensearchRequestTimeout": {
                    "type": "integer",
                    "description": "Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "maxOldSpaceSize",
                        "multipleDataSourceEnabled",
                        "opensearchRequestTimeout"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSaml:ManagedDatabaseOpensearchPropertiesSaml": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.\n"
                },
                "idpEntityId": {
                    "type": "string",
                    "description": "Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.\n"
                },
                "idpMetadataUrl": {
                    "type": "string",
                    "description": "Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.\n"
                },
                "idpPemtrustedcasContent": {
                    "type": "string",
                    "description": "PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.\n"
                },
                "rolesKey": {
                    "type": "string",
                    "description": "SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.\n"
                },
                "spEntityId": {
                    "type": "string",
                    "description": "Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.\n"
                },
                "subjectKey": {
                    "type": "string",
                    "description": "SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "idpEntityId",
                        "idpMetadataUrl",
                        "idpPemtrustedcasContent",
                        "rolesKey",
                        "spEntityId",
                        "subjectKey"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSearchBackpressure:ManagedDatabaseOpensearchPropertiesSearchBackpressure": {
            "properties": {
                "mode": {
                    "type": "string",
                    "description": "The search backpressure mode. The search backpressure mode. Valid values are monitor_only, enforced, or disabled. Default is monitor_only.\n"
                },
                "nodeDuress": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuress:ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuress",
                    "description": "Node duress settings.\n"
                },
                "searchShardTask": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTask:ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTask",
                    "description": "Search shard settings.\n"
                },
                "searchTask": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTask:ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTask",
                    "description": "Search task settings.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "mode",
                        "nodeDuress",
                        "searchShardTask",
                        "searchTask"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuress:ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuress": {
            "properties": {
                "cpuThreshold": {
                    "type": "number",
                    "description": "The CPU usage threshold (as a percentage) required for a node to be considered to be under duress. The CPU usage threshold (as a percentage) required for a node to be considered to be under duress. Default is 0.9.\n"
                },
                "heapThreshold": {
                    "type": "number",
                    "description": "The heap usage threshold (as a percentage) required for a node to be considered to be under duress. The heap usage threshold (as a percentage) required for a node to be considered to be under duress. Default is 0.7.\n"
                },
                "numSuccessiveBreaches": {
                    "type": "integer",
                    "description": "The number of successive limit breaches after which the node is considered to be under duress. The number of successive limit breaches after which the node is considered to be under duress. Default is 3.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cpuThreshold",
                        "heapThreshold",
                        "numSuccessiveBreaches"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTask:ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTask": {
            "properties": {
                "cancellationBurst": {
                    "type": "number",
                    "description": "The maximum number of search tasks to cancel in a single iteration of the observer thread. The maximum number of search tasks to cancel in a single iteration of the observer thread. Default is 10.0.\n"
                },
                "cancellationRate": {
                    "type": "number",
                    "description": "The maximum number of tasks to cancel per millisecond of elapsed time. The maximum number of tasks to cancel per millisecond of elapsed time. Default is 0.003.\n"
                },
                "cancellationRatio": {
                    "type": "number",
                    "description": "The maximum number of tasks to cancel. The maximum number of tasks to cancel, as a percentage of successful task completions. Default is 0.1.\n"
                },
                "cpuTimeMillisThreshold": {
                    "type": "integer",
                    "description": "The CPU usage threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. The CPU usage threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. Default is 15000.\n"
                },
                "elapsedTimeMillisThreshold": {
                    "type": "integer",
                    "description": "The elapsed time threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. The elapsed time threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. Default is 30000.\n"
                },
                "heapMovingAverageWindowSize": {
                    "type": "integer",
                    "description": "The number of previously completed search shard tasks to consider when calculating the rolling average of heap usage. The number of previously completed search shard tasks to consider when calculating the rolling average of heap usage. Default is 100.\n"
                },
                "heapPercentThreshold": {
                    "type": "number",
                    "description": "The heap usage threshold (as a percentage) required for a single search shard task before it is considered for cancellation. The heap usage threshold (as a percentage) required for a single search shard task before it is considered for cancellation. Default is 0.5.\n"
                },
                "heapVariance": {
                    "type": "number",
                    "description": "The minimum variance required for a single search shard task’s heap usage compared to the rolling average of previously completed tasks before it is considered for cancellation. The minimum variance required for a single search shard task’s heap usage compared to the rolling average of previously completed tasks before it is considered for cancellation. Default is 2.0.\n"
                },
                "totalHeapPercentThreshold": {
                    "type": "number",
                    "description": "The heap usage threshold (as a percentage) required for the sum of heap usages of all search shard tasks before cancellation is applied. The heap usage threshold (as a percentage) required for the sum of heap usages of all search shard tasks before cancellation is applied. Default is 0.5.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cancellationBurst",
                        "cancellationRate",
                        "cancellationRatio",
                        "cpuTimeMillisThreshold",
                        "elapsedTimeMillisThreshold",
                        "heapMovingAverageWindowSize",
                        "heapPercentThreshold",
                        "heapVariance",
                        "totalHeapPercentThreshold"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTask:ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTask": {
            "properties": {
                "cancellationBurst": {
                    "type": "number",
                    "description": "The maximum number of search tasks to cancel in a single iteration of the observer thread. The maximum number of search tasks to cancel in a single iteration of the observer thread. Default is 5.0.\n"
                },
                "cancellationRate": {
                    "type": "number",
                    "description": "The maximum number of search tasks to cancel per millisecond of elapsed time. The maximum number of search tasks to cancel per millisecond of elapsed time. Default is 0.003.\n"
                },
                "cancellationRatio": {
                    "type": "number",
                    "description": "The maximum number of search tasks to cancel, as a percentage of successful search task completions. The maximum number of search tasks to cancel, as a percentage of successful search task completions. Default is 0.1.\n"
                },
                "cpuTimeMillisThreshold": {
                    "type": "integer",
                    "description": "The CPU usage threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. The CPU usage threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. Default is 30000.\n"
                },
                "elapsedTimeMillisThreshold": {
                    "type": "integer",
                    "description": "The elapsed time threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. The elapsed time threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. Default is 45000.\n"
                },
                "heapMovingAverageWindowSize": {
                    "type": "integer",
                    "description": "The window size used to calculate the rolling average of the heap usage for the completed parent tasks. The window size used to calculate the rolling average of the heap usage for the completed parent tasks. Default is 10.\n"
                },
                "heapPercentThreshold": {
                    "type": "number",
                    "description": "The heap usage threshold (as a percentage) required for an individual parent task before it is considered for cancellation. The heap usage threshold (as a percentage) required for an individual parent task before it is considered for cancellation. Default is 0.2.\n"
                },
                "heapVariance": {
                    "type": "number",
                    "description": "The heap usage variance required for an individual parent task before it is considered for cancellation. The heap usage variance required for an individual parent task before it is considered for cancellation. A task is considered for cancellation when taskHeapUsage is greater than or equal to heapUsageMovingAverage * variance. Default is 2.0.\n"
                },
                "totalHeapPercentThreshold": {
                    "type": "number",
                    "description": "The heap usage threshold (as a percentage) required for the sum of heap usages of all search tasks before cancellation is applied. The heap usage threshold (as a percentage) required for the sum of heap usages of all search tasks before cancellation is applied. Default is 0.5.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cancellationBurst",
                        "cancellationRate",
                        "cancellationRatio",
                        "cpuTimeMillisThreshold",
                        "elapsedTimeMillisThreshold",
                        "heapMovingAverageWindowSize",
                        "heapPercentThreshold",
                        "heapVariance",
                        "totalHeapPercentThreshold"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueries:ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueries": {
            "properties": {
                "cpu": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpu:ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpu",
                    "description": "Top N queries monitoring by CPU.\n"
                },
                "latency": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatency:ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatency",
                    "description": "Top N queries monitoring by latency.\n"
                },
                "memory": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemory:ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemory",
                    "description": "Top N queries monitoring by memory.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cpu",
                        "latency",
                        "memory"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpu:ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpu": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.\n"
                },
                "topNSize": {
                    "type": "integer",
                    "description": "Specify the value of N for the top N queries by the metric.\n"
                },
                "windowSize": {
                    "type": "string",
                    "description": "The window size of the top N queries by the metric. Configure the window size of the top N queries.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "topNSize"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatency:ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatency": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.\n"
                },
                "topNSize": {
                    "type": "integer",
                    "description": "Specify the value of N for the top N queries by the metric.\n"
                },
                "windowSize": {
                    "type": "string",
                    "description": "The window size of the top N queries by the metric. Configure the window size of the top N queries.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "topNSize"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemory:ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemory": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.\n"
                },
                "topNSize": {
                    "type": "integer",
                    "description": "Specify the value of N for the top N queries by the metric.\n"
                },
                "windowSize": {
                    "type": "string",
                    "description": "The window size of the top N queries by the metric. Configure the window size of the top N queries.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "topNSize"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesSegrep:ManagedDatabaseOpensearchPropertiesSegrep": {
            "properties": {
                "pressureCheckpointLimit": {
                    "type": "integer",
                    "description": "The maximum number of indexing checkpoints that a replica shard can fall behind when copying from primary. Once `segrep.pressure.checkpoint.limit` is breached along with `segrep.pressure.time.limit`, the segment replication backpressure mechanism is initiated. Default is 4 checkpoints.\n"
                },
                "pressureEnabled": {
                    "type": "boolean",
                    "description": "Enables the segment replication backpressure mechanism. Default is false.\n"
                },
                "pressureReplicaStaleLimit": {
                    "type": "number",
                    "description": "The maximum number of stale replica shards that can exist in a replication group. Once `segrep.pressure.replica.stale.limit` is breached, the segment replication backpressure mechanism is initiated. Default is .5, which is 50% of a replication group.\n"
                },
                "pressureTimeLimit": {
                    "type": "string",
                    "description": "The maximum amount of time that a replica shard can take to copy from the primary shard. Once segrep.pressure.time.limit is breached along with segrep.pressure.checkpoint.limit, the segment replication backpressure mechanism is initiated. Default is 5 minutes.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "pressureCheckpointLimit",
                        "pressureEnabled",
                        "pressureReplicaStaleLimit",
                        "pressureTimeLimit"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressure:ManagedDatabaseOpensearchPropertiesShardIndexingPressure": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Enable or disable shard indexing backpressure. Enable or disable shard indexing backpressure. Default is false.\n"
                },
                "enforced": {
                    "type": "boolean",
                    "description": "Run shard indexing backpressure in shadow mode or enforced mode. Run shard indexing backpressure in shadow mode or enforced mode.\n            In shadow mode (value set as false), shard indexing backpressure tracks all granular-level metrics,\n            but it doesn’t actually reject any indexing requests.\n            In enforced mode (value set as true),\n            shard indexing backpressure rejects any requests to the cluster that might cause a dip in its performance.\n            Default is false.\n"
                },
                "operatingFactor": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactor:ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactor",
                    "description": "Operating factor.\n"
                },
                "primaryParameter": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameter:ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameter",
                    "description": "Primary parameter.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "enforced",
                        "operatingFactor",
                        "primaryParameter"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactor:ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactor": {
            "properties": {
                "lower": {
                    "type": "number",
                    "description": "Lower occupancy limit of the allocated quota of memory for the shard. Specify the lower occupancy limit of the allocated quota of memory for the shard.\n                    If the total memory usage of a shard is below this limit,\n                    shard indexing backpressure decreases the current allocated memory for that shard.\n                    Default is 0.75.\n"
                },
                "optimal": {
                    "type": "number",
                    "description": "Optimal occupancy of the allocated quota of memory for the shard. Specify the optimal occupancy of the allocated quota of memory for the shard.\n                    If the total memory usage of a shard is at this level,\n                    shard indexing backpressure doesn’t change the current allocated memory for that shard.\n                    Default is 0.85.\n"
                },
                "upper": {
                    "type": "number",
                    "description": "Upper occupancy limit of the allocated quota of memory for the shard. Specify the upper occupancy limit of the allocated quota of memory for the shard.\n                    If the total memory usage of a shard is above this limit,\n                    shard indexing backpressure increases the current allocated memory for that shard.\n                    Default is 0.95.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "lower",
                        "optimal",
                        "upper"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameter:ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameter": {
            "properties": {
                "node": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNode:ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNode"
                },
                "shard": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShard:ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShard"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "node",
                        "shard"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNode:ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNode": {
            "properties": {
                "softLimit": {
                    "type": "number",
                    "description": "Node soft limit. Define the percentage of the node-level memory\n                            threshold that acts as a soft indicator for strain on a node.\n                            Default is 0.7.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "softLimit"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShard:ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShard": {
            "properties": {
                "minLimit": {
                    "type": "number",
                    "description": "Shard min limit. Specify the minimum assigned quota for a new shard in any role (coordinator, primary, or replica).\n                            Shard indexing backpressure increases or decreases this allocated quota based on the inflow of traffic for the shard.\n                            Default is 0.001.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "minLimit"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabasePostgresqlComponent:ManagedDatabasePostgresqlComponent": {
            "properties": {
                "component": {
                    "type": "string",
                    "description": "Type of the component\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname of the component\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the component\n"
                },
                "route": {
                    "type": "string",
                    "description": "Component network route type\n"
                },
                "usage": {
                    "type": "string",
                    "description": "Usage of the component\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "component",
                        "host",
                        "port",
                        "route",
                        "usage"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabasePostgresqlNetwork:ManagedDatabasePostgresqlNetwork": {
            "properties": {
                "family": {
                    "type": "string",
                    "description": "Network family. Currently only `IPv4` is supported.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network. Must be unique within the service.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network. Must be private.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Private network UUID. Must reside in the same zone as the database.\n"
                }
            },
            "type": "object",
            "required": [
                "family",
                "name",
                "type",
                "uuid"
            ]
        },
        "upcloud:index/ManagedDatabasePostgresqlNodeState:ManagedDatabasePostgresqlNodeState": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name plus a node iteration\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role of the node\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the node\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "role",
                        "state"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabasePostgresqlProperties:ManagedDatabasePostgresqlProperties": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "adminUsername": {
                    "type": "string",
                    "description": "Custom username for admin user. This must be set only when a new service is being created.\n",
                    "willReplaceOnChanges": true
                },
                "automaticUtilityNetworkIpFilter": {
                    "type": "boolean",
                    "description": "Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.\n"
                },
                "autovacuumAnalyzeScaleFactor": {
                    "type": "number",
                    "description": "Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).\n"
                },
                "autovacuumAnalyzeThreshold": {
                    "type": "integer",
                    "description": "Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.\n"
                },
                "autovacuumFreezeMaxAge": {
                    "type": "integer",
                    "description": "Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.\n"
                },
                "autovacuumMaxWorkers": {
                    "type": "integer",
                    "description": "Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.\n"
                },
                "autovacuumNaptime": {
                    "type": "integer",
                    "description": "Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.\n"
                },
                "autovacuumVacuumCostDelay": {
                    "type": "integer",
                    "description": "Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.\n"
                },
                "autovacuumVacuumCostLimit": {
                    "type": "integer",
                    "description": "Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.\n"
                },
                "autovacuumVacuumScaleFactor": {
                    "type": "number",
                    "description": "Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).\n"
                },
                "autovacuumVacuumThreshold": {
                    "type": "integer",
                    "description": "Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.\n"
                },
                "backupHour": {
                    "type": "integer",
                    "description": "The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.\n"
                },
                "backupMinute": {
                    "type": "integer",
                    "description": "The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.\n"
                },
                "bgwriterDelay": {
                    "type": "integer",
                    "description": "Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.\n"
                },
                "bgwriterFlushAfter": {
                    "type": "integer",
                    "description": "Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.\n"
                },
                "bgwriterLruMaxpages": {
                    "type": "integer",
                    "description": "In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.\n"
                },
                "bgwriterLruMultiplier": {
                    "type": "number",
                    "description": "The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.\n"
                },
                "deadlockTimeout": {
                    "type": "integer",
                    "description": "This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.\n"
                },
                "defaultToastCompression": {
                    "type": "string",
                    "description": "Specifies the default TOAST compression method for values of compressible columns (the default is lz4).\n"
                },
                "idleInTransactionSessionTimeout": {
                    "type": "integer",
                    "description": "Time out sessions with open transactions after this number of milliseconds.\n"
                },
                "ipFilters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.\n"
                },
                "jit": {
                    "type": "boolean",
                    "description": "Controls system-wide use of Just-in-Time Compilation (JIT).\n"
                },
                "logAutovacuumMinDuration": {
                    "type": "integer",
                    "description": "Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.\n"
                },
                "logErrorVerbosity": {
                    "type": "string",
                    "description": "Controls the amount of detail written in the server log for each message that is logged.\n"
                },
                "logLinePrefix": {
                    "type": "string",
                    "description": "Choose from one of the available log formats.\n"
                },
                "logMinDurationStatement": {
                    "type": "integer",
                    "description": "Log statements that take more than this number of milliseconds to run, -1 disables.\n"
                },
                "logTempFiles": {
                    "type": "integer",
                    "description": "Log statements for each temporary file created larger than this number of kilobytes, -1 disables.\n"
                },
                "maxFilesPerProcess": {
                    "type": "integer",
                    "description": "PostgreSQL maximum number of files that can be open per process.\n"
                },
                "maxLocksPerTransaction": {
                    "type": "integer",
                    "description": "PostgreSQL maximum locks per transaction.\n"
                },
                "maxLogicalReplicationWorkers": {
                    "type": "integer",
                    "description": "PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).\n"
                },
                "maxParallelWorkers": {
                    "type": "integer",
                    "description": "Sets the maximum number of workers that the system can support for parallel queries.\n"
                },
                "maxParallelWorkersPerGather": {
                    "type": "integer",
                    "description": "Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.\n"
                },
                "maxPredLocksPerTransaction": {
                    "type": "integer",
                    "description": "PostgreSQL maximum predicate locks per transaction.\n"
                },
                "maxPreparedTransactions": {
                    "type": "integer",
                    "description": "PostgreSQL maximum prepared transactions.\n"
                },
                "maxReplicationSlots": {
                    "type": "integer",
                    "description": "PostgreSQL maximum replication slots.\n"
                },
                "maxSlotWalKeepSize": {
                    "type": "integer",
                    "description": "PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.\n"
                },
                "maxStackDepth": {
                    "type": "integer",
                    "description": "Maximum depth of the stack in bytes.\n"
                },
                "maxStandbyArchiveDelay": {
                    "type": "integer",
                    "description": "Max standby archive delay in milliseconds.\n"
                },
                "maxStandbyStreamingDelay": {
                    "type": "integer",
                    "description": "Max standby streaming delay in milliseconds.\n"
                },
                "maxWalSenders": {
                    "type": "integer",
                    "description": "PostgreSQL maximum WAL senders.\n"
                },
                "maxWorkerProcesses": {
                    "type": "integer",
                    "description": "Sets the maximum number of background processes that the system can support.\n"
                },
                "migration": {
                    "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlPropertiesMigration:ManagedDatabasePostgresqlPropertiesMigration",
                    "description": "Migrate data from existing server.\n"
                },
                "passwordEncryption": {
                    "type": "string",
                    "description": "Chooses the algorithm for encrypting passwords.\n",
                    "secret": true
                },
                "pgPartmanBgwInterval": {
                    "type": "integer",
                    "description": "Sets the time interval to run pg_partman's scheduled tasks.\n"
                },
                "pgPartmanBgwRole": {
                    "type": "string",
                    "description": "Controls which role to use for pg_partman's scheduled background tasks.\n"
                },
                "pgStatMonitorEnable": {
                    "type": "boolean",
                    "description": "Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.\n"
                },
                "pgStatMonitorPgsmEnableQueryPlan": {
                    "type": "boolean",
                    "description": "Enables or disables query plan monitoring.\n"
                },
                "pgStatMonitorPgsmMaxBuckets": {
                    "type": "integer",
                    "description": "Sets the maximum number of buckets.\n"
                },
                "pgStatStatementsTrack": {
                    "type": "string",
                    "description": "Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.\n"
                },
                "pgaudit": {
                    "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlPropertiesPgaudit:ManagedDatabasePostgresqlPropertiesPgaudit",
                    "description": "PGAudit settings. System-wide settings for the pgaudit extension.\n"
                },
                "pgbouncer": {
                    "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlPropertiesPgbouncer:ManagedDatabasePostgresqlPropertiesPgbouncer",
                    "description": "PGBouncer connection pooling settings. System-wide settings for pgbouncer.\n"
                },
                "pglookout": {
                    "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlPropertiesPglookout:ManagedDatabasePostgresqlPropertiesPglookout",
                    "description": "PGLookout settings. System-wide settings for pglookout.\n"
                },
                "publicAccess": {
                    "type": "boolean",
                    "description": "Public Access. Allow access to the service from the public Internet.\n"
                },
                "serviceLog": {
                    "type": "boolean",
                    "description": "Service logging. Store logs for the service so that they are available in the HTTP API and console.\n"
                },
                "sharedBuffersPercentage": {
                    "type": "number",
                    "description": "Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.\n"
                },
                "synchronousReplication": {
                    "type": "string",
                    "description": "Synchronous replication type. Note that the service plan also needs to support synchronous replication.\n"
                },
                "tempFileLimit": {
                    "type": "integer",
                    "description": "PostgreSQL temporary file limit in KiB, -1 for unlimited.\n"
                },
                "timescaledb": {
                    "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlPropertiesTimescaledb:ManagedDatabasePostgresqlPropertiesTimescaledb",
                    "description": "TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.\n"
                },
                "timezone": {
                    "type": "string",
                    "description": "PostgreSQL service timezone.\n"
                },
                "trackActivityQuerySize": {
                    "type": "integer",
                    "description": "Specifies the number of bytes reserved to track the currently executing command for each active session.\n"
                },
                "trackCommitTimestamp": {
                    "type": "string",
                    "description": "Record commit time of transactions.\n"
                },
                "trackFunctions": {
                    "type": "string",
                    "description": "Enables tracking of function call counts and time used.\n"
                },
                "trackIoTiming": {
                    "type": "string",
                    "description": "Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.\n"
                },
                "variant": {
                    "type": "string",
                    "description": "Variant of the PostgreSQL service, may affect the features that are exposed by default.\n"
                },
                "version": {
                    "type": "string",
                    "description": "PostgreSQL major version.\n"
                },
                "walSenderTimeout": {
                    "type": "integer",
                    "description": "Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.\n"
                },
                "walWriterDelay": {
                    "type": "integer",
                    "description": "WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.\n"
                },
                "workMem": {
                    "type": "integer",
                    "description": "Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "adminPassword",
                        "adminUsername",
                        "autovacuumAnalyzeScaleFactor",
                        "autovacuumAnalyzeThreshold",
                        "autovacuumFreezeMaxAge",
                        "autovacuumMaxWorkers",
                        "autovacuumNaptime",
                        "autovacuumVacuumCostDelay",
                        "autovacuumVacuumCostLimit",
                        "autovacuumVacuumScaleFactor",
                        "autovacuumVacuumThreshold",
                        "backupHour",
                        "backupMinute",
                        "bgwriterDelay",
                        "bgwriterFlushAfter",
                        "bgwriterLruMaxpages",
                        "bgwriterLruMultiplier",
                        "deadlockTimeout",
                        "defaultToastCompression",
                        "idleInTransactionSessionTimeout",
                        "ipFilters",
                        "jit",
                        "logAutovacuumMinDuration",
                        "logErrorVerbosity",
                        "logLinePrefix",
                        "logMinDurationStatement",
                        "logTempFiles",
                        "maxFilesPerProcess",
                        "maxLocksPerTransaction",
                        "maxLogicalReplicationWorkers",
                        "maxParallelWorkers",
                        "maxParallelWorkersPerGather",
                        "maxPredLocksPerTransaction",
                        "maxPreparedTransactions",
                        "maxReplicationSlots",
                        "maxSlotWalKeepSize",
                        "maxStackDepth",
                        "maxStandbyArchiveDelay",
                        "maxStandbyStreamingDelay",
                        "maxWalSenders",
                        "maxWorkerProcesses",
                        "migration",
                        "passwordEncryption",
                        "pgPartmanBgwInterval",
                        "pgPartmanBgwRole",
                        "pgStatMonitorPgsmEnableQueryPlan",
                        "pgStatMonitorPgsmMaxBuckets",
                        "pgStatStatementsTrack",
                        "pgaudit",
                        "pgbouncer",
                        "pglookout",
                        "serviceLog",
                        "sharedBuffersPercentage",
                        "synchronousReplication",
                        "tempFileLimit",
                        "timescaledb",
                        "trackActivityQuerySize",
                        "trackCommitTimestamp",
                        "trackFunctions",
                        "trackIoTiming",
                        "variant",
                        "version",
                        "walSenderTimeout",
                        "walWriterDelay",
                        "workMem"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabasePostgresqlPropertiesMigration:ManagedDatabasePostgresqlPropertiesMigration": {
            "properties": {
                "dbname": {
                    "type": "string",
                    "description": "Database name for bootstrapping the initial connection.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname or IP address of the server where to migrate data from.\n"
                },
                "ignoreDbs": {
                    "type": "string",
                    "description": "Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).\n"
                },
                "ignoreRoles": {
                    "type": "string",
                    "description": "Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).\n"
                },
                "method": {
                    "type": "string",
                    "description": "The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for authentication with the server where to migrate data from.\n",
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the server where to migrate data from.\n"
                },
                "ssl": {
                    "type": "boolean",
                    "description": "The server where to migrate data from is secured with SSL.\n"
                },
                "username": {
                    "type": "string",
                    "description": "User name for authentication with the server where to migrate data from.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dbname",
                        "host",
                        "ignoreDbs",
                        "ignoreRoles",
                        "method",
                        "password",
                        "port",
                        "ssl",
                        "username"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabasePostgresqlPropertiesPgaudit:ManagedDatabasePostgresqlPropertiesPgaudit": {
            "properties": {
                "featureEnabled": {
                    "type": "boolean",
                    "description": "Enable pgaudit extension. Enable pgaudit extension. When enabled, pgaudit extension will be automatically installed.Otherwise, extension will be uninstalled but auditing configurations will be preserved.\n"
                },
                "logCatalog": {
                    "type": "boolean",
                    "description": "Specifies that session logging should be enabled in the casewhere all relations in a statement are in pg_catalog.\n"
                },
                "logClient": {
                    "type": "boolean",
                    "description": "Specifies whether log messages will be visible to a client process such as psql.\n"
                },
                "logLevel": {
                    "type": "string",
                    "description": "Specifies the log level that will be used for log entries.\n"
                },
                "logMaxStringLength": {
                    "type": "integer",
                    "description": "Crop parameters representation and whole statements if they exceed this threshold. A (default) value of -1 disable the truncation.\n"
                },
                "logNestedStatements": {
                    "type": "boolean",
                    "description": "This GUC allows to turn off logging nested statements, that is, statements that are executed as part of another ExecutorRun.\n"
                },
                "logParameter": {
                    "type": "boolean",
                    "description": "Specifies that audit logging should include the parameters that were passed with the statement.\n"
                },
                "logParameterMaxSize": {
                    "type": "integer",
                    "description": "Specifies that parameter values longer than this setting (in bytes) should not be logged, but replaced with \u003clong param suppressed\u003e.\n"
                },
                "logRelation": {
                    "type": "boolean",
                    "description": "Specifies whether session audit logging should create a separate log entry for each relation (TABLE, VIEW, etc.) referenced in a SELECT or DML statement.\n"
                },
                "logRows": {
                    "type": "boolean",
                    "description": "Specifies that audit logging should include the rows retrieved or affected by a statement. When enabled the rows field will be included after the parameter field.\n"
                },
                "logStatement": {
                    "type": "boolean",
                    "description": "Specifies whether logging will include the statement text and parameters (if enabled).\n"
                },
                "logStatementOnce": {
                    "type": "boolean",
                    "description": "Specifies whether logging will include the statement text and parameters with the first log entry for a statement/substatement combination or with every entry.\n"
                },
                "logs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies which classes of statements will be logged by session audit logging.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the master role to use for object audit logging.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "featureEnabled",
                        "logCatalog",
                        "logClient",
                        "logLevel",
                        "logMaxStringLength",
                        "logNestedStatements",
                        "logParameter",
                        "logParameterMaxSize",
                        "logRelation",
                        "logRows",
                        "logStatement",
                        "logStatementOnce",
                        "logs",
                        "role"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabasePostgresqlPropertiesPgbouncer:ManagedDatabasePostgresqlPropertiesPgbouncer": {
            "properties": {
                "autodbIdleTimeout": {
                    "type": "integer",
                    "description": "If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].\n"
                },
                "autodbMaxDbConnections": {
                    "type": "integer",
                    "description": "Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.\n"
                },
                "autodbPoolMode": {
                    "type": "string",
                    "description": "PGBouncer pool mode.\n"
                },
                "autodbPoolSize": {
                    "type": "integer",
                    "description": "If non-zero then create automatically a pool of that size per user when a pool doesn't exist.\n"
                },
                "ignoreStartupParameters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of parameters to ignore when given in startup packet.\n"
                },
                "maxPreparedStatements": {
                    "type": "integer",
                    "description": "PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.\n"
                },
                "minPoolSize": {
                    "type": "integer",
                    "description": "Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.\n"
                },
                "serverIdleTimeout": {
                    "type": "integer",
                    "description": "If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].\n"
                },
                "serverLifetime": {
                    "type": "integer",
                    "description": "The pooler will close an unused server connection that has been connected longer than this. [seconds].\n"
                },
                "serverResetQueryAlways": {
                    "type": "boolean",
                    "description": "Run server_reset_query (DISCARD ALL) in all pooling modes.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "autodbIdleTimeout",
                        "autodbMaxDbConnections",
                        "autodbPoolMode",
                        "autodbPoolSize",
                        "ignoreStartupParameters",
                        "maxPreparedStatements",
                        "minPoolSize",
                        "serverIdleTimeout",
                        "serverLifetime",
                        "serverResetQueryAlways"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabasePostgresqlPropertiesPglookout:ManagedDatabasePostgresqlPropertiesPglookout": {
            "properties": {
                "maxFailoverReplicationTimeLag": {
                    "type": "integer",
                    "description": "Number of seconds of master unavailability before triggering database failover to standby.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "maxFailoverReplicationTimeLag"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabasePostgresqlPropertiesTimescaledb:ManagedDatabasePostgresqlPropertiesTimescaledb": {
            "properties": {
                "maxBackgroundWorkers": {
                    "type": "integer",
                    "description": "The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "maxBackgroundWorkers"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseRedisComponent:ManagedDatabaseRedisComponent": {
            "properties": {
                "component": {
                    "type": "string",
                    "description": "Type of the component\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname of the component\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the component\n"
                },
                "route": {
                    "type": "string",
                    "description": "Component network route type\n"
                },
                "usage": {
                    "type": "string",
                    "description": "Usage of the component\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "component",
                        "host",
                        "port",
                        "route",
                        "usage"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseRedisNetwork:ManagedDatabaseRedisNetwork": {
            "properties": {
                "family": {
                    "type": "string",
                    "description": "Network family. Currently only `IPv4` is supported.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network. Must be unique within the service.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network. Must be private.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Private network UUID. Must reside in the same zone as the database.\n"
                }
            },
            "type": "object",
            "required": [
                "family",
                "name",
                "type",
                "uuid"
            ]
        },
        "upcloud:index/ManagedDatabaseRedisNodeState:ManagedDatabaseRedisNodeState": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name plus a node iteration\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role of the node\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the node\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "role",
                        "state"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseRedisProperties:ManagedDatabaseRedisProperties": {
            "properties": {
                "automaticUtilityNetworkIpFilter": {
                    "type": "boolean",
                    "description": "Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.\n"
                },
                "backupHour": {
                    "type": "integer",
                    "description": "The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.\n"
                },
                "backupMinute": {
                    "type": "integer",
                    "description": "The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.\n"
                },
                "ipFilters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.\n"
                },
                "migration": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseRedisPropertiesMigration:ManagedDatabaseRedisPropertiesMigration",
                    "description": "Migrate data from existing server.\n"
                },
                "publicAccess": {
                    "type": "boolean",
                    "description": "Public Access. Allow access to the service from the public Internet.\n"
                },
                "redisAclChannelsDefault": {
                    "type": "string",
                    "description": "Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.\n"
                },
                "redisIoThreads": {
                    "type": "integer",
                    "description": "Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.\n"
                },
                "redisLfuDecayTime": {
                    "type": "integer",
                    "description": "LFU maxmemory-policy counter decay time in minutes.\n"
                },
                "redisLfuLogFactor": {
                    "type": "integer",
                    "description": "Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.\n"
                },
                "redisMaxmemoryPolicy": {
                    "type": "string",
                    "description": "Redis maxmemory-policy.\n"
                },
                "redisNotifyKeyspaceEvents": {
                    "type": "string",
                    "description": "Set notify-keyspace-events option.\n"
                },
                "redisNumberOfDatabases": {
                    "type": "integer",
                    "description": "Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.\n"
                },
                "redisPersistence": {
                    "type": "string",
                    "description": "Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.\n"
                },
                "redisPubsubClientOutputBufferLimit": {
                    "type": "integer",
                    "description": "Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.\n"
                },
                "redisSsl": {
                    "type": "boolean",
                    "description": "Require SSL to access Redis.\n"
                },
                "redisTimeout": {
                    "type": "integer",
                    "description": "Redis idle connection timeout in seconds.\n"
                },
                "redisVersion": {
                    "type": "string",
                    "description": "Redis major version.\n"
                },
                "serviceLog": {
                    "type": "boolean",
                    "description": "Service logging. Store logs for the service so that they are available in the HTTP API and console.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "backupHour",
                        "backupMinute",
                        "ipFilters",
                        "migration",
                        "redisAclChannelsDefault",
                        "redisIoThreads",
                        "redisLfuDecayTime",
                        "redisLfuLogFactor",
                        "redisMaxmemoryPolicy",
                        "redisNumberOfDatabases",
                        "redisPersistence",
                        "redisPubsubClientOutputBufferLimit",
                        "redisTimeout",
                        "redisVersion",
                        "serviceLog"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseRedisPropertiesMigration:ManagedDatabaseRedisPropertiesMigration": {
            "properties": {
                "dbname": {
                    "type": "string",
                    "description": "Database name for bootstrapping the initial connection.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname or IP address of the server where to migrate data from.\n"
                },
                "ignoreDbs": {
                    "type": "string",
                    "description": "Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).\n"
                },
                "ignoreRoles": {
                    "type": "string",
                    "description": "Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).\n"
                },
                "method": {
                    "type": "string",
                    "description": "The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for authentication with the server where to migrate data from.\n",
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the server where to migrate data from.\n"
                },
                "ssl": {
                    "type": "boolean",
                    "description": "The server where to migrate data from is secured with SSL.\n"
                },
                "username": {
                    "type": "string",
                    "description": "User name for authentication with the server where to migrate data from.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dbname",
                        "host",
                        "ignoreDbs",
                        "ignoreRoles",
                        "method",
                        "password",
                        "port",
                        "ssl",
                        "username"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseUserOpensearchAccessControl:ManagedDatabaseUserOpensearchAccessControl": {
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseUserOpensearchAccessControlRule:ManagedDatabaseUserOpensearchAccessControlRule"
                    },
                    "description": "Set user access control rules.\n"
                }
            },
            "type": "object",
            "required": [
                "rules"
            ]
        },
        "upcloud:index/ManagedDatabaseUserOpensearchAccessControlRule:ManagedDatabaseUserOpensearchAccessControlRule": {
            "properties": {
                "index": {
                    "type": "string",
                    "description": "Set index name, pattern or top level API.\n"
                },
                "permission": {
                    "type": "string",
                    "description": "Set permission access.\n"
                }
            },
            "type": "object",
            "required": [
                "index",
                "permission"
            ]
        },
        "upcloud:index/ManagedDatabaseUserPgAccessControl:ManagedDatabaseUserPgAccessControl": {
            "properties": {
                "allowReplication": {
                    "type": "boolean",
                    "description": "Grant replication privilege\n"
                }
            },
            "type": "object"
        },
        "upcloud:index/ManagedDatabaseUserRedisAccessControl:ManagedDatabaseUserRedisAccessControl": {
            "properties": {
                "categories": {
                    "type": "string",
                    "description": "Set access control to all commands in specified categories.\n"
                },
                "channels": {
                    "type": "string",
                    "description": "Set access control to Pub/Sub channels.\n"
                },
                "commands": {
                    "type": "string",
                    "description": "Set access control to commands.\n"
                },
                "keys": {
                    "type": "string",
                    "description": "Set access control to keys.\n"
                }
            },
            "type": "object"
        },
        "upcloud:index/ManagedDatabaseUserValkeyAccessControl:ManagedDatabaseUserValkeyAccessControl": {
            "properties": {
                "categories": {
                    "type": "string",
                    "description": "Set access control to all commands in specified categories.\n"
                },
                "channels": {
                    "type": "string",
                    "description": "Set access control to Pub/Sub channels.\n"
                },
                "commands": {
                    "type": "string",
                    "description": "Set access control to commands.\n"
                },
                "keys": {
                    "type": "string",
                    "description": "Set access control to keys.\n"
                }
            },
            "type": "object"
        },
        "upcloud:index/ManagedDatabaseValkeyComponent:ManagedDatabaseValkeyComponent": {
            "properties": {
                "component": {
                    "type": "string",
                    "description": "Type of the component\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname of the component\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the component\n"
                },
                "route": {
                    "type": "string",
                    "description": "Component network route type\n"
                },
                "usage": {
                    "type": "string",
                    "description": "Usage of the component\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "component",
                        "host",
                        "port",
                        "route",
                        "usage"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseValkeyNetwork:ManagedDatabaseValkeyNetwork": {
            "properties": {
                "family": {
                    "type": "string",
                    "description": "Network family. Currently only `IPv4` is supported.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the network. Must be unique within the service.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the network. Must be private.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Private network UUID. Must reside in the same zone as the database.\n"
                }
            },
            "type": "object",
            "required": [
                "family",
                "name",
                "type",
                "uuid"
            ]
        },
        "upcloud:index/ManagedDatabaseValkeyNodeState:ManagedDatabaseValkeyNodeState": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name plus a node iteration\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role of the node\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the node\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "role",
                        "state"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseValkeyProperties:ManagedDatabaseValkeyProperties": {
            "properties": {
                "automaticUtilityNetworkIpFilter": {
                    "type": "boolean",
                    "description": "Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.\n"
                },
                "backupHour": {
                    "type": "integer",
                    "description": "The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.\n"
                },
                "backupMinute": {
                    "type": "integer",
                    "description": "The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.\n"
                },
                "frequentSnapshots": {
                    "type": "boolean",
                    "description": "Frequent RDB snapshots. When enabled, Valkey will create frequent local RDB snapshots. When disabled, Valkey will only take RDB snapshots when a backup is created, based on the backup schedule. This setting is ignored when `valkey_persistence` is set to `off`.\n"
                },
                "ipFilters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.\n"
                },
                "migration": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyPropertiesMigration:ManagedDatabaseValkeyPropertiesMigration",
                    "description": "Migrate data from existing server.\n"
                },
                "publicAccess": {
                    "type": "boolean",
                    "description": "Public Access. Allow access to the service from the public Internet.\n"
                },
                "serviceLog": {
                    "type": "boolean",
                    "description": "Service logging. Store logs for the service so that they are available in the HTTP API and console.\n"
                },
                "valkeyAclChannelsDefault": {
                    "type": "string",
                    "description": "Default ACL for pub/sub channels used when a Valkey user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Valkey configuration acl-pubsub-default.\n"
                },
                "valkeyActiveExpireEffort": {
                    "type": "integer",
                    "description": "Active expire effort. Valkey reclaims expired keys both when accessed and in the background. The background process scans for expired keys to free memory. Increasing the active-expire-effort setting (default 1, max 10) uses more CPU to reclaim expired keys faster, reducing memory usage but potentially increasing latency.\n"
                },
                "valkeyIoThreads": {
                    "type": "integer",
                    "description": "Valkey IO thread count. Set Valkey IO thread count. Changing this will cause a restart of the Valkey service.\n"
                },
                "valkeyLfuDecayTime": {
                    "type": "integer",
                    "description": "LFU maxmemory-policy counter decay time in minutes.\n"
                },
                "valkeyLfuLogFactor": {
                    "type": "integer",
                    "description": "Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.\n"
                },
                "valkeyMaxmemoryPolicy": {
                    "type": "string",
                    "description": "Valkey maxmemory-policy.\n"
                },
                "valkeyNotifyKeyspaceEvents": {
                    "type": "string",
                    "description": "Set notify-keyspace-events option.\n"
                },
                "valkeyNumberOfDatabases": {
                    "type": "integer",
                    "description": "Number of Valkey databases. Set number of Valkey databases. Changing this will cause a restart of the Valkey service.\n"
                },
                "valkeyPersistence": {
                    "type": "string",
                    "description": "Valkey persistence. When persistence is 'rdb', Valkey does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.\n"
                },
                "valkeyPubsubClientOutputBufferLimit": {
                    "type": "integer",
                    "description": "Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.\n"
                },
                "valkeySsl": {
                    "type": "boolean",
                    "description": "Require SSL to access Valkey.\n"
                },
                "valkeyTimeout": {
                    "type": "integer",
                    "description": "Valkey idle connection timeout in seconds.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "backupHour",
                        "backupMinute",
                        "ipFilters",
                        "migration",
                        "serviceLog",
                        "valkeyAclChannelsDefault",
                        "valkeyActiveExpireEffort",
                        "valkeyIoThreads",
                        "valkeyLfuDecayTime",
                        "valkeyLfuLogFactor",
                        "valkeyMaxmemoryPolicy",
                        "valkeyNumberOfDatabases",
                        "valkeyPersistence",
                        "valkeyPubsubClientOutputBufferLimit",
                        "valkeyTimeout"
                    ]
                }
            }
        },
        "upcloud:index/ManagedDatabaseValkeyPropertiesMigration:ManagedDatabaseValkeyPropertiesMigration": {
            "properties": {
                "dbname": {
                    "type": "string",
                    "description": "Database name for bootstrapping the initial connection.\n"
                },
                "host": {
                    "type": "string",
                    "description": "Hostname or IP address of the server where to migrate data from.\n"
                },
                "ignoreDbs": {
                    "type": "string",
                    "description": "Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).\n"
                },
                "ignoreRoles": {
                    "type": "string",
                    "description": "Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).\n"
                },
                "method": {
                    "type": "string",
                    "description": "The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for authentication with the server where to migrate data from.\n",
                    "secret": true
                },
                "port": {
                    "type": "integer",
                    "description": "Port number of the server where to migrate data from.\n"
                },
                "ssl": {
                    "type": "boolean",
                    "description": "The server where to migrate data from is secured with SSL.\n"
                },
                "username": {
                    "type": "string",
                    "description": "User name for authentication with the server where to migrate data from.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dbname",
                        "host",
                        "ignoreDbs",
                        "ignoreRoles",
                        "method",
                        "password",
                        "port",
                        "ssl",
                        "username"
                    ]
                }
            }
        },
        "upcloud:index/ManagedObjectStorageEndpoint:ManagedObjectStorageEndpoint": {
            "properties": {
                "domainName": {
                    "type": "string",
                    "description": "Domain name of the endpoint.\n"
                },
                "iamUrl": {
                    "type": "string",
                    "description": "URL for IAM.\n"
                },
                "stsUrl": {
                    "type": "string",
                    "description": "URL for STS.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the endpoint (`private` / `public`).\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "domainName",
                        "iamUrl",
                        "stsUrl",
                        "type"
                    ]
                }
            }
        },
        "upcloud:index/ManagedObjectStorageNetwork:ManagedObjectStorageNetwork": {
            "properties": {
                "family": {
                    "type": "string",
                    "description": "Network family. IPv6 currently not supported.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Network name. Must be unique within the service.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Network type.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "Private network uuid. For public networks the field should be omitted.\n"
                }
            },
            "type": "object",
            "required": [
                "family",
                "name",
                "type"
            ]
        },
        "upcloud:index/NetworkIpNetwork:NetworkIpNetwork": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The CIDR range of the subnet\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Is DHCP enabled?\n"
                },
                "dhcpDefaultRoute": {
                    "type": "boolean",
                    "description": "Is the gateway the DHCP default route?\n"
                },
                "dhcpDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The DNS servers given by DHCP\n"
                },
                "dhcpRoutes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The additional DHCP classless static routes given by DHCP\n"
                },
                "family": {
                    "type": "string",
                    "description": "IP address family\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway address given by DHCP\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "dhcp",
                "family"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "address",
                        "dhcp",
                        "dhcpDefaultRoute",
                        "dhcpDns",
                        "dhcpRoutes",
                        "family",
                        "gateway"
                    ]
                }
            }
        },
        "upcloud:index/NetworkPeeringNetwork:NetworkPeeringNetwork": {
            "properties": {
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the network.\n"
                }
            },
            "type": "object",
            "required": [
                "uuid"
            ]
        },
        "upcloud:index/NetworkPeeringPeerNetwork:NetworkPeeringPeerNetwork": {
            "properties": {
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the network.\n"
                }
            },
            "type": "object",
            "required": [
                "uuid"
            ]
        },
        "upcloud:index/ObjectStorageBucket:ObjectStorageBucket": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the bucket\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "upcloud:index/RouterStaticRoute:RouterStaticRoute": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "nexthop": {
                    "type": "string"
                },
                "route": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "nexthop",
                "route",
                "type"
            ]
        },
        "upcloud:index/ServerFirewallRulesFirewallRule:ServerFirewallRulesFirewallRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action to take if the rule conditions are met. Valid values `accept | drop`\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Freeform comment string for the rule\n",
                    "willReplaceOnChanges": true
                },
                "destinationAddressEnd": {
                    "type": "string",
                    "description": "The destination address range ends from this address\n",
                    "willReplaceOnChanges": true
                },
                "destinationAddressStart": {
                    "type": "string",
                    "description": "The destination address range starts from this address\n",
                    "willReplaceOnChanges": true
                },
                "destinationPortEnd": {
                    "type": "string",
                    "description": "The destination port range ends from this port number\n",
                    "willReplaceOnChanges": true
                },
                "destinationPortStart": {
                    "type": "string",
                    "description": "The destination port range starts from this port number\n",
                    "willReplaceOnChanges": true
                },
                "direction": {
                    "type": "string",
                    "description": "The direction of network traffic this rule will be applied to\n",
                    "willReplaceOnChanges": true
                },
                "family": {
                    "type": "string",
                    "description": "The address family of new firewall rule\n",
                    "willReplaceOnChanges": true
                },
                "icmpType": {
                    "type": "string",
                    "description": "The ICMP type\n",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol this rule will be applied to\n",
                    "willReplaceOnChanges": true
                },
                "sourceAddressEnd": {
                    "type": "string",
                    "description": "The source address range ends from this address\n",
                    "willReplaceOnChanges": true
                },
                "sourceAddressStart": {
                    "type": "string",
                    "description": "The source address range starts from this address\n",
                    "willReplaceOnChanges": true
                },
                "sourcePortEnd": {
                    "type": "string",
                    "description": "The source port range ends from this port number\n",
                    "willReplaceOnChanges": true
                },
                "sourcePortStart": {
                    "type": "string",
                    "description": "The source port range starts from this port number\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "action",
                "direction"
            ]
        },
        "upcloud:index/ServerLogin:ServerLogin": {
            "properties": {
                "createPassword": {
                    "type": "boolean",
                    "description": "Indicates a password should be create to allow access\n"
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of ssh keys to access the server\n"
                },
                "passwordDelivery": {
                    "type": "string",
                    "description": "The delivery method for the server's root password (one of `none`, `email` or `sms`)\n"
                },
                "user": {
                    "type": "string",
                    "description": "Username to be create to access the server\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "createPassword",
                        "passwordDelivery"
                    ]
                }
            }
        },
        "upcloud:index/ServerNetworkInterface:ServerNetworkInterface": {
            "properties": {
                "additionalIpAddresses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ServerNetworkInterfaceAdditionalIpAddress:ServerNetworkInterfaceAdditionalIpAddress"
                    },
                    "description": "0-31 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`\n"
                },
                "bootable": {
                    "type": "boolean",
                    "description": "`true` if this interface should be used for network booting.\n"
                },
                "index": {
                    "type": "integer",
                    "description": "The interface index.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "The primary IP address of this interface.\n"
                },
                "ipAddressFamily": {
                    "type": "string",
                    "description": "The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).\n"
                },
                "ipAddressFloating": {
                    "type": "boolean",
                    "description": "`true` indicates that the primary IP address is a floating IP address.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of the interface.\n"
                },
                "network": {
                    "type": "string",
                    "description": "The UUID of the network to attach this interface to. Required for private network interfaces.\n"
                },
                "sourceIpFiltering": {
                    "type": "boolean",
                    "description": "`true` if source IP should be filtered.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Network interface type. For private network interfaces, a network must be specified with an existing network id.\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bootable",
                        "index",
                        "ipAddress",
                        "ipAddressFamily",
                        "ipAddressFloating",
                        "macAddress",
                        "network",
                        "sourceIpFiltering",
                        "type"
                    ]
                }
            }
        },
        "upcloud:index/ServerNetworkInterfaceAdditionalIpAddress:ServerNetworkInterfaceAdditionalIpAddress": {
            "properties": {
                "ipAddress": {
                    "type": "string",
                    "description": "An additional IP address for this interface.\n"
                },
                "ipAddressFamily": {
                    "type": "string",
                    "description": "The type of the additional IP address of this interface (one of `IPv4` or `IPv6`).\n"
                },
                "ipAddressFloating": {
                    "type": "boolean",
                    "description": "`true` indicates that the additional IP address is a floating IP address.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ipAddress",
                        "ipAddressFamily",
                        "ipAddressFloating"
                    ]
                }
            }
        },
        "upcloud:index/ServerSimpleBackup:ServerSimpleBackup": {
            "properties": {
                "plan": {
                    "type": "string",
                    "description": "Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).\n"
                }
            },
            "type": "object"
        },
        "upcloud:index/ServerStorageDevice:ServerStorageDevice": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.\n"
                },
                "addressPosition": {
                    "type": "string",
                    "description": "The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.\n"
                },
                "storage": {
                    "type": "string",
                    "description": "The UUID of the storage to attach to the server.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The device type the storage will be attached as\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "address",
                        "addressPosition",
                        "type"
                    ]
                }
            }
        },
        "upcloud:index/ServerTemplate:ServerTemplate": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.\n"
                },
                "addressPosition": {
                    "type": "string",
                    "description": "The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.\n"
                },
                "backupRule": {
                    "$ref": "#/types/upcloud:index/ServerTemplateBackupRule:ServerTemplateBackupRule"
                },
                "deleteAutoresizeBackup": {
                    "type": "boolean",
                    "description": "If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.\n"
                },
                "encrypt": {
                    "type": "boolean",
                    "description": "Sets if the storage is encrypted at rest\n"
                },
                "filesystemAutoresize": {
                    "type": "boolean",
                    "description": "If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.\n\t\t\t\t\t\t\tPlease note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used\n\t\t\t\t\t\t\tto restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).\n\t\t\t\t\t\t\tTaking and keeping backups incure costs.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique identifier for the storage\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the storage in gigabytes\n"
                },
                "storage": {
                    "type": "string",
                    "description": "A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.\n"
                },
                "tier": {
                    "type": "string",
                    "description": "The storage tier to use.\n"
                },
                "title": {
                    "type": "string",
                    "description": "A short, informative description\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "address",
                        "addressPosition",
                        "deleteAutoresizeBackup",
                        "encrypt",
                        "filesystemAutoresize",
                        "id",
                        "size",
                        "tier",
                        "title"
                    ]
                }
            }
        },
        "upcloud:index/ServerTemplateBackupRule:ServerTemplateBackupRule": {
            "properties": {
                "interval": {
                    "type": "string",
                    "description": "The weekday when the backup is created\n"
                },
                "retention": {
                    "type": "integer",
                    "description": "The number of days before a backup is automatically deleted\n"
                },
                "time": {
                    "type": "string",
                    "description": "The time of day when the backup is created\n"
                }
            },
            "type": "object",
            "required": [
                "interval",
                "retention",
                "time"
            ]
        },
        "upcloud:index/StorageBackupRule:StorageBackupRule": {
            "properties": {
                "interval": {
                    "type": "string",
                    "description": "The weekday when the backup is created\n"
                },
                "retention": {
                    "type": "integer",
                    "description": "The number of days before a backup is automatically deleted\n"
                },
                "time": {
                    "type": "string",
                    "description": "The time of day when the backup is created\n"
                }
            },
            "type": "object",
            "required": [
                "interval",
                "retention",
                "time"
            ]
        },
        "upcloud:index/StorageClone:StorageClone": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The unique identifier of the storage/template to clone.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "upcloud:index/StorageImport:StorageImport": {
            "properties": {
                "sha256sum": {
                    "type": "string",
                    "description": "sha256 sum of the imported data\n"
                },
                "source": {
                    "type": "string",
                    "description": "The mode of the import task. One of `http_import` or `direct_upload`.\n"
                },
                "sourceHash": {
                    "type": "string",
                    "description": "SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.\n"
                },
                "sourceLocation": {
                    "type": "string",
                    "description": "The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).\n"
                },
                "writtenBytes": {
                    "type": "integer",
                    "description": "Number of bytes imported\n"
                }
            },
            "type": "object",
            "required": [
                "source",
                "sourceLocation"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "sha256sum",
                        "source",
                        "sourceLocation",
                        "writtenBytes"
                    ]
                }
            }
        },
        "upcloud:index/getHostsHost:getHostsHost": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Free form text describing the host\n"
                },
                "hostId": {
                    "type": "integer",
                    "description": "The unique id of the host\n"
                },
                "statistics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/getHostsHostStatistic:getHostsHostStatistic"
                    }
                },
                "windowsEnabled": {
                    "type": "boolean",
                    "description": "If true, this node can be used as a host for Windows servers.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "hostId",
                "windowsEnabled",
                "zone"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getHostsHostStatistic:getHostsHostStatistic": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the statistic\n"
                },
                "timestamp": {
                    "type": "string",
                    "description": "The timestamp of the statistic\n"
                },
                "value": {
                    "type": "number",
                    "description": "The value of the statistic\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "timestamp",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getIpAddressesAddress:getIpAddressesAddress": {
            "properties": {
                "access": {
                    "type": "string",
                    "description": "Is address for utility or public network\n"
                },
                "address": {
                    "type": "string",
                    "description": "An UpCloud assigned IP Address\n"
                },
                "family": {
                    "type": "string",
                    "description": "IP address family\n"
                },
                "floating": {
                    "type": "boolean",
                    "description": "Does the IP Address represents a floating IP Address\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of server interface to assign address to\n"
                },
                "partOfPlan": {
                    "type": "boolean",
                    "description": "Is the address a part of a plan\n"
                },
                "ptrRecord": {
                    "type": "string",
                    "description": "A reverse DNS record entry\n"
                },
                "server": {
                    "type": "string",
                    "description": "The unique identifier for a server\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone of address, required when assigning a detached floating IP address, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "type": "object",
            "required": [
                "access",
                "address",
                "family",
                "floating",
                "mac",
                "partOfPlan",
                "ptrRecord",
                "server",
                "zone"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getManagedDatabaseMysqlSessionsSession:getManagedDatabaseMysqlSessionsSession": {
            "properties": {
                "applicationName": {
                    "type": "string",
                    "description": "Name of the application that is connected to this service.\n"
                },
                "clientAddr": {
                    "type": "string",
                    "description": "IP address of the client connected to this service.\n"
                },
                "datname": {
                    "type": "string",
                    "description": "Name of the database this service is connected to.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Process ID of this service.\n"
                },
                "query": {
                    "type": "string",
                    "description": "Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.\n"
                },
                "queryDuration": {
                    "type": "string",
                    "description": "The active query current duration.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.\n"
                },
                "usename": {
                    "type": "string",
                    "description": "Name of the user logged into this service.\n"
                }
            },
            "type": "object",
            "required": [
                "applicationName",
                "clientAddr",
                "datname",
                "id",
                "query",
                "queryDuration",
                "state",
                "usename"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getManagedDatabaseOpensearchIndicesIndex:getManagedDatabaseOpensearchIndicesIndex": {
            "properties": {
                "createTime": {
                    "type": "string",
                    "description": "Timestamp indicating the creation time of the index.\n"
                },
                "docs": {
                    "type": "integer",
                    "description": "Number of documents stored in the index.\n"
                },
                "health": {
                    "type": "string",
                    "description": "Health status of the index e.g. `green`, `yellow`, or `red`.\n"
                },
                "indexName": {
                    "type": "string",
                    "description": "Name of the index.\n"
                },
                "numberOfReplicas": {
                    "type": "integer",
                    "description": "Number of replicas configured for the index.\n"
                },
                "numberOfShards": {
                    "type": "integer",
                    "description": "Number of shards configured \u0026 used by the index.\n"
                },
                "readOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the index in bytes.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the index e.g. `open` or `closed`.\n"
                }
            },
            "type": "object",
            "required": [
                "createTime",
                "docs",
                "health",
                "indexName",
                "numberOfReplicas",
                "numberOfShards",
                "readOnlyAllowDelete",
                "size",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getManagedDatabasePostgresqlSessionsSession:getManagedDatabasePostgresqlSessionsSession": {
            "properties": {
                "applicationName": {
                    "type": "string",
                    "description": "Name of the application that is connected to this service.\n"
                },
                "backendStart": {
                    "type": "string",
                    "description": "Time when this process was started, i.e., when the client connected to the server.\n"
                },
                "backendType": {
                    "type": "string",
                    "description": "Type of current service.\n"
                },
                "backendXid": {
                    "type": "integer",
                    "description": "Top-level transaction identifier of this service, if any.\n"
                },
                "backendXmin": {
                    "type": "integer",
                    "description": "The current service's xmin horizon.\n"
                },
                "clientAddr": {
                    "type": "string",
                    "description": "IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.\n"
                },
                "clientHostname": {
                    "type": "string",
                    "description": "Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.\n"
                },
                "clientPort": {
                    "type": "integer",
                    "description": "TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.\n"
                },
                "datid": {
                    "type": "integer",
                    "description": "OID of the database this service is connected to.\n"
                },
                "datname": {
                    "type": "string",
                    "description": "Name of the database this service is connected to.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Process ID of this service.\n"
                },
                "query": {
                    "type": "string",
                    "description": "Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.\n"
                },
                "queryDuration": {
                    "type": "string",
                    "description": "The active query current duration.\n"
                },
                "queryStart": {
                    "type": "string",
                    "description": "Time when the currently active query was started, or if state is not active, when the last query was started.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.\n"
                },
                "stateChange": {
                    "type": "string",
                    "description": "Time when the state was last changed.\n"
                },
                "usename": {
                    "type": "string",
                    "description": "Name of the user logged into this service.\n"
                },
                "usesysid": {
                    "type": "integer",
                    "description": "OID of the user logged into this service.\n"
                },
                "waitEvent": {
                    "type": "string",
                    "description": "Wait event name if service is currently waiting.\n"
                },
                "waitEventType": {
                    "type": "string",
                    "description": "The type of event for which the service is waiting, if any; otherwise NULL.\n"
                },
                "xactStart": {
                    "type": "string",
                    "description": "Time when this process' current transaction was started, or null if no transaction is active.\n"
                }
            },
            "type": "object",
            "required": [
                "applicationName",
                "backendStart",
                "backendType",
                "backendXid",
                "backendXmin",
                "clientAddr",
                "clientHostname",
                "clientPort",
                "datid",
                "datname",
                "id",
                "query",
                "queryDuration",
                "queryStart",
                "state",
                "stateChange",
                "usename",
                "usesysid",
                "waitEvent",
                "waitEventType",
                "xactStart"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getManagedDatabaseRedisSessionsSession:getManagedDatabaseRedisSessionsSession": {
            "properties": {
                "activeChannelSubscriptions": {
                    "type": "integer",
                    "description": "Number of active channel subscriptions\n"
                },
                "activeDatabase": {
                    "type": "string",
                    "description": "Current database ID\n"
                },
                "activePatternMatchingChannelSubscriptions": {
                    "type": "integer",
                    "description": "Number of pattern matching subscriptions.\n"
                },
                "applicationName": {
                    "type": "string",
                    "description": "Name of the application that is connected to this service.\n"
                },
                "clientAddr": {
                    "type": "string",
                    "description": "Number of pattern matching subscriptions.\n"
                },
                "connectionAge": {
                    "type": "integer",
                    "description": "Total duration of the connection in nanoseconds.\n"
                },
                "connectionIdle": {
                    "type": "integer",
                    "description": "Idle time of the connection in nanoseconds.\n"
                },
                "flags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set containing flags' descriptions.\n"
                },
                "flagsRaw": {
                    "type": "string",
                    "description": "Client connection flags in raw string format.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Process ID of this session.\n"
                },
                "multiExecCommands": {
                    "type": "integer",
                    "description": "Number of commands in a MULTI/EXEC context.\n"
                },
                "outputBuffer": {
                    "type": "integer",
                    "description": "Output buffer length.\n"
                },
                "outputBufferMemory": {
                    "type": "integer",
                    "description": "Output buffer memory usage.\n"
                },
                "outputListLength": {
                    "type": "integer",
                    "description": "Output list length (replies are queued in this list when the buffer is full).\n"
                },
                "query": {
                    "type": "string",
                    "description": "The last executed command.\n"
                },
                "queryBuffer": {
                    "type": "integer",
                    "description": "Query buffer length (0 means no query pending).\n"
                },
                "queryBufferFree": {
                    "type": "integer",
                    "description": "Free space of the query buffer (0 means the buffer is full).\n"
                }
            },
            "type": "object",
            "required": [
                "activeChannelSubscriptions",
                "activeDatabase",
                "activePatternMatchingChannelSubscriptions",
                "applicationName",
                "clientAddr",
                "connectionAge",
                "connectionIdle",
                "flags",
                "flagsRaw",
                "id",
                "multiExecCommands",
                "outputBuffer",
                "outputBufferMemory",
                "outputListLength",
                "query",
                "queryBuffer",
                "queryBufferFree"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getManagedDatabaseValkeySessionsSession:getManagedDatabaseValkeySessionsSession": {
            "properties": {
                "activeChannelSubscriptions": {
                    "type": "integer",
                    "description": "Number of active channel subscriptions\n"
                },
                "activeDatabase": {
                    "type": "string",
                    "description": "Current database ID\n"
                },
                "activePatternMatchingChannelSubscriptions": {
                    "type": "integer",
                    "description": "Number of pattern matching subscriptions.\n"
                },
                "applicationName": {
                    "type": "string",
                    "description": "Name of the application that is connected to this service.\n"
                },
                "clientAddr": {
                    "type": "string",
                    "description": "Number of pattern matching subscriptions.\n"
                },
                "connectionAge": {
                    "type": "integer",
                    "description": "Total duration of the connection in nanoseconds.\n"
                },
                "connectionIdle": {
                    "type": "integer",
                    "description": "Idle time of the connection in nanoseconds.\n"
                },
                "flags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set containing flags' descriptions.\n"
                },
                "flagsRaw": {
                    "type": "string",
                    "description": "Client connection flags in raw string format.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Process ID of this session.\n"
                },
                "multiExecCommands": {
                    "type": "integer",
                    "description": "Number of commands in a MULTI/EXEC context.\n"
                },
                "outputBuffer": {
                    "type": "integer",
                    "description": "Output buffer length.\n"
                },
                "outputBufferMemory": {
                    "type": "integer",
                    "description": "Output buffer memory usage.\n"
                },
                "outputListLength": {
                    "type": "integer",
                    "description": "Output list length (replies are queued in this list when the buffer is full).\n"
                },
                "query": {
                    "type": "string",
                    "description": "The last executed command.\n"
                },
                "queryBuffer": {
                    "type": "integer",
                    "description": "Query buffer length (0 means no query pending).\n"
                },
                "queryBufferFree": {
                    "type": "integer",
                    "description": "Free space of the query buffer (0 means the buffer is full).\n"
                }
            },
            "type": "object",
            "required": [
                "activeChannelSubscriptions",
                "activeDatabase",
                "activePatternMatchingChannelSubscriptions",
                "applicationName",
                "clientAddr",
                "connectionAge",
                "connectionIdle",
                "flags",
                "flagsRaw",
                "id",
                "multiExecCommands",
                "outputBuffer",
                "outputBufferMemory",
                "outputListLength",
                "query",
                "queryBuffer",
                "queryBufferFree"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getManagedObjectStoragePoliciesPolicy:getManagedObjectStoragePoliciesPolicy": {
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "Policy ARN.\n"
                },
                "attachmentCount": {
                    "type": "integer",
                    "description": "Attachment count.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "defaultVersionId": {
                    "type": "string",
                    "description": "Default version id.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the policy.\n"
                },
                "document": {
                    "type": "string",
                    "description": "Policy document, URL-encoded compliant with RFC 3986.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Policy name.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                },
                "system": {
                    "type": "boolean",
                    "description": "Defines whether the policy was set up by the system.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                }
            },
            "type": "object",
            "required": [
                "arn",
                "attachmentCount",
                "createdAt",
                "defaultVersionId",
                "document",
                "name",
                "serviceUuid",
                "system",
                "updatedAt"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getManagedObjectStorageRegionsRegion:getManagedObjectStorageRegionsRegion": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the region.\n"
                },
                "primaryZone": {
                    "type": "string",
                    "description": "Primary zone of the region.\n"
                },
                "zones": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of zones in the region.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "primaryZone",
                "zones"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getNetworksNetwork:getNetworksNetwork": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The UUID of the network\n"
                },
                "ipNetworks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/getNetworksNetworkIpNetwork:getNetworksNetworkIpNetwork"
                    },
                    "description": "A list of IP subnets within the network\n"
                },
                "name": {
                    "type": "string",
                    "description": "A valid name for the network\n"
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/getNetworksNetworkServer:getNetworksNetworkServer"
                    },
                    "description": "A list of attached servers\n"
                },
                "type": {
                    "type": "string",
                    "description": "The network type\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone the network is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "ipNetworks",
                "name",
                "servers",
                "type",
                "zone"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getNetworksNetworkIpNetwork:getNetworksNetworkIpNetwork": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The CIDR range of the subnet\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Is DHCP enabled?\n"
                },
                "dhcpDefaultRoute": {
                    "type": "boolean",
                    "description": "Is the gateway the DHCP default route?\n"
                },
                "dhcpDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The DNS servers given by DHCP\n"
                },
                "dhcpRoutes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The additional DHCP classless static routes given by DHCP\n"
                },
                "family": {
                    "type": "string",
                    "description": "IP address family\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway address given by DHCP\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "dhcp",
                "dhcpDefaultRoute",
                "dhcpDns",
                "dhcpRoutes",
                "family",
                "gateway"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getNetworksNetworkServer:getNetworksNetworkServer": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The UUID of the server\n"
                },
                "title": {
                    "type": "string",
                    "description": "The short description of the server\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "upcloud:index/getTagsTag:getTagsTag": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Free form text representing the meaning of the tag\n"
                },
                "name": {
                    "type": "string",
                    "description": "The value representing the tag\n"
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A collection of servers that have been assigned the tag\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "name",
                "servers"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the upcloud package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "password": {
                "type": "string",
                "description": "Password for UpCloud API user. Can also be configured using the `UPCLOUD_PASSWORD` environment variable.\n"
            },
            "requestTimeoutSec": {
                "type": "integer",
                "description": "The duration (in seconds) that the provider waits for an HTTP request towards UpCloud API to complete. Defaults to 120\nseconds\n"
            },
            "retryMax": {
                "type": "integer",
                "description": "Maximum number of retries\n"
            },
            "retryWaitMaxSec": {
                "type": "integer",
                "description": "Maximum time to wait between retries\n"
            },
            "retryWaitMinSec": {
                "type": "integer",
                "description": "Minimum time to wait between retries\n"
            },
            "token": {
                "type": "string",
                "description": "Token for authenticating to UpCloud API. Can also be configured using the `UPCLOUD_TOKEN` environment variable.\n(EXPERIMENTAL)\n"
            },
            "username": {
                "type": "string",
                "description": "UpCloud username with API access. Can also be configured using the `UPCLOUD_USERNAME` environment variable.\n"
            }
        },
        "inputProperties": {
            "password": {
                "type": "string",
                "description": "Password for UpCloud API user. Can also be configured using the `UPCLOUD_PASSWORD` environment variable.\n"
            },
            "requestTimeoutSec": {
                "type": "integer",
                "description": "The duration (in seconds) that the provider waits for an HTTP request towards UpCloud API to complete. Defaults to 120\nseconds\n"
            },
            "retryMax": {
                "type": "integer",
                "description": "Maximum number of retries\n"
            },
            "retryWaitMaxSec": {
                "type": "integer",
                "description": "Maximum time to wait between retries\n"
            },
            "retryWaitMinSec": {
                "type": "integer",
                "description": "Minimum time to wait between retries\n"
            },
            "token": {
                "type": "string",
                "description": "Token for authenticating to UpCloud API. Can also be configured using the `UPCLOUD_TOKEN` environment variable.\n(EXPERIMENTAL)\n"
            },
            "username": {
                "type": "string",
                "description": "UpCloud username with API access. Can also be configured using the `UPCLOUD_USERNAME` environment variable.\n"
            }
        }
    },
    "resources": {
        "upcloud:index/floatingIpAddress:FloatingIpAddress": {
            "description": "This resource represents a UpCloud floating IP address resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Create a detached floating IP address.\nconst myFloatingAddress = new upcloud.FloatingIpAddress(\"my_floating_address\", {zone: \"de-fra1\"});\n// Floating IP address assigned to a server resource.\nconst example = new upcloud.Server(\"example\", {\n    hostname: \"terraform.example.tld\",\n    zone: \"de-fra1\",\n    plan: \"1xCPU-1GB\",\n    template: {\n        storage: \"Ubuntu Server 20.04 LTS (Focal Fossa)\",\n        size: 25,\n    },\n    networkInterfaces: [{\n        type: \"public\",\n    }],\n});\nconst myNewFloatingAddress = new upcloud.FloatingIpAddress(\"my_new_floating_address\", {macAddress: example.networkInterfaces.apply(networkInterfaces =\u003e networkInterfaces?.[0]?.macAddress)});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Create a detached floating IP address.\nmy_floating_address = upcloud.FloatingIpAddress(\"my_floating_address\", zone=\"de-fra1\")\n# Floating IP address assigned to a server resource.\nexample = upcloud.Server(\"example\",\n    hostname=\"terraform.example.tld\",\n    zone=\"de-fra1\",\n    plan=\"1xCPU-1GB\",\n    template={\n        \"storage\": \"Ubuntu Server 20.04 LTS (Focal Fossa)\",\n        \"size\": 25,\n    },\n    network_interfaces=[{\n        \"type\": \"public\",\n    }])\nmy_new_floating_address = upcloud.FloatingIpAddress(\"my_new_floating_address\", mac_address=example.network_interfaces[0].mac_address)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a detached floating IP address.\n    var myFloatingAddress = new UpCloud.FloatingIpAddress(\"my_floating_address\", new()\n    {\n        Zone = \"de-fra1\",\n    });\n\n    // Floating IP address assigned to a server resource.\n    var example = new UpCloud.Server(\"example\", new()\n    {\n        Hostname = \"terraform.example.tld\",\n        Zone = \"de-fra1\",\n        Plan = \"1xCPU-1GB\",\n        Template = new UpCloud.Inputs.ServerTemplateArgs\n        {\n            Storage = \"Ubuntu Server 20.04 LTS (Focal Fossa)\",\n            Size = 25,\n        },\n        NetworkInterfaces = new[]\n        {\n            new UpCloud.Inputs.ServerNetworkInterfaceArgs\n            {\n                Type = \"public\",\n            },\n        },\n    });\n\n    var myNewFloatingAddress = new UpCloud.FloatingIpAddress(\"my_new_floating_address\", new()\n    {\n        MacAddress = example.NetworkInterfaces.Apply(networkInterfaces =\u003e networkInterfaces[0]?.MacAddress),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create a detached floating IP address.\n\t\t_, err := upcloud.NewFloatingIpAddress(ctx, \"my_floating_address\", \u0026upcloud.FloatingIpAddressArgs{\n\t\t\tZone: pulumi.String(\"de-fra1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Floating IP address assigned to a server resource.\n\t\texample, err := upcloud.NewServer(ctx, \"example\", \u0026upcloud.ServerArgs{\n\t\t\tHostname: pulumi.String(\"terraform.example.tld\"),\n\t\t\tZone:     pulumi.String(\"de-fra1\"),\n\t\t\tPlan:     pulumi.String(\"1xCPU-1GB\"),\n\t\t\tTemplate: \u0026upcloud.ServerTemplateArgs{\n\t\t\t\tStorage: pulumi.String(\"Ubuntu Server 20.04 LTS (Focal Fossa)\"),\n\t\t\t\tSize:    pulumi.Int(25),\n\t\t\t},\n\t\t\tNetworkInterfaces: upcloud.ServerNetworkInterfaceArray{\n\t\t\t\t\u0026upcloud.ServerNetworkInterfaceArgs{\n\t\t\t\t\tType: pulumi.String(\"public\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewFloatingIpAddress(ctx, \"my_new_floating_address\", \u0026upcloud.FloatingIpAddressArgs{\n\t\t\tMacAddress: pulumi.String(example.NetworkInterfaces.ApplyT(func(networkInterfaces []upcloud.ServerNetworkInterface) (*string, error) {\n\t\t\t\treturn \u0026networkInterfaces[0].MacAddress, nil\n\t\t\t}).(pulumi.StringPtrOutput)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.FloatingIpAddress;\nimport com.pulumi.upcloud.FloatingIpAddressArgs;\nimport com.pulumi.upcloud.Server;\nimport com.pulumi.upcloud.ServerArgs;\nimport com.pulumi.upcloud.inputs.ServerTemplateArgs;\nimport com.pulumi.upcloud.inputs.ServerNetworkInterfaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create a detached floating IP address.\n        var myFloatingAddress = new FloatingIpAddress(\"myFloatingAddress\", FloatingIpAddressArgs.builder()\n            .zone(\"de-fra1\")\n            .build());\n\n        // Floating IP address assigned to a server resource.\n        var example = new Server(\"example\", ServerArgs.builder()\n            .hostname(\"terraform.example.tld\")\n            .zone(\"de-fra1\")\n            .plan(\"1xCPU-1GB\")\n            .template(ServerTemplateArgs.builder()\n                .storage(\"Ubuntu Server 20.04 LTS (Focal Fossa)\")\n                .size(25)\n                .build())\n            .networkInterfaces(ServerNetworkInterfaceArgs.builder()\n                .type(\"public\")\n                .build())\n            .build());\n\n        var myNewFloatingAddress = new FloatingIpAddress(\"myNewFloatingAddress\", FloatingIpAddressArgs.builder()\n            .macAddress(example.networkInterfaces().applyValue(_networkInterfaces -\u003e _networkInterfaces[0].macAddress()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a detached floating IP address.\n  myFloatingAddress:\n    type: upcloud:FloatingIpAddress\n    name: my_floating_address\n    properties:\n      zone: de-fra1\n  # Floating IP address assigned to a server resource.\n  example:\n    type: upcloud:Server\n    properties:\n      hostname: terraform.example.tld\n      zone: de-fra1\n      plan: 1xCPU-1GB\n      template:\n        storage: Ubuntu Server 20.04 LTS (Focal Fossa)\n        size: 25\n      networkInterfaces:\n        - type: public\n  myNewFloatingAddress:\n    type: upcloud:FloatingIpAddress\n    name: my_new_floating_address\n    properties:\n      macAddress: ${example.networkInterfaces[0].macAddress}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import upcloud:index/floatingIpAddress:FloatingIpAddress my_new_floating_address 94.237.114.205\n```\n\n",
            "properties": {
                "access": {
                    "type": "string",
                    "description": "Network access for the floating IP address. Supported value: `public`.\n"
                },
                "family": {
                    "type": "string",
                    "description": "The address family of the floating IP address.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "An UpCloud assigned IP Address.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "MAC address of a server interface to assign address to.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available\nzones with `upctl zone list`.\n"
                }
            },
            "required": [
                "access",
                "family",
                "ipAddress",
                "zone"
            ],
            "inputProperties": {
                "access": {
                    "type": "string",
                    "description": "Network access for the floating IP address. Supported value: `public`.\n"
                },
                "family": {
                    "type": "string",
                    "description": "The address family of the floating IP address.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "MAC address of a server interface to assign address to.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available\nzones with `upctl zone list`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FloatingIpAddress resources.\n",
                "properties": {
                    "access": {
                        "type": "string",
                        "description": "Network access for the floating IP address. Supported value: `public`.\n"
                    },
                    "family": {
                        "type": "string",
                        "description": "The address family of the floating IP address.\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "An UpCloud assigned IP Address.\n"
                    },
                    "macAddress": {
                        "type": "string",
                        "description": "MAC address of a server interface to assign address to.\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available\nzones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/gateway:Gateway": {
            "description": "Network gateways connect SDN Private Networks to external IP networks.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Create router for the gateway\nconst _this = new upcloud.Router(\"this\", {name: \"gateway-example-router\"});\n// Create network for the gateway\nconst thisNetwork = new upcloud.Network(\"this\", {\n    name: \"gateway-example-net\",\n    zone: \"pl-waw1\",\n    ipNetwork: {\n        address: \"172.16.2.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n    router: _this.id,\n});\nconst thisGateway = new upcloud.Gateway(\"this\", {\n    name: \"gateway-example-gw\",\n    zone: \"pl-waw1\",\n    features: [\"nat\"],\n    router: {\n        id: _this.id,\n    },\n    labels: {\n        \"managed-by\": \"terraform\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Create router for the gateway\nthis = upcloud.Router(\"this\", name=\"gateway-example-router\")\n# Create network for the gateway\nthis_network = upcloud.Network(\"this\",\n    name=\"gateway-example-net\",\n    zone=\"pl-waw1\",\n    ip_network={\n        \"address\": \"172.16.2.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    },\n    router=this.id)\nthis_gateway = upcloud.Gateway(\"this\",\n    name=\"gateway-example-gw\",\n    zone=\"pl-waw1\",\n    features=[\"nat\"],\n    router={\n        \"id\": this.id,\n    },\n    labels={\n        \"managed-by\": \"terraform\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create router for the gateway\n    var @this = new UpCloud.Router(\"this\", new()\n    {\n        Name = \"gateway-example-router\",\n    });\n\n    // Create network for the gateway\n    var thisNetwork = new UpCloud.Network(\"this\", new()\n    {\n        Name = \"gateway-example-net\",\n        Zone = \"pl-waw1\",\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"172.16.2.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n        Router = @this.Id,\n    });\n\n    var thisGateway = new UpCloud.Gateway(\"this\", new()\n    {\n        Name = \"gateway-example-gw\",\n        Zone = \"pl-waw1\",\n        Features = new[]\n        {\n            \"nat\",\n        },\n        Router = new UpCloud.Inputs.GatewayRouterArgs\n        {\n            Id = @this.Id,\n        },\n        Labels = \n        {\n            { \"managed-by\", \"terraform\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create router for the gateway\n\t\tthis, err := upcloud.NewRouter(ctx, \"this\", \u0026upcloud.RouterArgs{\n\t\t\tName: pulumi.String(\"gateway-example-router\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create network for the gateway\n\t\t_, err = upcloud.NewNetwork(ctx, \"this\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"gateway-example-net\"),\n\t\t\tZone: pulumi.String(\"pl-waw1\"),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"172.16.2.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t\tRouter: this.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewGateway(ctx, \"this\", \u0026upcloud.GatewayArgs{\n\t\t\tName: pulumi.String(\"gateway-example-gw\"),\n\t\t\tZone: pulumi.String(\"pl-waw1\"),\n\t\t\tFeatures: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"nat\"),\n\t\t\t},\n\t\t\tRouter: \u0026upcloud.GatewayRouterArgs{\n\t\t\t\tId: this.ID(),\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"managed-by\": pulumi.String(\"terraform\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Router;\nimport com.pulumi.upcloud.RouterArgs;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.Gateway;\nimport com.pulumi.upcloud.GatewayArgs;\nimport com.pulumi.upcloud.inputs.GatewayRouterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create router for the gateway\n        var this_ = new Router(\"this\", RouterArgs.builder()\n            .name(\"gateway-example-router\")\n            .build());\n\n        // Create network for the gateway\n        var thisNetwork = new Network(\"thisNetwork\", NetworkArgs.builder()\n            .name(\"gateway-example-net\")\n            .zone(\"pl-waw1\")\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"172.16.2.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .router(this_.id())\n            .build());\n\n        var thisGateway = new Gateway(\"thisGateway\", GatewayArgs.builder()\n            .name(\"gateway-example-gw\")\n            .zone(\"pl-waw1\")\n            .features(\"nat\")\n            .router(GatewayRouterArgs.builder()\n                .id(this_.id())\n                .build())\n            .labels(Map.of(\"managed-by\", \"terraform\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create router for the gateway\n  this:\n    type: upcloud:Router\n    properties:\n      name: gateway-example-router\n  # Create network for the gateway\n  thisNetwork:\n    type: upcloud:Network\n    name: this\n    properties:\n      name: gateway-example-net\n      zone: pl-waw1\n      ipNetwork:\n        address: 172.16.2.0/24\n        dhcp: true\n        family: IPv4\n      router: ${this.id}\n  thisGateway:\n    type: upcloud:Gateway\n    name: this\n    properties:\n      name: gateway-example-gw\n      zone: pl-waw1\n      features:\n        - nat\n      router:\n        id: ${this.id}\n      labels:\n        managed-by: terraform\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "address": {
                    "$ref": "#/types/upcloud:index/GatewayAddress:GatewayAddress",
                    "description": "IP addresses assigned to the gateway.\n"
                },
                "addresses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/GatewayAddress:GatewayAddress"
                    },
                    "description": "IP addresses assigned to the gateway.\n",
                    "deprecationMessage": "Use 'address' attribute instead. This attribute will be removed in the next major version of the provider"
                },
                "configuredStatus": {
                    "type": "string",
                    "description": "The service configured status indicates the service's current intended status. Managed by the customer.\n"
                },
                "connections": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Names of connections attached to the gateway. Note that this field can have outdated information as connections are\ncreated by a separate resource. To make sure that you have the most recent data run 'terrafrom refresh'.\n"
                },
                "features": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Features enabled for the gateway. Note that VPN feature is currently in beta, for more details see\nhttps://upcloud.com/resources/docs/networking#nat-and-vpn-gateways.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the network gateway.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Gateway name. Needs to be unique within the account.\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "The service operational state indicates the service's current operational, effective state. Managed by the system.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Gateway pricing plan.\n"
                },
                "router": {
                    "$ref": "#/types/upcloud:index/GatewayRouter:GatewayRouter",
                    "description": "Attached Router from where traffic is routed towards the network gateway service.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone in which the gateway will be hosted, e.g. `de-fra1`.\n"
                }
            },
            "required": [
                "address",
                "addresses",
                "connections",
                "features",
                "name",
                "operationalState",
                "plan",
                "router",
                "zone"
            ],
            "inputProperties": {
                "address": {
                    "$ref": "#/types/upcloud:index/GatewayAddress:GatewayAddress",
                    "description": "IP addresses assigned to the gateway.\n"
                },
                "configuredStatus": {
                    "type": "string",
                    "description": "The service configured status indicates the service's current intended status. Managed by the customer.\n"
                },
                "features": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Features enabled for the gateway. Note that VPN feature is currently in beta, for more details see\nhttps://upcloud.com/resources/docs/networking#nat-and-vpn-gateways.\n",
                    "willReplaceOnChanges": true
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the network gateway.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Gateway name. Needs to be unique within the account.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Gateway pricing plan.\n"
                },
                "router": {
                    "$ref": "#/types/upcloud:index/GatewayRouter:GatewayRouter",
                    "description": "Attached Router from where traffic is routed towards the network gateway service.\n",
                    "willReplaceOnChanges": true
                },
                "zone": {
                    "type": "string",
                    "description": "Zone in which the gateway will be hosted, e.g. `de-fra1`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "features",
                "router",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Gateway resources.\n",
                "properties": {
                    "address": {
                        "$ref": "#/types/upcloud:index/GatewayAddress:GatewayAddress",
                        "description": "IP addresses assigned to the gateway.\n"
                    },
                    "addresses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/GatewayAddress:GatewayAddress"
                        },
                        "description": "IP addresses assigned to the gateway.\n",
                        "deprecationMessage": "Use 'address' attribute instead. This attribute will be removed in the next major version of the provider"
                    },
                    "configuredStatus": {
                        "type": "string",
                        "description": "The service configured status indicates the service's current intended status. Managed by the customer.\n"
                    },
                    "connections": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Names of connections attached to the gateway. Note that this field can have outdated information as connections are\ncreated by a separate resource. To make sure that you have the most recent data run 'terrafrom refresh'.\n"
                    },
                    "features": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Features enabled for the gateway. Note that VPN feature is currently in beta, for more details see\nhttps://upcloud.com/resources/docs/networking#nat-and-vpn-gateways.\n",
                        "willReplaceOnChanges": true
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the network gateway.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Gateway name. Needs to be unique within the account.\n"
                    },
                    "operationalState": {
                        "type": "string",
                        "description": "The service operational state indicates the service's current operational, effective state. Managed by the system.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "Gateway pricing plan.\n"
                    },
                    "router": {
                        "$ref": "#/types/upcloud:index/GatewayRouter:GatewayRouter",
                        "description": "Attached Router from where traffic is routed towards the network gateway service.\n",
                        "willReplaceOnChanges": true
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone in which the gateway will be hosted, e.g. `de-fra1`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/gatewayConnection:GatewayConnection": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst _this = new upcloud.Router(\"this\", {name: \"gateway-example-router\"});\nconst thisNetwork = new upcloud.Network(\"this\", {\n    name: \"gateway-example-net\",\n    zone: \"pl-waw1\",\n    ipNetwork: {\n        address: \"172.16.2.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n    router: _this.id,\n});\nconst thisGateway = new upcloud.Gateway(\"this\", {\n    name: \"gateway-example-gw\",\n    zone: \"pl-waw1\",\n    features: [\"vpn\"],\n    plan: \"advanced\",\n    router: {\n        id: _this.id,\n    },\n});\nconst thisGatewayConnection = new upcloud.GatewayConnection(\"this\", {\n    gateway: thisGateway.id,\n    name: \"test-connection\",\n    type: \"ipsec\",\n    localRoutes: [{\n        name: \"local-route\",\n        type: \"static\",\n        staticNetwork: \"10.123.123.0/24\",\n    }],\n    remoteRoutes: [{\n        name: \"remote-route\",\n        type: \"static\",\n        staticNetwork: \"100.123.123.0/24\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nthis = upcloud.Router(\"this\", name=\"gateway-example-router\")\nthis_network = upcloud.Network(\"this\",\n    name=\"gateway-example-net\",\n    zone=\"pl-waw1\",\n    ip_network={\n        \"address\": \"172.16.2.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    },\n    router=this.id)\nthis_gateway = upcloud.Gateway(\"this\",\n    name=\"gateway-example-gw\",\n    zone=\"pl-waw1\",\n    features=[\"vpn\"],\n    plan=\"advanced\",\n    router={\n        \"id\": this.id,\n    })\nthis_gateway_connection = upcloud.GatewayConnection(\"this\",\n    gateway=this_gateway.id,\n    name=\"test-connection\",\n    type=\"ipsec\",\n    local_routes=[{\n        \"name\": \"local-route\",\n        \"type\": \"static\",\n        \"static_network\": \"10.123.123.0/24\",\n    }],\n    remote_routes=[{\n        \"name\": \"remote-route\",\n        \"type\": \"static\",\n        \"static_network\": \"100.123.123.0/24\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new UpCloud.Router(\"this\", new()\n    {\n        Name = \"gateway-example-router\",\n    });\n\n    var thisNetwork = new UpCloud.Network(\"this\", new()\n    {\n        Name = \"gateway-example-net\",\n        Zone = \"pl-waw1\",\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"172.16.2.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n        Router = @this.Id,\n    });\n\n    var thisGateway = new UpCloud.Gateway(\"this\", new()\n    {\n        Name = \"gateway-example-gw\",\n        Zone = \"pl-waw1\",\n        Features = new[]\n        {\n            \"vpn\",\n        },\n        Plan = \"advanced\",\n        Router = new UpCloud.Inputs.GatewayRouterArgs\n        {\n            Id = @this.Id,\n        },\n    });\n\n    var thisGatewayConnection = new UpCloud.GatewayConnection(\"this\", new()\n    {\n        Gateway = thisGateway.Id,\n        Name = \"test-connection\",\n        Type = \"ipsec\",\n        LocalRoutes = new[]\n        {\n            new UpCloud.Inputs.GatewayConnectionLocalRouteArgs\n            {\n                Name = \"local-route\",\n                Type = \"static\",\n                StaticNetwork = \"10.123.123.0/24\",\n            },\n        },\n        RemoteRoutes = new[]\n        {\n            new UpCloud.Inputs.GatewayConnectionRemoteRouteArgs\n            {\n                Name = \"remote-route\",\n                Type = \"static\",\n                StaticNetwork = \"100.123.123.0/24\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := upcloud.NewRouter(ctx, \"this\", \u0026upcloud.RouterArgs{\n\t\t\tName: pulumi.String(\"gateway-example-router\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewNetwork(ctx, \"this\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"gateway-example-net\"),\n\t\t\tZone: pulumi.String(\"pl-waw1\"),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"172.16.2.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t\tRouter: this.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisGateway, err := upcloud.NewGateway(ctx, \"this\", \u0026upcloud.GatewayArgs{\n\t\t\tName: pulumi.String(\"gateway-example-gw\"),\n\t\t\tZone: pulumi.String(\"pl-waw1\"),\n\t\t\tFeatures: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vpn\"),\n\t\t\t},\n\t\t\tPlan: pulumi.String(\"advanced\"),\n\t\t\tRouter: \u0026upcloud.GatewayRouterArgs{\n\t\t\t\tId: this.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewGatewayConnection(ctx, \"this\", \u0026upcloud.GatewayConnectionArgs{\n\t\t\tGateway: thisGateway.ID(),\n\t\t\tName:    pulumi.String(\"test-connection\"),\n\t\t\tType:    pulumi.String(\"ipsec\"),\n\t\t\tLocalRoutes: upcloud.GatewayConnectionLocalRouteArray{\n\t\t\t\t\u0026upcloud.GatewayConnectionLocalRouteArgs{\n\t\t\t\t\tName:          pulumi.String(\"local-route\"),\n\t\t\t\t\tType:          pulumi.String(\"static\"),\n\t\t\t\t\tStaticNetwork: pulumi.String(\"10.123.123.0/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tRemoteRoutes: upcloud.GatewayConnectionRemoteRouteArray{\n\t\t\t\t\u0026upcloud.GatewayConnectionRemoteRouteArgs{\n\t\t\t\t\tName:          pulumi.String(\"remote-route\"),\n\t\t\t\t\tType:          pulumi.String(\"static\"),\n\t\t\t\t\tStaticNetwork: pulumi.String(\"100.123.123.0/24\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Router;\nimport com.pulumi.upcloud.RouterArgs;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.Gateway;\nimport com.pulumi.upcloud.GatewayArgs;\nimport com.pulumi.upcloud.inputs.GatewayRouterArgs;\nimport com.pulumi.upcloud.GatewayConnection;\nimport com.pulumi.upcloud.GatewayConnectionArgs;\nimport com.pulumi.upcloud.inputs.GatewayConnectionLocalRouteArgs;\nimport com.pulumi.upcloud.inputs.GatewayConnectionRemoteRouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new Router(\"this\", RouterArgs.builder()\n            .name(\"gateway-example-router\")\n            .build());\n\n        var thisNetwork = new Network(\"thisNetwork\", NetworkArgs.builder()\n            .name(\"gateway-example-net\")\n            .zone(\"pl-waw1\")\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"172.16.2.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .router(this_.id())\n            .build());\n\n        var thisGateway = new Gateway(\"thisGateway\", GatewayArgs.builder()\n            .name(\"gateway-example-gw\")\n            .zone(\"pl-waw1\")\n            .features(\"vpn\")\n            .plan(\"advanced\")\n            .router(GatewayRouterArgs.builder()\n                .id(this_.id())\n                .build())\n            .build());\n\n        var thisGatewayConnection = new GatewayConnection(\"thisGatewayConnection\", GatewayConnectionArgs.builder()\n            .gateway(thisGateway.id())\n            .name(\"test-connection\")\n            .type(\"ipsec\")\n            .localRoutes(GatewayConnectionLocalRouteArgs.builder()\n                .name(\"local-route\")\n                .type(\"static\")\n                .staticNetwork(\"10.123.123.0/24\")\n                .build())\n            .remoteRoutes(GatewayConnectionRemoteRouteArgs.builder()\n                .name(\"remote-route\")\n                .type(\"static\")\n                .staticNetwork(\"100.123.123.0/24\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: upcloud:Router\n    properties:\n      name: gateway-example-router\n  thisNetwork:\n    type: upcloud:Network\n    name: this\n    properties:\n      name: gateway-example-net\n      zone: pl-waw1\n      ipNetwork:\n        address: 172.16.2.0/24\n        dhcp: true\n        family: IPv4\n      router: ${this.id}\n  thisGateway:\n    type: upcloud:Gateway\n    name: this\n    properties:\n      name: gateway-example-gw\n      zone: pl-waw1\n      features:\n        - vpn\n      plan: advanced\n      router:\n        id: ${this.id}\n  thisGatewayConnection:\n    type: upcloud:GatewayConnection\n    name: this\n    properties:\n      gateway: ${thisGateway.id}\n      name: test-connection\n      type: ipsec\n      localRoutes:\n        - name: local-route\n          type: static\n          staticNetwork: 10.123.123.0/24\n      remoteRoutes:\n        - name: remote-route\n          type: static\n          staticNetwork: 100.123.123.0/24\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "gateway": {
                    "type": "string",
                    "description": "The ID of the upcloud.Gateway resource to which the connection belongs.\n"
                },
                "localRoutes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/GatewayConnectionLocalRoute:GatewayConnectionLocalRoute"
                    },
                    "description": "Route for the UpCloud side of the network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the connection, should be unique within the gateway.\n"
                },
                "remoteRoutes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/GatewayConnectionRemoteRoute:GatewayConnectionRemoteRoute"
                    },
                    "description": "Route for the remote side of the network.\n"
                },
                "tunnels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of connection's tunnels names. Note that this field can have outdated information as connections are created by a\nseparate resource. To make sure that you have the most recent data run 'terrafrom refresh'.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the connection; currently the only supported type is 'ipsec'.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the connection\n"
                }
            },
            "required": [
                "gateway",
                "name",
                "tunnels",
                "uuid"
            ],
            "inputProperties": {
                "gateway": {
                    "type": "string",
                    "description": "The ID of the upcloud.Gateway resource to which the connection belongs.\n",
                    "willReplaceOnChanges": true
                },
                "localRoutes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/GatewayConnectionLocalRoute:GatewayConnectionLocalRoute"
                    },
                    "description": "Route for the UpCloud side of the network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the connection, should be unique within the gateway.\n",
                    "willReplaceOnChanges": true
                },
                "remoteRoutes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/GatewayConnectionRemoteRoute:GatewayConnectionRemoteRoute"
                    },
                    "description": "Route for the remote side of the network.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the connection; currently the only supported type is 'ipsec'.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "gateway"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GatewayConnection resources.\n",
                "properties": {
                    "gateway": {
                        "type": "string",
                        "description": "The ID of the upcloud.Gateway resource to which the connection belongs.\n",
                        "willReplaceOnChanges": true
                    },
                    "localRoutes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/GatewayConnectionLocalRoute:GatewayConnectionLocalRoute"
                        },
                        "description": "Route for the UpCloud side of the network.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the connection, should be unique within the gateway.\n",
                        "willReplaceOnChanges": true
                    },
                    "remoteRoutes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/GatewayConnectionRemoteRoute:GatewayConnectionRemoteRoute"
                        },
                        "description": "Route for the remote side of the network.\n"
                    },
                    "tunnels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of connection's tunnels names. Note that this field can have outdated information as connections are created by a\nseparate resource. To make sure that you have the most recent data run 'terrafrom refresh'.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the connection; currently the only supported type is 'ipsec'.\n",
                        "willReplaceOnChanges": true
                    },
                    "uuid": {
                        "type": "string",
                        "description": "The UUID of the connection\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/gatewayConnectionTunnel:GatewayConnectionTunnel": {
            "description": "## Example Usage\n\n",
            "properties": {
                "connectionId": {
                    "type": "string",
                    "description": "ID of the upcloud.GatewayConnection resource to which the tunnel belongs\n"
                },
                "ipsecAuthPsk": {
                    "$ref": "#/types/upcloud:index/GatewayConnectionTunnelIpsecAuthPsk:GatewayConnectionTunnelIpsecAuthPsk",
                    "description": "Configuration for authenticating with pre-shared key\n"
                },
                "ipsecProperties": {
                    "$ref": "#/types/upcloud:index/GatewayConnectionTunnelIpsecProperties:GatewayConnectionTunnelIpsecProperties",
                    "description": "IPsec configuration for the tunnel\n"
                },
                "localAddressName": {
                    "type": "string",
                    "description": "Public (UpCloud) endpoint address of this tunnel\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the tunnel, should be unique within the connection\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "Tunnel's current operational, effective state\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "Remote public IP address of the tunnel\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the tunnel\n"
                }
            },
            "required": [
                "connectionId",
                "ipsecAuthPsk",
                "ipsecProperties",
                "localAddressName",
                "name",
                "operationalState",
                "remoteAddress",
                "uuid"
            ],
            "inputProperties": {
                "connectionId": {
                    "type": "string",
                    "description": "ID of the upcloud.GatewayConnection resource to which the tunnel belongs\n",
                    "willReplaceOnChanges": true
                },
                "ipsecAuthPsk": {
                    "$ref": "#/types/upcloud:index/GatewayConnectionTunnelIpsecAuthPsk:GatewayConnectionTunnelIpsecAuthPsk",
                    "description": "Configuration for authenticating with pre-shared key\n",
                    "willReplaceOnChanges": true
                },
                "ipsecProperties": {
                    "$ref": "#/types/upcloud:index/GatewayConnectionTunnelIpsecProperties:GatewayConnectionTunnelIpsecProperties",
                    "description": "IPsec configuration for the tunnel\n"
                },
                "localAddressName": {
                    "type": "string",
                    "description": "Public (UpCloud) endpoint address of this tunnel\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the tunnel, should be unique within the connection\n",
                    "willReplaceOnChanges": true
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "Remote public IP address of the tunnel\n"
                }
            },
            "requiredInputs": [
                "connectionId",
                "ipsecAuthPsk",
                "localAddressName",
                "remoteAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GatewayConnectionTunnel resources.\n",
                "properties": {
                    "connectionId": {
                        "type": "string",
                        "description": "ID of the upcloud.GatewayConnection resource to which the tunnel belongs\n",
                        "willReplaceOnChanges": true
                    },
                    "ipsecAuthPsk": {
                        "$ref": "#/types/upcloud:index/GatewayConnectionTunnelIpsecAuthPsk:GatewayConnectionTunnelIpsecAuthPsk",
                        "description": "Configuration for authenticating with pre-shared key\n",
                        "willReplaceOnChanges": true
                    },
                    "ipsecProperties": {
                        "$ref": "#/types/upcloud:index/GatewayConnectionTunnelIpsecProperties:GatewayConnectionTunnelIpsecProperties",
                        "description": "IPsec configuration for the tunnel\n"
                    },
                    "localAddressName": {
                        "type": "string",
                        "description": "Public (UpCloud) endpoint address of this tunnel\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the tunnel, should be unique within the connection\n",
                        "willReplaceOnChanges": true
                    },
                    "operationalState": {
                        "type": "string",
                        "description": "Tunnel's current operational, effective state\n"
                    },
                    "remoteAddress": {
                        "type": "string",
                        "description": "Remote public IP address of the tunnel\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "The UUID of the tunnel\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/kubernetesCluster:KubernetesCluster": {
            "description": "This resource represents a [Managed Kubernetes](https://upcloud.com/products/managed-kubernetes) cluster.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Create a network for the Kubernetes cluster\nconst example = new upcloud.Network(\"example\", {\n    name: \"example-network\",\n    zone: \"de-fra1\",\n    ipNetwork: {\n        address: \"172.16.1.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\n// Create a Kubernetes cluster\nconst exampleKubernetesCluster = new upcloud.KubernetesCluster(\"example\", {\n    controlPlaneIpFilters: [\"0.0.0.0/0\"],\n    name: \"exampleapp\",\n    network: example.id,\n    zone: \"de-fra1\",\n});\n// Kubernetes cluster with private node groups requires a network that is routed through NAT gateway.\nconst example2 = new upcloud.Router(\"example2\", {name: \"example2-router\"});\nconst example2Gateway = new upcloud.Gateway(\"example2\", {\n    name: \"example2-nat-gateway\",\n    zone: \"de-fra1\",\n    features: [\"nat\"],\n    router: {\n        id: example2.id,\n    },\n});\nconst example2Network = new upcloud.Network(\"example2\", {\n    name: \"example2-network\",\n    zone: \"de-fra1\",\n    ipNetwork: {\n        address: \"10.10.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n        dhcpDefaultRoute: true,\n    },\n    router: example2.id,\n});\nconst example2KubernetesCluster = new upcloud.KubernetesCluster(\"example2\", {\n    controlPlaneIpFilters: [\"0.0.0.0/0\"],\n    name: \"example2-cluster\",\n    network: example2Network.id,\n    zone: \"de-fra1\",\n    plan: \"prod-md\",\n    privateNodeGroups: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Create a network for the Kubernetes cluster\nexample = upcloud.Network(\"example\",\n    name=\"example-network\",\n    zone=\"de-fra1\",\n    ip_network={\n        \"address\": \"172.16.1.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\n# Create a Kubernetes cluster\nexample_kubernetes_cluster = upcloud.KubernetesCluster(\"example\",\n    control_plane_ip_filters=[\"0.0.0.0/0\"],\n    name=\"exampleapp\",\n    network=example.id,\n    zone=\"de-fra1\")\n# Kubernetes cluster with private node groups requires a network that is routed through NAT gateway.\nexample2 = upcloud.Router(\"example2\", name=\"example2-router\")\nexample2_gateway = upcloud.Gateway(\"example2\",\n    name=\"example2-nat-gateway\",\n    zone=\"de-fra1\",\n    features=[\"nat\"],\n    router={\n        \"id\": example2.id,\n    })\nexample2_network = upcloud.Network(\"example2\",\n    name=\"example2-network\",\n    zone=\"de-fra1\",\n    ip_network={\n        \"address\": \"10.10.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n        \"dhcp_default_route\": True,\n    },\n    router=example2.id)\nexample2_kubernetes_cluster = upcloud.KubernetesCluster(\"example2\",\n    control_plane_ip_filters=[\"0.0.0.0/0\"],\n    name=\"example2-cluster\",\n    network=example2_network.id,\n    zone=\"de-fra1\",\n    plan=\"prod-md\",\n    private_node_groups=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a network for the Kubernetes cluster\n    var example = new UpCloud.Network(\"example\", new()\n    {\n        Name = \"example-network\",\n        Zone = \"de-fra1\",\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"172.16.1.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    // Create a Kubernetes cluster\n    var exampleKubernetesCluster = new UpCloud.KubernetesCluster(\"example\", new()\n    {\n        ControlPlaneIpFilters = new[]\n        {\n            \"0.0.0.0/0\",\n        },\n        Name = \"exampleapp\",\n        Network = example.Id,\n        Zone = \"de-fra1\",\n    });\n\n    // Kubernetes cluster with private node groups requires a network that is routed through NAT gateway.\n    var example2 = new UpCloud.Router(\"example2\", new()\n    {\n        Name = \"example2-router\",\n    });\n\n    var example2Gateway = new UpCloud.Gateway(\"example2\", new()\n    {\n        Name = \"example2-nat-gateway\",\n        Zone = \"de-fra1\",\n        Features = new[]\n        {\n            \"nat\",\n        },\n        Router = new UpCloud.Inputs.GatewayRouterArgs\n        {\n            Id = example2.Id,\n        },\n    });\n\n    var example2Network = new UpCloud.Network(\"example2\", new()\n    {\n        Name = \"example2-network\",\n        Zone = \"de-fra1\",\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.10.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n            DhcpDefaultRoute = true,\n        },\n        Router = example2.Id,\n    });\n\n    var example2KubernetesCluster = new UpCloud.KubernetesCluster(\"example2\", new()\n    {\n        ControlPlaneIpFilters = new[]\n        {\n            \"0.0.0.0/0\",\n        },\n        Name = \"example2-cluster\",\n        Network = example2Network.Id,\n        Zone = \"de-fra1\",\n        Plan = \"prod-md\",\n        PrivateNodeGroups = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create a network for the Kubernetes cluster\n\t\texample, err := upcloud.NewNetwork(ctx, \"example\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"example-network\"),\n\t\t\tZone: pulumi.String(\"de-fra1\"),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"172.16.1.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a Kubernetes cluster\n\t\t_, err = upcloud.NewKubernetesCluster(ctx, \"example\", \u0026upcloud.KubernetesClusterArgs{\n\t\t\tControlPlaneIpFilters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"0.0.0.0/0\"),\n\t\t\t},\n\t\t\tName:    pulumi.String(\"exampleapp\"),\n\t\t\tNetwork: example.ID(),\n\t\t\tZone:    pulumi.String(\"de-fra1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Kubernetes cluster with private node groups requires a network that is routed through NAT gateway.\n\t\texample2, err := upcloud.NewRouter(ctx, \"example2\", \u0026upcloud.RouterArgs{\n\t\t\tName: pulumi.String(\"example2-router\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewGateway(ctx, \"example2\", \u0026upcloud.GatewayArgs{\n\t\t\tName: pulumi.String(\"example2-nat-gateway\"),\n\t\t\tZone: pulumi.String(\"de-fra1\"),\n\t\t\tFeatures: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"nat\"),\n\t\t\t},\n\t\t\tRouter: \u0026upcloud.GatewayRouterArgs{\n\t\t\t\tId: example2.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample2Network, err := upcloud.NewNetwork(ctx, \"example2\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"example2-network\"),\n\t\t\tZone: pulumi.String(\"de-fra1\"),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress:          pulumi.String(\"10.10.0.0/24\"),\n\t\t\t\tDhcp:             pulumi.Bool(true),\n\t\t\t\tFamily:           pulumi.String(\"IPv4\"),\n\t\t\t\tDhcpDefaultRoute: pulumi.Bool(true),\n\t\t\t},\n\t\t\tRouter: example2.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewKubernetesCluster(ctx, \"example2\", \u0026upcloud.KubernetesClusterArgs{\n\t\t\tControlPlaneIpFilters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"0.0.0.0/0\"),\n\t\t\t},\n\t\t\tName:              pulumi.String(\"example2-cluster\"),\n\t\t\tNetwork:           example2Network.ID(),\n\t\t\tZone:              pulumi.String(\"de-fra1\"),\n\t\t\tPlan:              pulumi.String(\"prod-md\"),\n\t\t\tPrivateNodeGroups: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.KubernetesCluster;\nimport com.pulumi.upcloud.KubernetesClusterArgs;\nimport com.pulumi.upcloud.Router;\nimport com.pulumi.upcloud.RouterArgs;\nimport com.pulumi.upcloud.Gateway;\nimport com.pulumi.upcloud.GatewayArgs;\nimport com.pulumi.upcloud.inputs.GatewayRouterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create a network for the Kubernetes cluster\n        var example = new Network(\"example\", NetworkArgs.builder()\n            .name(\"example-network\")\n            .zone(\"de-fra1\")\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"172.16.1.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        // Create a Kubernetes cluster\n        var exampleKubernetesCluster = new KubernetesCluster(\"exampleKubernetesCluster\", KubernetesClusterArgs.builder()\n            .controlPlaneIpFilters(\"0.0.0.0/0\")\n            .name(\"exampleapp\")\n            .network(example.id())\n            .zone(\"de-fra1\")\n            .build());\n\n        // Kubernetes cluster with private node groups requires a network that is routed through NAT gateway.\n        var example2 = new Router(\"example2\", RouterArgs.builder()\n            .name(\"example2-router\")\n            .build());\n\n        var example2Gateway = new Gateway(\"example2Gateway\", GatewayArgs.builder()\n            .name(\"example2-nat-gateway\")\n            .zone(\"de-fra1\")\n            .features(\"nat\")\n            .router(GatewayRouterArgs.builder()\n                .id(example2.id())\n                .build())\n            .build());\n\n        var example2Network = new Network(\"example2Network\", NetworkArgs.builder()\n            .name(\"example2-network\")\n            .zone(\"de-fra1\")\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.10.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .dhcpDefaultRoute(true)\n                .build())\n            .router(example2.id())\n            .build());\n\n        var example2KubernetesCluster = new KubernetesCluster(\"example2KubernetesCluster\", KubernetesClusterArgs.builder()\n            .controlPlaneIpFilters(\"0.0.0.0/0\")\n            .name(\"example2-cluster\")\n            .network(example2Network.id())\n            .zone(\"de-fra1\")\n            .plan(\"prod-md\")\n            .privateNodeGroups(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a network for the Kubernetes cluster\n  example:\n    type: upcloud:Network\n    properties:\n      name: example-network\n      zone: de-fra1\n      ipNetwork:\n        address: 172.16.1.0/24\n        dhcp: true\n        family: IPv4\n  # Create a Kubernetes cluster\n  exampleKubernetesCluster:\n    type: upcloud:KubernetesCluster\n    name: example\n    properties:\n      controlPlaneIpFilters:\n        - 0.0.0.0/0\n      name: exampleapp\n      network: ${example.id}\n      zone: de-fra1\n  # Kubernetes cluster with private node groups requires a network that is routed through NAT gateway.\n  example2:\n    type: upcloud:Router\n    properties:\n      name: example2-router\n  example2Gateway:\n    type: upcloud:Gateway\n    name: example2\n    properties:\n      name: example2-nat-gateway\n      zone: de-fra1\n      features:\n        - nat\n      router:\n        id: ${example2.id}\n  example2Network:\n    type: upcloud:Network\n    name: example2\n    properties:\n      name: example2-network\n      zone: de-fra1\n      ipNetwork:\n        address: 10.10.0.0/24\n        dhcp: true\n        family: IPv4\n        dhcpDefaultRoute: true\n      router: ${example2.id}\n  example2KubernetesCluster:\n    type: upcloud:KubernetesCluster\n    name: example2\n    properties:\n      controlPlaneIpFilters:\n        - 0.0.0.0/0\n      name: example2-cluster\n      network: ${example2Network.id}\n      zone: de-fra1\n      plan: prod-md\n      privateNodeGroups: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "controlPlaneIpFilters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any\nsource, use `[\"0.0.0.0/0\"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node\ngroups or exposed Kubernetes services.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Cluster name. Needs to be unique within the account.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Network ID for the cluster to run in.\n"
                },
                "networkCidr": {
                    "type": "string",
                    "description": "Network CIDR for the given network. Computed automatically.\n"
                },
                "nodeGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Names of the node groups configured to cluster\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.\n"
                },
                "privateNodeGroups": {
                    "type": "boolean",
                    "description": "Enable private node groups. Private node groups requires a network that is routed through NAT gateway.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Operational state of the cluster.\n"
                },
                "storageEncryption": {
                    "type": "string",
                    "description": "Set default storage encryption strategy for all nodes in the cluster.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone\nlist`.\n"
                }
            },
            "required": [
                "controlPlaneIpFilters",
                "labels",
                "name",
                "network",
                "networkCidr",
                "nodeGroups",
                "plan",
                "privateNodeGroups",
                "state",
                "version",
                "zone"
            ],
            "inputProperties": {
                "controlPlaneIpFilters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any\nsource, use `[\"0.0.0.0/0\"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node\ngroups or exposed Kubernetes services.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Cluster name. Needs to be unique within the account.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Network ID for the cluster to run in.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.\n"
                },
                "privateNodeGroups": {
                    "type": "boolean",
                    "description": "Enable private node groups. Private node groups requires a network that is routed through NAT gateway.\n"
                },
                "storageEncryption": {
                    "type": "string",
                    "description": "Set default storage encryption strategy for all nodes in the cluster.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone\nlist`.\n"
                }
            },
            "requiredInputs": [
                "controlPlaneIpFilters",
                "network",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering KubernetesCluster resources.\n",
                "properties": {
                    "controlPlaneIpFilters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any\nsource, use `[\"0.0.0.0/0\"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node\ngroups or exposed Kubernetes services.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Cluster name. Needs to be unique within the account.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "Network ID for the cluster to run in.\n"
                    },
                    "networkCidr": {
                        "type": "string",
                        "description": "Network CIDR for the given network. Computed automatically.\n"
                    },
                    "nodeGroups": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Names of the node groups configured to cluster\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.\n"
                    },
                    "privateNodeGroups": {
                        "type": "boolean",
                        "description": "Enable private node groups. Private node groups requires a network that is routed through NAT gateway.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Operational state of the cluster.\n"
                    },
                    "storageEncryption": {
                        "type": "string",
                        "description": "Set default storage encryption strategy for all nodes in the cluster.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`.\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone\nlist`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/kubernetesNodeGroup:KubernetesNodeGroup": {
            "description": "This resource represents a [Managed Kubernetes](https://upcloud.com/products/managed-kubernetes) cluster.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Create a network for the Kubernetes cluster\nconst example = new upcloud.Network(\"example\", {\n    name: \"example-network\",\n    zone: \"de-fra1\",\n    ipNetwork: {\n        address: \"172.16.1.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\n// Create a Kubernetes cluster\nconst exampleKubernetesCluster = new upcloud.KubernetesCluster(\"example\", {\n    controlPlaneIpFilters: [\"0.0.0.0/0\"],\n    name: \"exampleapp\",\n    network: example.id,\n    zone: \"de-fra1\",\n});\n// Create a Kubernetes cluster node group\nconst group = new upcloud.KubernetesNodeGroup(\"group\", {\n    cluster: upcloudKubernetesCluster.example.id,\n    nodeCount: 2,\n    name: \"medium\",\n    plan: \"2xCPU-4GB\",\n    labels: {\n        managedBy: \"terraform\",\n    },\n    taints: [{\n        effect: \"NoExecute\",\n        key: \"taintKey\",\n        value: \"taintValue\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Create a network for the Kubernetes cluster\nexample = upcloud.Network(\"example\",\n    name=\"example-network\",\n    zone=\"de-fra1\",\n    ip_network={\n        \"address\": \"172.16.1.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\n# Create a Kubernetes cluster\nexample_kubernetes_cluster = upcloud.KubernetesCluster(\"example\",\n    control_plane_ip_filters=[\"0.0.0.0/0\"],\n    name=\"exampleapp\",\n    network=example.id,\n    zone=\"de-fra1\")\n# Create a Kubernetes cluster node group\ngroup = upcloud.KubernetesNodeGroup(\"group\",\n    cluster=upcloud_kubernetes_cluster[\"example\"][\"id\"],\n    node_count=2,\n    name=\"medium\",\n    plan=\"2xCPU-4GB\",\n    labels={\n        \"managedBy\": \"terraform\",\n    },\n    taints=[{\n        \"effect\": \"NoExecute\",\n        \"key\": \"taintKey\",\n        \"value\": \"taintValue\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a network for the Kubernetes cluster\n    var example = new UpCloud.Network(\"example\", new()\n    {\n        Name = \"example-network\",\n        Zone = \"de-fra1\",\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"172.16.1.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    // Create a Kubernetes cluster\n    var exampleKubernetesCluster = new UpCloud.KubernetesCluster(\"example\", new()\n    {\n        ControlPlaneIpFilters = new[]\n        {\n            \"0.0.0.0/0\",\n        },\n        Name = \"exampleapp\",\n        Network = example.Id,\n        Zone = \"de-fra1\",\n    });\n\n    // Create a Kubernetes cluster node group\n    var @group = new UpCloud.KubernetesNodeGroup(\"group\", new()\n    {\n        Cluster = upcloudKubernetesCluster.Example.Id,\n        NodeCount = 2,\n        Name = \"medium\",\n        Plan = \"2xCPU-4GB\",\n        Labels = \n        {\n            { \"managedBy\", \"terraform\" },\n        },\n        Taints = new[]\n        {\n            new UpCloud.Inputs.KubernetesNodeGroupTaintArgs\n            {\n                Effect = \"NoExecute\",\n                Key = \"taintKey\",\n                Value = \"taintValue\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create a network for the Kubernetes cluster\n\t\texample, err := upcloud.NewNetwork(ctx, \"example\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"example-network\"),\n\t\t\tZone: pulumi.String(\"de-fra1\"),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"172.16.1.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a Kubernetes cluster\n\t\t_, err = upcloud.NewKubernetesCluster(ctx, \"example\", \u0026upcloud.KubernetesClusterArgs{\n\t\t\tControlPlaneIpFilters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"0.0.0.0/0\"),\n\t\t\t},\n\t\t\tName:    pulumi.String(\"exampleapp\"),\n\t\t\tNetwork: example.ID(),\n\t\t\tZone:    pulumi.String(\"de-fra1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a Kubernetes cluster node group\n\t\t_, err = upcloud.NewKubernetesNodeGroup(ctx, \"group\", \u0026upcloud.KubernetesNodeGroupArgs{\n\t\t\tCluster:   pulumi.Any(upcloudKubernetesCluster.Example.Id),\n\t\t\tNodeCount: pulumi.Int(2),\n\t\t\tName:      pulumi.String(\"medium\"),\n\t\t\tPlan:      pulumi.String(\"2xCPU-4GB\"),\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"managedBy\": pulumi.String(\"terraform\"),\n\t\t\t},\n\t\t\tTaints: upcloud.KubernetesNodeGroupTaintArray{\n\t\t\t\t\u0026upcloud.KubernetesNodeGroupTaintArgs{\n\t\t\t\t\tEffect: pulumi.String(\"NoExecute\"),\n\t\t\t\t\tKey:    pulumi.String(\"taintKey\"),\n\t\t\t\t\tValue:  pulumi.String(\"taintValue\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.KubernetesCluster;\nimport com.pulumi.upcloud.KubernetesClusterArgs;\nimport com.pulumi.upcloud.KubernetesNodeGroup;\nimport com.pulumi.upcloud.KubernetesNodeGroupArgs;\nimport com.pulumi.upcloud.inputs.KubernetesNodeGroupTaintArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create a network for the Kubernetes cluster\n        var example = new Network(\"example\", NetworkArgs.builder()\n            .name(\"example-network\")\n            .zone(\"de-fra1\")\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"172.16.1.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        // Create a Kubernetes cluster\n        var exampleKubernetesCluster = new KubernetesCluster(\"exampleKubernetesCluster\", KubernetesClusterArgs.builder()\n            .controlPlaneIpFilters(\"0.0.0.0/0\")\n            .name(\"exampleapp\")\n            .network(example.id())\n            .zone(\"de-fra1\")\n            .build());\n\n        // Create a Kubernetes cluster node group\n        var group = new KubernetesNodeGroup(\"group\", KubernetesNodeGroupArgs.builder()\n            .cluster(upcloudKubernetesCluster.example().id())\n            .nodeCount(2)\n            .name(\"medium\")\n            .plan(\"2xCPU-4GB\")\n            .labels(Map.of(\"managedBy\", \"terraform\"))\n            .taints(KubernetesNodeGroupTaintArgs.builder()\n                .effect(\"NoExecute\")\n                .key(\"taintKey\")\n                .value(\"taintValue\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a network for the Kubernetes cluster\n  example:\n    type: upcloud:Network\n    properties:\n      name: example-network\n      zone: de-fra1\n      ipNetwork:\n        address: 172.16.1.0/24\n        dhcp: true\n        family: IPv4\n  # Create a Kubernetes cluster\n  exampleKubernetesCluster:\n    type: upcloud:KubernetesCluster\n    name: example\n    properties:\n      controlPlaneIpFilters:\n        - 0.0.0.0/0\n      name: exampleapp\n      network: ${example.id}\n      zone: de-fra1\n  # Create a Kubernetes cluster node group\n  group:\n    type: upcloud:KubernetesNodeGroup\n    properties:\n      cluster: ${upcloudKubernetesCluster.example.id}\n      nodeCount: 2\n      name: medium\n      plan: 2xCPU-4GB\n      labels:\n        managedBy: terraform\n      taints:\n        - effect: NoExecute\n          key: taintKey\n          value: taintValue\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "antiAffinity": {
                    "type": "boolean",
                    "description": "If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is\nconsidered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.\n"
                },
                "cluster": {
                    "type": "string",
                    "description": "UUID of the cluster.\n"
                },
                "customPlan": {
                    "$ref": "#/types/upcloud:index/KubernetesNodeGroupCustomPlan:KubernetesNodeGroupCustomPlan",
                    "description": "Resource properties for custom plan\n"
                },
                "kubeletArgs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/KubernetesNodeGroupKubeletArg:KubernetesNodeGroupKubeletArg"
                    },
                    "description": "Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will\nprefix the arguments with `--` when preparing kubelet call. Note that these arguments will be passed directly to kubelet\nCLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful\nwhen adding kubelet args.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the node_group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the node group. Needs to be unique within a cluster.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Amount of nodes to provision in the node group.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The server plan used for the node group. You can list available plans with `upctl server plans`\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to\nconnect to the nodes via SSH once they are running.\n"
                },
                "storageEncryption": {
                    "type": "string",
                    "description": "The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption\nstrategy will be used, if applicable.\n"
                },
                "taints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/KubernetesNodeGroupTaint:KubernetesNodeGroupTaint"
                    },
                    "description": "Taints for the nodes in this group.\n"
                },
                "utilityNetworkAccess": {
                    "type": "boolean",
                    "description": "If set to false, nodes in this group will not have access to utility network.\n"
                }
            },
            "required": [
                "antiAffinity",
                "cluster",
                "labels",
                "name",
                "nodeCount",
                "plan",
                "sshKeys",
                "storageEncryption",
                "utilityNetworkAccess"
            ],
            "inputProperties": {
                "antiAffinity": {
                    "type": "boolean",
                    "description": "If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is\nconsidered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.\n"
                },
                "cluster": {
                    "type": "string",
                    "description": "UUID of the cluster.\n"
                },
                "customPlan": {
                    "$ref": "#/types/upcloud:index/KubernetesNodeGroupCustomPlan:KubernetesNodeGroupCustomPlan",
                    "description": "Resource properties for custom plan\n"
                },
                "kubeletArgs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/KubernetesNodeGroupKubeletArg:KubernetesNodeGroupKubeletArg"
                    },
                    "description": "Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will\nprefix the arguments with `--` when preparing kubelet call. Note that these arguments will be passed directly to kubelet\nCLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful\nwhen adding kubelet args.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the node_group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the node group. Needs to be unique within a cluster.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Amount of nodes to provision in the node group.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The server plan used for the node group. You can list available plans with `upctl server plans`\n"
                },
                "sshKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to\nconnect to the nodes via SSH once they are running.\n"
                },
                "storageEncryption": {
                    "type": "string",
                    "description": "The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption\nstrategy will be used, if applicable.\n"
                },
                "taints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/KubernetesNodeGroupTaint:KubernetesNodeGroupTaint"
                    },
                    "description": "Taints for the nodes in this group.\n"
                },
                "utilityNetworkAccess": {
                    "type": "boolean",
                    "description": "If set to false, nodes in this group will not have access to utility network.\n"
                }
            },
            "requiredInputs": [
                "cluster",
                "nodeCount",
                "plan"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering KubernetesNodeGroup resources.\n",
                "properties": {
                    "antiAffinity": {
                        "type": "boolean",
                        "description": "If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is\nconsidered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.\n"
                    },
                    "cluster": {
                        "type": "string",
                        "description": "UUID of the cluster.\n"
                    },
                    "customPlan": {
                        "$ref": "#/types/upcloud:index/KubernetesNodeGroupCustomPlan:KubernetesNodeGroupCustomPlan",
                        "description": "Resource properties for custom plan\n"
                    },
                    "kubeletArgs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/KubernetesNodeGroupKubeletArg:KubernetesNodeGroupKubeletArg"
                        },
                        "description": "Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will\nprefix the arguments with `--` when preparing kubelet call. Note that these arguments will be passed directly to kubelet\nCLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful\nwhen adding kubelet args.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the node_group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the node group. Needs to be unique within a cluster.\n"
                    },
                    "nodeCount": {
                        "type": "integer",
                        "description": "Amount of nodes to provision in the node group.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The server plan used for the node group. You can list available plans with `upctl server plans`\n"
                    },
                    "sshKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to\nconnect to the nodes via SSH once they are running.\n"
                    },
                    "storageEncryption": {
                        "type": "string",
                        "description": "The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption\nstrategy will be used, if applicable.\n"
                    },
                    "taints": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/KubernetesNodeGroupTaint:KubernetesNodeGroupTaint"
                        },
                        "description": "Taints for the nodes in this group.\n"
                    },
                    "utilityNetworkAccess": {
                        "type": "boolean",
                        "description": "If set to false, nodes in this group will not have access to utility network.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancer:Loadbalancer": {
            "description": "This resource represents [Managed Load Balancer](https://upcloud.com/products/managed-load-balancer) service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst config = new pulumi.Config();\nconst lbZone = config.get(\"lbZone\") || \"fi-hel2\";\nconst lbNetwork = new upcloud.Network(\"lb_network\", {\n    name: \"lb-test-net\",\n    zone: lbZone,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst lb = new upcloud.Loadbalancer(\"lb\", {\n    configuredStatus: \"started\",\n    name: \"lb-test\",\n    plan: \"development\",\n    zone: lbZone,\n    networks: [\n        {\n            name: \"Private-Net\",\n            type: \"private\",\n            family: \"IPv4\",\n            network: upcloudNetwork.lbNetwork.id,\n        },\n        {\n            name: \"Public-Net\",\n            type: \"public\",\n            family: \"IPv4\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nconfig = pulumi.Config()\nlb_zone = config.get(\"lbZone\")\nif lb_zone is None:\n    lb_zone = \"fi-hel2\"\nlb_network = upcloud.Network(\"lb_network\",\n    name=\"lb-test-net\",\n    zone=lb_zone,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nlb = upcloud.Loadbalancer(\"lb\",\n    configured_status=\"started\",\n    name=\"lb-test\",\n    plan=\"development\",\n    zone=lb_zone,\n    networks=[\n        {\n            \"name\": \"Private-Net\",\n            \"type\": \"private\",\n            \"family\": \"IPv4\",\n            \"network\": upcloud_network[\"lbNetwork\"][\"id\"],\n        },\n        {\n            \"name\": \"Public-Net\",\n            \"type\": \"public\",\n            \"family\": \"IPv4\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var lbZone = config.Get(\"lbZone\") ?? \"fi-hel2\";\n    var lbNetwork = new UpCloud.Network(\"lb_network\", new()\n    {\n        Name = \"lb-test-net\",\n        Zone = lbZone,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var lb = new UpCloud.Loadbalancer(\"lb\", new()\n    {\n        ConfiguredStatus = \"started\",\n        Name = \"lb-test\",\n        Plan = \"development\",\n        Zone = lbZone,\n        Networks = new[]\n        {\n            new UpCloud.Inputs.LoadbalancerNetworkArgs\n            {\n                Name = \"Private-Net\",\n                Type = \"private\",\n                Family = \"IPv4\",\n                Network = upcloudNetwork.LbNetwork.Id,\n            },\n            new UpCloud.Inputs.LoadbalancerNetworkArgs\n            {\n                Name = \"Public-Net\",\n                Type = \"public\",\n                Family = \"IPv4\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tlbZone := \"fi-hel2\"\n\t\tif param := cfg.Get(\"lbZone\"); param != \"\" {\n\t\t\tlbZone = param\n\t\t}\n\t\t_, err := upcloud.NewNetwork(ctx, \"lb_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"lb-test-net\"),\n\t\t\tZone: pulumi.String(lbZone),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancer(ctx, \"lb\", \u0026upcloud.LoadbalancerArgs{\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tName:             pulumi.String(\"lb-test\"),\n\t\t\tPlan:             pulumi.String(\"development\"),\n\t\t\tZone:             pulumi.String(lbZone),\n\t\t\tNetworks: upcloud.LoadbalancerNetworkArray{\n\t\t\t\t\u0026upcloud.LoadbalancerNetworkArgs{\n\t\t\t\t\tName:    pulumi.String(\"Private-Net\"),\n\t\t\t\t\tType:    pulumi.String(\"private\"),\n\t\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t\t\tNetwork: pulumi.Any(upcloudNetwork.LbNetwork.Id),\n\t\t\t\t},\n\t\t\t\t\u0026upcloud.LoadbalancerNetworkArgs{\n\t\t\t\t\tName:   pulumi.String(\"Public-Net\"),\n\t\t\t\t\tType:   pulumi.String(\"public\"),\n\t\t\t\t\tFamily: pulumi.String(\"IPv4\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.Loadbalancer;\nimport com.pulumi.upcloud.LoadbalancerArgs;\nimport com.pulumi.upcloud.inputs.LoadbalancerNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var lbZone = config.get(\"lbZone\").orElse(\"fi-hel2\");\n        var lbNetwork = new Network(\"lbNetwork\", NetworkArgs.builder()\n            .name(\"lb-test-net\")\n            .zone(lbZone)\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        var lb = new Loadbalancer(\"lb\", LoadbalancerArgs.builder()\n            .configuredStatus(\"started\")\n            .name(\"lb-test\")\n            .plan(\"development\")\n            .zone(lbZone)\n            .networks(            \n                LoadbalancerNetworkArgs.builder()\n                    .name(\"Private-Net\")\n                    .type(\"private\")\n                    .family(\"IPv4\")\n                    .network(upcloudNetwork.lbNetwork().id())\n                    .build(),\n                LoadbalancerNetworkArgs.builder()\n                    .name(\"Public-Net\")\n                    .type(\"public\")\n                    .family(\"IPv4\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  lbZone:\n    type: string\n    default: fi-hel2\nresources:\n  lbNetwork:\n    type: upcloud:Network\n    name: lb_network\n    properties:\n      name: lb-test-net\n      zone: ${lbZone}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  lb:\n    type: upcloud:Loadbalancer\n    properties:\n      configuredStatus: started\n      name: lb-test\n      plan: development\n      zone: ${lbZone}\n      networks:\n        - name: Private-Net\n          type: private\n          family: IPv4\n          network: ${upcloudNetwork.lbNetwork.id}\n        - name: Public-Net\n          type: public\n          family: IPv4\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "backends": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Backends are groups of customer servers whose traffic should be balanced.\n"
                },
                "configuredStatus": {
                    "type": "string",
                    "description": "The service configured status indicates the service's current intended status. Managed by the customer.\n"
                },
                "dnsName": {
                    "type": "string",
                    "description": "DNS name of the load balancer\n",
                    "deprecationMessage": "Use 'networks' to get network DNS name"
                },
                "frontends": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Frontends receive the traffic before dispatching it to the backends.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the load balancer.\n"
                },
                "maintenanceDow": {
                    "type": "string",
                    "description": "The day of the week on which maintenance will be performed. If not provided, we will randomly select a weekend day.\nValid values `monday|tuesday|wednesday|thursday|friday|saturday|sunday`.\n"
                },
                "maintenanceTime": {
                    "type": "string",
                    "description": "The time at which the maintenance will begin in UTC. A 2-hour timeframe has been allocated for maintenance. During this\nperiod, the multi-node production plans will not experience any downtime, while the one-node plans will have a downtime\nof 1-2 minutes. If not provided, we will randomly select an off-peak time. Needs to be a valid time format in UTC\nHH:MM:SSZ, for example `20:01:01Z`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the service. Must be unique within customer account.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Private network UUID where traffic will be routed. Must reside in load balancer zone.\n",
                    "deprecationMessage": "Use 'networks' to define networks attached to load balancer"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerNetwork:LoadbalancerNetwork"
                    },
                    "description": "Attached Networks from where traffic consumed and routed. Private networks must reside in loadbalancer zone.\n"
                },
                "nodes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerNode:LoadbalancerNode"
                    },
                    "description": "Nodes are instances running load balancer service\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "The service operational state indicates the service's current operational, effective state. Managed by the system.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Plan which the service will have. You can list available load balancer plans with `upctl loadbalancer plans`\n"
                },
                "resolvers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Domain Name Resolvers.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone in which the service will be hosted, e.g. `fi-hel1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "backends",
                "configuredStatus",
                "dnsName",
                "frontends",
                "labels",
                "maintenanceDow",
                "maintenanceTime",
                "name",
                "network",
                "nodes",
                "operationalState",
                "plan",
                "resolvers",
                "zone"
            ],
            "inputProperties": {
                "configuredStatus": {
                    "type": "string",
                    "description": "The service configured status indicates the service's current intended status. Managed by the customer.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the load balancer.\n"
                },
                "maintenanceDow": {
                    "type": "string",
                    "description": "The day of the week on which maintenance will be performed. If not provided, we will randomly select a weekend day.\nValid values `monday|tuesday|wednesday|thursday|friday|saturday|sunday`.\n"
                },
                "maintenanceTime": {
                    "type": "string",
                    "description": "The time at which the maintenance will begin in UTC. A 2-hour timeframe has been allocated for maintenance. During this\nperiod, the multi-node production plans will not experience any downtime, while the one-node plans will have a downtime\nof 1-2 minutes. If not provided, we will randomly select an off-peak time. Needs to be a valid time format in UTC\nHH:MM:SSZ, for example `20:01:01Z`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the service. Must be unique within customer account.\n"
                },
                "network": {
                    "type": "string",
                    "description": "Private network UUID where traffic will be routed. Must reside in load balancer zone.\n",
                    "deprecationMessage": "Use 'networks' to define networks attached to load balancer"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerNetwork:LoadbalancerNetwork"
                    },
                    "description": "Attached Networks from where traffic consumed and routed. Private networks must reside in loadbalancer zone.\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Plan which the service will have. You can list available load balancer plans with `upctl loadbalancer plans`\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone in which the service will be hosted, e.g. `fi-hel1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "plan",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Loadbalancer resources.\n",
                "properties": {
                    "backends": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Backends are groups of customer servers whose traffic should be balanced.\n"
                    },
                    "configuredStatus": {
                        "type": "string",
                        "description": "The service configured status indicates the service's current intended status. Managed by the customer.\n"
                    },
                    "dnsName": {
                        "type": "string",
                        "description": "DNS name of the load balancer\n",
                        "deprecationMessage": "Use 'networks' to get network DNS name"
                    },
                    "frontends": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Frontends receive the traffic before dispatching it to the backends.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the load balancer.\n"
                    },
                    "maintenanceDow": {
                        "type": "string",
                        "description": "The day of the week on which maintenance will be performed. If not provided, we will randomly select a weekend day.\nValid values `monday|tuesday|wednesday|thursday|friday|saturday|sunday`.\n"
                    },
                    "maintenanceTime": {
                        "type": "string",
                        "description": "The time at which the maintenance will begin in UTC. A 2-hour timeframe has been allocated for maintenance. During this\nperiod, the multi-node production plans will not experience any downtime, while the one-node plans will have a downtime\nof 1-2 minutes. If not provided, we will randomly select an off-peak time. Needs to be a valid time format in UTC\nHH:MM:SSZ, for example `20:01:01Z`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the service. Must be unique within customer account.\n"
                    },
                    "network": {
                        "type": "string",
                        "description": "Private network UUID where traffic will be routed. Must reside in load balancer zone.\n",
                        "deprecationMessage": "Use 'networks' to define networks attached to load balancer"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/LoadbalancerNetwork:LoadbalancerNetwork"
                        },
                        "description": "Attached Networks from where traffic consumed and routed. Private networks must reside in loadbalancer zone.\n"
                    },
                    "nodes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/LoadbalancerNode:LoadbalancerNode"
                        },
                        "description": "Nodes are instances running load balancer service\n"
                    },
                    "operationalState": {
                        "type": "string",
                        "description": "The service operational state indicates the service's current operational, effective state. Managed by the system.\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "Plan which the service will have. You can list available load balancer plans with `upctl loadbalancer plans`\n"
                    },
                    "resolvers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Domain Name Resolvers.\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone in which the service will be hosted, e.g. `fi-hel1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerBackend:LoadbalancerBackend": {
            "description": "This resource represents load balancer backend service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst config = new pulumi.Config();\nconst lbZone = config.get(\"lbZone\") || \"fi-hel2\";\nconst lbNetwork = new upcloud.Network(\"lb_network\", {\n    name: \"lb-test-net\",\n    zone: lbZone,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst lb = new upcloud.Loadbalancer(\"lb\", {\n    configuredStatus: \"started\",\n    name: \"lb-test\",\n    plan: \"development\",\n    zone: lbZone,\n    network: upcloudNetwork.lbNetwork.id,\n});\nconst lbBe1 = new upcloud.LoadbalancerBackend(\"lb_be_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-be-1-test\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nconfig = pulumi.Config()\nlb_zone = config.get(\"lbZone\")\nif lb_zone is None:\n    lb_zone = \"fi-hel2\"\nlb_network = upcloud.Network(\"lb_network\",\n    name=\"lb-test-net\",\n    zone=lb_zone,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nlb = upcloud.Loadbalancer(\"lb\",\n    configured_status=\"started\",\n    name=\"lb-test\",\n    plan=\"development\",\n    zone=lb_zone,\n    network=upcloud_network[\"lbNetwork\"][\"id\"])\nlb_be1 = upcloud.LoadbalancerBackend(\"lb_be_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-be-1-test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var lbZone = config.Get(\"lbZone\") ?? \"fi-hel2\";\n    var lbNetwork = new UpCloud.Network(\"lb_network\", new()\n    {\n        Name = \"lb-test-net\",\n        Zone = lbZone,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var lb = new UpCloud.Loadbalancer(\"lb\", new()\n    {\n        ConfiguredStatus = \"started\",\n        Name = \"lb-test\",\n        Plan = \"development\",\n        Zone = lbZone,\n        Network = upcloudNetwork.LbNetwork.Id,\n    });\n\n    var lbBe1 = new UpCloud.LoadbalancerBackend(\"lb_be_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-be-1-test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tlbZone := \"fi-hel2\"\n\t\tif param := cfg.Get(\"lbZone\"); param != \"\" {\n\t\t\tlbZone = param\n\t\t}\n\t\t_, err := upcloud.NewNetwork(ctx, \"lb_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"lb-test-net\"),\n\t\t\tZone: pulumi.String(lbZone),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancer(ctx, \"lb\", \u0026upcloud.LoadbalancerArgs{\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tName:             pulumi.String(\"lb-test\"),\n\t\t\tPlan:             pulumi.String(\"development\"),\n\t\t\tZone:             pulumi.String(lbZone),\n\t\t\tNetwork:          pulumi.Any(upcloudNetwork.LbNetwork.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerBackend(ctx, \"lb_be_1\", \u0026upcloud.LoadbalancerBackendArgs{\n\t\t\tLoadbalancer: pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:         pulumi.String(\"lb-be-1-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.Loadbalancer;\nimport com.pulumi.upcloud.LoadbalancerArgs;\nimport com.pulumi.upcloud.LoadbalancerBackend;\nimport com.pulumi.upcloud.LoadbalancerBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var lbZone = config.get(\"lbZone\").orElse(\"fi-hel2\");\n        var lbNetwork = new Network(\"lbNetwork\", NetworkArgs.builder()\n            .name(\"lb-test-net\")\n            .zone(lbZone)\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        var lb = new Loadbalancer(\"lb\", LoadbalancerArgs.builder()\n            .configuredStatus(\"started\")\n            .name(\"lb-test\")\n            .plan(\"development\")\n            .zone(lbZone)\n            .network(upcloudNetwork.lbNetwork().id())\n            .build());\n\n        var lbBe1 = new LoadbalancerBackend(\"lbBe1\", LoadbalancerBackendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-be-1-test\")\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  lbZone:\n    type: string\n    default: fi-hel2\nresources:\n  lbNetwork:\n    type: upcloud:Network\n    name: lb_network\n    properties:\n      name: lb-test-net\n      zone: ${lbZone}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  lb:\n    type: upcloud:Loadbalancer\n    properties:\n      configuredStatus: started\n      name: lb-test\n      plan: development\n      zone: ${lbZone}\n      network: ${upcloudNetwork.lbNetwork.id}\n  lbBe1:\n    type: upcloud:LoadbalancerBackend\n    name: lb_be_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-be-1-test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "loadbalancer": {
                    "type": "string",
                    "description": "UUID of the load balancer to which the backend is connected.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Backend member server UUIDs. Members receive traffic dispatched from the frontends.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the backend. Must be unique within the load balancer service.\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/LoadbalancerBackendProperties:LoadbalancerBackendProperties"
                },
                "resolverName": {
                    "type": "string",
                    "description": "Domain name resolver used with dynamic type members.\n"
                },
                "tlsConfigs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of TLS config names.\n"
                }
            },
            "required": [
                "loadbalancer",
                "members",
                "name",
                "resolverName",
                "tlsConfigs"
            ],
            "inputProperties": {
                "loadbalancer": {
                    "type": "string",
                    "description": "UUID of the load balancer to which the backend is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the backend. Must be unique within the load balancer service.\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/LoadbalancerBackendProperties:LoadbalancerBackendProperties"
                },
                "resolverName": {
                    "type": "string",
                    "description": "Domain name resolver used with dynamic type members.\n"
                }
            },
            "requiredInputs": [
                "loadbalancer"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerBackend resources.\n",
                "properties": {
                    "loadbalancer": {
                        "type": "string",
                        "description": "UUID of the load balancer to which the backend is connected.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Backend member server UUIDs. Members receive traffic dispatched from the frontends.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the backend. Must be unique within the load balancer service.\n"
                    },
                    "properties": {
                        "$ref": "#/types/upcloud:index/LoadbalancerBackendProperties:LoadbalancerBackendProperties"
                    },
                    "resolverName": {
                        "type": "string",
                        "description": "Domain name resolver used with dynamic type members.\n"
                    },
                    "tlsConfigs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of TLS config names.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerBackendTlsConfig:LoadbalancerBackendTlsConfig": {
            "description": "This resource represents backend TLS config\n",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "ID of the load balancer backend to which the TLS config is connected.\n"
                },
                "certificateBundle": {
                    "type": "string",
                    "description": "Reference to certificate bundle ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the TLS config. Must be unique within customer account.\n"
                }
            },
            "required": [
                "backend",
                "certificateBundle",
                "name"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "ID of the load balancer backend to which the TLS config is connected.\n"
                },
                "certificateBundle": {
                    "type": "string",
                    "description": "Reference to certificate bundle ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the TLS config. Must be unique within customer account.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "certificateBundle"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerBackendTlsConfig resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "ID of the load balancer backend to which the TLS config is connected.\n"
                    },
                    "certificateBundle": {
                        "type": "string",
                        "description": "Reference to certificate bundle ID.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the TLS config. Must be unique within customer account.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerDynamicBackendMember:LoadbalancerDynamicBackendMember": {
            "description": "This resource represents load balancer dynamic backend member\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst config = new pulumi.Config();\nconst lbZone = config.get(\"lbZone\") || \"fi-hel2\";\nconst lbNetwork = new upcloud.Network(\"lb_network\", {\n    name: \"lb-test-net\",\n    zone: lbZone,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst lb = new upcloud.Loadbalancer(\"lb\", {\n    configuredStatus: \"started\",\n    name: \"lb-test\",\n    plan: \"development\",\n    zone: lbZone,\n    network: upcloudNetwork.lbNetwork.id,\n});\nconst lbDns1 = new upcloud.LoadbalancerResolver(\"lb_dns_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-resolver-1-test\",\n    cacheInvalid: 10,\n    cacheValid: 100,\n    retries: 5,\n    timeout: 10,\n    timeoutRetry: 10,\n    nameservers: [\n        \"94.237.127.9:53\",\n        \"94.237.40.9:53\",\n    ],\n});\nconst lbBe1 = new upcloud.LoadbalancerBackend(\"lb_be_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    resolverName: upcloudLoadbalancerResolver.lbDns1.name,\n    name: \"lb-be-1-test\",\n});\nconst lbBe1Dm1 = new upcloud.LoadbalancerDynamicBackendMember(\"lb_be_1_dm_1\", {\n    backend: upcloudLoadbalancerBackend.lbBe1.id,\n    name: \"lb-be-1-dm-1-test\",\n    weight: 10,\n    maxSessions: 10,\n    enabled: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nconfig = pulumi.Config()\nlb_zone = config.get(\"lbZone\")\nif lb_zone is None:\n    lb_zone = \"fi-hel2\"\nlb_network = upcloud.Network(\"lb_network\",\n    name=\"lb-test-net\",\n    zone=lb_zone,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nlb = upcloud.Loadbalancer(\"lb\",\n    configured_status=\"started\",\n    name=\"lb-test\",\n    plan=\"development\",\n    zone=lb_zone,\n    network=upcloud_network[\"lbNetwork\"][\"id\"])\nlb_dns1 = upcloud.LoadbalancerResolver(\"lb_dns_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-resolver-1-test\",\n    cache_invalid=10,\n    cache_valid=100,\n    retries=5,\n    timeout=10,\n    timeout_retry=10,\n    nameservers=[\n        \"94.237.127.9:53\",\n        \"94.237.40.9:53\",\n    ])\nlb_be1 = upcloud.LoadbalancerBackend(\"lb_be_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    resolver_name=upcloud_loadbalancer_resolver[\"lbDns1\"][\"name\"],\n    name=\"lb-be-1-test\")\nlb_be1_dm1 = upcloud.LoadbalancerDynamicBackendMember(\"lb_be_1_dm_1\",\n    backend=upcloud_loadbalancer_backend[\"lbBe1\"][\"id\"],\n    name=\"lb-be-1-dm-1-test\",\n    weight=10,\n    max_sessions=10,\n    enabled=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var lbZone = config.Get(\"lbZone\") ?? \"fi-hel2\";\n    var lbNetwork = new UpCloud.Network(\"lb_network\", new()\n    {\n        Name = \"lb-test-net\",\n        Zone = lbZone,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var lb = new UpCloud.Loadbalancer(\"lb\", new()\n    {\n        ConfiguredStatus = \"started\",\n        Name = \"lb-test\",\n        Plan = \"development\",\n        Zone = lbZone,\n        Network = upcloudNetwork.LbNetwork.Id,\n    });\n\n    var lbDns1 = new UpCloud.LoadbalancerResolver(\"lb_dns_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-resolver-1-test\",\n        CacheInvalid = 10,\n        CacheValid = 100,\n        Retries = 5,\n        Timeout = 10,\n        TimeoutRetry = 10,\n        Nameservers = new[]\n        {\n            \"94.237.127.9:53\",\n            \"94.237.40.9:53\",\n        },\n    });\n\n    var lbBe1 = new UpCloud.LoadbalancerBackend(\"lb_be_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        ResolverName = upcloudLoadbalancerResolver.LbDns1.Name,\n        Name = \"lb-be-1-test\",\n    });\n\n    var lbBe1Dm1 = new UpCloud.LoadbalancerDynamicBackendMember(\"lb_be_1_dm_1\", new()\n    {\n        Backend = upcloudLoadbalancerBackend.LbBe1.Id,\n        Name = \"lb-be-1-dm-1-test\",\n        Weight = 10,\n        MaxSessions = 10,\n        Enabled = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tlbZone := \"fi-hel2\"\n\t\tif param := cfg.Get(\"lbZone\"); param != \"\" {\n\t\t\tlbZone = param\n\t\t}\n\t\t_, err := upcloud.NewNetwork(ctx, \"lb_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"lb-test-net\"),\n\t\t\tZone: pulumi.String(lbZone),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancer(ctx, \"lb\", \u0026upcloud.LoadbalancerArgs{\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tName:             pulumi.String(\"lb-test\"),\n\t\t\tPlan:             pulumi.String(\"development\"),\n\t\t\tZone:             pulumi.String(lbZone),\n\t\t\tNetwork:          pulumi.Any(upcloudNetwork.LbNetwork.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerResolver(ctx, \"lb_dns_1\", \u0026upcloud.LoadbalancerResolverArgs{\n\t\t\tLoadbalancer: pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:         pulumi.String(\"lb-resolver-1-test\"),\n\t\t\tCacheInvalid: pulumi.Int(10),\n\t\t\tCacheValid:   pulumi.Int(100),\n\t\t\tRetries:      pulumi.Int(5),\n\t\t\tTimeout:      pulumi.Int(10),\n\t\t\tTimeoutRetry: pulumi.Int(10),\n\t\t\tNameservers: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"94.237.127.9:53\"),\n\t\t\t\tpulumi.String(\"94.237.40.9:53\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerBackend(ctx, \"lb_be_1\", \u0026upcloud.LoadbalancerBackendArgs{\n\t\t\tLoadbalancer: pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tResolverName: pulumi.Any(upcloudLoadbalancerResolver.LbDns1.Name),\n\t\t\tName:         pulumi.String(\"lb-be-1-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerDynamicBackendMember(ctx, \"lb_be_1_dm_1\", \u0026upcloud.LoadbalancerDynamicBackendMemberArgs{\n\t\t\tBackend:     pulumi.Any(upcloudLoadbalancerBackend.LbBe1.Id),\n\t\t\tName:        pulumi.String(\"lb-be-1-dm-1-test\"),\n\t\t\tWeight:      pulumi.Int(10),\n\t\t\tMaxSessions: pulumi.Int(10),\n\t\t\tEnabled:     pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.Loadbalancer;\nimport com.pulumi.upcloud.LoadbalancerArgs;\nimport com.pulumi.upcloud.LoadbalancerResolver;\nimport com.pulumi.upcloud.LoadbalancerResolverArgs;\nimport com.pulumi.upcloud.LoadbalancerBackend;\nimport com.pulumi.upcloud.LoadbalancerBackendArgs;\nimport com.pulumi.upcloud.LoadbalancerDynamicBackendMember;\nimport com.pulumi.upcloud.LoadbalancerDynamicBackendMemberArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var lbZone = config.get(\"lbZone\").orElse(\"fi-hel2\");\n        var lbNetwork = new Network(\"lbNetwork\", NetworkArgs.builder()\n            .name(\"lb-test-net\")\n            .zone(lbZone)\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        var lb = new Loadbalancer(\"lb\", LoadbalancerArgs.builder()\n            .configuredStatus(\"started\")\n            .name(\"lb-test\")\n            .plan(\"development\")\n            .zone(lbZone)\n            .network(upcloudNetwork.lbNetwork().id())\n            .build());\n\n        var lbDns1 = new LoadbalancerResolver(\"lbDns1\", LoadbalancerResolverArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-resolver-1-test\")\n            .cacheInvalid(10)\n            .cacheValid(100)\n            .retries(5)\n            .timeout(10)\n            .timeoutRetry(10)\n            .nameservers(            \n                \"94.237.127.9:53\",\n                \"94.237.40.9:53\")\n            .build());\n\n        var lbBe1 = new LoadbalancerBackend(\"lbBe1\", LoadbalancerBackendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .resolverName(upcloudLoadbalancerResolver.lbDns1().name())\n            .name(\"lb-be-1-test\")\n            .build());\n\n        var lbBe1Dm1 = new LoadbalancerDynamicBackendMember(\"lbBe1Dm1\", LoadbalancerDynamicBackendMemberArgs.builder()\n            .backend(upcloudLoadbalancerBackend.lbBe1().id())\n            .name(\"lb-be-1-dm-1-test\")\n            .weight(10)\n            .maxSessions(10)\n            .enabled(false)\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  lbZone:\n    type: string\n    default: fi-hel2\nresources:\n  lbNetwork:\n    type: upcloud:Network\n    name: lb_network\n    properties:\n      name: lb-test-net\n      zone: ${lbZone}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  lb:\n    type: upcloud:Loadbalancer\n    properties:\n      configuredStatus: started\n      name: lb-test\n      plan: development\n      zone: ${lbZone}\n      network: ${upcloudNetwork.lbNetwork.id}\n  lbDns1:\n    type: upcloud:LoadbalancerResolver\n    name: lb_dns_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-resolver-1-test\n      cacheInvalid: 10\n      cacheValid: 100\n      retries: 5\n      timeout: 10\n      timeoutRetry: 10\n      nameservers:\n        - 94.237.127.9:53\n        - 94.237.40.9:53\n  lbBe1:\n    type: upcloud:LoadbalancerBackend\n    name: lb_be_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      resolverName: ${upcloudLoadbalancerResolver.lbDns1.name}\n      name: lb-be-1-test\n  lbBe1Dm1:\n    type: upcloud:LoadbalancerDynamicBackendMember\n    name: lb_be_1_dm_1\n    properties:\n      backend: ${upcloudLoadbalancerBackend.lbBe1.id}\n      name: lb-be-1-dm-1-test\n      weight: 10\n      maxSessions: 10\n      enabled: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "ID of the load balancer backend to which the member is connected.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates if the member is enabled. Disabled members are excluded from load balancing.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Optional fallback IP address in case of failure on DNS resolving.\n"
                },
                "maxSessions": {
                    "type": "integer",
                    "description": "Maximum number of sessions before queueing.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the member. Must be unique within within the load balancer backend.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Server port. Port is optional and can be specified in DNS SRV record.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Weight of the member. The higher the weight, the more traffic the member receives.\n"
                }
            },
            "required": [
                "backend",
                "enabled",
                "ip",
                "maxSessions",
                "name",
                "port",
                "weight"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "ID of the load balancer backend to which the member is connected.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates if the member is enabled. Disabled members are excluded from load balancing.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Optional fallback IP address in case of failure on DNS resolving.\n"
                },
                "maxSessions": {
                    "type": "integer",
                    "description": "Maximum number of sessions before queueing.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the member. Must be unique within within the load balancer backend.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Server port. Port is optional and can be specified in DNS SRV record.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Weight of the member. The higher the weight, the more traffic the member receives.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "maxSessions",
                "weight"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerDynamicBackendMember resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "ID of the load balancer backend to which the member is connected.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicates if the member is enabled. Disabled members are excluded from load balancing.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "Optional fallback IP address in case of failure on DNS resolving.\n"
                    },
                    "maxSessions": {
                        "type": "integer",
                        "description": "Maximum number of sessions before queueing.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the member. Must be unique within within the load balancer backend.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Server port. Port is optional and can be specified in DNS SRV record.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "Weight of the member. The higher the weight, the more traffic the member receives.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerDynamicCertificateBundle:LoadbalancerDynamicCertificateBundle": {
            "description": "This resource represents dynamic certificate bundle\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst lbCbD1 = new upcloud.LoadbalancerDynamicCertificateBundle(\"lb_cb_d1\", {\n    name: \"lb-cb-d1-test\",\n    hostnames: [\n        \"example.com\",\n        \"app.example.net\",\n    ],\n    keyType: \"rsa\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nlb_cb_d1 = upcloud.LoadbalancerDynamicCertificateBundle(\"lb_cb_d1\",\n    name=\"lb-cb-d1-test\",\n    hostnames=[\n        \"example.com\",\n        \"app.example.net\",\n    ],\n    key_type=\"rsa\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var lbCbD1 = new UpCloud.LoadbalancerDynamicCertificateBundle(\"lb_cb_d1\", new()\n    {\n        Name = \"lb-cb-d1-test\",\n        Hostnames = new[]\n        {\n            \"example.com\",\n            \"app.example.net\",\n        },\n        KeyType = \"rsa\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upcloud.NewLoadbalancerDynamicCertificateBundle(ctx, \"lb_cb_d1\", \u0026upcloud.LoadbalancerDynamicCertificateBundleArgs{\n\t\t\tName: pulumi.String(\"lb-cb-d1-test\"),\n\t\t\tHostnames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"example.com\"),\n\t\t\t\tpulumi.String(\"app.example.net\"),\n\t\t\t},\n\t\t\tKeyType: pulumi.String(\"rsa\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.LoadbalancerDynamicCertificateBundle;\nimport com.pulumi.upcloud.LoadbalancerDynamicCertificateBundleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var lbCbD1 = new LoadbalancerDynamicCertificateBundle(\"lbCbD1\", LoadbalancerDynamicCertificateBundleArgs.builder()\n            .name(\"lb-cb-d1-test\")\n            .hostnames(            \n                \"example.com\",\n                \"app.example.net\")\n            .keyType(\"rsa\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  lbCbD1:\n    type: upcloud:LoadbalancerDynamicCertificateBundle\n    name: lb_cb_d1\n    properties:\n      name: lb-cb-d1-test\n      hostnames:\n        - example.com\n        - app.example.net\n      keyType: rsa\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Certificate hostnames.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Private key type (`rsa` / `ecdsa`).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate bundle. Must be unique within customer account.\n"
                },
                "notAfter": {
                    "type": "string",
                    "description": "The time after which a certificate is no longer valid.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "The time on which a certificate becomes valid.\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "The service operational state indicates the service's current operational, effective state. Managed by the system.\n"
                }
            },
            "required": [
                "hostnames",
                "keyType",
                "name",
                "notAfter",
                "notBefore",
                "operationalState"
            ],
            "inputProperties": {
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Certificate hostnames.\n"
                },
                "keyType": {
                    "type": "string",
                    "description": "Private key type (`rsa` / `ecdsa`).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate bundle. Must be unique within customer account.\n"
                }
            },
            "requiredInputs": [
                "hostnames",
                "keyType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerDynamicCertificateBundle resources.\n",
                "properties": {
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Certificate hostnames.\n"
                    },
                    "keyType": {
                        "type": "string",
                        "description": "Private key type (`rsa` / `ecdsa`).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the certificate bundle. Must be unique within customer account.\n"
                    },
                    "notAfter": {
                        "type": "string",
                        "description": "The time after which a certificate is no longer valid.\n"
                    },
                    "notBefore": {
                        "type": "string",
                        "description": "The time on which a certificate becomes valid.\n"
                    },
                    "operationalState": {
                        "type": "string",
                        "description": "The service operational state indicates the service's current operational, effective state. Managed by the system.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerFrontend:LoadbalancerFrontend": {
            "description": "This resource represents load balancer frontend service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst config = new pulumi.Config();\nconst lbZone = config.get(\"lbZone\") || \"fi-hel2\";\nconst lbNetwork = new upcloud.Network(\"lb_network\", {\n    name: \"lb-test-net\",\n    zone: lbZone,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst lbFe1 = new upcloud.LoadbalancerFrontend(\"lb_fe_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-fe-1-test\",\n    mode: \"http\",\n    port: 8080,\n    defaultBackendName: upcloudLoadbalancerBackend.lbBe1.name,\n    networks: [{\n        name: upcloudLoadbalancer.lb.networks[1].name,\n    }],\n});\nconst lb = new upcloud.Loadbalancer(\"lb\", {\n    configuredStatus: \"started\",\n    name: \"lb-test\",\n    plan: \"development\",\n    zone: lbZone,\n    networks: [\n        {\n            name: \"Private-Net\",\n            type: \"private\",\n            family: \"IPv4\",\n            network: upcloudNetwork.lbNetwork.id,\n        },\n        {\n            name: \"Public-Net\",\n            type: \"public\",\n            family: \"IPv4\",\n        },\n    ],\n});\nconst lbBe1 = new upcloud.LoadbalancerBackend(\"lb_be_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-be-1-test\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nconfig = pulumi.Config()\nlb_zone = config.get(\"lbZone\")\nif lb_zone is None:\n    lb_zone = \"fi-hel2\"\nlb_network = upcloud.Network(\"lb_network\",\n    name=\"lb-test-net\",\n    zone=lb_zone,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nlb_fe1 = upcloud.LoadbalancerFrontend(\"lb_fe_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-fe-1-test\",\n    mode=\"http\",\n    port=8080,\n    default_backend_name=upcloud_loadbalancer_backend[\"lbBe1\"][\"name\"],\n    networks=[{\n        \"name\": upcloud_loadbalancer[\"lb\"][\"networks\"][1][\"name\"],\n    }])\nlb = upcloud.Loadbalancer(\"lb\",\n    configured_status=\"started\",\n    name=\"lb-test\",\n    plan=\"development\",\n    zone=lb_zone,\n    networks=[\n        {\n            \"name\": \"Private-Net\",\n            \"type\": \"private\",\n            \"family\": \"IPv4\",\n            \"network\": upcloud_network[\"lbNetwork\"][\"id\"],\n        },\n        {\n            \"name\": \"Public-Net\",\n            \"type\": \"public\",\n            \"family\": \"IPv4\",\n        },\n    ])\nlb_be1 = upcloud.LoadbalancerBackend(\"lb_be_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-be-1-test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var lbZone = config.Get(\"lbZone\") ?? \"fi-hel2\";\n    var lbNetwork = new UpCloud.Network(\"lb_network\", new()\n    {\n        Name = \"lb-test-net\",\n        Zone = lbZone,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var lbFe1 = new UpCloud.LoadbalancerFrontend(\"lb_fe_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-fe-1-test\",\n        Mode = \"http\",\n        Port = 8080,\n        DefaultBackendName = upcloudLoadbalancerBackend.LbBe1.Name,\n        Networks = new[]\n        {\n            new UpCloud.Inputs.LoadbalancerFrontendNetworkArgs\n            {\n                Name = upcloudLoadbalancer.Lb.Networks[1].Name,\n            },\n        },\n    });\n\n    var lb = new UpCloud.Loadbalancer(\"lb\", new()\n    {\n        ConfiguredStatus = \"started\",\n        Name = \"lb-test\",\n        Plan = \"development\",\n        Zone = lbZone,\n        Networks = new[]\n        {\n            new UpCloud.Inputs.LoadbalancerNetworkArgs\n            {\n                Name = \"Private-Net\",\n                Type = \"private\",\n                Family = \"IPv4\",\n                Network = upcloudNetwork.LbNetwork.Id,\n            },\n            new UpCloud.Inputs.LoadbalancerNetworkArgs\n            {\n                Name = \"Public-Net\",\n                Type = \"public\",\n                Family = \"IPv4\",\n            },\n        },\n    });\n\n    var lbBe1 = new UpCloud.LoadbalancerBackend(\"lb_be_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-be-1-test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tlbZone := \"fi-hel2\"\n\t\tif param := cfg.Get(\"lbZone\"); param != \"\" {\n\t\t\tlbZone = param\n\t\t}\n\t\t_, err := upcloud.NewNetwork(ctx, \"lb_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"lb-test-net\"),\n\t\t\tZone: pulumi.String(lbZone),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerFrontend(ctx, \"lb_fe_1\", \u0026upcloud.LoadbalancerFrontendArgs{\n\t\t\tLoadbalancer:       pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:               pulumi.String(\"lb-fe-1-test\"),\n\t\t\tMode:               pulumi.String(\"http\"),\n\t\t\tPort:               pulumi.Int(8080),\n\t\t\tDefaultBackendName: pulumi.Any(upcloudLoadbalancerBackend.LbBe1.Name),\n\t\t\tNetworks: upcloud.LoadbalancerFrontendNetworkArray{\n\t\t\t\t\u0026upcloud.LoadbalancerFrontendNetworkArgs{\n\t\t\t\t\tName: pulumi.Any(upcloudLoadbalancer.Lb.Networks[1].Name),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancer(ctx, \"lb\", \u0026upcloud.LoadbalancerArgs{\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tName:             pulumi.String(\"lb-test\"),\n\t\t\tPlan:             pulumi.String(\"development\"),\n\t\t\tZone:             pulumi.String(lbZone),\n\t\t\tNetworks: upcloud.LoadbalancerNetworkArray{\n\t\t\t\t\u0026upcloud.LoadbalancerNetworkArgs{\n\t\t\t\t\tName:    pulumi.String(\"Private-Net\"),\n\t\t\t\t\tType:    pulumi.String(\"private\"),\n\t\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t\t\tNetwork: pulumi.Any(upcloudNetwork.LbNetwork.Id),\n\t\t\t\t},\n\t\t\t\t\u0026upcloud.LoadbalancerNetworkArgs{\n\t\t\t\t\tName:   pulumi.String(\"Public-Net\"),\n\t\t\t\t\tType:   pulumi.String(\"public\"),\n\t\t\t\t\tFamily: pulumi.String(\"IPv4\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerBackend(ctx, \"lb_be_1\", \u0026upcloud.LoadbalancerBackendArgs{\n\t\t\tLoadbalancer: pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:         pulumi.String(\"lb-be-1-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.LoadbalancerFrontend;\nimport com.pulumi.upcloud.LoadbalancerFrontendArgs;\nimport com.pulumi.upcloud.inputs.LoadbalancerFrontendNetworkArgs;\nimport com.pulumi.upcloud.Loadbalancer;\nimport com.pulumi.upcloud.LoadbalancerArgs;\nimport com.pulumi.upcloud.inputs.LoadbalancerNetworkArgs;\nimport com.pulumi.upcloud.LoadbalancerBackend;\nimport com.pulumi.upcloud.LoadbalancerBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var lbZone = config.get(\"lbZone\").orElse(\"fi-hel2\");\n        var lbNetwork = new Network(\"lbNetwork\", NetworkArgs.builder()\n            .name(\"lb-test-net\")\n            .zone(lbZone)\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        var lbFe1 = new LoadbalancerFrontend(\"lbFe1\", LoadbalancerFrontendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-fe-1-test\")\n            .mode(\"http\")\n            .port(8080)\n            .defaultBackendName(upcloudLoadbalancerBackend.lbBe1().name())\n            .networks(LoadbalancerFrontendNetworkArgs.builder()\n                .name(upcloudLoadbalancer.lb().networks()[1].name())\n                .build())\n            .build());\n\n        var lb = new Loadbalancer(\"lb\", LoadbalancerArgs.builder()\n            .configuredStatus(\"started\")\n            .name(\"lb-test\")\n            .plan(\"development\")\n            .zone(lbZone)\n            .networks(            \n                LoadbalancerNetworkArgs.builder()\n                    .name(\"Private-Net\")\n                    .type(\"private\")\n                    .family(\"IPv4\")\n                    .network(upcloudNetwork.lbNetwork().id())\n                    .build(),\n                LoadbalancerNetworkArgs.builder()\n                    .name(\"Public-Net\")\n                    .type(\"public\")\n                    .family(\"IPv4\")\n                    .build())\n            .build());\n\n        var lbBe1 = new LoadbalancerBackend(\"lbBe1\", LoadbalancerBackendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-be-1-test\")\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  lbZone:\n    type: string\n    default: fi-hel2\nresources:\n  lbNetwork:\n    type: upcloud:Network\n    name: lb_network\n    properties:\n      name: lb-test-net\n      zone: ${lbZone}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  lbFe1:\n    type: upcloud:LoadbalancerFrontend\n    name: lb_fe_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-fe-1-test\n      mode: http\n      port: 8080\n      defaultBackendName: ${upcloudLoadbalancerBackend.lbBe1.name}\n      networks:\n        - name: ${upcloudLoadbalancer.lb.networks[1].name}\n  lb:\n    type: upcloud:Loadbalancer\n    properties:\n      configuredStatus: started\n      name: lb-test\n      plan: development\n      zone: ${lbZone}\n      networks:\n        - name: Private-Net\n          type: private\n          family: IPv4\n          network: ${upcloudNetwork.lbNetwork.id}\n        - name: Public-Net\n          type: public\n          family: IPv4\n  lbBe1:\n    type: upcloud:LoadbalancerBackend\n    name: lb_be_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-be-1-test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "defaultBackendName": {
                    "type": "string",
                    "description": "The name of the backend where traffic will be routed by default. The default backend can be overridden in frontend\nrules. Note that the frontend resource depends on the default backend resource. Use the `name` field of a backend\nresource as the value for this field (like in the example above) or the `depends_on` meta argument to ensure the\nresources are created and destroyed in the correct order.\n"
                },
                "loadbalancer": {
                    "type": "string",
                    "description": "UUID of the load balancer to which the frontend is connected.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "When load balancer operating in `tcp` mode it acts as a layer 4 proxy. In `http` mode it acts as a layer 7 proxy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the frontend. Must be unique within the load balancer service.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendNetwork:LoadbalancerFrontendNetwork"
                    },
                    "description": "Networks that frontend will be listening. Networks are required if load balancer has `networks` defined. This field will\nbe required when deprecated field `network` is removed from load balancer resource.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port to listen for incoming requests.\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/LoadbalancerFrontendProperties:LoadbalancerFrontendProperties"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of frontend rule names.\n"
                },
                "tlsConfigs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set of TLS config names.\n"
                }
            },
            "required": [
                "defaultBackendName",
                "loadbalancer",
                "mode",
                "name",
                "port",
                "rules",
                "tlsConfigs"
            ],
            "inputProperties": {
                "defaultBackendName": {
                    "type": "string",
                    "description": "The name of the backend where traffic will be routed by default. The default backend can be overridden in frontend\nrules. Note that the frontend resource depends on the default backend resource. Use the `name` field of a backend\nresource as the value for this field (like in the example above) or the `depends_on` meta argument to ensure the\nresources are created and destroyed in the correct order.\n"
                },
                "loadbalancer": {
                    "type": "string",
                    "description": "UUID of the load balancer to which the frontend is connected.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "When load balancer operating in `tcp` mode it acts as a layer 4 proxy. In `http` mode it acts as a layer 7 proxy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the frontend. Must be unique within the load balancer service.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendNetwork:LoadbalancerFrontendNetwork"
                    },
                    "description": "Networks that frontend will be listening. Networks are required if load balancer has `networks` defined. This field will\nbe required when deprecated field `network` is removed from load balancer resource.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port to listen for incoming requests.\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/LoadbalancerFrontendProperties:LoadbalancerFrontendProperties"
                }
            },
            "requiredInputs": [
                "defaultBackendName",
                "loadbalancer",
                "mode",
                "port"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerFrontend resources.\n",
                "properties": {
                    "defaultBackendName": {
                        "type": "string",
                        "description": "The name of the backend where traffic will be routed by default. The default backend can be overridden in frontend\nrules. Note that the frontend resource depends on the default backend resource. Use the `name` field of a backend\nresource as the value for this field (like in the example above) or the `depends_on` meta argument to ensure the\nresources are created and destroyed in the correct order.\n"
                    },
                    "loadbalancer": {
                        "type": "string",
                        "description": "UUID of the load balancer to which the frontend is connected.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "When load balancer operating in `tcp` mode it acts as a layer 4 proxy. In `http` mode it acts as a layer 7 proxy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the frontend. Must be unique within the load balancer service.\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/LoadbalancerFrontendNetwork:LoadbalancerFrontendNetwork"
                        },
                        "description": "Networks that frontend will be listening. Networks are required if load balancer has `networks` defined. This field will\nbe required when deprecated field `network` is removed from load balancer resource.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port to listen for incoming requests.\n"
                    },
                    "properties": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendProperties:LoadbalancerFrontendProperties"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of frontend rule names.\n"
                    },
                    "tlsConfigs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set of TLS config names.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerFrontendRule:LoadbalancerFrontendRule": {
            "description": "This resource represents load balancer frontend rule.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst config = new pulumi.Config();\nconst lbZone = config.get(\"lbZone\") || \"fi-hel2\";\nconst lbNetwork = new upcloud.Network(\"lb_network\", {\n    name: \"lb-test-net\",\n    zone: lbZone,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst lbFe1R1 = new upcloud.LoadbalancerFrontendRule(\"lb_fe_1_r1\", {\n    frontend: upcloudLoadbalancerFrontend.lbFe1.id,\n    name: \"lb-fe-1-r1-test\",\n    priority: 10,\n    matchers: {\n        srcIps: [{\n            value: \"192.168.0.0/24\",\n        }],\n    },\n    actions: {\n        useBackends: [{\n            backendName: upcloudLoadbalancerBackend.lbBe1.name,\n        }],\n    },\n});\nconst lbFe1 = new upcloud.LoadbalancerFrontend(\"lb_fe_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-fe-1-test\",\n    mode: \"http\",\n    port: 8080,\n    defaultBackendName: upcloudLoadbalancerBackend.lbBe1.name,\n});\nconst lb = new upcloud.Loadbalancer(\"lb\", {\n    configuredStatus: \"started\",\n    name: \"lb-test\",\n    plan: \"development\",\n    zone: lbZone,\n    networks: [\n        {\n            type: \"public\",\n            family: \"IPv4\",\n            name: \"public\",\n        },\n        {\n            type: \"private\",\n            family: \"IPv4\",\n            name: \"private\",\n            network: upcloudNetwork.lbNetwork.id,\n        },\n    ],\n});\nconst lbBe1 = new upcloud.LoadbalancerBackend(\"lb_be_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-be-1-test\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nconfig = pulumi.Config()\nlb_zone = config.get(\"lbZone\")\nif lb_zone is None:\n    lb_zone = \"fi-hel2\"\nlb_network = upcloud.Network(\"lb_network\",\n    name=\"lb-test-net\",\n    zone=lb_zone,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nlb_fe1_r1 = upcloud.LoadbalancerFrontendRule(\"lb_fe_1_r1\",\n    frontend=upcloud_loadbalancer_frontend[\"lbFe1\"][\"id\"],\n    name=\"lb-fe-1-r1-test\",\n    priority=10,\n    matchers={\n        \"src_ips\": [{\n            \"value\": \"192.168.0.0/24\",\n        }],\n    },\n    actions={\n        \"use_backends\": [{\n            \"backend_name\": upcloud_loadbalancer_backend[\"lbBe1\"][\"name\"],\n        }],\n    })\nlb_fe1 = upcloud.LoadbalancerFrontend(\"lb_fe_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-fe-1-test\",\n    mode=\"http\",\n    port=8080,\n    default_backend_name=upcloud_loadbalancer_backend[\"lbBe1\"][\"name\"])\nlb = upcloud.Loadbalancer(\"lb\",\n    configured_status=\"started\",\n    name=\"lb-test\",\n    plan=\"development\",\n    zone=lb_zone,\n    networks=[\n        {\n            \"type\": \"public\",\n            \"family\": \"IPv4\",\n            \"name\": \"public\",\n        },\n        {\n            \"type\": \"private\",\n            \"family\": \"IPv4\",\n            \"name\": \"private\",\n            \"network\": upcloud_network[\"lbNetwork\"][\"id\"],\n        },\n    ])\nlb_be1 = upcloud.LoadbalancerBackend(\"lb_be_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-be-1-test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var lbZone = config.Get(\"lbZone\") ?? \"fi-hel2\";\n    var lbNetwork = new UpCloud.Network(\"lb_network\", new()\n    {\n        Name = \"lb-test-net\",\n        Zone = lbZone,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var lbFe1R1 = new UpCloud.LoadbalancerFrontendRule(\"lb_fe_1_r1\", new()\n    {\n        Frontend = upcloudLoadbalancerFrontend.LbFe1.Id,\n        Name = \"lb-fe-1-r1-test\",\n        Priority = 10,\n        Matchers = new UpCloud.Inputs.LoadbalancerFrontendRuleMatchersArgs\n        {\n            SrcIps = new[]\n            {\n                new UpCloud.Inputs.LoadbalancerFrontendRuleMatchersSrcIpArgs\n                {\n                    Value = \"192.168.0.0/24\",\n                },\n            },\n        },\n        Actions = new UpCloud.Inputs.LoadbalancerFrontendRuleActionsArgs\n        {\n            UseBackends = new[]\n            {\n                new UpCloud.Inputs.LoadbalancerFrontendRuleActionsUseBackendArgs\n                {\n                    BackendName = upcloudLoadbalancerBackend.LbBe1.Name,\n                },\n            },\n        },\n    });\n\n    var lbFe1 = new UpCloud.LoadbalancerFrontend(\"lb_fe_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-fe-1-test\",\n        Mode = \"http\",\n        Port = 8080,\n        DefaultBackendName = upcloudLoadbalancerBackend.LbBe1.Name,\n    });\n\n    var lb = new UpCloud.Loadbalancer(\"lb\", new()\n    {\n        ConfiguredStatus = \"started\",\n        Name = \"lb-test\",\n        Plan = \"development\",\n        Zone = lbZone,\n        Networks = new[]\n        {\n            new UpCloud.Inputs.LoadbalancerNetworkArgs\n            {\n                Type = \"public\",\n                Family = \"IPv4\",\n                Name = \"public\",\n            },\n            new UpCloud.Inputs.LoadbalancerNetworkArgs\n            {\n                Type = \"private\",\n                Family = \"IPv4\",\n                Name = \"private\",\n                Network = upcloudNetwork.LbNetwork.Id,\n            },\n        },\n    });\n\n    var lbBe1 = new UpCloud.LoadbalancerBackend(\"lb_be_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-be-1-test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tlbZone := \"fi-hel2\"\n\t\tif param := cfg.Get(\"lbZone\"); param != \"\" {\n\t\t\tlbZone = param\n\t\t}\n\t\t_, err := upcloud.NewNetwork(ctx, \"lb_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"lb-test-net\"),\n\t\t\tZone: pulumi.String(lbZone),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerFrontendRule(ctx, \"lb_fe_1_r1\", \u0026upcloud.LoadbalancerFrontendRuleArgs{\n\t\t\tFrontend: pulumi.Any(upcloudLoadbalancerFrontend.LbFe1.Id),\n\t\t\tName:     pulumi.String(\"lb-fe-1-r1-test\"),\n\t\t\tPriority: pulumi.Int(10),\n\t\t\tMatchers: \u0026upcloud.LoadbalancerFrontendRuleMatchersArgs{\n\t\t\t\tSrcIps: upcloud.LoadbalancerFrontendRuleMatchersSrcIpArray{\n\t\t\t\t\t\u0026upcloud.LoadbalancerFrontendRuleMatchersSrcIpArgs{\n\t\t\t\t\t\tValue: pulumi.String(\"192.168.0.0/24\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tActions: \u0026upcloud.LoadbalancerFrontendRuleActionsArgs{\n\t\t\t\tUseBackends: upcloud.LoadbalancerFrontendRuleActionsUseBackendArray{\n\t\t\t\t\t\u0026upcloud.LoadbalancerFrontendRuleActionsUseBackendArgs{\n\t\t\t\t\t\tBackendName: pulumi.Any(upcloudLoadbalancerBackend.LbBe1.Name),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerFrontend(ctx, \"lb_fe_1\", \u0026upcloud.LoadbalancerFrontendArgs{\n\t\t\tLoadbalancer:       pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:               pulumi.String(\"lb-fe-1-test\"),\n\t\t\tMode:               pulumi.String(\"http\"),\n\t\t\tPort:               pulumi.Int(8080),\n\t\t\tDefaultBackendName: pulumi.Any(upcloudLoadbalancerBackend.LbBe1.Name),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancer(ctx, \"lb\", \u0026upcloud.LoadbalancerArgs{\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tName:             pulumi.String(\"lb-test\"),\n\t\t\tPlan:             pulumi.String(\"development\"),\n\t\t\tZone:             pulumi.String(lbZone),\n\t\t\tNetworks: upcloud.LoadbalancerNetworkArray{\n\t\t\t\t\u0026upcloud.LoadbalancerNetworkArgs{\n\t\t\t\t\tType:   pulumi.String(\"public\"),\n\t\t\t\t\tFamily: pulumi.String(\"IPv4\"),\n\t\t\t\t\tName:   pulumi.String(\"public\"),\n\t\t\t\t},\n\t\t\t\t\u0026upcloud.LoadbalancerNetworkArgs{\n\t\t\t\t\tType:    pulumi.String(\"private\"),\n\t\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t\t\tName:    pulumi.String(\"private\"),\n\t\t\t\t\tNetwork: pulumi.Any(upcloudNetwork.LbNetwork.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerBackend(ctx, \"lb_be_1\", \u0026upcloud.LoadbalancerBackendArgs{\n\t\t\tLoadbalancer: pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:         pulumi.String(\"lb-be-1-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.LoadbalancerFrontendRule;\nimport com.pulumi.upcloud.LoadbalancerFrontendRuleArgs;\nimport com.pulumi.upcloud.inputs.LoadbalancerFrontendRuleMatchersArgs;\nimport com.pulumi.upcloud.inputs.LoadbalancerFrontendRuleActionsArgs;\nimport com.pulumi.upcloud.LoadbalancerFrontend;\nimport com.pulumi.upcloud.LoadbalancerFrontendArgs;\nimport com.pulumi.upcloud.Loadbalancer;\nimport com.pulumi.upcloud.LoadbalancerArgs;\nimport com.pulumi.upcloud.inputs.LoadbalancerNetworkArgs;\nimport com.pulumi.upcloud.LoadbalancerBackend;\nimport com.pulumi.upcloud.LoadbalancerBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var lbZone = config.get(\"lbZone\").orElse(\"fi-hel2\");\n        var lbNetwork = new Network(\"lbNetwork\", NetworkArgs.builder()\n            .name(\"lb-test-net\")\n            .zone(lbZone)\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        var lbFe1R1 = new LoadbalancerFrontendRule(\"lbFe1R1\", LoadbalancerFrontendRuleArgs.builder()\n            .frontend(upcloudLoadbalancerFrontend.lbFe1().id())\n            .name(\"lb-fe-1-r1-test\")\n            .priority(10)\n            .matchers(LoadbalancerFrontendRuleMatchersArgs.builder()\n                .srcIps(LoadbalancerFrontendRuleMatchersSrcIpArgs.builder()\n                    .value(\"192.168.0.0/24\")\n                    .build())\n                .build())\n            .actions(LoadbalancerFrontendRuleActionsArgs.builder()\n                .useBackends(LoadbalancerFrontendRuleActionsUseBackendArgs.builder()\n                    .backendName(upcloudLoadbalancerBackend.lbBe1().name())\n                    .build())\n                .build())\n            .build());\n\n        var lbFe1 = new LoadbalancerFrontend(\"lbFe1\", LoadbalancerFrontendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-fe-1-test\")\n            .mode(\"http\")\n            .port(8080)\n            .defaultBackendName(upcloudLoadbalancerBackend.lbBe1().name())\n            .build());\n\n        var lb = new Loadbalancer(\"lb\", LoadbalancerArgs.builder()\n            .configuredStatus(\"started\")\n            .name(\"lb-test\")\n            .plan(\"development\")\n            .zone(lbZone)\n            .networks(            \n                LoadbalancerNetworkArgs.builder()\n                    .type(\"public\")\n                    .family(\"IPv4\")\n                    .name(\"public\")\n                    .build(),\n                LoadbalancerNetworkArgs.builder()\n                    .type(\"private\")\n                    .family(\"IPv4\")\n                    .name(\"private\")\n                    .network(upcloudNetwork.lbNetwork().id())\n                    .build())\n            .build());\n\n        var lbBe1 = new LoadbalancerBackend(\"lbBe1\", LoadbalancerBackendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-be-1-test\")\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  lbZone:\n    type: string\n    default: fi-hel2\nresources:\n  lbNetwork:\n    type: upcloud:Network\n    name: lb_network\n    properties:\n      name: lb-test-net\n      zone: ${lbZone}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  lbFe1R1:\n    type: upcloud:LoadbalancerFrontendRule\n    name: lb_fe_1_r1\n    properties:\n      frontend: ${upcloudLoadbalancerFrontend.lbFe1.id}\n      name: lb-fe-1-r1-test\n      priority: 10\n      matchers:\n        srcIps:\n          - value: 192.168.0.0/24\n      actions:\n        useBackends:\n          - backendName: ${upcloudLoadbalancerBackend.lbBe1.name}\n  lbFe1:\n    type: upcloud:LoadbalancerFrontend\n    name: lb_fe_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-fe-1-test\n      mode: http\n      port: 8080\n      defaultBackendName: ${upcloudLoadbalancerBackend.lbBe1.name}\n  lb:\n    type: upcloud:Loadbalancer\n    properties:\n      configuredStatus: started\n      name: lb-test\n      plan: development\n      zone: ${lbZone}\n      networks:\n        - type: public\n          family: IPv4\n          name: public\n        - type: private\n          family: IPv4\n          name: private\n          network: ${upcloudNetwork.lbNetwork.id}\n  lbBe1:\n    type: upcloud:LoadbalancerBackend\n    name: lb_be_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-be-1-test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "actions": {
                    "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActions:LoadbalancerFrontendRuleActions",
                    "description": "Rule actions.\n"
                },
                "frontend": {
                    "type": "string",
                    "description": "ID of the load balancer frontend to which the frontend rule is connected.\n"
                },
                "matchers": {
                    "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchers:LoadbalancerFrontendRuleMatchers",
                    "description": "Set of rule matchers. If rule doesn't have matchers, then action applies to all incoming requests.\n"
                },
                "matchingCondition": {
                    "type": "string",
                    "description": "Defines boolean operator used to combine multiple matchers. Defaults to `and`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the frontend rule. Must be unique within the frontend.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Rule with the higher priority goes first. Rules with the same priority processed in alphabetical order.\n"
                }
            },
            "required": [
                "frontend",
                "matchingCondition",
                "name",
                "priority"
            ],
            "inputProperties": {
                "actions": {
                    "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActions:LoadbalancerFrontendRuleActions",
                    "description": "Rule actions.\n"
                },
                "frontend": {
                    "type": "string",
                    "description": "ID of the load balancer frontend to which the frontend rule is connected.\n"
                },
                "matchers": {
                    "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchers:LoadbalancerFrontendRuleMatchers",
                    "description": "Set of rule matchers. If rule doesn't have matchers, then action applies to all incoming requests.\n"
                },
                "matchingCondition": {
                    "type": "string",
                    "description": "Defines boolean operator used to combine multiple matchers. Defaults to `and`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the frontend rule. Must be unique within the frontend.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Rule with the higher priority goes first. Rules with the same priority processed in alphabetical order.\n"
                }
            },
            "requiredInputs": [
                "frontend",
                "priority"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerFrontendRule resources.\n",
                "properties": {
                    "actions": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleActions:LoadbalancerFrontendRuleActions",
                        "description": "Rule actions.\n"
                    },
                    "frontend": {
                        "type": "string",
                        "description": "ID of the load balancer frontend to which the frontend rule is connected.\n"
                    },
                    "matchers": {
                        "$ref": "#/types/upcloud:index/LoadbalancerFrontendRuleMatchers:LoadbalancerFrontendRuleMatchers",
                        "description": "Set of rule matchers. If rule doesn't have matchers, then action applies to all incoming requests.\n"
                    },
                    "matchingCondition": {
                        "type": "string",
                        "description": "Defines boolean operator used to combine multiple matchers. Defaults to `and`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the frontend rule. Must be unique within the frontend.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Rule with the higher priority goes first. Rules with the same priority processed in alphabetical order.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerFrontendTlsConfig:LoadbalancerFrontendTlsConfig": {
            "description": "This resource represents frontend TLS config\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst lbFe1Tls1 = new upcloud.LoadbalancerFrontendTlsConfig(\"lb_fe_1_tls1\", {\n    frontend: upcloudLoadbalancerFrontend.lbFe1.id,\n    name: \"lb-fe-1-tls1-test\",\n    certificateBundle: upcloudLoadbalancerManualCertificateBundle[\"lb-cb-m1\"].id,\n});\nconst config = new pulumi.Config();\nconst lbZone = config.get(\"lbZone\") || \"fi-hel2\";\nconst lbNetwork = new upcloud.Network(\"lb_network\", {\n    name: \"lb-test-net\",\n    zone: lbZone,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst lb_cb_m1 = new upcloud.LoadbalancerManualCertificateBundle(\"lb-cb-m1\", {\n    name: \"lb-cb-m1-test\",\n    certificate: \"LS0tLS1CRUdJTiBDRVJ...\",\n    privateKey: \"LS0tLS1CRUdJTiBQUkl...\",\n});\nconst lbFe1 = new upcloud.LoadbalancerFrontend(\"lb_fe_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-fe-1-test\",\n    mode: \"http\",\n    port: 8080,\n    defaultBackendName: upcloudLoadbalancerBackend.lbBe1.name,\n});\nconst lb = new upcloud.Loadbalancer(\"lb\", {\n    configuredStatus: \"started\",\n    name: \"lb-test\",\n    plan: \"development\",\n    zone: lbZone,\n    network: upcloudNetwork.lbNetwork.id,\n});\nconst lbBe1 = new upcloud.LoadbalancerBackend(\"lb_be_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-be-1-test\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nlb_fe1_tls1 = upcloud.LoadbalancerFrontendTlsConfig(\"lb_fe_1_tls1\",\n    frontend=upcloud_loadbalancer_frontend[\"lbFe1\"][\"id\"],\n    name=\"lb-fe-1-tls1-test\",\n    certificate_bundle=upcloud_loadbalancer_manual_certificate_bundle[\"lb-cb-m1\"][\"id\"])\nconfig = pulumi.Config()\nlb_zone = config.get(\"lbZone\")\nif lb_zone is None:\n    lb_zone = \"fi-hel2\"\nlb_network = upcloud.Network(\"lb_network\",\n    name=\"lb-test-net\",\n    zone=lb_zone,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nlb_cb_m1 = upcloud.LoadbalancerManualCertificateBundle(\"lb-cb-m1\",\n    name=\"lb-cb-m1-test\",\n    certificate=\"LS0tLS1CRUdJTiBDRVJ...\",\n    private_key=\"LS0tLS1CRUdJTiBQUkl...\")\nlb_fe1 = upcloud.LoadbalancerFrontend(\"lb_fe_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-fe-1-test\",\n    mode=\"http\",\n    port=8080,\n    default_backend_name=upcloud_loadbalancer_backend[\"lbBe1\"][\"name\"])\nlb = upcloud.Loadbalancer(\"lb\",\n    configured_status=\"started\",\n    name=\"lb-test\",\n    plan=\"development\",\n    zone=lb_zone,\n    network=upcloud_network[\"lbNetwork\"][\"id\"])\nlb_be1 = upcloud.LoadbalancerBackend(\"lb_be_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-be-1-test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var lbFe1Tls1 = new UpCloud.LoadbalancerFrontendTlsConfig(\"lb_fe_1_tls1\", new()\n    {\n        Frontend = upcloudLoadbalancerFrontend.LbFe1.Id,\n        Name = \"lb-fe-1-tls1-test\",\n        CertificateBundle = upcloudLoadbalancerManualCertificateBundle.Lb_cb_m1.Id,\n    });\n\n    var config = new Config();\n    var lbZone = config.Get(\"lbZone\") ?? \"fi-hel2\";\n    var lbNetwork = new UpCloud.Network(\"lb_network\", new()\n    {\n        Name = \"lb-test-net\",\n        Zone = lbZone,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var lb_cb_m1 = new UpCloud.LoadbalancerManualCertificateBundle(\"lb-cb-m1\", new()\n    {\n        Name = \"lb-cb-m1-test\",\n        Certificate = \"LS0tLS1CRUdJTiBDRVJ...\",\n        PrivateKey = \"LS0tLS1CRUdJTiBQUkl...\",\n    });\n\n    var lbFe1 = new UpCloud.LoadbalancerFrontend(\"lb_fe_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-fe-1-test\",\n        Mode = \"http\",\n        Port = 8080,\n        DefaultBackendName = upcloudLoadbalancerBackend.LbBe1.Name,\n    });\n\n    var lb = new UpCloud.Loadbalancer(\"lb\", new()\n    {\n        ConfiguredStatus = \"started\",\n        Name = \"lb-test\",\n        Plan = \"development\",\n        Zone = lbZone,\n        Network = upcloudNetwork.LbNetwork.Id,\n    });\n\n    var lbBe1 = new UpCloud.LoadbalancerBackend(\"lb_be_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-be-1-test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upcloud.NewLoadbalancerFrontendTlsConfig(ctx, \"lb_fe_1_tls1\", \u0026upcloud.LoadbalancerFrontendTlsConfigArgs{\n\t\t\tFrontend:          pulumi.Any(upcloudLoadbalancerFrontend.LbFe1.Id),\n\t\t\tName:              pulumi.String(\"lb-fe-1-tls1-test\"),\n\t\t\tCertificateBundle: pulumi.Any(upcloudLoadbalancerManualCertificateBundle.LbCbM1.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcfg := config.New(ctx, \"\")\n\t\tlbZone := \"fi-hel2\"\n\t\tif param := cfg.Get(\"lbZone\"); param != \"\" {\n\t\t\tlbZone = param\n\t\t}\n\t\t_, err = upcloud.NewNetwork(ctx, \"lb_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"lb-test-net\"),\n\t\t\tZone: pulumi.String(lbZone),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerManualCertificateBundle(ctx, \"lb-cb-m1\", \u0026upcloud.LoadbalancerManualCertificateBundleArgs{\n\t\t\tName:        pulumi.String(\"lb-cb-m1-test\"),\n\t\t\tCertificate: pulumi.String(\"LS0tLS1CRUdJTiBDRVJ...\"),\n\t\t\tPrivateKey:  pulumi.String(\"LS0tLS1CRUdJTiBQUkl...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerFrontend(ctx, \"lb_fe_1\", \u0026upcloud.LoadbalancerFrontendArgs{\n\t\t\tLoadbalancer:       pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:               pulumi.String(\"lb-fe-1-test\"),\n\t\t\tMode:               pulumi.String(\"http\"),\n\t\t\tPort:               pulumi.Int(8080),\n\t\t\tDefaultBackendName: pulumi.Any(upcloudLoadbalancerBackend.LbBe1.Name),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancer(ctx, \"lb\", \u0026upcloud.LoadbalancerArgs{\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tName:             pulumi.String(\"lb-test\"),\n\t\t\tPlan:             pulumi.String(\"development\"),\n\t\t\tZone:             pulumi.String(lbZone),\n\t\t\tNetwork:          pulumi.Any(upcloudNetwork.LbNetwork.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerBackend(ctx, \"lb_be_1\", \u0026upcloud.LoadbalancerBackendArgs{\n\t\t\tLoadbalancer: pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:         pulumi.String(\"lb-be-1-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.LoadbalancerFrontendTlsConfig;\nimport com.pulumi.upcloud.LoadbalancerFrontendTlsConfigArgs;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.LoadbalancerManualCertificateBundle;\nimport com.pulumi.upcloud.LoadbalancerManualCertificateBundleArgs;\nimport com.pulumi.upcloud.LoadbalancerFrontend;\nimport com.pulumi.upcloud.LoadbalancerFrontendArgs;\nimport com.pulumi.upcloud.Loadbalancer;\nimport com.pulumi.upcloud.LoadbalancerArgs;\nimport com.pulumi.upcloud.LoadbalancerBackend;\nimport com.pulumi.upcloud.LoadbalancerBackendArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        var lbFe1Tls1 = new LoadbalancerFrontendTlsConfig(\"lbFe1Tls1\", LoadbalancerFrontendTlsConfigArgs.builder()\n            .frontend(upcloudLoadbalancerFrontend.lbFe1().id())\n            .name(\"lb-fe-1-tls1-test\")\n            .certificateBundle(upcloudLoadbalancerManualCertificateBundle.lb-cb-m1().id())\n            .build());\n\n        final var lbZone = config.get(\"lbZone\").orElse(\"fi-hel2\");\n        var lbNetwork = new Network(\"lbNetwork\", NetworkArgs.builder()\n            .name(\"lb-test-net\")\n            .zone(lbZone)\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        var lb_cb_m1 = new LoadbalancerManualCertificateBundle(\"lb-cb-m1\", LoadbalancerManualCertificateBundleArgs.builder()\n            .name(\"lb-cb-m1-test\")\n            .certificate(\"LS0tLS1CRUdJTiBDRVJ...\")\n            .privateKey(\"LS0tLS1CRUdJTiBQUkl...\")\n            .build());\n\n        var lbFe1 = new LoadbalancerFrontend(\"lbFe1\", LoadbalancerFrontendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-fe-1-test\")\n            .mode(\"http\")\n            .port(8080)\n            .defaultBackendName(upcloudLoadbalancerBackend.lbBe1().name())\n            .build());\n\n        var lb = new Loadbalancer(\"lb\", LoadbalancerArgs.builder()\n            .configuredStatus(\"started\")\n            .name(\"lb-test\")\n            .plan(\"development\")\n            .zone(lbZone)\n            .network(upcloudNetwork.lbNetwork().id())\n            .build());\n\n        var lbBe1 = new LoadbalancerBackend(\"lbBe1\", LoadbalancerBackendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-be-1-test\")\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  lbZone:\n    type: string\n    default: fi-hel2\nresources:\n  lbFe1Tls1:\n    type: upcloud:LoadbalancerFrontendTlsConfig\n    name: lb_fe_1_tls1\n    properties:\n      frontend: ${upcloudLoadbalancerFrontend.lbFe1.id}\n      name: lb-fe-1-tls1-test\n      certificateBundle: ${upcloudLoadbalancerManualCertificateBundle\"lb-cb-m1\"[%!s(MISSING)].id}\n  lbNetwork:\n    type: upcloud:Network\n    name: lb_network\n    properties:\n      name: lb-test-net\n      zone: ${lbZone}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  lb-cb-m1:\n    type: upcloud:LoadbalancerManualCertificateBundle\n    properties:\n      name: lb-cb-m1-test\n      certificate: LS0tLS1CRUdJTiBDRVJ...\n      privateKey: LS0tLS1CRUdJTiBQUkl...\n  lbFe1:\n    type: upcloud:LoadbalancerFrontend\n    name: lb_fe_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-fe-1-test\n      mode: http\n      port: 8080\n      defaultBackendName: ${upcloudLoadbalancerBackend.lbBe1.name}\n  lb:\n    type: upcloud:Loadbalancer\n    properties:\n      configuredStatus: started\n      name: lb-test\n      plan: development\n      zone: ${lbZone}\n      network: ${upcloudNetwork.lbNetwork.id}\n  lbBe1:\n    type: upcloud:LoadbalancerBackend\n    name: lb_be_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-be-1-test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "certificateBundle": {
                    "type": "string",
                    "description": "Reference to certificate bundle ID.\n"
                },
                "frontend": {
                    "type": "string",
                    "description": "ID of the load balancer frontend to which the TLS config is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the TLS config. Must be unique within customer account.\n"
                }
            },
            "required": [
                "certificateBundle",
                "frontend",
                "name"
            ],
            "inputProperties": {
                "certificateBundle": {
                    "type": "string",
                    "description": "Reference to certificate bundle ID.\n"
                },
                "frontend": {
                    "type": "string",
                    "description": "ID of the load balancer frontend to which the TLS config is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the TLS config. Must be unique within customer account.\n"
                }
            },
            "requiredInputs": [
                "certificateBundle",
                "frontend"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerFrontendTlsConfig resources.\n",
                "properties": {
                    "certificateBundle": {
                        "type": "string",
                        "description": "Reference to certificate bundle ID.\n"
                    },
                    "frontend": {
                        "type": "string",
                        "description": "ID of the load balancer frontend to which the TLS config is connected.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the TLS config. Must be unique within customer account.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerManualCertificateBundle:LoadbalancerManualCertificateBundle": {
            "description": "This resource represents manual certificate bundle\n\n",
            "properties": {
                "certificate": {
                    "type": "string",
                    "description": "Certificate as base64 encoded string. Must be in PEM format.\n"
                },
                "intermediates": {
                    "type": "string",
                    "description": "Intermediate certificates as base64 encoded string. Must be in PEM format.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate bundle. Must be unique within customer account.\n"
                },
                "notAfter": {
                    "type": "string",
                    "description": "The time after which a certificate is no longer valid.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "The time on which a certificate becomes valid.\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "The service operational state indicates the service's current operational, effective state. Managed by the system.\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private key as base64 encoded string. Must be in PEM format.\n",
                    "secret": true
                }
            },
            "required": [
                "certificate",
                "intermediates",
                "name",
                "notAfter",
                "notBefore",
                "operationalState",
                "privateKey"
            ],
            "inputProperties": {
                "certificate": {
                    "type": "string",
                    "description": "Certificate as base64 encoded string. Must be in PEM format.\n"
                },
                "intermediates": {
                    "type": "string",
                    "description": "Intermediate certificates as base64 encoded string. Must be in PEM format.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the certificate bundle. Must be unique within customer account.\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private key as base64 encoded string. Must be in PEM format.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "certificate",
                "privateKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerManualCertificateBundle resources.\n",
                "properties": {
                    "certificate": {
                        "type": "string",
                        "description": "Certificate as base64 encoded string. Must be in PEM format.\n"
                    },
                    "intermediates": {
                        "type": "string",
                        "description": "Intermediate certificates as base64 encoded string. Must be in PEM format.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the certificate bundle. Must be unique within customer account.\n"
                    },
                    "notAfter": {
                        "type": "string",
                        "description": "The time after which a certificate is no longer valid.\n"
                    },
                    "notBefore": {
                        "type": "string",
                        "description": "The time on which a certificate becomes valid.\n"
                    },
                    "operationalState": {
                        "type": "string",
                        "description": "The service operational state indicates the service's current operational, effective state. Managed by the system.\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "Private key as base64 encoded string. Must be in PEM format.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerResolver:LoadbalancerResolver": {
            "description": "This resource represents load balancer resolver.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst config = new pulumi.Config();\nconst lbZone = config.get(\"lbZone\") || \"fi-hel2\";\nconst lbNetwork = new upcloud.Network(\"lb_network\", {\n    name: \"lb-test-net\",\n    zone: lbZone,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst lb = new upcloud.Loadbalancer(\"lb\", {\n    configuredStatus: \"started\",\n    name: \"lb-test\",\n    plan: \"development\",\n    zone: lbZone,\n    network: upcloudNetwork.lbNetwork.id,\n});\nconst lbResolver1 = new upcloud.LoadbalancerResolver(\"lb_resolver_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-resolver-1-test\",\n    cacheInvalid: 10,\n    cacheValid: 100,\n    retries: 5,\n    timeout: 10,\n    timeoutRetry: 10,\n    nameservers: [\"10.0.0.10:53\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nconfig = pulumi.Config()\nlb_zone = config.get(\"lbZone\")\nif lb_zone is None:\n    lb_zone = \"fi-hel2\"\nlb_network = upcloud.Network(\"lb_network\",\n    name=\"lb-test-net\",\n    zone=lb_zone,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nlb = upcloud.Loadbalancer(\"lb\",\n    configured_status=\"started\",\n    name=\"lb-test\",\n    plan=\"development\",\n    zone=lb_zone,\n    network=upcloud_network[\"lbNetwork\"][\"id\"])\nlb_resolver1 = upcloud.LoadbalancerResolver(\"lb_resolver_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-resolver-1-test\",\n    cache_invalid=10,\n    cache_valid=100,\n    retries=5,\n    timeout=10,\n    timeout_retry=10,\n    nameservers=[\"10.0.0.10:53\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var lbZone = config.Get(\"lbZone\") ?? \"fi-hel2\";\n    var lbNetwork = new UpCloud.Network(\"lb_network\", new()\n    {\n        Name = \"lb-test-net\",\n        Zone = lbZone,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var lb = new UpCloud.Loadbalancer(\"lb\", new()\n    {\n        ConfiguredStatus = \"started\",\n        Name = \"lb-test\",\n        Plan = \"development\",\n        Zone = lbZone,\n        Network = upcloudNetwork.LbNetwork.Id,\n    });\n\n    var lbResolver1 = new UpCloud.LoadbalancerResolver(\"lb_resolver_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-resolver-1-test\",\n        CacheInvalid = 10,\n        CacheValid = 100,\n        Retries = 5,\n        Timeout = 10,\n        TimeoutRetry = 10,\n        Nameservers = new[]\n        {\n            \"10.0.0.10:53\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tlbZone := \"fi-hel2\"\n\t\tif param := cfg.Get(\"lbZone\"); param != \"\" {\n\t\t\tlbZone = param\n\t\t}\n\t\t_, err := upcloud.NewNetwork(ctx, \"lb_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"lb-test-net\"),\n\t\t\tZone: pulumi.String(lbZone),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancer(ctx, \"lb\", \u0026upcloud.LoadbalancerArgs{\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tName:             pulumi.String(\"lb-test\"),\n\t\t\tPlan:             pulumi.String(\"development\"),\n\t\t\tZone:             pulumi.String(lbZone),\n\t\t\tNetwork:          pulumi.Any(upcloudNetwork.LbNetwork.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerResolver(ctx, \"lb_resolver_1\", \u0026upcloud.LoadbalancerResolverArgs{\n\t\t\tLoadbalancer: pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:         pulumi.String(\"lb-resolver-1-test\"),\n\t\t\tCacheInvalid: pulumi.Int(10),\n\t\t\tCacheValid:   pulumi.Int(100),\n\t\t\tRetries:      pulumi.Int(5),\n\t\t\tTimeout:      pulumi.Int(10),\n\t\t\tTimeoutRetry: pulumi.Int(10),\n\t\t\tNameservers: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.0.0.10:53\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.Loadbalancer;\nimport com.pulumi.upcloud.LoadbalancerArgs;\nimport com.pulumi.upcloud.LoadbalancerResolver;\nimport com.pulumi.upcloud.LoadbalancerResolverArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var lbZone = config.get(\"lbZone\").orElse(\"fi-hel2\");\n        var lbNetwork = new Network(\"lbNetwork\", NetworkArgs.builder()\n            .name(\"lb-test-net\")\n            .zone(lbZone)\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        var lb = new Loadbalancer(\"lb\", LoadbalancerArgs.builder()\n            .configuredStatus(\"started\")\n            .name(\"lb-test\")\n            .plan(\"development\")\n            .zone(lbZone)\n            .network(upcloudNetwork.lbNetwork().id())\n            .build());\n\n        var lbResolver1 = new LoadbalancerResolver(\"lbResolver1\", LoadbalancerResolverArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-resolver-1-test\")\n            .cacheInvalid(10)\n            .cacheValid(100)\n            .retries(5)\n            .timeout(10)\n            .timeoutRetry(10)\n            .nameservers(\"10.0.0.10:53\")\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  lbZone:\n    type: string\n    default: fi-hel2\nresources:\n  lbNetwork:\n    type: upcloud:Network\n    name: lb_network\n    properties:\n      name: lb-test-net\n      zone: ${lbZone}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  lb:\n    type: upcloud:Loadbalancer\n    properties:\n      configuredStatus: started\n      name: lb-test\n      plan: development\n      zone: ${lbZone}\n      network: ${upcloudNetwork.lbNetwork.id}\n  lbResolver1:\n    type: upcloud:LoadbalancerResolver\n    name: lb_resolver_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-resolver-1-test\n      cacheInvalid: 10\n      cacheValid: 100\n      retries: 5\n      timeout: 10\n      timeoutRetry: 10\n      nameservers:\n        - 10.0.0.10:53\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "cacheInvalid": {
                    "type": "integer",
                    "description": "Time in seconds to cache invalid results.\n"
                },
                "cacheValid": {
                    "type": "integer",
                    "description": "Time in seconds to cache valid results.\n"
                },
                "loadbalancer": {
                    "type": "string",
                    "description": "ID of the load balancer to which the resolver is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resolver. Must be unique within the service.\n"
                },
                "nameservers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of nameserver IP addresses. Nameserver can reside in public internet or in customer private network. Port is\noptional, if missing then default 53 will be used.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Number of retries on failure.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "Timeout for the query in seconds.\n"
                },
                "timeoutRetry": {
                    "type": "integer",
                    "description": "Timeout for the query retries in seconds.\n"
                }
            },
            "required": [
                "cacheInvalid",
                "cacheValid",
                "loadbalancer",
                "name",
                "nameservers",
                "retries",
                "timeout",
                "timeoutRetry"
            ],
            "inputProperties": {
                "cacheInvalid": {
                    "type": "integer",
                    "description": "Time in seconds to cache invalid results.\n"
                },
                "cacheValid": {
                    "type": "integer",
                    "description": "Time in seconds to cache valid results.\n"
                },
                "loadbalancer": {
                    "type": "string",
                    "description": "ID of the load balancer to which the resolver is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resolver. Must be unique within the service.\n"
                },
                "nameservers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of nameserver IP addresses. Nameserver can reside in public internet or in customer private network. Port is\noptional, if missing then default 53 will be used.\n"
                },
                "retries": {
                    "type": "integer",
                    "description": "Number of retries on failure.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "Timeout for the query in seconds.\n"
                },
                "timeoutRetry": {
                    "type": "integer",
                    "description": "Timeout for the query retries in seconds.\n"
                }
            },
            "requiredInputs": [
                "cacheInvalid",
                "cacheValid",
                "loadbalancer",
                "nameservers",
                "retries",
                "timeout",
                "timeoutRetry"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerResolver resources.\n",
                "properties": {
                    "cacheInvalid": {
                        "type": "integer",
                        "description": "Time in seconds to cache invalid results.\n"
                    },
                    "cacheValid": {
                        "type": "integer",
                        "description": "Time in seconds to cache valid results.\n"
                    },
                    "loadbalancer": {
                        "type": "string",
                        "description": "ID of the load balancer to which the resolver is connected.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resolver. Must be unique within the service.\n"
                    },
                    "nameservers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of nameserver IP addresses. Nameserver can reside in public internet or in customer private network. Port is\noptional, if missing then default 53 will be used.\n"
                    },
                    "retries": {
                        "type": "integer",
                        "description": "Number of retries on failure.\n"
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Timeout for the query in seconds.\n"
                    },
                    "timeoutRetry": {
                        "type": "integer",
                        "description": "Timeout for the query retries in seconds.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/loadbalancerStaticBackendMember:LoadbalancerStaticBackendMember": {
            "description": "This resource represents load balancer static backend member\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst config = new pulumi.Config();\nconst lbZone = config.get(\"lbZone\") || \"fi-hel2\";\nconst lbNetwork = new upcloud.Network(\"lb_network\", {\n    name: \"lb-test-net\",\n    zone: lbZone,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst lb = new upcloud.Loadbalancer(\"lb\", {\n    configuredStatus: \"started\",\n    name: \"lb-test\",\n    plan: \"development\",\n    zone: lbZone,\n    network: upcloudNetwork.lbNetwork.id,\n});\nconst lbBe1 = new upcloud.LoadbalancerBackend(\"lb_be_1\", {\n    loadbalancer: upcloudLoadbalancer.lb.id,\n    name: \"lb-be-1-test\",\n});\nconst lbBe1Sm1 = new upcloud.LoadbalancerStaticBackendMember(\"lb_be_1_sm_1\", {\n    backend: upcloudLoadbalancerBackend.lbBe1.id,\n    name: \"lb-be-1-sm-1-test\",\n    ip: \"10.0.0.10\",\n    port: 8000,\n    weight: 0,\n    maxSessions: 0,\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nconfig = pulumi.Config()\nlb_zone = config.get(\"lbZone\")\nif lb_zone is None:\n    lb_zone = \"fi-hel2\"\nlb_network = upcloud.Network(\"lb_network\",\n    name=\"lb-test-net\",\n    zone=lb_zone,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nlb = upcloud.Loadbalancer(\"lb\",\n    configured_status=\"started\",\n    name=\"lb-test\",\n    plan=\"development\",\n    zone=lb_zone,\n    network=upcloud_network[\"lbNetwork\"][\"id\"])\nlb_be1 = upcloud.LoadbalancerBackend(\"lb_be_1\",\n    loadbalancer=upcloud_loadbalancer[\"lb\"][\"id\"],\n    name=\"lb-be-1-test\")\nlb_be1_sm1 = upcloud.LoadbalancerStaticBackendMember(\"lb_be_1_sm_1\",\n    backend=upcloud_loadbalancer_backend[\"lbBe1\"][\"id\"],\n    name=\"lb-be-1-sm-1-test\",\n    ip=\"10.0.0.10\",\n    port=8000,\n    weight=0,\n    max_sessions=0,\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var lbZone = config.Get(\"lbZone\") ?? \"fi-hel2\";\n    var lbNetwork = new UpCloud.Network(\"lb_network\", new()\n    {\n        Name = \"lb-test-net\",\n        Zone = lbZone,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var lb = new UpCloud.Loadbalancer(\"lb\", new()\n    {\n        ConfiguredStatus = \"started\",\n        Name = \"lb-test\",\n        Plan = \"development\",\n        Zone = lbZone,\n        Network = upcloudNetwork.LbNetwork.Id,\n    });\n\n    var lbBe1 = new UpCloud.LoadbalancerBackend(\"lb_be_1\", new()\n    {\n        Loadbalancer = upcloudLoadbalancer.Lb.Id,\n        Name = \"lb-be-1-test\",\n    });\n\n    var lbBe1Sm1 = new UpCloud.LoadbalancerStaticBackendMember(\"lb_be_1_sm_1\", new()\n    {\n        Backend = upcloudLoadbalancerBackend.LbBe1.Id,\n        Name = \"lb-be-1-sm-1-test\",\n        Ip = \"10.0.0.10\",\n        Port = 8000,\n        Weight = 0,\n        MaxSessions = 0,\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tlbZone := \"fi-hel2\"\n\t\tif param := cfg.Get(\"lbZone\"); param != \"\" {\n\t\t\tlbZone = param\n\t\t}\n\t\t_, err := upcloud.NewNetwork(ctx, \"lb_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"lb-test-net\"),\n\t\t\tZone: pulumi.String(lbZone),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancer(ctx, \"lb\", \u0026upcloud.LoadbalancerArgs{\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tName:             pulumi.String(\"lb-test\"),\n\t\t\tPlan:             pulumi.String(\"development\"),\n\t\t\tZone:             pulumi.String(lbZone),\n\t\t\tNetwork:          pulumi.Any(upcloudNetwork.LbNetwork.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerBackend(ctx, \"lb_be_1\", \u0026upcloud.LoadbalancerBackendArgs{\n\t\t\tLoadbalancer: pulumi.Any(upcloudLoadbalancer.Lb.Id),\n\t\t\tName:         pulumi.String(\"lb-be-1-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewLoadbalancerStaticBackendMember(ctx, \"lb_be_1_sm_1\", \u0026upcloud.LoadbalancerStaticBackendMemberArgs{\n\t\t\tBackend:     pulumi.Any(upcloudLoadbalancerBackend.LbBe1.Id),\n\t\t\tName:        pulumi.String(\"lb-be-1-sm-1-test\"),\n\t\t\tIp:          pulumi.String(\"10.0.0.10\"),\n\t\t\tPort:        pulumi.Int(8000),\n\t\t\tWeight:      pulumi.Int(0),\n\t\t\tMaxSessions: pulumi.Int(0),\n\t\t\tEnabled:     pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.Loadbalancer;\nimport com.pulumi.upcloud.LoadbalancerArgs;\nimport com.pulumi.upcloud.LoadbalancerBackend;\nimport com.pulumi.upcloud.LoadbalancerBackendArgs;\nimport com.pulumi.upcloud.LoadbalancerStaticBackendMember;\nimport com.pulumi.upcloud.LoadbalancerStaticBackendMemberArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var lbZone = config.get(\"lbZone\").orElse(\"fi-hel2\");\n        var lbNetwork = new Network(\"lbNetwork\", NetworkArgs.builder()\n            .name(\"lb-test-net\")\n            .zone(lbZone)\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        var lb = new Loadbalancer(\"lb\", LoadbalancerArgs.builder()\n            .configuredStatus(\"started\")\n            .name(\"lb-test\")\n            .plan(\"development\")\n            .zone(lbZone)\n            .network(upcloudNetwork.lbNetwork().id())\n            .build());\n\n        var lbBe1 = new LoadbalancerBackend(\"lbBe1\", LoadbalancerBackendArgs.builder()\n            .loadbalancer(upcloudLoadbalancer.lb().id())\n            .name(\"lb-be-1-test\")\n            .build());\n\n        var lbBe1Sm1 = new LoadbalancerStaticBackendMember(\"lbBe1Sm1\", LoadbalancerStaticBackendMemberArgs.builder()\n            .backend(upcloudLoadbalancerBackend.lbBe1().id())\n            .name(\"lb-be-1-sm-1-test\")\n            .ip(\"10.0.0.10\")\n            .port(8000)\n            .weight(0)\n            .maxSessions(0)\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  lbZone:\n    type: string\n    default: fi-hel2\nresources:\n  lbNetwork:\n    type: upcloud:Network\n    name: lb_network\n    properties:\n      name: lb-test-net\n      zone: ${lbZone}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  lb:\n    type: upcloud:Loadbalancer\n    properties:\n      configuredStatus: started\n      name: lb-test\n      plan: development\n      zone: ${lbZone}\n      network: ${upcloudNetwork.lbNetwork.id}\n  lbBe1:\n    type: upcloud:LoadbalancerBackend\n    name: lb_be_1\n    properties:\n      loadbalancer: ${upcloudLoadbalancer.lb.id}\n      name: lb-be-1-test\n  lbBe1Sm1:\n    type: upcloud:LoadbalancerStaticBackendMember\n    name: lb_be_1_sm_1\n    properties:\n      backend: ${upcloudLoadbalancerBackend.lbBe1.id}\n      name: lb-be-1-sm-1-test\n      ip: 10.0.0.10\n      port: 8000\n      weight: 0\n      maxSessions: 0\n      enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "backend": {
                    "type": "string",
                    "description": "ID of the load balancer backend to which the member is connected.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates if the member is enabled. Disabled members are excluded from load balancing.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Optional fallback IP address in case of failure on DNS resolving.\n"
                },
                "maxSessions": {
                    "type": "integer",
                    "description": "Maximum number of sessions before queueing.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the member. Must be unique within within the load balancer backend.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Server port. Port is optional and can be specified in DNS SRV record.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Weight of the member. The higher the weight, the more traffic the member receives.\n"
                }
            },
            "required": [
                "backend",
                "enabled",
                "ip",
                "maxSessions",
                "name",
                "port",
                "weight"
            ],
            "inputProperties": {
                "backend": {
                    "type": "string",
                    "description": "ID of the load balancer backend to which the member is connected.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates if the member is enabled. Disabled members are excluded from load balancing.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Optional fallback IP address in case of failure on DNS resolving.\n"
                },
                "maxSessions": {
                    "type": "integer",
                    "description": "Maximum number of sessions before queueing.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the member. Must be unique within within the load balancer backend.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Server port. Port is optional and can be specified in DNS SRV record.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "Weight of the member. The higher the weight, the more traffic the member receives.\n"
                }
            },
            "requiredInputs": [
                "backend",
                "maxSessions",
                "weight"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LoadbalancerStaticBackendMember resources.\n",
                "properties": {
                    "backend": {
                        "type": "string",
                        "description": "ID of the load balancer backend to which the member is connected.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicates if the member is enabled. Disabled members are excluded from load balancing.\n"
                    },
                    "ip": {
                        "type": "string",
                        "description": "Optional fallback IP address in case of failure on DNS resolving.\n"
                    },
                    "maxSessions": {
                        "type": "integer",
                        "description": "Maximum number of sessions before queueing.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the member. Must be unique within within the load balancer backend.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Server port. Port is optional and can be specified in DNS SRV record.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "Weight of the member. The higher the weight, the more traffic the member receives.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedDatabaseLogicalDatabase:ManagedDatabaseLogicalDatabase": {
            "description": "This resource represents a logical database in managed database\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// PostgreSQL managed database with additional logical database: example_db \nconst example = new upcloud.ManagedDatabasePostgresql(\"example\", {\n    name: \"postgres\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    title: \"postgres\",\n    zone: \"fi-hel1\",\n});\nconst exampleDb = new upcloud.ManagedDatabaseLogicalDatabase(\"example_db\", {\n    service: example.id,\n    name: \"example_db\",\n});\n// MySQL managed database with additional logical database: example2_db \nconst exampleManagedDatabaseMysql = new upcloud.ManagedDatabaseMysql(\"example\", {\n    name: \"mysql\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    title: \"mysql\",\n    zone: \"fi-hel1\",\n});\nconst example2Db = new upcloud.ManagedDatabaseLogicalDatabase(\"example2_db\", {\n    service: exampleManagedDatabaseMysql.id,\n    name: \"example2_db\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# PostgreSQL managed database with additional logical database: example_db \nexample = upcloud.ManagedDatabasePostgresql(\"example\",\n    name=\"postgres\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    title=\"postgres\",\n    zone=\"fi-hel1\")\nexample_db = upcloud.ManagedDatabaseLogicalDatabase(\"example_db\",\n    service=example.id,\n    name=\"example_db\")\n# MySQL managed database with additional logical database: example2_db \nexample_managed_database_mysql = upcloud.ManagedDatabaseMysql(\"example\",\n    name=\"mysql\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    title=\"mysql\",\n    zone=\"fi-hel1\")\nexample2_db = upcloud.ManagedDatabaseLogicalDatabase(\"example2_db\",\n    service=example_managed_database_mysql.id,\n    name=\"example2_db\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // PostgreSQL managed database with additional logical database: example_db \n    var example = new UpCloud.ManagedDatabasePostgresql(\"example\", new()\n    {\n        Name = \"postgres\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Title = \"postgres\",\n        Zone = \"fi-hel1\",\n    });\n\n    var exampleDb = new UpCloud.ManagedDatabaseLogicalDatabase(\"example_db\", new()\n    {\n        Service = example.Id,\n        Name = \"example_db\",\n    });\n\n    // MySQL managed database with additional logical database: example2_db \n    var exampleManagedDatabaseMysql = new UpCloud.ManagedDatabaseMysql(\"example\", new()\n    {\n        Name = \"mysql\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Title = \"mysql\",\n        Zone = \"fi-hel1\",\n    });\n\n    var example2Db = new UpCloud.ManagedDatabaseLogicalDatabase(\"example2_db\", new()\n    {\n        Service = exampleManagedDatabaseMysql.Id,\n        Name = \"example2_db\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// PostgreSQL managed database with additional logical database: example_db\n\t\texample, err := upcloud.NewManagedDatabasePostgresql(ctx, \"example\", \u0026upcloud.ManagedDatabasePostgresqlArgs{\n\t\t\tName:  pulumi.String(\"postgres\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tTitle: pulumi.String(\"postgres\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedDatabaseLogicalDatabase(ctx, \"example_db\", \u0026upcloud.ManagedDatabaseLogicalDatabaseArgs{\n\t\t\tService: example.ID(),\n\t\t\tName:    pulumi.String(\"example_db\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// MySQL managed database with additional logical database: example2_db\n\t\texampleManagedDatabaseMysql, err := upcloud.NewManagedDatabaseMysql(ctx, \"example\", \u0026upcloud.ManagedDatabaseMysqlArgs{\n\t\t\tName:  pulumi.String(\"mysql\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tTitle: pulumi.String(\"mysql\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedDatabaseLogicalDatabase(ctx, \"example2_db\", \u0026upcloud.ManagedDatabaseLogicalDatabaseArgs{\n\t\t\tService: exampleManagedDatabaseMysql.ID(),\n\t\t\tName:    pulumi.String(\"example2_db\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabasePostgresql;\nimport com.pulumi.upcloud.ManagedDatabasePostgresqlArgs;\nimport com.pulumi.upcloud.ManagedDatabaseLogicalDatabase;\nimport com.pulumi.upcloud.ManagedDatabaseLogicalDatabaseArgs;\nimport com.pulumi.upcloud.ManagedDatabaseMysql;\nimport com.pulumi.upcloud.ManagedDatabaseMysqlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // PostgreSQL managed database with additional logical database: example_db \n        var example = new ManagedDatabasePostgresql(\"example\", ManagedDatabasePostgresqlArgs.builder()\n            .name(\"postgres\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .title(\"postgres\")\n            .zone(\"fi-hel1\")\n            .build());\n\n        var exampleDb = new ManagedDatabaseLogicalDatabase(\"exampleDb\", ManagedDatabaseLogicalDatabaseArgs.builder()\n            .service(example.id())\n            .name(\"example_db\")\n            .build());\n\n        // MySQL managed database with additional logical database: example2_db \n        var exampleManagedDatabaseMysql = new ManagedDatabaseMysql(\"exampleManagedDatabaseMysql\", ManagedDatabaseMysqlArgs.builder()\n            .name(\"mysql\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .title(\"mysql\")\n            .zone(\"fi-hel1\")\n            .build());\n\n        var example2Db = new ManagedDatabaseLogicalDatabase(\"example2Db\", ManagedDatabaseLogicalDatabaseArgs.builder()\n            .service(exampleManagedDatabaseMysql.id())\n            .name(\"example2_db\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # PostgreSQL managed database with additional logical database: example_db\n  example:\n    type: upcloud:ManagedDatabasePostgresql\n    properties:\n      name: postgres\n      plan: 1x1xCPU-2GB-25GB\n      title: postgres\n      zone: fi-hel1\n  exampleDb:\n    type: upcloud:ManagedDatabaseLogicalDatabase\n    name: example_db\n    properties:\n      service: ${example.id}\n      name: example_db\n  # MySQL managed database with additional logical database: example2_db\n  exampleManagedDatabaseMysql:\n    type: upcloud:ManagedDatabaseMysql\n    name: example\n    properties:\n      name: mysql\n      plan: 1x1xCPU-2GB-25GB\n      title: mysql\n      zone: fi-hel1\n  example2Db:\n    type: upcloud:ManagedDatabaseLogicalDatabase\n    name: example2_db\n    properties:\n      service: ${exampleManagedDatabaseMysql.id}\n      name: example2_db\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "characterSet": {
                    "type": "string",
                    "description": "Default character set for the database (LC_CTYPE)\n"
                },
                "collation": {
                    "type": "string",
                    "description": "Default collation for the database (LC_COLLATE)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the logical database\n"
                },
                "service": {
                    "type": "string",
                    "description": "Service's UUID for which this user belongs to\n"
                }
            },
            "required": [
                "characterSet",
                "collation",
                "name",
                "service"
            ],
            "inputProperties": {
                "characterSet": {
                    "type": "string",
                    "description": "Default character set for the database (LC_CTYPE)\n",
                    "willReplaceOnChanges": true
                },
                "collation": {
                    "type": "string",
                    "description": "Default collation for the database (LC_COLLATE)\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the logical database\n",
                    "willReplaceOnChanges": true
                },
                "service": {
                    "type": "string",
                    "description": "Service's UUID for which this user belongs to\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "service"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedDatabaseLogicalDatabase resources.\n",
                "properties": {
                    "characterSet": {
                        "type": "string",
                        "description": "Default character set for the database (LC_CTYPE)\n",
                        "willReplaceOnChanges": true
                    },
                    "collation": {
                        "type": "string",
                        "description": "Default collation for the database (LC_COLLATE)\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the logical database\n",
                        "willReplaceOnChanges": true
                    },
                    "service": {
                        "type": "string",
                        "description": "Service's UUID for which this user belongs to\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedDatabaseMysql:ManagedDatabaseMysql": {
            "description": "This resource represents MySQL managed database. See UpCloud [Managed Databases](https://upcloud.com/products/managed-databases) product page for more details about the service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Minimal config\nconst example1 = new upcloud.ManagedDatabaseMysql(\"example_1\", {\n    name: \"mysql-1\",\n    title: \"mysql-1-example-1\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    zone: \"fi-hel1\",\n});\n// Shutdown instance after creation\nconst example2 = new upcloud.ManagedDatabaseMysql(\"example_2\", {\n    name: \"mysql-2\",\n    title: \"mysql-2-example-2\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    zone: \"fi-hel1\",\n    powered: false,\n});\n// Service with custom properties\n// Note that this basically sets strict mode off which is not normally recommended\nconst example3 = new upcloud.ManagedDatabaseMysql(\"example_3\", {\n    name: \"mysql-3\",\n    title: \"mysql-3-example-3\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    zone: \"fi-hel1\",\n    properties: {\n        sqlMode: \"NO_ENGINE_SUBSTITUTION\",\n        waitTimeout: 300,\n        sortBufferSize: 4000000,\n        maxAllowedPacket: 16000000,\n        adminUsername: \"admin\",\n        adminPassword: \"\u003cADMIN_PASSWORD\u003e\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Minimal config\nexample1 = upcloud.ManagedDatabaseMysql(\"example_1\",\n    name=\"mysql-1\",\n    title=\"mysql-1-example-1\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    zone=\"fi-hel1\")\n# Shutdown instance after creation\nexample2 = upcloud.ManagedDatabaseMysql(\"example_2\",\n    name=\"mysql-2\",\n    title=\"mysql-2-example-2\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    zone=\"fi-hel1\",\n    powered=False)\n# Service with custom properties\n# Note that this basically sets strict mode off which is not normally recommended\nexample3 = upcloud.ManagedDatabaseMysql(\"example_3\",\n    name=\"mysql-3\",\n    title=\"mysql-3-example-3\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    zone=\"fi-hel1\",\n    properties={\n        \"sql_mode\": \"NO_ENGINE_SUBSTITUTION\",\n        \"wait_timeout\": 300,\n        \"sort_buffer_size\": 4000000,\n        \"max_allowed_packet\": 16000000,\n        \"admin_username\": \"admin\",\n        \"admin_password\": \"\u003cADMIN_PASSWORD\u003e\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Minimal config\n    var example1 = new UpCloud.ManagedDatabaseMysql(\"example_1\", new()\n    {\n        Name = \"mysql-1\",\n        Title = \"mysql-1-example-1\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Zone = \"fi-hel1\",\n    });\n\n    // Shutdown instance after creation\n    var example2 = new UpCloud.ManagedDatabaseMysql(\"example_2\", new()\n    {\n        Name = \"mysql-2\",\n        Title = \"mysql-2-example-2\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Zone = \"fi-hel1\",\n        Powered = false,\n    });\n\n    // Service with custom properties\n    // Note that this basically sets strict mode off which is not normally recommended\n    var example3 = new UpCloud.ManagedDatabaseMysql(\"example_3\", new()\n    {\n        Name = \"mysql-3\",\n        Title = \"mysql-3-example-3\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Zone = \"fi-hel1\",\n        Properties = new UpCloud.Inputs.ManagedDatabaseMysqlPropertiesArgs\n        {\n            SqlMode = \"NO_ENGINE_SUBSTITUTION\",\n            WaitTimeout = 300,\n            SortBufferSize = 4000000,\n            MaxAllowedPacket = 16000000,\n            AdminUsername = \"admin\",\n            AdminPassword = \"\u003cADMIN_PASSWORD\u003e\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Minimal config\n\t\t_, err := upcloud.NewManagedDatabaseMysql(ctx, \"example_1\", \u0026upcloud.ManagedDatabaseMysqlArgs{\n\t\t\tName:  pulumi.String(\"mysql-1\"),\n\t\t\tTitle: pulumi.String(\"mysql-1-example-1\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Shutdown instance after creation\n\t\t_, err = upcloud.NewManagedDatabaseMysql(ctx, \"example_2\", \u0026upcloud.ManagedDatabaseMysqlArgs{\n\t\t\tName:    pulumi.String(\"mysql-2\"),\n\t\t\tTitle:   pulumi.String(\"mysql-2-example-2\"),\n\t\t\tPlan:    pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tZone:    pulumi.String(\"fi-hel1\"),\n\t\t\tPowered: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Service with custom properties\n\t\t// Note that this basically sets strict mode off which is not normally recommended\n\t\t_, err = upcloud.NewManagedDatabaseMysql(ctx, \"example_3\", \u0026upcloud.ManagedDatabaseMysqlArgs{\n\t\t\tName:  pulumi.String(\"mysql-3\"),\n\t\t\tTitle: pulumi.String(\"mysql-3-example-3\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t\tProperties: \u0026upcloud.ManagedDatabaseMysqlPropertiesArgs{\n\t\t\t\tSqlMode:          pulumi.String(\"NO_ENGINE_SUBSTITUTION\"),\n\t\t\t\tWaitTimeout:      pulumi.Int(300),\n\t\t\t\tSortBufferSize:   pulumi.Int(4000000),\n\t\t\t\tMaxAllowedPacket: pulumi.Int(16000000),\n\t\t\t\tAdminUsername:    pulumi.String(\"admin\"),\n\t\t\t\tAdminPassword:    pulumi.String(\"\u003cADMIN_PASSWORD\u003e\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabaseMysql;\nimport com.pulumi.upcloud.ManagedDatabaseMysqlArgs;\nimport com.pulumi.upcloud.inputs.ManagedDatabaseMysqlPropertiesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Minimal config\n        var example1 = new ManagedDatabaseMysql(\"example1\", ManagedDatabaseMysqlArgs.builder()\n            .name(\"mysql-1\")\n            .title(\"mysql-1-example-1\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .zone(\"fi-hel1\")\n            .build());\n\n        // Shutdown instance after creation\n        var example2 = new ManagedDatabaseMysql(\"example2\", ManagedDatabaseMysqlArgs.builder()\n            .name(\"mysql-2\")\n            .title(\"mysql-2-example-2\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .zone(\"fi-hel1\")\n            .powered(false)\n            .build());\n\n        // Service with custom properties\n        // Note that this basically sets strict mode off which is not normally recommended\n        var example3 = new ManagedDatabaseMysql(\"example3\", ManagedDatabaseMysqlArgs.builder()\n            .name(\"mysql-3\")\n            .title(\"mysql-3-example-3\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .zone(\"fi-hel1\")\n            .properties(ManagedDatabaseMysqlPropertiesArgs.builder()\n                .sqlMode(\"NO_ENGINE_SUBSTITUTION\")\n                .waitTimeout(300)\n                .sortBufferSize(4000000)\n                .maxAllowedPacket(16000000)\n                .adminUsername(\"admin\")\n                .adminPassword(\"\u003cADMIN_PASSWORD\u003e\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Minimal config\n  example1:\n    type: upcloud:ManagedDatabaseMysql\n    name: example_1\n    properties:\n      name: mysql-1\n      title: mysql-1-example-1\n      plan: 1x1xCPU-2GB-25GB\n      zone: fi-hel1\n  # Shutdown instance after creation\n  example2:\n    type: upcloud:ManagedDatabaseMysql\n    name: example_2\n    properties:\n      name: mysql-2\n      title: mysql-2-example-2\n      plan: 1x1xCPU-2GB-25GB\n      zone: fi-hel1\n      powered: false\n  # Service with custom properties\n  # Note that this basically sets strict mode off which is not normally recommended\n  example3:\n    type: upcloud:ManagedDatabaseMysql\n    name: example_3\n    properties:\n      name: mysql-3\n      title: mysql-3-example-3\n      plan: 1x1xCPU-2GB-25GB\n      zone: fi-hel1\n      properties:\n        sqlMode: NO_ENGINE_SUBSTITUTION\n        waitTimeout: 300\n        sortBufferSize: 4e+06\n        maxAllowedPacket: 1.6e+07\n        adminUsername: admin\n        adminPassword: \u003cADMIN_PASSWORD\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlComponent:ManagedDatabaseMysqlComponent"
                    },
                    "description": "Service component information\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlNetwork:ManagedDatabaseMysqlNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "nodeStates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlNodeState:ManagedDatabaseMysqlNodeState"
                    },
                    "description": "Information about nodes providing the managed service\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "primaryDatabase": {
                    "type": "string",
                    "description": "Primary database name\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlProperties:ManagedDatabaseMysqlProperties",
                    "description": "Database Engine properties for MySQL\n"
                },
                "serviceHost": {
                    "type": "string",
                    "description": "Hostname to the service instance\n"
                },
                "servicePassword": {
                    "type": "string",
                    "description": "Primary username's password to the service instance\n",
                    "secret": true
                },
                "servicePort": {
                    "type": "string",
                    "description": "Port to the service instance\n"
                },
                "serviceUri": {
                    "type": "string",
                    "description": "URI to the service instance\n",
                    "secret": true
                },
                "serviceUsername": {
                    "type": "string",
                    "description": "Primary username to the service instance\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the service\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the service\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "components",
                "maintenanceWindowDow",
                "maintenanceWindowTime",
                "name",
                "nodeStates",
                "plan",
                "primaryDatabase",
                "properties",
                "serviceHost",
                "servicePassword",
                "servicePort",
                "serviceUri",
                "serviceUsername",
                "state",
                "title",
                "type",
                "zone"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                    "willReplaceOnChanges": true
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlNetwork:ManagedDatabaseMysqlNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlProperties:ManagedDatabaseMysqlProperties",
                    "description": "Database Engine properties for MySQL\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "plan",
                "title",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedDatabaseMysql resources.\n",
                "properties": {
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlComponent:ManagedDatabaseMysqlComponent"
                        },
                        "description": "Service component information\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the managed database.\n"
                    },
                    "maintenanceWindowDow": {
                        "type": "string",
                        "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                    },
                    "maintenanceWindowTime": {
                        "type": "string",
                        "description": "Maintenance window UTC time in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                        "willReplaceOnChanges": true
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlNetwork:ManagedDatabaseMysqlNetwork"
                        },
                        "description": "Private networks attached to the managed database\n"
                    },
                    "nodeStates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlNodeState:ManagedDatabaseMysqlNodeState"
                        },
                        "description": "Information about nodes providing the managed service\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                    },
                    "powered": {
                        "type": "boolean",
                        "description": "The administrative power state of the service\n"
                    },
                    "primaryDatabase": {
                        "type": "string",
                        "description": "Primary database name\n"
                    },
                    "properties": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseMysqlProperties:ManagedDatabaseMysqlProperties",
                        "description": "Database Engine properties for MySQL\n"
                    },
                    "serviceHost": {
                        "type": "string",
                        "description": "Hostname to the service instance\n"
                    },
                    "servicePassword": {
                        "type": "string",
                        "description": "Primary username's password to the service instance\n",
                        "secret": true
                    },
                    "servicePort": {
                        "type": "string",
                        "description": "Port to the service instance\n"
                    },
                    "serviceUri": {
                        "type": "string",
                        "description": "URI to the service instance\n",
                        "secret": true
                    },
                    "serviceUsername": {
                        "type": "string",
                        "description": "Primary username to the service instance\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the service\n"
                    },
                    "terminationProtection": {
                        "type": "boolean",
                        "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of a managed database instance\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the service\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedDatabaseOpensearch:ManagedDatabaseOpensearch": {
            "description": "This resource represents OpenSearch managed database. See UpCloud [Managed Databases](https://upcloud.com/products/managed-databases) product page for more details about the service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Minimal config\nconst example1 = new upcloud.ManagedDatabaseOpensearch(\"example_1\", {\n    name: \"opensearch-1\",\n    title: \"opensearch-1-example-1\",\n    plan: \"1x2xCPU-4GB-80GB-1D\",\n    zone: \"fi-hel2\",\n});\n// Service with custom properties and access control\nconst example2 = new upcloud.ManagedDatabaseOpensearch(\"example_2\", {\n    name: \"opensearch-2\",\n    title: \"opensearch-2-example-2\",\n    plan: \"1x2xCPU-4GB-80GB-1D\",\n    zone: \"fi-hel1\",\n    accessControl: true,\n    extendedAccessControl: true,\n    properties: {\n        publicAccess: false,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Minimal config\nexample1 = upcloud.ManagedDatabaseOpensearch(\"example_1\",\n    name=\"opensearch-1\",\n    title=\"opensearch-1-example-1\",\n    plan=\"1x2xCPU-4GB-80GB-1D\",\n    zone=\"fi-hel2\")\n# Service with custom properties and access control\nexample2 = upcloud.ManagedDatabaseOpensearch(\"example_2\",\n    name=\"opensearch-2\",\n    title=\"opensearch-2-example-2\",\n    plan=\"1x2xCPU-4GB-80GB-1D\",\n    zone=\"fi-hel1\",\n    access_control=True,\n    extended_access_control=True,\n    properties={\n        \"public_access\": False,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Minimal config\n    var example1 = new UpCloud.ManagedDatabaseOpensearch(\"example_1\", new()\n    {\n        Name = \"opensearch-1\",\n        Title = \"opensearch-1-example-1\",\n        Plan = \"1x2xCPU-4GB-80GB-1D\",\n        Zone = \"fi-hel2\",\n    });\n\n    // Service with custom properties and access control\n    var example2 = new UpCloud.ManagedDatabaseOpensearch(\"example_2\", new()\n    {\n        Name = \"opensearch-2\",\n        Title = \"opensearch-2-example-2\",\n        Plan = \"1x2xCPU-4GB-80GB-1D\",\n        Zone = \"fi-hel1\",\n        AccessControl = true,\n        ExtendedAccessControl = true,\n        Properties = new UpCloud.Inputs.ManagedDatabaseOpensearchPropertiesArgs\n        {\n            PublicAccess = false,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Minimal config\n\t\t_, err := upcloud.NewManagedDatabaseOpensearch(ctx, \"example_1\", \u0026upcloud.ManagedDatabaseOpensearchArgs{\n\t\t\tName:  pulumi.String(\"opensearch-1\"),\n\t\t\tTitle: pulumi.String(\"opensearch-1-example-1\"),\n\t\t\tPlan:  pulumi.String(\"1x2xCPU-4GB-80GB-1D\"),\n\t\t\tZone:  pulumi.String(\"fi-hel2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Service with custom properties and access control\n\t\t_, err = upcloud.NewManagedDatabaseOpensearch(ctx, \"example_2\", \u0026upcloud.ManagedDatabaseOpensearchArgs{\n\t\t\tName:                  pulumi.String(\"opensearch-2\"),\n\t\t\tTitle:                 pulumi.String(\"opensearch-2-example-2\"),\n\t\t\tPlan:                  pulumi.String(\"1x2xCPU-4GB-80GB-1D\"),\n\t\t\tZone:                  pulumi.String(\"fi-hel1\"),\n\t\t\tAccessControl:         pulumi.Bool(true),\n\t\t\tExtendedAccessControl: pulumi.Bool(true),\n\t\t\tProperties: \u0026upcloud.ManagedDatabaseOpensearchPropertiesArgs{\n\t\t\t\tPublicAccess: pulumi.Bool(false),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabaseOpensearch;\nimport com.pulumi.upcloud.ManagedDatabaseOpensearchArgs;\nimport com.pulumi.upcloud.inputs.ManagedDatabaseOpensearchPropertiesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Minimal config\n        var example1 = new ManagedDatabaseOpensearch(\"example1\", ManagedDatabaseOpensearchArgs.builder()\n            .name(\"opensearch-1\")\n            .title(\"opensearch-1-example-1\")\n            .plan(\"1x2xCPU-4GB-80GB-1D\")\n            .zone(\"fi-hel2\")\n            .build());\n\n        // Service with custom properties and access control\n        var example2 = new ManagedDatabaseOpensearch(\"example2\", ManagedDatabaseOpensearchArgs.builder()\n            .name(\"opensearch-2\")\n            .title(\"opensearch-2-example-2\")\n            .plan(\"1x2xCPU-4GB-80GB-1D\")\n            .zone(\"fi-hel1\")\n            .accessControl(true)\n            .extendedAccessControl(true)\n            .properties(ManagedDatabaseOpensearchPropertiesArgs.builder()\n                .publicAccess(false)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Minimal config\n  example1:\n    type: upcloud:ManagedDatabaseOpensearch\n    name: example_1\n    properties:\n      name: opensearch-1\n      title: opensearch-1-example-1\n      plan: 1x2xCPU-4GB-80GB-1D\n      zone: fi-hel2\n  # Service with custom properties and access control\n  example2:\n    type: upcloud:ManagedDatabaseOpensearch\n    name: example_2\n    properties:\n      name: opensearch-2\n      title: opensearch-2-example-2\n      plan: 1x2xCPU-4GB-80GB-1D\n      zone: fi-hel1\n      accessControl: true\n      extendedAccessControl: true\n      properties:\n        publicAccess: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "accessControl": {
                    "type": "boolean",
                    "description": "Enables users access control for OpenSearch service. User access control rules will only be enforced if this attribute\nis enabled.\n"
                },
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchComponent:ManagedDatabaseOpensearchComponent"
                    },
                    "description": "Service component information\n"
                },
                "extendedAccessControl": {
                    "type": "boolean",
                    "description": "Grant access to top-level `_mget`, `_msearch` and `_bulk` APIs. Users are limited to perform operations on indices based\non the user-specific access control rules.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchNetwork:ManagedDatabaseOpensearchNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "nodeStates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchNodeState:ManagedDatabaseOpensearchNodeState"
                    },
                    "description": "Information about nodes providing the managed service\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "primaryDatabase": {
                    "type": "string",
                    "description": "Primary database name\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchProperties:ManagedDatabaseOpensearchProperties",
                    "description": "Database Engine properties for OpenSearch\n"
                },
                "serviceHost": {
                    "type": "string",
                    "description": "Hostname to the service instance\n"
                },
                "servicePassword": {
                    "type": "string",
                    "description": "Primary username's password to the service instance\n",
                    "secret": true
                },
                "servicePort": {
                    "type": "string",
                    "description": "Port to the service instance\n"
                },
                "serviceUri": {
                    "type": "string",
                    "description": "URI to the service instance\n",
                    "secret": true
                },
                "serviceUsername": {
                    "type": "string",
                    "description": "Primary username to the service instance\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the service\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the service\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "accessControl",
                "components",
                "extendedAccessControl",
                "maintenanceWindowDow",
                "maintenanceWindowTime",
                "name",
                "nodeStates",
                "plan",
                "primaryDatabase",
                "properties",
                "serviceHost",
                "servicePassword",
                "servicePort",
                "serviceUri",
                "serviceUsername",
                "state",
                "title",
                "type",
                "zone"
            ],
            "inputProperties": {
                "accessControl": {
                    "type": "boolean",
                    "description": "Enables users access control for OpenSearch service. User access control rules will only be enforced if this attribute\nis enabled.\n"
                },
                "extendedAccessControl": {
                    "type": "boolean",
                    "description": "Grant access to top-level `_mget`, `_msearch` and `_bulk` APIs. Users are limited to perform operations on indices based\non the user-specific access control rules.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                    "willReplaceOnChanges": true
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchNetwork:ManagedDatabaseOpensearchNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchProperties:ManagedDatabaseOpensearchProperties",
                    "description": "Database Engine properties for OpenSearch\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "plan",
                "title",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedDatabaseOpensearch resources.\n",
                "properties": {
                    "accessControl": {
                        "type": "boolean",
                        "description": "Enables users access control for OpenSearch service. User access control rules will only be enforced if this attribute\nis enabled.\n"
                    },
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchComponent:ManagedDatabaseOpensearchComponent"
                        },
                        "description": "Service component information\n"
                    },
                    "extendedAccessControl": {
                        "type": "boolean",
                        "description": "Grant access to top-level `_mget`, `_msearch` and `_bulk` APIs. Users are limited to perform operations on indices based\non the user-specific access control rules.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the managed database.\n"
                    },
                    "maintenanceWindowDow": {
                        "type": "string",
                        "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                    },
                    "maintenanceWindowTime": {
                        "type": "string",
                        "description": "Maintenance window UTC time in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                        "willReplaceOnChanges": true
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchNetwork:ManagedDatabaseOpensearchNetwork"
                        },
                        "description": "Private networks attached to the managed database\n"
                    },
                    "nodeStates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchNodeState:ManagedDatabaseOpensearchNodeState"
                        },
                        "description": "Information about nodes providing the managed service\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                    },
                    "powered": {
                        "type": "boolean",
                        "description": "The administrative power state of the service\n"
                    },
                    "primaryDatabase": {
                        "type": "string",
                        "description": "Primary database name\n"
                    },
                    "properties": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseOpensearchProperties:ManagedDatabaseOpensearchProperties",
                        "description": "Database Engine properties for OpenSearch\n"
                    },
                    "serviceHost": {
                        "type": "string",
                        "description": "Hostname to the service instance\n"
                    },
                    "servicePassword": {
                        "type": "string",
                        "description": "Primary username's password to the service instance\n",
                        "secret": true
                    },
                    "servicePort": {
                        "type": "string",
                        "description": "Port to the service instance\n"
                    },
                    "serviceUri": {
                        "type": "string",
                        "description": "URI to the service instance\n",
                        "secret": true
                    },
                    "serviceUsername": {
                        "type": "string",
                        "description": "Primary username to the service instance\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the service\n"
                    },
                    "terminationProtection": {
                        "type": "boolean",
                        "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of a managed database instance\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the service\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedDatabasePostgresql:ManagedDatabasePostgresql": {
            "description": "This resource represents PostgreSQL managed database. See UpCloud [Managed Databases](https://upcloud.com/products/managed-databases) product page for more details about the service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Minimal config\nconst example1 = new upcloud.ManagedDatabasePostgresql(\"example_1\", {\n    name: \"postgres-1\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    title: \"postgres\",\n    zone: \"fi-hel1\",\n});\n// Service with custom properties\nconst example2 = new upcloud.ManagedDatabasePostgresql(\"example_2\", {\n    name: \"postgres-2\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    title: \"postgres\",\n    zone: \"fi-hel1\",\n    properties: {\n        timezone: \"Europe/Helsinki\",\n        adminUsername: \"admin\",\n        adminPassword: \"\u003cADMIN_PASSWORD\u003e\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Minimal config\nexample1 = upcloud.ManagedDatabasePostgresql(\"example_1\",\n    name=\"postgres-1\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    title=\"postgres\",\n    zone=\"fi-hel1\")\n# Service with custom properties\nexample2 = upcloud.ManagedDatabasePostgresql(\"example_2\",\n    name=\"postgres-2\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    title=\"postgres\",\n    zone=\"fi-hel1\",\n    properties={\n        \"timezone\": \"Europe/Helsinki\",\n        \"admin_username\": \"admin\",\n        \"admin_password\": \"\u003cADMIN_PASSWORD\u003e\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Minimal config\n    var example1 = new UpCloud.ManagedDatabasePostgresql(\"example_1\", new()\n    {\n        Name = \"postgres-1\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Title = \"postgres\",\n        Zone = \"fi-hel1\",\n    });\n\n    // Service with custom properties\n    var example2 = new UpCloud.ManagedDatabasePostgresql(\"example_2\", new()\n    {\n        Name = \"postgres-2\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Title = \"postgres\",\n        Zone = \"fi-hel1\",\n        Properties = new UpCloud.Inputs.ManagedDatabasePostgresqlPropertiesArgs\n        {\n            Timezone = \"Europe/Helsinki\",\n            AdminUsername = \"admin\",\n            AdminPassword = \"\u003cADMIN_PASSWORD\u003e\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Minimal config\n\t\t_, err := upcloud.NewManagedDatabasePostgresql(ctx, \"example_1\", \u0026upcloud.ManagedDatabasePostgresqlArgs{\n\t\t\tName:  pulumi.String(\"postgres-1\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tTitle: pulumi.String(\"postgres\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Service with custom properties\n\t\t_, err = upcloud.NewManagedDatabasePostgresql(ctx, \"example_2\", \u0026upcloud.ManagedDatabasePostgresqlArgs{\n\t\t\tName:  pulumi.String(\"postgres-2\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tTitle: pulumi.String(\"postgres\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t\tProperties: \u0026upcloud.ManagedDatabasePostgresqlPropertiesArgs{\n\t\t\t\tTimezone:      pulumi.String(\"Europe/Helsinki\"),\n\t\t\t\tAdminUsername: pulumi.String(\"admin\"),\n\t\t\t\tAdminPassword: pulumi.String(\"\u003cADMIN_PASSWORD\u003e\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabasePostgresql;\nimport com.pulumi.upcloud.ManagedDatabasePostgresqlArgs;\nimport com.pulumi.upcloud.inputs.ManagedDatabasePostgresqlPropertiesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Minimal config\n        var example1 = new ManagedDatabasePostgresql(\"example1\", ManagedDatabasePostgresqlArgs.builder()\n            .name(\"postgres-1\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .title(\"postgres\")\n            .zone(\"fi-hel1\")\n            .build());\n\n        // Service with custom properties\n        var example2 = new ManagedDatabasePostgresql(\"example2\", ManagedDatabasePostgresqlArgs.builder()\n            .name(\"postgres-2\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .title(\"postgres\")\n            .zone(\"fi-hel1\")\n            .properties(ManagedDatabasePostgresqlPropertiesArgs.builder()\n                .timezone(\"Europe/Helsinki\")\n                .adminUsername(\"admin\")\n                .adminPassword(\"\u003cADMIN_PASSWORD\u003e\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Minimal config\n  example1:\n    type: upcloud:ManagedDatabasePostgresql\n    name: example_1\n    properties:\n      name: postgres-1\n      plan: 1x1xCPU-2GB-25GB\n      title: postgres\n      zone: fi-hel1\n  # Service with custom properties\n  example2:\n    type: upcloud:ManagedDatabasePostgresql\n    name: example_2\n    properties:\n      name: postgres-2\n      plan: 1x1xCPU-2GB-25GB\n      title: postgres\n      zone: fi-hel1\n      properties:\n        timezone: Europe/Helsinki\n        adminUsername: admin\n        adminPassword: \u003cADMIN_PASSWORD\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlComponent:ManagedDatabasePostgresqlComponent"
                    },
                    "description": "Service component information\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlNetwork:ManagedDatabasePostgresqlNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "nodeStates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlNodeState:ManagedDatabasePostgresqlNodeState"
                    },
                    "description": "Information about nodes providing the managed service\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "primaryDatabase": {
                    "type": "string",
                    "description": "Primary database name\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlProperties:ManagedDatabasePostgresqlProperties",
                    "description": "Database Engine properties for PostgreSQL\n"
                },
                "serviceHost": {
                    "type": "string",
                    "description": "Hostname to the service instance\n"
                },
                "servicePassword": {
                    "type": "string",
                    "description": "Primary username's password to the service instance\n",
                    "secret": true
                },
                "servicePort": {
                    "type": "string",
                    "description": "Port to the service instance\n"
                },
                "serviceUri": {
                    "type": "string",
                    "description": "URI to the service instance\n",
                    "secret": true
                },
                "serviceUsername": {
                    "type": "string",
                    "description": "Primary username to the service instance\n"
                },
                "sslmode": {
                    "type": "string",
                    "description": "SSL Connection Mode for PostgreSQL\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the service\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the service\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "components",
                "maintenanceWindowDow",
                "maintenanceWindowTime",
                "name",
                "nodeStates",
                "plan",
                "primaryDatabase",
                "properties",
                "serviceHost",
                "servicePassword",
                "servicePort",
                "serviceUri",
                "serviceUsername",
                "sslmode",
                "state",
                "title",
                "type",
                "zone"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                    "willReplaceOnChanges": true
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlNetwork:ManagedDatabasePostgresqlNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlProperties:ManagedDatabasePostgresqlProperties",
                    "description": "Database Engine properties for PostgreSQL\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "plan",
                "title",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedDatabasePostgresql resources.\n",
                "properties": {
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlComponent:ManagedDatabasePostgresqlComponent"
                        },
                        "description": "Service component information\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the managed database.\n"
                    },
                    "maintenanceWindowDow": {
                        "type": "string",
                        "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                    },
                    "maintenanceWindowTime": {
                        "type": "string",
                        "description": "Maintenance window UTC time in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                        "willReplaceOnChanges": true
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlNetwork:ManagedDatabasePostgresqlNetwork"
                        },
                        "description": "Private networks attached to the managed database\n"
                    },
                    "nodeStates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlNodeState:ManagedDatabasePostgresqlNodeState"
                        },
                        "description": "Information about nodes providing the managed service\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                    },
                    "powered": {
                        "type": "boolean",
                        "description": "The administrative power state of the service\n"
                    },
                    "primaryDatabase": {
                        "type": "string",
                        "description": "Primary database name\n"
                    },
                    "properties": {
                        "$ref": "#/types/upcloud:index/ManagedDatabasePostgresqlProperties:ManagedDatabasePostgresqlProperties",
                        "description": "Database Engine properties for PostgreSQL\n"
                    },
                    "serviceHost": {
                        "type": "string",
                        "description": "Hostname to the service instance\n"
                    },
                    "servicePassword": {
                        "type": "string",
                        "description": "Primary username's password to the service instance\n",
                        "secret": true
                    },
                    "servicePort": {
                        "type": "string",
                        "description": "Port to the service instance\n"
                    },
                    "serviceUri": {
                        "type": "string",
                        "description": "URI to the service instance\n",
                        "secret": true
                    },
                    "serviceUsername": {
                        "type": "string",
                        "description": "Primary username to the service instance\n"
                    },
                    "sslmode": {
                        "type": "string",
                        "description": "SSL Connection Mode for PostgreSQL\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the service\n"
                    },
                    "terminationProtection": {
                        "type": "boolean",
                        "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of a managed database instance\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the service\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedDatabaseRedis:ManagedDatabaseRedis": {
            "description": "\u003e Redis is deprecated in favor of Valkey. Please use Valkey for new key value store instances.\n\nThis resource represents Redis managed database. See UpCloud [Managed Databases](https://upcloud.com/products/managed-databases) product page for more details about the service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Minimal config\nconst example1 = new upcloud.ManagedDatabaseRedis(\"example_1\", {\n    name: \"redis-1\",\n    title: \"redis-1-example-2\",\n    plan: \"1x1xCPU-2GB\",\n    zone: \"fi-hel2\",\n});\n// Service with custom properties\nconst example2 = new upcloud.ManagedDatabaseRedis(\"example_2\", {\n    name: \"redis-2\",\n    title: \"redis-2-example-2\",\n    plan: \"1x1xCPU-2GB\",\n    zone: \"fi-hel1\",\n    properties: {\n        publicAccess: false,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Minimal config\nexample1 = upcloud.ManagedDatabaseRedis(\"example_1\",\n    name=\"redis-1\",\n    title=\"redis-1-example-2\",\n    plan=\"1x1xCPU-2GB\",\n    zone=\"fi-hel2\")\n# Service with custom properties\nexample2 = upcloud.ManagedDatabaseRedis(\"example_2\",\n    name=\"redis-2\",\n    title=\"redis-2-example-2\",\n    plan=\"1x1xCPU-2GB\",\n    zone=\"fi-hel1\",\n    properties={\n        \"public_access\": False,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Minimal config\n    var example1 = new UpCloud.ManagedDatabaseRedis(\"example_1\", new()\n    {\n        Name = \"redis-1\",\n        Title = \"redis-1-example-2\",\n        Plan = \"1x1xCPU-2GB\",\n        Zone = \"fi-hel2\",\n    });\n\n    // Service with custom properties\n    var example2 = new UpCloud.ManagedDatabaseRedis(\"example_2\", new()\n    {\n        Name = \"redis-2\",\n        Title = \"redis-2-example-2\",\n        Plan = \"1x1xCPU-2GB\",\n        Zone = \"fi-hel1\",\n        Properties = new UpCloud.Inputs.ManagedDatabaseRedisPropertiesArgs\n        {\n            PublicAccess = false,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Minimal config\n\t\t_, err := upcloud.NewManagedDatabaseRedis(ctx, \"example_1\", \u0026upcloud.ManagedDatabaseRedisArgs{\n\t\t\tName:  pulumi.String(\"redis-1\"),\n\t\t\tTitle: pulumi.String(\"redis-1-example-2\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Service with custom properties\n\t\t_, err = upcloud.NewManagedDatabaseRedis(ctx, \"example_2\", \u0026upcloud.ManagedDatabaseRedisArgs{\n\t\t\tName:  pulumi.String(\"redis-2\"),\n\t\t\tTitle: pulumi.String(\"redis-2-example-2\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t\tProperties: \u0026upcloud.ManagedDatabaseRedisPropertiesArgs{\n\t\t\t\tPublicAccess: pulumi.Bool(false),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabaseRedis;\nimport com.pulumi.upcloud.ManagedDatabaseRedisArgs;\nimport com.pulumi.upcloud.inputs.ManagedDatabaseRedisPropertiesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Minimal config\n        var example1 = new ManagedDatabaseRedis(\"example1\", ManagedDatabaseRedisArgs.builder()\n            .name(\"redis-1\")\n            .title(\"redis-1-example-2\")\n            .plan(\"1x1xCPU-2GB\")\n            .zone(\"fi-hel2\")\n            .build());\n\n        // Service with custom properties\n        var example2 = new ManagedDatabaseRedis(\"example2\", ManagedDatabaseRedisArgs.builder()\n            .name(\"redis-2\")\n            .title(\"redis-2-example-2\")\n            .plan(\"1x1xCPU-2GB\")\n            .zone(\"fi-hel1\")\n            .properties(ManagedDatabaseRedisPropertiesArgs.builder()\n                .publicAccess(false)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Minimal config\n  example1:\n    type: upcloud:ManagedDatabaseRedis\n    name: example_1\n    properties:\n      name: redis-1\n      title: redis-1-example-2\n      plan: 1x1xCPU-2GB\n      zone: fi-hel2\n  # Service with custom properties\n  example2:\n    type: upcloud:ManagedDatabaseRedis\n    name: example_2\n    properties:\n      name: redis-2\n      title: redis-2-example-2\n      plan: 1x1xCPU-2GB\n      zone: fi-hel1\n      properties:\n        publicAccess: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseRedisComponent:ManagedDatabaseRedisComponent"
                    },
                    "description": "Service component information\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseRedisNetwork:ManagedDatabaseRedisNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "nodeStates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseRedisNodeState:ManagedDatabaseRedisNodeState"
                    },
                    "description": "Information about nodes providing the managed service\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "primaryDatabase": {
                    "type": "string",
                    "description": "Primary database name\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseRedisProperties:ManagedDatabaseRedisProperties",
                    "description": "Database Engine properties for Redis\n"
                },
                "serviceHost": {
                    "type": "string",
                    "description": "Hostname to the service instance\n"
                },
                "servicePassword": {
                    "type": "string",
                    "description": "Primary username's password to the service instance\n",
                    "secret": true
                },
                "servicePort": {
                    "type": "string",
                    "description": "Port to the service instance\n"
                },
                "serviceUri": {
                    "type": "string",
                    "description": "URI to the service instance\n",
                    "secret": true
                },
                "serviceUsername": {
                    "type": "string",
                    "description": "Primary username to the service instance\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the service\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the service\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "components",
                "maintenanceWindowDow",
                "maintenanceWindowTime",
                "name",
                "nodeStates",
                "plan",
                "primaryDatabase",
                "properties",
                "serviceHost",
                "servicePassword",
                "servicePort",
                "serviceUri",
                "serviceUsername",
                "state",
                "title",
                "type",
                "zone"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                    "willReplaceOnChanges": true
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseRedisNetwork:ManagedDatabaseRedisNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseRedisProperties:ManagedDatabaseRedisProperties",
                    "description": "Database Engine properties for Redis\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "plan",
                "title",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedDatabaseRedis resources.\n",
                "properties": {
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseRedisComponent:ManagedDatabaseRedisComponent"
                        },
                        "description": "Service component information\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the managed database.\n"
                    },
                    "maintenanceWindowDow": {
                        "type": "string",
                        "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                    },
                    "maintenanceWindowTime": {
                        "type": "string",
                        "description": "Maintenance window UTC time in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                        "willReplaceOnChanges": true
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseRedisNetwork:ManagedDatabaseRedisNetwork"
                        },
                        "description": "Private networks attached to the managed database\n"
                    },
                    "nodeStates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseRedisNodeState:ManagedDatabaseRedisNodeState"
                        },
                        "description": "Information about nodes providing the managed service\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                    },
                    "powered": {
                        "type": "boolean",
                        "description": "The administrative power state of the service\n"
                    },
                    "primaryDatabase": {
                        "type": "string",
                        "description": "Primary database name\n"
                    },
                    "properties": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseRedisProperties:ManagedDatabaseRedisProperties",
                        "description": "Database Engine properties for Redis\n"
                    },
                    "serviceHost": {
                        "type": "string",
                        "description": "Hostname to the service instance\n"
                    },
                    "servicePassword": {
                        "type": "string",
                        "description": "Primary username's password to the service instance\n",
                        "secret": true
                    },
                    "servicePort": {
                        "type": "string",
                        "description": "Port to the service instance\n"
                    },
                    "serviceUri": {
                        "type": "string",
                        "description": "URI to the service instance\n",
                        "secret": true
                    },
                    "serviceUsername": {
                        "type": "string",
                        "description": "Primary username to the service instance\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the service\n"
                    },
                    "terminationProtection": {
                        "type": "boolean",
                        "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of a managed database instance\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the service\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedDatabaseUser:ManagedDatabaseUser": {
            "description": "This resource represents a user in managed database\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst example = new upcloud.ManagedDatabasePostgresql(\"example\", {\n    name: \"postgres\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    title: \"postgres\",\n    zone: \"fi-hel1\",\n});\nconst exampleUser = new upcloud.ManagedDatabaseUser(\"example_user\", {\n    service: example.id,\n    username: \"example_user\",\n    password: \"\u003cUSER_PASSWORD\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nexample = upcloud.ManagedDatabasePostgresql(\"example\",\n    name=\"postgres\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    title=\"postgres\",\n    zone=\"fi-hel1\")\nexample_user = upcloud.ManagedDatabaseUser(\"example_user\",\n    service=example.id,\n    username=\"example_user\",\n    password=\"\u003cUSER_PASSWORD\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new UpCloud.ManagedDatabasePostgresql(\"example\", new()\n    {\n        Name = \"postgres\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Title = \"postgres\",\n        Zone = \"fi-hel1\",\n    });\n\n    var exampleUser = new UpCloud.ManagedDatabaseUser(\"example_user\", new()\n    {\n        Service = example.Id,\n        Username = \"example_user\",\n        Password = \"\u003cUSER_PASSWORD\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := upcloud.NewManagedDatabasePostgresql(ctx, \"example\", \u0026upcloud.ManagedDatabasePostgresqlArgs{\n\t\t\tName:  pulumi.String(\"postgres\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tTitle: pulumi.String(\"postgres\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedDatabaseUser(ctx, \"example_user\", \u0026upcloud.ManagedDatabaseUserArgs{\n\t\t\tService:  example.ID(),\n\t\t\tUsername: pulumi.String(\"example_user\"),\n\t\t\tPassword: pulumi.String(\"\u003cUSER_PASSWORD\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabasePostgresql;\nimport com.pulumi.upcloud.ManagedDatabasePostgresqlArgs;\nimport com.pulumi.upcloud.ManagedDatabaseUser;\nimport com.pulumi.upcloud.ManagedDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ManagedDatabasePostgresql(\"example\", ManagedDatabasePostgresqlArgs.builder()\n            .name(\"postgres\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .title(\"postgres\")\n            .zone(\"fi-hel1\")\n            .build());\n\n        var exampleUser = new ManagedDatabaseUser(\"exampleUser\", ManagedDatabaseUserArgs.builder()\n            .service(example.id())\n            .username(\"example_user\")\n            .password(\"\u003cUSER_PASSWORD\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: upcloud:ManagedDatabasePostgresql\n    properties:\n      name: postgres\n      plan: 1x1xCPU-2GB-25GB\n      title: postgres\n      zone: fi-hel1\n  exampleUser:\n    type: upcloud:ManagedDatabaseUser\n    name: example_user\n    properties:\n      service: ${example.id}\n      username: example_user\n      password: \u003cUSER_PASSWORD\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "authentication": {
                    "type": "string",
                    "description": "MySQL only, authentication type.\n"
                },
                "opensearchAccessControl": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseUserOpensearchAccessControl:ManagedDatabaseUserOpensearchAccessControl",
                    "description": "OpenSearch access control object.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for the database user. Defaults to a random value\n",
                    "secret": true
                },
                "pgAccessControl": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseUserPgAccessControl:ManagedDatabaseUserPgAccessControl",
                    "description": "PostgreSQL access control object.\n"
                },
                "redisAccessControl": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseUserRedisAccessControl:ManagedDatabaseUserRedisAccessControl",
                    "description": "Redis access control object.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Service's UUID for which this user belongs to\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the user. Only normal type users can be created\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the database user\n"
                },
                "valkeyAccessControl": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseUserValkeyAccessControl:ManagedDatabaseUserValkeyAccessControl",
                    "description": "Valkey access control object.\n"
                }
            },
            "required": [
                "password",
                "service",
                "type",
                "username"
            ],
            "inputProperties": {
                "authentication": {
                    "type": "string",
                    "description": "MySQL only, authentication type.\n"
                },
                "opensearchAccessControl": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseUserOpensearchAccessControl:ManagedDatabaseUserOpensearchAccessControl",
                    "description": "OpenSearch access control object.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for the database user. Defaults to a random value\n",
                    "secret": true
                },
                "pgAccessControl": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseUserPgAccessControl:ManagedDatabaseUserPgAccessControl",
                    "description": "PostgreSQL access control object.\n"
                },
                "redisAccessControl": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseUserRedisAccessControl:ManagedDatabaseUserRedisAccessControl",
                    "description": "Redis access control object.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Service's UUID for which this user belongs to\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Name of the database user\n",
                    "willReplaceOnChanges": true
                },
                "valkeyAccessControl": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseUserValkeyAccessControl:ManagedDatabaseUserValkeyAccessControl",
                    "description": "Valkey access control object.\n"
                }
            },
            "requiredInputs": [
                "service",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedDatabaseUser resources.\n",
                "properties": {
                    "authentication": {
                        "type": "string",
                        "description": "MySQL only, authentication type.\n"
                    },
                    "opensearchAccessControl": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseUserOpensearchAccessControl:ManagedDatabaseUserOpensearchAccessControl",
                        "description": "OpenSearch access control object.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password for the database user. Defaults to a random value\n",
                        "secret": true
                    },
                    "pgAccessControl": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseUserPgAccessControl:ManagedDatabaseUserPgAccessControl",
                        "description": "PostgreSQL access control object.\n"
                    },
                    "redisAccessControl": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseUserRedisAccessControl:ManagedDatabaseUserRedisAccessControl",
                        "description": "Redis access control object.\n"
                    },
                    "service": {
                        "type": "string",
                        "description": "Service's UUID for which this user belongs to\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the user. Only normal type users can be created\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Name of the database user\n",
                        "willReplaceOnChanges": true
                    },
                    "valkeyAccessControl": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseUserValkeyAccessControl:ManagedDatabaseUserValkeyAccessControl",
                        "description": "Valkey access control object.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedDatabaseValkey:ManagedDatabaseValkey": {
            "description": "This resource represents Valkey managed database. See UpCloud [Managed Databases](https://upcloud.com/products/managed-databases) product page for more details about the service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Minimal config\nconst example1 = new upcloud.ManagedDatabaseValkey(\"example_1\", {\n    name: \"valkey-1\",\n    title: \"valkey-example-1\",\n    plan: \"1x1xCPU-2GB\",\n    zone: \"fi-hel2\",\n});\n// Service with custom properties\nconst example2 = new upcloud.ManagedDatabaseValkey(\"example_2\", {\n    name: \"valkey-2\",\n    title: \"valkey-example-2\",\n    plan: \"1x1xCPU-2GB\",\n    zone: \"fi-hel1\",\n    properties: {\n        publicAccess: false,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Minimal config\nexample1 = upcloud.ManagedDatabaseValkey(\"example_1\",\n    name=\"valkey-1\",\n    title=\"valkey-example-1\",\n    plan=\"1x1xCPU-2GB\",\n    zone=\"fi-hel2\")\n# Service with custom properties\nexample2 = upcloud.ManagedDatabaseValkey(\"example_2\",\n    name=\"valkey-2\",\n    title=\"valkey-example-2\",\n    plan=\"1x1xCPU-2GB\",\n    zone=\"fi-hel1\",\n    properties={\n        \"public_access\": False,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Minimal config\n    var example1 = new UpCloud.ManagedDatabaseValkey(\"example_1\", new()\n    {\n        Name = \"valkey-1\",\n        Title = \"valkey-example-1\",\n        Plan = \"1x1xCPU-2GB\",\n        Zone = \"fi-hel2\",\n    });\n\n    // Service with custom properties\n    var example2 = new UpCloud.ManagedDatabaseValkey(\"example_2\", new()\n    {\n        Name = \"valkey-2\",\n        Title = \"valkey-example-2\",\n        Plan = \"1x1xCPU-2GB\",\n        Zone = \"fi-hel1\",\n        Properties = new UpCloud.Inputs.ManagedDatabaseValkeyPropertiesArgs\n        {\n            PublicAccess = false,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Minimal config\n\t\t_, err := upcloud.NewManagedDatabaseValkey(ctx, \"example_1\", \u0026upcloud.ManagedDatabaseValkeyArgs{\n\t\t\tName:  pulumi.String(\"valkey-1\"),\n\t\t\tTitle: pulumi.String(\"valkey-example-1\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Service with custom properties\n\t\t_, err = upcloud.NewManagedDatabaseValkey(ctx, \"example_2\", \u0026upcloud.ManagedDatabaseValkeyArgs{\n\t\t\tName:  pulumi.String(\"valkey-2\"),\n\t\t\tTitle: pulumi.String(\"valkey-example-2\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t\tProperties: \u0026upcloud.ManagedDatabaseValkeyPropertiesArgs{\n\t\t\t\tPublicAccess: pulumi.Bool(false),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabaseValkey;\nimport com.pulumi.upcloud.ManagedDatabaseValkeyArgs;\nimport com.pulumi.upcloud.inputs.ManagedDatabaseValkeyPropertiesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Minimal config\n        var example1 = new ManagedDatabaseValkey(\"example1\", ManagedDatabaseValkeyArgs.builder()\n            .name(\"valkey-1\")\n            .title(\"valkey-example-1\")\n            .plan(\"1x1xCPU-2GB\")\n            .zone(\"fi-hel2\")\n            .build());\n\n        // Service with custom properties\n        var example2 = new ManagedDatabaseValkey(\"example2\", ManagedDatabaseValkeyArgs.builder()\n            .name(\"valkey-2\")\n            .title(\"valkey-example-2\")\n            .plan(\"1x1xCPU-2GB\")\n            .zone(\"fi-hel1\")\n            .properties(ManagedDatabaseValkeyPropertiesArgs.builder()\n                .publicAccess(false)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Minimal config\n  example1:\n    type: upcloud:ManagedDatabaseValkey\n    name: example_1\n    properties:\n      name: valkey-1\n      title: valkey-example-1\n      plan: 1x1xCPU-2GB\n      zone: fi-hel2\n  # Service with custom properties\n  example2:\n    type: upcloud:ManagedDatabaseValkey\n    name: example_2\n    properties:\n      name: valkey-2\n      title: valkey-example-2\n      plan: 1x1xCPU-2GB\n      zone: fi-hel1\n      properties:\n        publicAccess: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyComponent:ManagedDatabaseValkeyComponent"
                    },
                    "description": "Service component information\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyNetwork:ManagedDatabaseValkeyNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "nodeStates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyNodeState:ManagedDatabaseValkeyNodeState"
                    },
                    "description": "Information about nodes providing the managed service\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "primaryDatabase": {
                    "type": "string",
                    "description": "Primary database name\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyProperties:ManagedDatabaseValkeyProperties",
                    "description": "Database Engine properties for Valkey\n"
                },
                "serviceHost": {
                    "type": "string",
                    "description": "Hostname to the service instance\n"
                },
                "servicePassword": {
                    "type": "string",
                    "description": "Primary username's password to the service instance\n",
                    "secret": true
                },
                "servicePort": {
                    "type": "string",
                    "description": "Port to the service instance\n"
                },
                "serviceUri": {
                    "type": "string",
                    "description": "URI to the service instance\n",
                    "secret": true
                },
                "serviceUsername": {
                    "type": "string",
                    "description": "Primary username to the service instance\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the service\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the service\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "components",
                "maintenanceWindowDow",
                "maintenanceWindowTime",
                "name",
                "nodeStates",
                "plan",
                "primaryDatabase",
                "properties",
                "serviceHost",
                "servicePassword",
                "servicePort",
                "serviceUri",
                "serviceUsername",
                "state",
                "title",
                "type",
                "zone"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed database.\n"
                },
                "maintenanceWindowDow": {
                    "type": "string",
                    "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                },
                "maintenanceWindowTime": {
                    "type": "string",
                    "description": "Maintenance window UTC time in hh:mm:ss format\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                    "willReplaceOnChanges": true
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyNetwork:ManagedDatabaseValkeyNetwork"
                    },
                    "description": "Private networks attached to the managed database\n"
                },
                "plan": {
                    "type": "string",
                    "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                },
                "powered": {
                    "type": "boolean",
                    "description": "The administrative power state of the service\n"
                },
                "properties": {
                    "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyProperties:ManagedDatabaseValkeyProperties",
                    "description": "Database Engine properties for Valkey\n"
                },
                "terminationProtection": {
                    "type": "boolean",
                    "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of a managed database instance\n"
                },
                "zone": {
                    "type": "string",
                    "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "plan",
                "title",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedDatabaseValkey resources.\n",
                "properties": {
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyComponent:ManagedDatabaseValkeyComponent"
                        },
                        "description": "Service component information\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the managed database.\n"
                    },
                    "maintenanceWindowDow": {
                        "type": "string",
                        "description": "Maintenance window day of week. Lower case weekday name (monday, tuesday, ...)\n"
                    },
                    "maintenanceWindowTime": {
                        "type": "string",
                        "description": "Maintenance window UTC time in hh:mm:ss format\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the service. The name is used as a prefix for the logical hostname. Must be unique within an account\n",
                        "willReplaceOnChanges": true
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyNetwork:ManagedDatabaseValkeyNetwork"
                        },
                        "description": "Private networks attached to the managed database\n"
                    },
                    "nodeStates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyNodeState:ManagedDatabaseValkeyNodeState"
                        },
                        "description": "Information about nodes providing the managed service\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "Service plan to use. This determines how much resources the instance will have. You can list available plans with `upctl\ndatabase plans \u003ctype\u003e`.\n"
                    },
                    "powered": {
                        "type": "boolean",
                        "description": "The administrative power state of the service\n"
                    },
                    "primaryDatabase": {
                        "type": "string",
                        "description": "Primary database name\n"
                    },
                    "properties": {
                        "$ref": "#/types/upcloud:index/ManagedDatabaseValkeyProperties:ManagedDatabaseValkeyProperties",
                        "description": "Database Engine properties for Valkey\n"
                    },
                    "serviceHost": {
                        "type": "string",
                        "description": "Hostname to the service instance\n"
                    },
                    "servicePassword": {
                        "type": "string",
                        "description": "Primary username's password to the service instance\n",
                        "secret": true
                    },
                    "servicePort": {
                        "type": "string",
                        "description": "Port to the service instance\n"
                    },
                    "serviceUri": {
                        "type": "string",
                        "description": "URI to the service instance\n",
                        "secret": true
                    },
                    "serviceUsername": {
                        "type": "string",
                        "description": "Primary username to the service instance\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of the service\n"
                    },
                    "terminationProtection": {
                        "type": "boolean",
                        "description": "If set to true, prevents the managed service from being powered off, or deleted.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of a managed database instance\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the service\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "Zone where the instance resides, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedObjectStorage:ManagedObjectStorage": {
            "description": "This resource represents an UpCloud Managed Object Storage instance, which provides S3 compatible storage.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Create router for the network\nconst _this = new upcloud.Router(\"this\", {name: \"object-storage-example-router\"});\n// Create network for the Managed Object Storage\nconst thisNetwork = new upcloud.Network(\"this\", {\n    name: \"object-storage-example-net\",\n    zone: \"fi-hel1\",\n    ipNetwork: {\n        address: \"172.16.2.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n    router: _this.id,\n});\nconst thisManagedObjectStorage = new upcloud.ManagedObjectStorage(\"this\", {\n    name: \"example\",\n    region: \"europe-1\",\n    configuredStatus: \"started\",\n    networks: [{\n        family: \"IPv4\",\n        name: \"example-private-net\",\n        type: \"private\",\n        uuid: thisNetwork.id,\n    }],\n    labels: {\n        \"managed-by\": \"terraform\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Create router for the network\nthis = upcloud.Router(\"this\", name=\"object-storage-example-router\")\n# Create network for the Managed Object Storage\nthis_network = upcloud.Network(\"this\",\n    name=\"object-storage-example-net\",\n    zone=\"fi-hel1\",\n    ip_network={\n        \"address\": \"172.16.2.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    },\n    router=this.id)\nthis_managed_object_storage = upcloud.ManagedObjectStorage(\"this\",\n    name=\"example\",\n    region=\"europe-1\",\n    configured_status=\"started\",\n    networks=[{\n        \"family\": \"IPv4\",\n        \"name\": \"example-private-net\",\n        \"type\": \"private\",\n        \"uuid\": this_network.id,\n    }],\n    labels={\n        \"managed-by\": \"terraform\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create router for the network\n    var @this = new UpCloud.Router(\"this\", new()\n    {\n        Name = \"object-storage-example-router\",\n    });\n\n    // Create network for the Managed Object Storage\n    var thisNetwork = new UpCloud.Network(\"this\", new()\n    {\n        Name = \"object-storage-example-net\",\n        Zone = \"fi-hel1\",\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"172.16.2.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n        Router = @this.Id,\n    });\n\n    var thisManagedObjectStorage = new UpCloud.ManagedObjectStorage(\"this\", new()\n    {\n        Name = \"example\",\n        Region = \"europe-1\",\n        ConfiguredStatus = \"started\",\n        Networks = new[]\n        {\n            new UpCloud.Inputs.ManagedObjectStorageNetworkArgs\n            {\n                Family = \"IPv4\",\n                Name = \"example-private-net\",\n                Type = \"private\",\n                Uuid = thisNetwork.Id,\n            },\n        },\n        Labels = \n        {\n            { \"managed-by\", \"terraform\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create router for the network\n\t\tthis, err := upcloud.NewRouter(ctx, \"this\", \u0026upcloud.RouterArgs{\n\t\t\tName: pulumi.String(\"object-storage-example-router\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create network for the Managed Object Storage\n\t\tthisNetwork, err := upcloud.NewNetwork(ctx, \"this\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"object-storage-example-net\"),\n\t\t\tZone: pulumi.String(\"fi-hel1\"),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"172.16.2.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t\tRouter: this.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedObjectStorage(ctx, \"this\", \u0026upcloud.ManagedObjectStorageArgs{\n\t\t\tName:             pulumi.String(\"example\"),\n\t\t\tRegion:           pulumi.String(\"europe-1\"),\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tNetworks: upcloud.ManagedObjectStorageNetworkArray{\n\t\t\t\t\u0026upcloud.ManagedObjectStorageNetworkArgs{\n\t\t\t\t\tFamily: pulumi.String(\"IPv4\"),\n\t\t\t\t\tName:   pulumi.String(\"example-private-net\"),\n\t\t\t\t\tType:   pulumi.String(\"private\"),\n\t\t\t\t\tUuid:   thisNetwork.ID(),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"managed-by\": pulumi.String(\"terraform\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Router;\nimport com.pulumi.upcloud.RouterArgs;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.ManagedObjectStorage;\nimport com.pulumi.upcloud.ManagedObjectStorageArgs;\nimport com.pulumi.upcloud.inputs.ManagedObjectStorageNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create router for the network\n        var this_ = new Router(\"this\", RouterArgs.builder()\n            .name(\"object-storage-example-router\")\n            .build());\n\n        // Create network for the Managed Object Storage\n        var thisNetwork = new Network(\"thisNetwork\", NetworkArgs.builder()\n            .name(\"object-storage-example-net\")\n            .zone(\"fi-hel1\")\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"172.16.2.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .router(this_.id())\n            .build());\n\n        var thisManagedObjectStorage = new ManagedObjectStorage(\"thisManagedObjectStorage\", ManagedObjectStorageArgs.builder()\n            .name(\"example\")\n            .region(\"europe-1\")\n            .configuredStatus(\"started\")\n            .networks(ManagedObjectStorageNetworkArgs.builder()\n                .family(\"IPv4\")\n                .name(\"example-private-net\")\n                .type(\"private\")\n                .uuid(thisNetwork.id())\n                .build())\n            .labels(Map.of(\"managed-by\", \"terraform\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create router for the network\n  this:\n    type: upcloud:Router\n    properties:\n      name: object-storage-example-router\n  # Create network for the Managed Object Storage\n  thisNetwork:\n    type: upcloud:Network\n    name: this\n    properties:\n      name: object-storage-example-net\n      zone: fi-hel1\n      ipNetwork:\n        address: 172.16.2.0/24\n        dhcp: true\n        family: IPv4\n      router: ${this.id}\n  thisManagedObjectStorage:\n    type: upcloud:ManagedObjectStorage\n    name: this\n    properties:\n      name: example\n      region: europe-1\n      configuredStatus: started\n      networks:\n        - family: IPv4\n          name: example-private-net\n          type: private\n          uuid: ${thisNetwork.id}\n      labels:\n        managed-by: terraform\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "configuredStatus": {
                    "type": "string",
                    "description": "Service status managed by the end user.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedObjectStorageEndpoint:ManagedObjectStorageEndpoint"
                    },
                    "description": "Endpoints for accessing the Managed Object Storage service.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed object storage.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Managed Object Storage service. Must be unique within account.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedObjectStorageNetwork:ManagedObjectStorageNetwork"
                    },
                    "description": "Attached networks from where object storage can be used. Private networks must reside in object storage region. To gain\naccess from multiple private networks that might reside in different zones, create the networks and a corresponding\nrouter for each network.\n"
                },
                "operationalState": {
                    "type": "string",
                    "description": "Operational state of the Managed Object Storage service.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Region in which the service will be hosted, see `upcloud.getManagedObjectStorageRegions` data source.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Creation time.\n"
                }
            },
            "required": [
                "configuredStatus",
                "createdAt",
                "endpoints",
                "name",
                "operationalState",
                "region",
                "updatedAt"
            ],
            "inputProperties": {
                "configuredStatus": {
                    "type": "string",
                    "description": "Service status managed by the end user.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the managed object storage.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Managed Object Storage service. Must be unique within account.\n"
                },
                "networks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ManagedObjectStorageNetwork:ManagedObjectStorageNetwork"
                    },
                    "description": "Attached networks from where object storage can be used. Private networks must reside in object storage region. To gain\naccess from multiple private networks that might reside in different zones, create the networks and a corresponding\nrouter for each network.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Region in which the service will be hosted, see `upcloud.getManagedObjectStorageRegions` data source.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "configuredStatus",
                "region"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedObjectStorage resources.\n",
                "properties": {
                    "configuredStatus": {
                        "type": "string",
                        "description": "Service status managed by the end user.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedObjectStorageEndpoint:ManagedObjectStorageEndpoint"
                        },
                        "description": "Endpoints for accessing the Managed Object Storage service.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the managed object storage.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Managed Object Storage service. Must be unique within account.\n"
                    },
                    "networks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ManagedObjectStorageNetwork:ManagedObjectStorageNetwork"
                        },
                        "description": "Attached networks from where object storage can be used. Private networks must reside in object storage region. To gain\naccess from multiple private networks that might reside in different zones, create the networks and a corresponding\nrouter for each network.\n"
                    },
                    "operationalState": {
                        "type": "string",
                        "description": "Operational state of the Managed Object Storage service.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "Region in which the service will be hosted, see `upcloud.getManagedObjectStorageRegions` data source.\n",
                        "willReplaceOnChanges": true
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Creation time.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedObjectStorageBucket:ManagedObjectStorageBucket": {
            "description": "This resource represents an UpCloud Managed Object Storage bucket.\n\n\u003e This resource uses the UpCloud API to manage the Managed Object Storage buckets. The main difference to S3 API is that the buckets can be deleted even when the bucket contains objects.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst example = new upcloud.ManagedObjectStorage(\"example\", {\n    name: \"bucket-example-objstov2\",\n    region: \"europe-1\",\n    configuredStatus: \"started\",\n});\nconst exampleManagedObjectStorageBucket = new upcloud.ManagedObjectStorageBucket(\"example\", {\n    serviceUuid: example.id,\n    name: \"bucket\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nexample = upcloud.ManagedObjectStorage(\"example\",\n    name=\"bucket-example-objstov2\",\n    region=\"europe-1\",\n    configured_status=\"started\")\nexample_managed_object_storage_bucket = upcloud.ManagedObjectStorageBucket(\"example\",\n    service_uuid=example.id,\n    name=\"bucket\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new UpCloud.ManagedObjectStorage(\"example\", new()\n    {\n        Name = \"bucket-example-objstov2\",\n        Region = \"europe-1\",\n        ConfiguredStatus = \"started\",\n    });\n\n    var exampleManagedObjectStorageBucket = new UpCloud.ManagedObjectStorageBucket(\"example\", new()\n    {\n        ServiceUuid = example.Id,\n        Name = \"bucket\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := upcloud.NewManagedObjectStorage(ctx, \"example\", \u0026upcloud.ManagedObjectStorageArgs{\n\t\t\tName:             pulumi.String(\"bucket-example-objstov2\"),\n\t\t\tRegion:           pulumi.String(\"europe-1\"),\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedObjectStorageBucket(ctx, \"example\", \u0026upcloud.ManagedObjectStorageBucketArgs{\n\t\t\tServiceUuid: example.ID(),\n\t\t\tName:        pulumi.String(\"bucket\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedObjectStorage;\nimport com.pulumi.upcloud.ManagedObjectStorageArgs;\nimport com.pulumi.upcloud.ManagedObjectStorageBucket;\nimport com.pulumi.upcloud.ManagedObjectStorageBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ManagedObjectStorage(\"example\", ManagedObjectStorageArgs.builder()\n            .name(\"bucket-example-objstov2\")\n            .region(\"europe-1\")\n            .configuredStatus(\"started\")\n            .build());\n\n        var exampleManagedObjectStorageBucket = new ManagedObjectStorageBucket(\"exampleManagedObjectStorageBucket\", ManagedObjectStorageBucketArgs.builder()\n            .serviceUuid(example.id())\n            .name(\"bucket\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: upcloud:ManagedObjectStorage\n    properties:\n      name: bucket-example-objstov2\n      region: europe-1\n      configuredStatus: started\n  exampleManagedObjectStorageBucket:\n    type: upcloud:ManagedObjectStorageBucket\n    name: example\n    properties:\n      serviceUuid: ${example.id}\n      name: bucket\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the bucket.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                },
                "totalObjects": {
                    "type": "integer",
                    "description": "Number of objects stored in the bucket.\n"
                },
                "totalSizeBytes": {
                    "type": "integer",
                    "description": "Total size of objects stored in the bucket.\n"
                }
            },
            "required": [
                "name",
                "serviceUuid",
                "totalObjects",
                "totalSizeBytes"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Name of the bucket.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                }
            },
            "requiredInputs": [
                "serviceUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedObjectStorageBucket resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the bucket.\n"
                    },
                    "serviceUuid": {
                        "type": "string",
                        "description": "Managed Object Storage service UUID.\n"
                    },
                    "totalObjects": {
                        "type": "integer",
                        "description": "Number of objects stored in the bucket.\n"
                    },
                    "totalSizeBytes": {
                        "type": "integer",
                        "description": "Total size of objects stored in the bucket.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedObjectStorageCustomDomain:ManagedObjectStorageCustomDomain": {
            "description": "This resource represents an UpCloud Managed Object Storage custom domain. Note that DNS settings for the custom domain should be configured before creating this resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst thisManagedObjectStorage = new upcloud.ManagedObjectStorage(\"this\", {\n    name: \"object-storage-custom-domain-example\",\n    region: \"europe-1\",\n    configuredStatus: \"started\",\n    networks: [{\n        family: \"IPv4\",\n        name: \"public\",\n        type: \"public\",\n    }],\n});\nconst _this = upcloud.getLoadBalancerDnsChallengeDomain({});\n// Before creating the custom domain, configure the DNS settings for your custom domain. For example, if your custom domain is objects.example.com, you should configure the following DNS records:\n// - \"_acme-challenge.objects IN CNAME ${data.upcloud_load_balancer_dns_challenge_domain.this.domain}\"\n// - \"objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n// - \"*.objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\nconst thisManagedObjectStorageCustomDomain = new upcloud.ManagedObjectStorageCustomDomain(\"this\", {\n    serviceUuid: thisManagedObjectStorage.id,\n    domainName: \"objects.example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nthis_managed_object_storage = upcloud.ManagedObjectStorage(\"this\",\n    name=\"object-storage-custom-domain-example\",\n    region=\"europe-1\",\n    configured_status=\"started\",\n    networks=[{\n        \"family\": \"IPv4\",\n        \"name\": \"public\",\n        \"type\": \"public\",\n    }])\nthis = upcloud.get_load_balancer_dns_challenge_domain()\n# Before creating the custom domain, configure the DNS settings for your custom domain. For example, if your custom domain is objects.example.com, you should configure the following DNS records:\n# - \"_acme-challenge.objects IN CNAME ${data.upcloud_load_balancer_dns_challenge_domain.this.domain}\"\n# - \"objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n# - \"*.objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\nthis_managed_object_storage_custom_domain = upcloud.ManagedObjectStorageCustomDomain(\"this\",\n    service_uuid=this_managed_object_storage.id,\n    domain_name=\"objects.example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var thisManagedObjectStorage = new UpCloud.ManagedObjectStorage(\"this\", new()\n    {\n        Name = \"object-storage-custom-domain-example\",\n        Region = \"europe-1\",\n        ConfiguredStatus = \"started\",\n        Networks = new[]\n        {\n            new UpCloud.Inputs.ManagedObjectStorageNetworkArgs\n            {\n                Family = \"IPv4\",\n                Name = \"public\",\n                Type = \"public\",\n            },\n        },\n    });\n\n    var @this = UpCloud.GetLoadBalancerDnsChallengeDomain.Invoke();\n\n    // Before creating the custom domain, configure the DNS settings for your custom domain. For example, if your custom domain is objects.example.com, you should configure the following DNS records:\n    // - \"_acme-challenge.objects IN CNAME ${data.upcloud_load_balancer_dns_challenge_domain.this.domain}\"\n    // - \"objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n    // - \"*.objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n    var thisManagedObjectStorageCustomDomain = new UpCloud.ManagedObjectStorageCustomDomain(\"this\", new()\n    {\n        ServiceUuid = thisManagedObjectStorage.Id,\n        DomainName = \"objects.example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthisManagedObjectStorage, err := upcloud.NewManagedObjectStorage(ctx, \"this\", \u0026upcloud.ManagedObjectStorageArgs{\n\t\t\tName:             pulumi.String(\"object-storage-custom-domain-example\"),\n\t\t\tRegion:           pulumi.String(\"europe-1\"),\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t\tNetworks: upcloud.ManagedObjectStorageNetworkArray{\n\t\t\t\t\u0026upcloud.ManagedObjectStorageNetworkArgs{\n\t\t\t\t\tFamily: pulumi.String(\"IPv4\"),\n\t\t\t\t\tName:   pulumi.String(\"public\"),\n\t\t\t\t\tType:   pulumi.String(\"public\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.GetLoadBalancerDnsChallengeDomain(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Before creating the custom domain, configure the DNS settings for your custom domain. For example, if your custom domain is objects.example.com, you should configure the following DNS records:\n\t\t// - \"_acme-challenge.objects IN CNAME ${data.upcloud_load_balancer_dns_challenge_domain.this.domain}\"\n\t\t// - \"objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n\t\t// - \"*.objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n\t\t_, err = upcloud.NewManagedObjectStorageCustomDomain(ctx, \"this\", \u0026upcloud.ManagedObjectStorageCustomDomainArgs{\n\t\t\tServiceUuid: thisManagedObjectStorage.ID(),\n\t\t\tDomainName:  pulumi.String(\"objects.example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedObjectStorage;\nimport com.pulumi.upcloud.ManagedObjectStorageArgs;\nimport com.pulumi.upcloud.inputs.ManagedObjectStorageNetworkArgs;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.ManagedObjectStorageCustomDomain;\nimport com.pulumi.upcloud.ManagedObjectStorageCustomDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var thisManagedObjectStorage = new ManagedObjectStorage(\"thisManagedObjectStorage\", ManagedObjectStorageArgs.builder()\n            .name(\"object-storage-custom-domain-example\")\n            .region(\"europe-1\")\n            .configuredStatus(\"started\")\n            .networks(ManagedObjectStorageNetworkArgs.builder()\n                .family(\"IPv4\")\n                .name(\"public\")\n                .type(\"public\")\n                .build())\n            .build());\n\n        final var this = UpcloudFunctions.getLoadBalancerDnsChallengeDomain(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n        // Before creating the custom domain, configure the DNS settings for your custom domain. For example, if your custom domain is objects.example.com, you should configure the following DNS records:\n        // - \"_acme-challenge.objects IN CNAME ${data.upcloud_load_balancer_dns_challenge_domain.this.domain}\"\n        // - \"objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n        // - \"*.objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n        var thisManagedObjectStorageCustomDomain = new ManagedObjectStorageCustomDomain(\"thisManagedObjectStorageCustomDomain\", ManagedObjectStorageCustomDomainArgs.builder()\n            .serviceUuid(thisManagedObjectStorage.id())\n            .domainName(\"objects.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  thisManagedObjectStorage:\n    type: upcloud:ManagedObjectStorage\n    name: this\n    properties:\n      name: object-storage-custom-domain-example\n      region: europe-1\n      configuredStatus: started\n      networks:\n        - family: IPv4\n          name: public\n          type: public\n  # Before creating the custom domain, configure the DNS settings for your custom domain. For example, if your custom domain is objects.example.com, you should configure the following DNS records:\n  # // - \"_acme-challenge.objects IN CNAME ${data.upcloud_load_balancer_dns_challenge_domain.this.domain}\"\n  # // - \"objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n  # // - \"*.objects IN CNAME ${[for i in upcloud_managed_object_storage.this.endpoint: i.domain_name if i.type == \"public\"][0]}\"\n  thisManagedObjectStorageCustomDomain:\n    type: upcloud:ManagedObjectStorageCustomDomain\n    name: this\n    properties:\n      serviceUuid: ${thisManagedObjectStorage.id}\n      domainName: objects.example.com\nvariables:\n  this:\n    fn::invoke:\n      function: upcloud:getLoadBalancerDnsChallengeDomain\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "domainName": {
                    "type": "string",
                    "description": "Must be a subdomain and consist of 3 to 5 parts such as objects.example.com. Cannot be root-level domain e.g.\nexample.com.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                },
                "type": {
                    "type": "string",
                    "description": "At the moment only `public` is accepted.\n"
                }
            },
            "required": [
                "domainName",
                "serviceUuid",
                "type"
            ],
            "inputProperties": {
                "domainName": {
                    "type": "string",
                    "description": "Must be a subdomain and consist of 3 to 5 parts such as objects.example.com. Cannot be root-level domain e.g.\nexample.com.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                },
                "type": {
                    "type": "string",
                    "description": "At the moment only `public` is accepted.\n"
                }
            },
            "requiredInputs": [
                "domainName",
                "serviceUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedObjectStorageCustomDomain resources.\n",
                "properties": {
                    "domainName": {
                        "type": "string",
                        "description": "Must be a subdomain and consist of 3 to 5 parts such as objects.example.com. Cannot be root-level domain e.g.\nexample.com.\n"
                    },
                    "serviceUuid": {
                        "type": "string",
                        "description": "Managed Object Storage service UUID.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "At the moment only `public` is accepted.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedObjectStoragePolicy:ManagedObjectStoragePolicy": {
            "description": "This resource represents an UpCloud Managed Object Storage policy.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst _this = new upcloud.ManagedObjectStorage(\"this\", {\n    name: \"example\",\n    region: \"europe-1\",\n    configuredStatus: \"started\",\n});\nconst thisManagedObjectStoragePolicy = new upcloud.ManagedObjectStoragePolicy(\"this\", {\n    name: \"example\",\n    description: \"example description\",\n    document: \"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\",\n    serviceUuid: _this.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nthis = upcloud.ManagedObjectStorage(\"this\",\n    name=\"example\",\n    region=\"europe-1\",\n    configured_status=\"started\")\nthis_managed_object_storage_policy = upcloud.ManagedObjectStoragePolicy(\"this\",\n    name=\"example\",\n    description=\"example description\",\n    document=\"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\",\n    service_uuid=this.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new UpCloud.ManagedObjectStorage(\"this\", new()\n    {\n        Name = \"example\",\n        Region = \"europe-1\",\n        ConfiguredStatus = \"started\",\n    });\n\n    var thisManagedObjectStoragePolicy = new UpCloud.ManagedObjectStoragePolicy(\"this\", new()\n    {\n        Name = \"example\",\n        Description = \"example description\",\n        Document = \"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\",\n        ServiceUuid = @this.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := upcloud.NewManagedObjectStorage(ctx, \"this\", \u0026upcloud.ManagedObjectStorageArgs{\n\t\t\tName:             pulumi.String(\"example\"),\n\t\t\tRegion:           pulumi.String(\"europe-1\"),\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedObjectStoragePolicy(ctx, \"this\", \u0026upcloud.ManagedObjectStoragePolicyArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"example description\"),\n\t\t\tDocument:    pulumi.String(\"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\"),\n\t\t\tServiceUuid: this.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedObjectStorage;\nimport com.pulumi.upcloud.ManagedObjectStorageArgs;\nimport com.pulumi.upcloud.ManagedObjectStoragePolicy;\nimport com.pulumi.upcloud.ManagedObjectStoragePolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new ManagedObjectStorage(\"this\", ManagedObjectStorageArgs.builder()\n            .name(\"example\")\n            .region(\"europe-1\")\n            .configuredStatus(\"started\")\n            .build());\n\n        var thisManagedObjectStoragePolicy = new ManagedObjectStoragePolicy(\"thisManagedObjectStoragePolicy\", ManagedObjectStoragePolicyArgs.builder()\n            .name(\"example\")\n            .description(\"example description\")\n            .document(\"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\")\n            .serviceUuid(this_.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: upcloud:ManagedObjectStorage\n    properties:\n      name: example\n      region: europe-1\n      configuredStatus: started\n  thisManagedObjectStoragePolicy:\n    type: upcloud:ManagedObjectStoragePolicy\n    name: this\n    properties:\n      name: example\n      description: example description\n      document: '%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D'\n      serviceUuid: ${this.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "Policy ARN.\n"
                },
                "attachmentCount": {
                    "type": "integer",
                    "description": "Attachment count.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "defaultVersionId": {
                    "type": "string",
                    "description": "Default version id.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the policy.\n"
                },
                "document": {
                    "type": "string",
                    "description": "Policy document, URL-encoded compliant with RFC 3986. Extra whitespace and escapes are ignored when determining if the\ndocument has changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Policy name.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                },
                "system": {
                    "type": "boolean",
                    "description": "Defines whether the policy was set up by the system.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                }
            },
            "required": [
                "arn",
                "attachmentCount",
                "createdAt",
                "defaultVersionId",
                "document",
                "name",
                "serviceUuid",
                "system",
                "updatedAt"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the policy.\n"
                },
                "document": {
                    "type": "string",
                    "description": "Policy document, URL-encoded compliant with RFC 3986. Extra whitespace and escapes are ignored when determining if the\ndocument has changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Policy name.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                }
            },
            "requiredInputs": [
                "document",
                "serviceUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedObjectStoragePolicy resources.\n",
                "properties": {
                    "arn": {
                        "type": "string",
                        "description": "Policy ARN.\n"
                    },
                    "attachmentCount": {
                        "type": "integer",
                        "description": "Attachment count.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "defaultVersionId": {
                        "type": "string",
                        "description": "Default version id.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the policy.\n"
                    },
                    "document": {
                        "type": "string",
                        "description": "Policy document, URL-encoded compliant with RFC 3986. Extra whitespace and escapes are ignored when determining if the\ndocument has changed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Policy name.\n"
                    },
                    "serviceUuid": {
                        "type": "string",
                        "description": "Managed Object Storage service UUID.\n"
                    },
                    "system": {
                        "type": "boolean",
                        "description": "Defines whether the policy was set up by the system.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedObjectStorageUser:ManagedObjectStorageUser": {
            "description": "This resource represents an UpCloud Managed Object Storage user. No relation to UpCloud API accounts.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst _this = new upcloud.ManagedObjectStorage(\"this\", {\n    name: \"example\",\n    region: \"europe-1\",\n    configuredStatus: \"started\",\n});\nconst thisManagedObjectStorageUser = new upcloud.ManagedObjectStorageUser(\"this\", {\n    username: \"example\",\n    serviceUuid: _this.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nthis = upcloud.ManagedObjectStorage(\"this\",\n    name=\"example\",\n    region=\"europe-1\",\n    configured_status=\"started\")\nthis_managed_object_storage_user = upcloud.ManagedObjectStorageUser(\"this\",\n    username=\"example\",\n    service_uuid=this.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new UpCloud.ManagedObjectStorage(\"this\", new()\n    {\n        Name = \"example\",\n        Region = \"europe-1\",\n        ConfiguredStatus = \"started\",\n    });\n\n    var thisManagedObjectStorageUser = new UpCloud.ManagedObjectStorageUser(\"this\", new()\n    {\n        Username = \"example\",\n        ServiceUuid = @this.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := upcloud.NewManagedObjectStorage(ctx, \"this\", \u0026upcloud.ManagedObjectStorageArgs{\n\t\t\tName:             pulumi.String(\"example\"),\n\t\t\tRegion:           pulumi.String(\"europe-1\"),\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedObjectStorageUser(ctx, \"this\", \u0026upcloud.ManagedObjectStorageUserArgs{\n\t\t\tUsername:    pulumi.String(\"example\"),\n\t\t\tServiceUuid: this.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedObjectStorage;\nimport com.pulumi.upcloud.ManagedObjectStorageArgs;\nimport com.pulumi.upcloud.ManagedObjectStorageUser;\nimport com.pulumi.upcloud.ManagedObjectStorageUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new ManagedObjectStorage(\"this\", ManagedObjectStorageArgs.builder()\n            .name(\"example\")\n            .region(\"europe-1\")\n            .configuredStatus(\"started\")\n            .build());\n\n        var thisManagedObjectStorageUser = new ManagedObjectStorageUser(\"thisManagedObjectStorageUser\", ManagedObjectStorageUserArgs.builder()\n            .username(\"example\")\n            .serviceUuid(this_.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: upcloud:ManagedObjectStorage\n    properties:\n      name: example\n      region: europe-1\n      configuredStatus: started\n  thisManagedObjectStorageUser:\n    type: upcloud:ManagedObjectStorageUser\n    name: this\n    properties:\n      username: example\n      serviceUuid: ${this.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "User ARN.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Custom usernames for accessing the object storage. No relation to UpCloud API accounts. See\n`upcloud.ManagedObjectStorageUserAccessKey` for managing access keys and `upcloud.ManagedObjectStorageUserPolicy` for\nmanaging policies.\n"
                }
            },
            "required": [
                "arn",
                "createdAt",
                "serviceUuid",
                "username"
            ],
            "inputProperties": {
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Custom usernames for accessing the object storage. No relation to UpCloud API accounts. See\n`upcloud.ManagedObjectStorageUserAccessKey` for managing access keys and `upcloud.ManagedObjectStorageUserPolicy` for\nmanaging policies.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "serviceUuid",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedObjectStorageUser resources.\n",
                "properties": {
                    "arn": {
                        "type": "string",
                        "description": "User ARN.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "serviceUuid": {
                        "type": "string",
                        "description": "Managed Object Storage service UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Custom usernames for accessing the object storage. No relation to UpCloud API accounts. See\n`upcloud.ManagedObjectStorageUserAccessKey` for managing access keys and `upcloud.ManagedObjectStorageUserPolicy` for\nmanaging policies.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedObjectStorageUserAccessKey:ManagedObjectStorageUserAccessKey": {
            "description": "This resource represents an UpCloud Managed Object Storage user access key.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst _this = new upcloud.ManagedObjectStorage(\"this\", {\n    name: \"example\",\n    region: \"europe-1\",\n    configuredStatus: \"started\",\n});\nconst thisManagedObjectStorageUser = new upcloud.ManagedObjectStorageUser(\"this\", {\n    username: \"example\",\n    serviceUuid: _this.id,\n});\nconst thisManagedObjectStorageUserAccessKey = new upcloud.ManagedObjectStorageUserAccessKey(\"this\", {\n    username: thisManagedObjectStorageUser.username,\n    serviceUuid: _this.id,\n    status: \"Active\",\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nthis = upcloud.ManagedObjectStorage(\"this\",\n    name=\"example\",\n    region=\"europe-1\",\n    configured_status=\"started\")\nthis_managed_object_storage_user = upcloud.ManagedObjectStorageUser(\"this\",\n    username=\"example\",\n    service_uuid=this.id)\nthis_managed_object_storage_user_access_key = upcloud.ManagedObjectStorageUserAccessKey(\"this\",\n    username=this_managed_object_storage_user.username,\n    service_uuid=this.id,\n    status=\"Active\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new UpCloud.ManagedObjectStorage(\"this\", new()\n    {\n        Name = \"example\",\n        Region = \"europe-1\",\n        ConfiguredStatus = \"started\",\n    });\n\n    var thisManagedObjectStorageUser = new UpCloud.ManagedObjectStorageUser(\"this\", new()\n    {\n        Username = \"example\",\n        ServiceUuid = @this.Id,\n    });\n\n    var thisManagedObjectStorageUserAccessKey = new UpCloud.ManagedObjectStorageUserAccessKey(\"this\", new()\n    {\n        Username = thisManagedObjectStorageUser.Username,\n        ServiceUuid = @this.Id,\n        Status = \"Active\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := upcloud.NewManagedObjectStorage(ctx, \"this\", \u0026upcloud.ManagedObjectStorageArgs{\n\t\t\tName:             pulumi.String(\"example\"),\n\t\t\tRegion:           pulumi.String(\"europe-1\"),\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisManagedObjectStorageUser, err := upcloud.NewManagedObjectStorageUser(ctx, \"this\", \u0026upcloud.ManagedObjectStorageUserArgs{\n\t\t\tUsername:    pulumi.String(\"example\"),\n\t\t\tServiceUuid: this.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedObjectStorageUserAccessKey(ctx, \"this\", \u0026upcloud.ManagedObjectStorageUserAccessKeyArgs{\n\t\t\tUsername:    thisManagedObjectStorageUser.Username,\n\t\t\tServiceUuid: this.ID(),\n\t\t\tStatus:      pulumi.String(\"Active\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedObjectStorage;\nimport com.pulumi.upcloud.ManagedObjectStorageArgs;\nimport com.pulumi.upcloud.ManagedObjectStorageUser;\nimport com.pulumi.upcloud.ManagedObjectStorageUserArgs;\nimport com.pulumi.upcloud.ManagedObjectStorageUserAccessKey;\nimport com.pulumi.upcloud.ManagedObjectStorageUserAccessKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new ManagedObjectStorage(\"this\", ManagedObjectStorageArgs.builder()\n            .name(\"example\")\n            .region(\"europe-1\")\n            .configuredStatus(\"started\")\n            .build());\n\n        var thisManagedObjectStorageUser = new ManagedObjectStorageUser(\"thisManagedObjectStorageUser\", ManagedObjectStorageUserArgs.builder()\n            .username(\"example\")\n            .serviceUuid(this_.id())\n            .build());\n\n        var thisManagedObjectStorageUserAccessKey = new ManagedObjectStorageUserAccessKey(\"thisManagedObjectStorageUserAccessKey\", ManagedObjectStorageUserAccessKeyArgs.builder()\n            .username(thisManagedObjectStorageUser.username())\n            .serviceUuid(this_.id())\n            .status(\"Active\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: upcloud:ManagedObjectStorage\n    properties:\n      name: example\n      region: europe-1\n      configuredStatus: started\n  thisManagedObjectStorageUser:\n    type: upcloud:ManagedObjectStorageUser\n    name: this\n    properties:\n      username: example\n      serviceUuid: ${this.id}\n  thisManagedObjectStorageUserAccessKey:\n    type: upcloud:ManagedObjectStorageUserAccessKey\n    name: this\n    properties:\n      username: ${thisManagedObjectStorageUser.username}\n      serviceUuid: ${this.id}\n      status: Active\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "accessKeyId": {
                    "type": "string",
                    "description": "Access key id.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation time.\n"
                },
                "lastUsedAt": {
                    "type": "string",
                    "description": "Last used.\n"
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "Secret access key.\n",
                    "secret": true
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the key. Valid values: `Active`|`Inactive`\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username.\n"
                }
            },
            "required": [
                "accessKeyId",
                "createdAt",
                "lastUsedAt",
                "secretAccessKey",
                "serviceUuid",
                "status",
                "username"
            ],
            "inputProperties": {
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n",
                    "willReplaceOnChanges": true
                },
                "status": {
                    "type": "string",
                    "description": "Status of the key. Valid values: `Active`|`Inactive`\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "serviceUuid",
                "status",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedObjectStorageUserAccessKey resources.\n",
                "properties": {
                    "accessKeyId": {
                        "type": "string",
                        "description": "Access key id.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Creation time.\n"
                    },
                    "lastUsedAt": {
                        "type": "string",
                        "description": "Last used.\n"
                    },
                    "secretAccessKey": {
                        "type": "string",
                        "description": "Secret access key.\n",
                        "secret": true
                    },
                    "serviceUuid": {
                        "type": "string",
                        "description": "Managed Object Storage service UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the key. Valid values: `Active`|`Inactive`\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/managedObjectStorageUserPolicy:ManagedObjectStorageUserPolicy": {
            "description": "This resource represents an UpCloud Managed Object Storage user policy attachment.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst _this = new upcloud.ManagedObjectStorage(\"this\", {\n    name: \"example\",\n    region: \"europe-1\",\n    configuredStatus: \"started\",\n});\nconst thisManagedObjectStoragePolicy = new upcloud.ManagedObjectStoragePolicy(\"this\", {\n    name: \"example\",\n    description: \"example description\",\n    document: \"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\",\n    serviceUuid: _this.id,\n});\nconst thisManagedObjectStorageUser = new upcloud.ManagedObjectStorageUser(\"this\", {\n    username: \"example\",\n    serviceUuid: _this.id,\n});\nconst thisManagedObjectStorageUserPolicy = new upcloud.ManagedObjectStorageUserPolicy(\"this\", {\n    username: thisManagedObjectStorageUser.username,\n    serviceUuid: _this.id,\n    name: thisManagedObjectStoragePolicy.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nthis = upcloud.ManagedObjectStorage(\"this\",\n    name=\"example\",\n    region=\"europe-1\",\n    configured_status=\"started\")\nthis_managed_object_storage_policy = upcloud.ManagedObjectStoragePolicy(\"this\",\n    name=\"example\",\n    description=\"example description\",\n    document=\"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\",\n    service_uuid=this.id)\nthis_managed_object_storage_user = upcloud.ManagedObjectStorageUser(\"this\",\n    username=\"example\",\n    service_uuid=this.id)\nthis_managed_object_storage_user_policy = upcloud.ManagedObjectStorageUserPolicy(\"this\",\n    username=this_managed_object_storage_user.username,\n    service_uuid=this.id,\n    name=this_managed_object_storage_policy.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new UpCloud.ManagedObjectStorage(\"this\", new()\n    {\n        Name = \"example\",\n        Region = \"europe-1\",\n        ConfiguredStatus = \"started\",\n    });\n\n    var thisManagedObjectStoragePolicy = new UpCloud.ManagedObjectStoragePolicy(\"this\", new()\n    {\n        Name = \"example\",\n        Description = \"example description\",\n        Document = \"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\",\n        ServiceUuid = @this.Id,\n    });\n\n    var thisManagedObjectStorageUser = new UpCloud.ManagedObjectStorageUser(\"this\", new()\n    {\n        Username = \"example\",\n        ServiceUuid = @this.Id,\n    });\n\n    var thisManagedObjectStorageUserPolicy = new UpCloud.ManagedObjectStorageUserPolicy(\"this\", new()\n    {\n        Username = thisManagedObjectStorageUser.Username,\n        ServiceUuid = @this.Id,\n        Name = thisManagedObjectStoragePolicy.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := upcloud.NewManagedObjectStorage(ctx, \"this\", \u0026upcloud.ManagedObjectStorageArgs{\n\t\t\tName:             pulumi.String(\"example\"),\n\t\t\tRegion:           pulumi.String(\"europe-1\"),\n\t\t\tConfiguredStatus: pulumi.String(\"started\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisManagedObjectStoragePolicy, err := upcloud.NewManagedObjectStoragePolicy(ctx, \"this\", \u0026upcloud.ManagedObjectStoragePolicyArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"example description\"),\n\t\t\tDocument:    pulumi.String(\"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\"),\n\t\t\tServiceUuid: this.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisManagedObjectStorageUser, err := upcloud.NewManagedObjectStorageUser(ctx, \"this\", \u0026upcloud.ManagedObjectStorageUserArgs{\n\t\t\tUsername:    pulumi.String(\"example\"),\n\t\t\tServiceUuid: this.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewManagedObjectStorageUserPolicy(ctx, \"this\", \u0026upcloud.ManagedObjectStorageUserPolicyArgs{\n\t\t\tUsername:    thisManagedObjectStorageUser.Username,\n\t\t\tServiceUuid: this.ID(),\n\t\t\tName:        thisManagedObjectStoragePolicy.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedObjectStorage;\nimport com.pulumi.upcloud.ManagedObjectStorageArgs;\nimport com.pulumi.upcloud.ManagedObjectStoragePolicy;\nimport com.pulumi.upcloud.ManagedObjectStoragePolicyArgs;\nimport com.pulumi.upcloud.ManagedObjectStorageUser;\nimport com.pulumi.upcloud.ManagedObjectStorageUserArgs;\nimport com.pulumi.upcloud.ManagedObjectStorageUserPolicy;\nimport com.pulumi.upcloud.ManagedObjectStorageUserPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new ManagedObjectStorage(\"this\", ManagedObjectStorageArgs.builder()\n            .name(\"example\")\n            .region(\"europe-1\")\n            .configuredStatus(\"started\")\n            .build());\n\n        var thisManagedObjectStoragePolicy = new ManagedObjectStoragePolicy(\"thisManagedObjectStoragePolicy\", ManagedObjectStoragePolicyArgs.builder()\n            .name(\"example\")\n            .description(\"example description\")\n            .document(\"%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D\")\n            .serviceUuid(this_.id())\n            .build());\n\n        var thisManagedObjectStorageUser = new ManagedObjectStorageUser(\"thisManagedObjectStorageUser\", ManagedObjectStorageUserArgs.builder()\n            .username(\"example\")\n            .serviceUuid(this_.id())\n            .build());\n\n        var thisManagedObjectStorageUserPolicy = new ManagedObjectStorageUserPolicy(\"thisManagedObjectStorageUserPolicy\", ManagedObjectStorageUserPolicyArgs.builder()\n            .username(thisManagedObjectStorageUser.username())\n            .serviceUuid(this_.id())\n            .name(thisManagedObjectStoragePolicy.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: upcloud:ManagedObjectStorage\n    properties:\n      name: example\n      region: europe-1\n      configuredStatus: started\n  thisManagedObjectStoragePolicy:\n    type: upcloud:ManagedObjectStoragePolicy\n    name: this\n    properties:\n      name: example\n      description: example description\n      document: '%7B%22Version%22%3A%20%222012-10-17%22%2C%20%20%22Statement%22%3A%20%5B%7B%22Action%22%3A%20%5B%22iam%3AGetUser%22%5D%2C%20%22Resource%22%3A%20%22%2A%22%2C%20%22Effect%22%3A%20%22Allow%22%2C%20%22Sid%22%3A%20%22editor%22%7D%5D%7D'\n      serviceUuid: ${this.id}\n  thisManagedObjectStorageUser:\n    type: upcloud:ManagedObjectStorageUser\n    name: this\n    properties:\n      username: example\n      serviceUuid: ${this.id}\n  thisManagedObjectStorageUserPolicy:\n    type: upcloud:ManagedObjectStorageUserPolicy\n    name: this\n    properties:\n      username: ${thisManagedObjectStorageUser.username}\n      serviceUuid: ${this.id}\n      name: ${thisManagedObjectStoragePolicy.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Policy name.\n"
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username.\n"
                }
            },
            "required": [
                "name",
                "serviceUuid",
                "username"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Policy name.\n",
                    "willReplaceOnChanges": true
                },
                "serviceUuid": {
                    "type": "string",
                    "description": "Managed Object Storage service UUID.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "serviceUuid",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedObjectStorageUserPolicy resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Policy name.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceUuid": {
                        "type": "string",
                        "description": "Managed Object Storage service UUID.\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Username.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/network:Network": {
            "description": "This resource represents an SDN private network that cloud servers and other resources from the same zone can be attached to.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst exampleRouter = new upcloud.Router(\"example_router\", {name: \"example_router\"});\n// SDN network with a router\nconst exampleNetwork = new upcloud.Network(\"example_network\", {\n    name: \"example_private_net\",\n    zone: \"nl-ams1\",\n    router: exampleRouter.id,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        dhcpDefaultRoute: false,\n        family: \"IPv4\",\n        gateway: \"10.0.0.1\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nexample_router = upcloud.Router(\"example_router\", name=\"example_router\")\n# SDN network with a router\nexample_network = upcloud.Network(\"example_network\",\n    name=\"example_private_net\",\n    zone=\"nl-ams1\",\n    router=example_router.id,\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"dhcp_default_route\": False,\n        \"family\": \"IPv4\",\n        \"gateway\": \"10.0.0.1\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleRouter = new UpCloud.Router(\"example_router\", new()\n    {\n        Name = \"example_router\",\n    });\n\n    // SDN network with a router\n    var exampleNetwork = new UpCloud.Network(\"example_network\", new()\n    {\n        Name = \"example_private_net\",\n        Zone = \"nl-ams1\",\n        Router = exampleRouter.Id,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            DhcpDefaultRoute = false,\n            Family = \"IPv4\",\n            Gateway = \"10.0.0.1\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleRouter, err := upcloud.NewRouter(ctx, \"example_router\", \u0026upcloud.RouterArgs{\n\t\t\tName: pulumi.String(\"example_router\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// SDN network with a router\n\t\t_, err = upcloud.NewNetwork(ctx, \"example_network\", \u0026upcloud.NetworkArgs{\n\t\t\tName:   pulumi.String(\"example_private_net\"),\n\t\t\tZone:   pulumi.String(\"nl-ams1\"),\n\t\t\tRouter: exampleRouter.ID(),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress:          pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:             pulumi.Bool(true),\n\t\t\t\tDhcpDefaultRoute: pulumi.Bool(false),\n\t\t\t\tFamily:           pulumi.String(\"IPv4\"),\n\t\t\t\tGateway:          pulumi.String(\"10.0.0.1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Router;\nimport com.pulumi.upcloud.RouterArgs;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleRouter = new Router(\"exampleRouter\", RouterArgs.builder()\n            .name(\"example_router\")\n            .build());\n\n        // SDN network with a router\n        var exampleNetwork = new Network(\"exampleNetwork\", NetworkArgs.builder()\n            .name(\"example_private_net\")\n            .zone(\"nl-ams1\")\n            .router(exampleRouter.id())\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .dhcpDefaultRoute(false)\n                .family(\"IPv4\")\n                .gateway(\"10.0.0.1\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # SDN network with a router\n  exampleNetwork:\n    type: upcloud:Network\n    name: example_network\n    properties:\n      name: example_private_net\n      zone: nl-ams1\n      router: ${exampleRouter.id}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        dhcpDefaultRoute: false\n        family: IPv4\n        gateway: 10.0.0.1\n  exampleRouter:\n    type: upcloud:Router\n    name: example_router\n    properties:\n      name: example_router\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import upcloud:index/network:Network my_example_network 03e44422-07b8-4798-a597-c8eab1fa64df\n```\n\n",
            "properties": {
                "ipNetwork": {
                    "$ref": "#/types/upcloud:index/NetworkIpNetwork:NetworkIpNetwork",
                    "description": "IP subnet within the network. Network must have exactly one IP subnet.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the network.\n"
                },
                "router": {
                    "type": "string",
                    "description": "UUID of a router to attach to this network.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The network type\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone the network is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "ipNetwork",
                "labels",
                "name",
                "type",
                "zone"
            ],
            "inputProperties": {
                "ipNetwork": {
                    "$ref": "#/types/upcloud:index/NetworkIpNetwork:NetworkIpNetwork",
                    "description": "IP subnet within the network. Network must have exactly one IP subnet.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the network.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the network.\n"
                },
                "router": {
                    "type": "string",
                    "description": "UUID of a router to attach to this network.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone the network is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "ipNetwork",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Network resources.\n",
                "properties": {
                    "ipNetwork": {
                        "$ref": "#/types/upcloud:index/NetworkIpNetwork:NetworkIpNetwork",
                        "description": "IP subnet within the network. Network must have exactly one IP subnet.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the network.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the network.\n"
                    },
                    "router": {
                        "type": "string",
                        "description": "UUID of a router to attach to this network.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The network type\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The zone the network is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/networkPeering:NetworkPeering": {
            "description": "Network peerings can be used to connect networks across accounts. For the network peering to become active, the peering must be made from both directions.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Network peering requires the networks to have routers attached to them.\nconst _this = new upcloud.Router(\"this\", {name: \"network-peering-example-router\"});\nconst example = new upcloud.Network(\"example\", {\n    name: \"network-peering-example-net\",\n    zone: \"nl-ams1\",\n    router: exampleUpcloudRouter.id,\n    ipNetwork: {\n        address: \"10.0.0.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\nconst thisNetworkPeering: upcloud.NetworkPeering[] = [];\nfor (const range = {value: 0}; range.value \u003c 1; range.value++) {\n    thisNetworkPeering.push(new upcloud.NetworkPeering(`this-${range.value}`, {\n        name: \"network-peering-example-peering\",\n        network: {\n            uuid: example.id,\n        },\n        peerNetwork: {\n            uuid: \"0305723a-e5cb-4ef6-985d-e36ed44d133a\",\n        },\n    }));\n}\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Network peering requires the networks to have routers attached to them.\nthis = upcloud.Router(\"this\", name=\"network-peering-example-router\")\nexample = upcloud.Network(\"example\",\n    name=\"network-peering-example-net\",\n    zone=\"nl-ams1\",\n    router=example_upcloud_router[\"id\"],\n    ip_network={\n        \"address\": \"10.0.0.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\nthis_network_peering = []\nfor range in [{\"value\": i} for i in range(0, 1)]:\n    this_network_peering.append(upcloud.NetworkPeering(f\"this-{range['value']}\",\n        name=\"network-peering-example-peering\",\n        network={\n            \"uuid\": example.id,\n        },\n        peer_network={\n            \"uuid\": \"0305723a-e5cb-4ef6-985d-e36ed44d133a\",\n        }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Network peering requires the networks to have routers attached to them.\n    var @this = new UpCloud.Router(\"this\", new()\n    {\n        Name = \"network-peering-example-router\",\n    });\n\n    var example = new UpCloud.Network(\"example\", new()\n    {\n        Name = \"network-peering-example-net\",\n        Zone = \"nl-ams1\",\n        Router = exampleUpcloudRouter.Id,\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"10.0.0.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    var thisNetworkPeering = new List\u003cUpCloud.NetworkPeering\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c 1; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        thisNetworkPeering.Add(new UpCloud.NetworkPeering($\"this-{range.Value}\", new()\n        {\n            Name = \"network-peering-example-peering\",\n            Network = new UpCloud.Inputs.NetworkPeeringNetworkArgs\n            {\n                Uuid = example.Id,\n            },\n            PeerNetwork = new UpCloud.Inputs.NetworkPeeringPeerNetworkArgs\n            {\n                Uuid = \"0305723a-e5cb-4ef6-985d-e36ed44d133a\",\n            },\n        }));\n    }\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Network peering requires the networks to have routers attached to them.\n\t\t_, err := upcloud.NewRouter(ctx, \"this\", \u0026upcloud.RouterArgs{\n\t\t\tName: pulumi.String(\"network-peering-example-router\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := upcloud.NewNetwork(ctx, \"example\", \u0026upcloud.NetworkArgs{\n\t\t\tName:   pulumi.String(\"network-peering-example-net\"),\n\t\t\tZone:   pulumi.String(\"nl-ams1\"),\n\t\t\tRouter: pulumi.Any(exampleUpcloudRouter.Id),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"10.0.0.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar thisNetworkPeering []*upcloud.NetworkPeering\n\t\tfor index := 0; index \u003c 1; index++ {\n\t\t\tkey0 := index\n\t\t\t_ := index\n\t\t\t__res, err := upcloud.NewNetworkPeering(ctx, fmt.Sprintf(\"this-%v\", key0), \u0026upcloud.NetworkPeeringArgs{\n\t\t\t\tName: pulumi.String(\"network-peering-example-peering\"),\n\t\t\t\tNetwork: \u0026upcloud.NetworkPeeringNetworkArgs{\n\t\t\t\t\tUuid: example.ID(),\n\t\t\t\t},\n\t\t\t\tPeerNetwork: \u0026upcloud.NetworkPeeringPeerNetworkArgs{\n\t\t\t\t\tUuid: pulumi.String(\"0305723a-e5cb-4ef6-985d-e36ed44d133a\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tthisNetworkPeering = append(thisNetworkPeering, __res)\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Router;\nimport com.pulumi.upcloud.RouterArgs;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.NetworkPeering;\nimport com.pulumi.upcloud.NetworkPeeringArgs;\nimport com.pulumi.upcloud.inputs.NetworkPeeringNetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkPeeringPeerNetworkArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Network peering requires the networks to have routers attached to them.\n        var this_ = new Router(\"this\", RouterArgs.builder()\n            .name(\"network-peering-example-router\")\n            .build());\n\n        var example = new Network(\"example\", NetworkArgs.builder()\n            .name(\"network-peering-example-net\")\n            .zone(\"nl-ams1\")\n            .router(exampleUpcloudRouter.id())\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"10.0.0.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        for (var i = 0; i \u003c 1; i++) {\n            new NetworkPeering(\"thisNetworkPeering-\" + i, NetworkPeeringArgs.builder()\n                .name(\"network-peering-example-peering\")\n                .network(NetworkPeeringNetworkArgs.builder()\n                    .uuid(example.id())\n                    .build())\n                .peerNetwork(NetworkPeeringPeerNetworkArgs.builder()\n                    .uuid(\"0305723a-e5cb-4ef6-985d-e36ed44d133a\")\n                    .build())\n                .build());\n\n        \n}\n    }\n}\n```\n```yaml\nresources:\n  # Network peering requires the networks to have routers attached to them.\n  this:\n    type: upcloud:Router\n    properties:\n      name: network-peering-example-router\n  example:\n    type: upcloud:Network\n    properties:\n      name: network-peering-example-net\n      zone: nl-ams1\n      router: ${exampleUpcloudRouter.id}\n      ipNetwork:\n        address: 10.0.0.0/24\n        dhcp: true\n        family: IPv4\n  thisNetworkPeering:\n    type: upcloud:NetworkPeering\n    name: this\n    properties:\n      name: network-peering-example-peering\n      network:\n        uuid: ${example.id}\n      peerNetwork:\n        uuid: 0305723a-e5cb-4ef6-985d-e36ed44d133a\n    options: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "configuredStatus": {
                    "type": "string",
                    "description": "Configured status of the network peering.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the network peering.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the network peering.\n"
                },
                "network": {
                    "$ref": "#/types/upcloud:index/NetworkPeeringNetwork:NetworkPeeringNetwork",
                    "description": "Local network of the network peering.\n"
                },
                "peerNetwork": {
                    "$ref": "#/types/upcloud:index/NetworkPeeringPeerNetwork:NetworkPeeringPeerNetwork",
                    "description": "Peer network of the network peering.\n"
                }
            },
            "required": [
                "configuredStatus",
                "labels",
                "name",
                "network",
                "peerNetwork"
            ],
            "inputProperties": {
                "configuredStatus": {
                    "type": "string",
                    "description": "Configured status of the network peering.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the network peering.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the network peering.\n"
                },
                "network": {
                    "$ref": "#/types/upcloud:index/NetworkPeeringNetwork:NetworkPeeringNetwork",
                    "description": "Local network of the network peering.\n"
                },
                "peerNetwork": {
                    "$ref": "#/types/upcloud:index/NetworkPeeringPeerNetwork:NetworkPeeringPeerNetwork",
                    "description": "Peer network of the network peering.\n"
                }
            },
            "requiredInputs": [
                "network",
                "peerNetwork"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkPeering resources.\n",
                "properties": {
                    "configuredStatus": {
                        "type": "string",
                        "description": "Configured status of the network peering.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the network peering.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the network peering.\n"
                    },
                    "network": {
                        "$ref": "#/types/upcloud:index/NetworkPeeringNetwork:NetworkPeeringNetwork",
                        "description": "Local network of the network peering.\n"
                    },
                    "peerNetwork": {
                        "$ref": "#/types/upcloud:index/NetworkPeeringPeerNetwork:NetworkPeeringPeerNetwork",
                        "description": "Peer network of the network peering.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/objectStorage:ObjectStorage": {
            "description": "\u003e The `upcloud.ObjectStorage` resource manages previous generatation object storage instances that will reach end of life (EOL) by the end of 2024. For new instances, consider using the new Object Storage product managed with `upcloud.ManagedObjectStorage` resource.\n\nThis resource represents an UpCloud Object Storage instance, which provides S3 compatible storage.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Object storage instance called storage-name in the fi-hel2 zone, with 2 buckets called \"products\" and \"images\".\nconst myObjectStorage = new upcloud.ObjectStorage(\"my_object_storage\", {\n    size: 250,\n    name: \"storage-name\",\n    zone: \"fi-hel2\",\n    accessKey: \"admin\",\n    secretKey: \"changeme\",\n    description: \"catalogue\",\n    buckets: [\n        {\n            name: \"products\",\n        },\n        {\n            name: \"images\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Object storage instance called storage-name in the fi-hel2 zone, with 2 buckets called \"products\" and \"images\".\nmy_object_storage = upcloud.ObjectStorage(\"my_object_storage\",\n    size=250,\n    name=\"storage-name\",\n    zone=\"fi-hel2\",\n    access_key=\"admin\",\n    secret_key=\"changeme\",\n    description=\"catalogue\",\n    buckets=[\n        {\n            \"name\": \"products\",\n        },\n        {\n            \"name\": \"images\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Object storage instance called storage-name in the fi-hel2 zone, with 2 buckets called \"products\" and \"images\".\n    var myObjectStorage = new UpCloud.ObjectStorage(\"my_object_storage\", new()\n    {\n        Size = 250,\n        Name = \"storage-name\",\n        Zone = \"fi-hel2\",\n        AccessKey = \"admin\",\n        SecretKey = \"changeme\",\n        Description = \"catalogue\",\n        Buckets = new[]\n        {\n            new UpCloud.Inputs.ObjectStorageBucketArgs\n            {\n                Name = \"products\",\n            },\n            new UpCloud.Inputs.ObjectStorageBucketArgs\n            {\n                Name = \"images\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Object storage instance called storage-name in the fi-hel2 zone, with 2 buckets called \"products\" and \"images\".\n\t\t_, err := upcloud.NewObjectStorage(ctx, \"my_object_storage\", \u0026upcloud.ObjectStorageArgs{\n\t\t\tSize:        pulumi.Int(250),\n\t\t\tName:        pulumi.String(\"storage-name\"),\n\t\t\tZone:        pulumi.String(\"fi-hel2\"),\n\t\t\tAccessKey:   pulumi.String(\"admin\"),\n\t\t\tSecretKey:   pulumi.String(\"changeme\"),\n\t\t\tDescription: pulumi.String(\"catalogue\"),\n\t\t\tBuckets: upcloud.ObjectStorageBucketArray{\n\t\t\t\t\u0026upcloud.ObjectStorageBucketArgs{\n\t\t\t\t\tName: pulumi.String(\"products\"),\n\t\t\t\t},\n\t\t\t\t\u0026upcloud.ObjectStorageBucketArgs{\n\t\t\t\t\tName: pulumi.String(\"images\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ObjectStorage;\nimport com.pulumi.upcloud.ObjectStorageArgs;\nimport com.pulumi.upcloud.inputs.ObjectStorageBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Object storage instance called storage-name in the fi-hel2 zone, with 2 buckets called \"products\" and \"images\".\n        var myObjectStorage = new ObjectStorage(\"myObjectStorage\", ObjectStorageArgs.builder()\n            .size(250)\n            .name(\"storage-name\")\n            .zone(\"fi-hel2\")\n            .accessKey(\"admin\")\n            .secretKey(\"changeme\")\n            .description(\"catalogue\")\n            .buckets(            \n                ObjectStorageBucketArgs.builder()\n                    .name(\"products\")\n                    .build(),\n                ObjectStorageBucketArgs.builder()\n                    .name(\"images\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Object storage instance called storage-name in the fi-hel2 zone, with 2 buckets called \"products\" and \"images\".\n  myObjectStorage:\n    type: upcloud:ObjectStorage\n    name: my_object_storage\n    properties:\n      size: 250 # allocate up to 250GB of storage\n      name: storage-name\n      zone: fi-hel2\n      accessKey: admin\n      secretKey: changeme\n      description: catalogue\n      buckets:\n        - name: products\n        - name: images\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nFor object storage import to work properly, you need to set environment variables for access and secret key.\n\nThe environment variables names are UPCLOUD_OBJECT_STORAGE_ACCESS_KEY_{name} and UPCLOUD_OBJECT_STORAGE_SECRET_KEY_{name}\n\nwhere {name} is the name of your object storage instance (not the resource label!), all uppercased, and with all dashes (-)\n\nreplaced with underscores (_). So importing an object storage that is named \"my-storage\" will look like this:\n\nUPCLOUD_OBJECT_STORAGE_ACCESS_KEY_MY_STORAGE=accesskey \\\n\nUPCLOUD_OBJECT_STORAGE_SECRET_KEY_MY_STORAGE=supersecret \\\n\n```sh\n$ pulumi import upcloud:index/objectStorage:ObjectStorage example_storage 06c1f4b6-faf2-47d0-8896-1d941092b009\n```\n\n",
            "properties": {
                "accessKey": {
                    "type": "string",
                    "description": "The access key used to identify user. Can be set to an empty string, which will tell the provider to get the access key\nfrom environment variable. The environment variable should be \"UPCLOUD_OBJECT_STORAGE_ACCESS_KEY_{name}\". {name} is the\nname given to object storage instance (so not the resource label), it should be all uppercased and all dashes (-) should\nbe replaced with underscores (_). For example, object storage named \"my-files\" would use environment variable named\n\"UPCLOUD_OBJECT_STORAGE_ACCESS_KEY_MY_FILES\".\n"
                },
                "buckets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ObjectStorageBucket:ObjectStorageBucket"
                    }
                },
                "created": {
                    "type": "string"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the object storage instance to be created\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the object storage instance to be created\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The secret key used to authenticate user. Can be set to an empty string, which will tell the provider to get the secret\nkey from environment variable. The environment variable should be \"UPCLOUD_OBJECT_STORAGE_SECRET_KEY_{name}\". {name} is\nthe name given to object storage instance (so not the resource label), it should be all uppercased and all dashes (-)\nshould be replaced with underscores (_). For example, object storage named \"my-files\" would use environment variable\nnamed \"UPCLOUD_OBJECT_STORAGE_SECRET_KEY_MY_FILES\".\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the object storage instance in gigabytes\n"
                },
                "state": {
                    "type": "string"
                },
                "url": {
                    "type": "string"
                },
                "usedSpace": {
                    "type": "integer"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone in which the object storage instance will be created, e.g. `de-fra1`. You can list available zones with `upctl\nzone list`.\n"
                }
            },
            "required": [
                "accessKey",
                "created",
                "description",
                "name",
                "secretKey",
                "size",
                "state",
                "url",
                "usedSpace",
                "zone"
            ],
            "inputProperties": {
                "accessKey": {
                    "type": "string",
                    "description": "The access key used to identify user. Can be set to an empty string, which will tell the provider to get the access key\nfrom environment variable. The environment variable should be \"UPCLOUD_OBJECT_STORAGE_ACCESS_KEY_{name}\". {name} is the\nname given to object storage instance (so not the resource label), it should be all uppercased and all dashes (-) should\nbe replaced with underscores (_). For example, object storage named \"my-files\" would use environment variable named\n\"UPCLOUD_OBJECT_STORAGE_ACCESS_KEY_MY_FILES\".\n"
                },
                "buckets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ObjectStorageBucket:ObjectStorageBucket"
                    }
                },
                "description": {
                    "type": "string",
                    "description": "The description of the object storage instance to be created\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the object storage instance to be created\n"
                },
                "secretKey": {
                    "type": "string",
                    "description": "The secret key used to authenticate user. Can be set to an empty string, which will tell the provider to get the secret\nkey from environment variable. The environment variable should be \"UPCLOUD_OBJECT_STORAGE_SECRET_KEY_{name}\". {name} is\nthe name given to object storage instance (so not the resource label), it should be all uppercased and all dashes (-)\nshould be replaced with underscores (_). For example, object storage named \"my-files\" would use environment variable\nnamed \"UPCLOUD_OBJECT_STORAGE_SECRET_KEY_MY_FILES\".\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the object storage instance in gigabytes\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone in which the object storage instance will be created, e.g. `de-fra1`. You can list available zones with `upctl\nzone list`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accessKey",
                "description",
                "secretKey",
                "size",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ObjectStorage resources.\n",
                "properties": {
                    "accessKey": {
                        "type": "string",
                        "description": "The access key used to identify user. Can be set to an empty string, which will tell the provider to get the access key\nfrom environment variable. The environment variable should be \"UPCLOUD_OBJECT_STORAGE_ACCESS_KEY_{name}\". {name} is the\nname given to object storage instance (so not the resource label), it should be all uppercased and all dashes (-) should\nbe replaced with underscores (_). For example, object storage named \"my-files\" would use environment variable named\n\"UPCLOUD_OBJECT_STORAGE_ACCESS_KEY_MY_FILES\".\n"
                    },
                    "buckets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ObjectStorageBucket:ObjectStorageBucket"
                        }
                    },
                    "created": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the object storage instance to be created\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the object storage instance to be created\n"
                    },
                    "secretKey": {
                        "type": "string",
                        "description": "The secret key used to authenticate user. Can be set to an empty string, which will tell the provider to get the secret\nkey from environment variable. The environment variable should be \"UPCLOUD_OBJECT_STORAGE_SECRET_KEY_{name}\". {name} is\nthe name given to object storage instance (so not the resource label), it should be all uppercased and all dashes (-)\nshould be replaced with underscores (_). For example, object storage named \"my-files\" would use environment variable\nnamed \"UPCLOUD_OBJECT_STORAGE_SECRET_KEY_MY_FILES\".\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the object storage instance in gigabytes\n"
                    },
                    "state": {
                        "type": "string"
                    },
                    "url": {
                        "type": "string"
                    },
                    "usedSpace": {
                        "type": "integer"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The zone in which the object storage instance will be created, e.g. `de-fra1`. You can list available zones with `upctl\nzone list`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/router:Router": {
            "description": "Routers can be used to connect multiple Private Networks. UpCloud Servers on any attached network can communicate directly with each other.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst myExampleRouter = new upcloud.Router(\"my_example_router\", {name: \"My Example Router\"});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nmy_example_router = upcloud.Router(\"my_example_router\", name=\"My Example Router\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myExampleRouter = new UpCloud.Router(\"my_example_router\", new()\n    {\n        Name = \"My Example Router\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upcloud.NewRouter(ctx, \"my_example_router\", \u0026upcloud.RouterArgs{\n\t\t\tName: pulumi.String(\"My Example Router\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Router;\nimport com.pulumi.upcloud.RouterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myExampleRouter = new Router(\"myExampleRouter\", RouterArgs.builder()\n            .name(\"My Example Router\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myExampleRouter:\n    type: upcloud:Router\n    name: my_example_router\n    properties:\n      name: My Example Router\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import upcloud:index/router:Router my_example_router 049d7ca2-757e-4fb1-a833-f87ee056547a\n```\n\n",
            "properties": {
                "attachedNetworks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of UUIDs representing networks attached to this router.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the router.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the router.\n"
                },
                "staticRoute": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/RouterStaticRoute:RouterStaticRoute"
                    },
                    "description": "A collection of user managed static routes for this router.\n"
                },
                "staticRoutes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/RouterStaticRoute:RouterStaticRoute"
                    },
                    "description": "A collection of static routes for this router. This set includes both user and service defined static routes. The\nobjects in this set use the same schema as `static_route` blocks.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the router\n"
                }
            },
            "required": [
                "attachedNetworks",
                "labels",
                "name",
                "staticRoutes",
                "type"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the router.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the router.\n"
                },
                "staticRoute": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/RouterStaticRoute:RouterStaticRoute"
                    },
                    "description": "A collection of user managed static routes for this router.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Router resources.\n",
                "properties": {
                    "attachedNetworks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of UUIDs representing networks attached to this router.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the router.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the router.\n"
                    },
                    "staticRoute": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/RouterStaticRoute:RouterStaticRoute"
                        },
                        "description": "A collection of user managed static routes for this router.\n"
                    },
                    "staticRoutes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/RouterStaticRoute:RouterStaticRoute"
                        },
                        "description": "A collection of static routes for this router. This set includes both user and service defined static routes. The\nobjects in this set use the same schema as `static_route` blocks.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the router\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/server:Server": {
            "description": "The UpCloud server resource allows the creation, update and deletion of a [cloud server](https://upcloud.com/products/cloud-servers).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  example:\n    type: upcloud:Server\n    properties:\n      hostname: terraform.example.tld\n      zone: de-fra1\n      plan: 1xCPU-1GB\n      template:\n        storage: Ubuntu Server 20.04 LTS (Focal Fossa)\n        size: 25\n        backupRules:\n          - interval: daily\n            time: '0100'\n            retention: 8\n      networkInterfaces:\n        - type: public\n      labels:\n        env: dev\n        production: 'false'\n      login:\n        user: myusername\n        keys:\n          - \u003cYOUR SSH PUBLIC KEY\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import upcloud:index/server:Server example_server ead4544f-10bf-42a3-b98a-a0fea2e2ad14\n```\n\n",
            "properties": {
                "bootOrder": {
                    "type": "string",
                    "description": "The boot device order, `cdrom`|`disk`|`network` or comma separated combination of those values. Defaults to `disk`\n"
                },
                "cpu": {
                    "type": "integer",
                    "description": "The number of CPU cores for the server\n"
                },
                "firewall": {
                    "type": "boolean",
                    "description": "Are firewall rules active for the server\n"
                },
                "host": {
                    "type": "integer",
                    "description": "Use this to start the VM on a specific host. Refers to value from host -attribute. Only available for private cloud\nhosts\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname of the server.\n"
                },
                "hotResize": {
                    "type": "boolean",
                    "description": "If set to true, allows changing the server plan without requiring a reboot. This enables hot resizing of the server. If\nhot resizing fails, the apply operation will fail.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the server.\n"
                },
                "login": {
                    "$ref": "#/types/upcloud:index/ServerLogin:ServerLogin",
                    "description": "Configure access credentials to the server\n"
                },
                "mem": {
                    "type": "integer",
                    "description": "The amount of memory for the server (in megabytes)\n"
                },
                "metadata": {
                    "type": "boolean",
                    "description": "Is metadata service active for the server\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ServerNetworkInterface:ServerNetworkInterface"
                    },
                    "description": "One or more blocks describing the network interfaces of the server. In addition to list order, the configured network\ninterfaces are matched to the server's actual network interfaces by `index` and `ip_address` fields. This is to avoid\npublic and utility network interfaces being re-assigned when the server is updated. This might result to inaccurate\ndiffs in the plan, when interfaces are re-ordered or when interface is removed from the middle of the list. We recommend\nexplicitly setting the value for `index` in configuration, when re-ordering interfaces or when removing interface from\nmiddle of the list.\n"
                },
                "nicModel": {
                    "type": "string",
                    "description": "The model of the server's network interfaces\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The pricing plan used for the server. You can list available server plans with `upctl server plans`\n"
                },
                "serverGroup": {
                    "type": "string",
                    "description": "The UUID of a server group to attach this server to. Note that the server can also be attached to a server group via the\n`members` property of `upcloud.ServerGroup`. Only one of the these should be defined at a time. This value is only\nupdated if it has been set to non-zero value.\n"
                },
                "simpleBackup": {
                    "$ref": "#/types/upcloud:index/ServerSimpleBackup:ServerSimpleBackup"
                },
                "storageDevices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ServerStorageDevice:ServerStorageDevice"
                    },
                    "description": "A set of storage devices associated with the server\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The server related tags\n"
                },
                "template": {
                    "$ref": "#/types/upcloud:index/ServerTemplate:ServerTemplate",
                    "description": "Block describing the preconfigured operating system\n"
                },
                "timezone": {
                    "type": "string",
                    "description": "The timezone of the server. The timezone must be a valid timezone string, e.g. `Europe/Helsinki`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "A short, informational description of the server.\n"
                },
                "userData": {
                    "type": "string",
                    "description": "Defines URL for a server setup script, or the script body itself\n"
                },
                "videoModel": {
                    "type": "string",
                    "description": "The model of the server's video interface\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone in which the server will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "bootOrder",
                "cpu",
                "firewall",
                "host",
                "hostname",
                "hotResize",
                "labels",
                "mem",
                "nicModel",
                "plan",
                "tags",
                "timezone",
                "title",
                "videoModel",
                "zone"
            ],
            "inputProperties": {
                "bootOrder": {
                    "type": "string",
                    "description": "The boot device order, `cdrom`|`disk`|`network` or comma separated combination of those values. Defaults to `disk`\n"
                },
                "cpu": {
                    "type": "integer",
                    "description": "The number of CPU cores for the server\n"
                },
                "firewall": {
                    "type": "boolean",
                    "description": "Are firewall rules active for the server\n"
                },
                "host": {
                    "type": "integer",
                    "description": "Use this to start the VM on a specific host. Refers to value from host -attribute. Only available for private cloud\nhosts\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname of the server.\n"
                },
                "hotResize": {
                    "type": "boolean",
                    "description": "If set to true, allows changing the server plan without requiring a reboot. This enables hot resizing of the server. If\nhot resizing fails, the apply operation will fail.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the server.\n"
                },
                "login": {
                    "$ref": "#/types/upcloud:index/ServerLogin:ServerLogin",
                    "description": "Configure access credentials to the server\n"
                },
                "mem": {
                    "type": "integer",
                    "description": "The amount of memory for the server (in megabytes)\n"
                },
                "metadata": {
                    "type": "boolean",
                    "description": "Is metadata service active for the server\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ServerNetworkInterface:ServerNetworkInterface"
                    },
                    "description": "One or more blocks describing the network interfaces of the server. In addition to list order, the configured network\ninterfaces are matched to the server's actual network interfaces by `index` and `ip_address` fields. This is to avoid\npublic and utility network interfaces being re-assigned when the server is updated. This might result to inaccurate\ndiffs in the plan, when interfaces are re-ordered or when interface is removed from the middle of the list. We recommend\nexplicitly setting the value for `index` in configuration, when re-ordering interfaces or when removing interface from\nmiddle of the list.\n"
                },
                "nicModel": {
                    "type": "string",
                    "description": "The model of the server's network interfaces\n"
                },
                "plan": {
                    "type": "string",
                    "description": "The pricing plan used for the server. You can list available server plans with `upctl server plans`\n"
                },
                "serverGroup": {
                    "type": "string",
                    "description": "The UUID of a server group to attach this server to. Note that the server can also be attached to a server group via the\n`members` property of `upcloud.ServerGroup`. Only one of the these should be defined at a time. This value is only\nupdated if it has been set to non-zero value.\n"
                },
                "simpleBackup": {
                    "$ref": "#/types/upcloud:index/ServerSimpleBackup:ServerSimpleBackup"
                },
                "storageDevices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ServerStorageDevice:ServerStorageDevice"
                    },
                    "description": "A set of storage devices associated with the server\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The server related tags\n"
                },
                "template": {
                    "$ref": "#/types/upcloud:index/ServerTemplate:ServerTemplate",
                    "description": "Block describing the preconfigured operating system\n"
                },
                "timezone": {
                    "type": "string",
                    "description": "The timezone of the server. The timezone must be a valid timezone string, e.g. `Europe/Helsinki`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "A short, informational description of the server.\n"
                },
                "userData": {
                    "type": "string",
                    "description": "Defines URL for a server setup script, or the script body itself\n"
                },
                "videoModel": {
                    "type": "string",
                    "description": "The model of the server's video interface\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone in which the server will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "hostname",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Server resources.\n",
                "properties": {
                    "bootOrder": {
                        "type": "string",
                        "description": "The boot device order, `cdrom`|`disk`|`network` or comma separated combination of those values. Defaults to `disk`\n"
                    },
                    "cpu": {
                        "type": "integer",
                        "description": "The number of CPU cores for the server\n"
                    },
                    "firewall": {
                        "type": "boolean",
                        "description": "Are firewall rules active for the server\n"
                    },
                    "host": {
                        "type": "integer",
                        "description": "Use this to start the VM on a specific host. Refers to value from host -attribute. Only available for private cloud\nhosts\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The hostname of the server.\n"
                    },
                    "hotResize": {
                        "type": "boolean",
                        "description": "If set to true, allows changing the server plan without requiring a reboot. This enables hot resizing of the server. If\nhot resizing fails, the apply operation will fail.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the server.\n"
                    },
                    "login": {
                        "$ref": "#/types/upcloud:index/ServerLogin:ServerLogin",
                        "description": "Configure access credentials to the server\n"
                    },
                    "mem": {
                        "type": "integer",
                        "description": "The amount of memory for the server (in megabytes)\n"
                    },
                    "metadata": {
                        "type": "boolean",
                        "description": "Is metadata service active for the server\n"
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ServerNetworkInterface:ServerNetworkInterface"
                        },
                        "description": "One or more blocks describing the network interfaces of the server. In addition to list order, the configured network\ninterfaces are matched to the server's actual network interfaces by `index` and `ip_address` fields. This is to avoid\npublic and utility network interfaces being re-assigned when the server is updated. This might result to inaccurate\ndiffs in the plan, when interfaces are re-ordered or when interface is removed from the middle of the list. We recommend\nexplicitly setting the value for `index` in configuration, when re-ordering interfaces or when removing interface from\nmiddle of the list.\n"
                    },
                    "nicModel": {
                        "type": "string",
                        "description": "The model of the server's network interfaces\n"
                    },
                    "plan": {
                        "type": "string",
                        "description": "The pricing plan used for the server. You can list available server plans with `upctl server plans`\n"
                    },
                    "serverGroup": {
                        "type": "string",
                        "description": "The UUID of a server group to attach this server to. Note that the server can also be attached to a server group via the\n`members` property of `upcloud.ServerGroup`. Only one of the these should be defined at a time. This value is only\nupdated if it has been set to non-zero value.\n"
                    },
                    "simpleBackup": {
                        "$ref": "#/types/upcloud:index/ServerSimpleBackup:ServerSimpleBackup"
                    },
                    "storageDevices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ServerStorageDevice:ServerStorageDevice"
                        },
                        "description": "A set of storage devices associated with the server\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The server related tags\n"
                    },
                    "template": {
                        "$ref": "#/types/upcloud:index/ServerTemplate:ServerTemplate",
                        "description": "Block describing the preconfigured operating system\n"
                    },
                    "timezone": {
                        "type": "string",
                        "description": "The timezone of the server. The timezone must be a valid timezone string, e.g. `Europe/Helsinki`.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "A short, informational description of the server.\n"
                    },
                    "userData": {
                        "type": "string",
                        "description": "Defines URL for a server setup script, or the script body itself\n"
                    },
                    "videoModel": {
                        "type": "string",
                        "description": "The model of the server's video interface\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The zone in which the server will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/serverFirewallRules:ServerFirewallRules": {
            "description": "Firewall rules are used to control network access of UpCloud servers. Each server has its own firewall rules and there should be only one `upcloud.ServerFirewallRules` resource per server.\nThe firewall is enabled on public and utility network interfaces.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// The following example defines a server and then links the server to a single firewall rule. \n// The list of firewall rules applied to the server can be expanded by providing additional server_firewall_rules blocks.\nconst example = new upcloud.Server(\"example\", {\n    firewall: true,\n    hostname: \"terraform.example.tld\",\n    zone: \"de-fra1\",\n    plan: \"1xCPU-1GB\",\n    template: {\n        storage: \"Ubuntu Server 20.04 LTS (Focal Fossa)\",\n        size: 25,\n    },\n    networkInterfaces: [{\n        type: \"utility\",\n    }],\n});\nconst exampleServerFirewallRules = new upcloud.ServerFirewallRules(\"example\", {\n    serverId: example.id,\n    firewallRules: [{\n        action: \"accept\",\n        comment: \"Allow SSH from this network\",\n        destinationPortEnd: \"22\",\n        destinationPortStart: \"22\",\n        direction: \"in\",\n        family: \"IPv4\",\n        protocol: \"tcp\",\n        sourceAddressEnd: \"192.168.1.255\",\n        sourceAddressStart: \"192.168.1.1\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# The following example defines a server and then links the server to a single firewall rule. \n# The list of firewall rules applied to the server can be expanded by providing additional server_firewall_rules blocks.\nexample = upcloud.Server(\"example\",\n    firewall=True,\n    hostname=\"terraform.example.tld\",\n    zone=\"de-fra1\",\n    plan=\"1xCPU-1GB\",\n    template={\n        \"storage\": \"Ubuntu Server 20.04 LTS (Focal Fossa)\",\n        \"size\": 25,\n    },\n    network_interfaces=[{\n        \"type\": \"utility\",\n    }])\nexample_server_firewall_rules = upcloud.ServerFirewallRules(\"example\",\n    server_id=example.id,\n    firewall_rules=[{\n        \"action\": \"accept\",\n        \"comment\": \"Allow SSH from this network\",\n        \"destination_port_end\": \"22\",\n        \"destination_port_start\": \"22\",\n        \"direction\": \"in\",\n        \"family\": \"IPv4\",\n        \"protocol\": \"tcp\",\n        \"source_address_end\": \"192.168.1.255\",\n        \"source_address_start\": \"192.168.1.1\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // The following example defines a server and then links the server to a single firewall rule. \n    // The list of firewall rules applied to the server can be expanded by providing additional server_firewall_rules blocks.\n    var example = new UpCloud.Server(\"example\", new()\n    {\n        Firewall = true,\n        Hostname = \"terraform.example.tld\",\n        Zone = \"de-fra1\",\n        Plan = \"1xCPU-1GB\",\n        Template = new UpCloud.Inputs.ServerTemplateArgs\n        {\n            Storage = \"Ubuntu Server 20.04 LTS (Focal Fossa)\",\n            Size = 25,\n        },\n        NetworkInterfaces = new[]\n        {\n            new UpCloud.Inputs.ServerNetworkInterfaceArgs\n            {\n                Type = \"utility\",\n            },\n        },\n    });\n\n    var exampleServerFirewallRules = new UpCloud.ServerFirewallRules(\"example\", new()\n    {\n        ServerId = example.Id,\n        FirewallRules = new[]\n        {\n            new UpCloud.Inputs.ServerFirewallRulesFirewallRuleArgs\n            {\n                Action = \"accept\",\n                Comment = \"Allow SSH from this network\",\n                DestinationPortEnd = \"22\",\n                DestinationPortStart = \"22\",\n                Direction = \"in\",\n                Family = \"IPv4\",\n                Protocol = \"tcp\",\n                SourceAddressEnd = \"192.168.1.255\",\n                SourceAddressStart = \"192.168.1.1\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// The following example defines a server and then links the server to a single firewall rule.\n\t\t// The list of firewall rules applied to the server can be expanded by providing additional server_firewall_rules blocks.\n\t\texample, err := upcloud.NewServer(ctx, \"example\", \u0026upcloud.ServerArgs{\n\t\t\tFirewall: pulumi.Bool(true),\n\t\t\tHostname: pulumi.String(\"terraform.example.tld\"),\n\t\t\tZone:     pulumi.String(\"de-fra1\"),\n\t\t\tPlan:     pulumi.String(\"1xCPU-1GB\"),\n\t\t\tTemplate: \u0026upcloud.ServerTemplateArgs{\n\t\t\t\tStorage: pulumi.String(\"Ubuntu Server 20.04 LTS (Focal Fossa)\"),\n\t\t\t\tSize:    pulumi.Int(25),\n\t\t\t},\n\t\t\tNetworkInterfaces: upcloud.ServerNetworkInterfaceArray{\n\t\t\t\t\u0026upcloud.ServerNetworkInterfaceArgs{\n\t\t\t\t\tType: pulumi.String(\"utility\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewServerFirewallRules(ctx, \"example\", \u0026upcloud.ServerFirewallRulesArgs{\n\t\t\tServerId: example.ID(),\n\t\t\tFirewallRules: upcloud.ServerFirewallRulesFirewallRuleArray{\n\t\t\t\t\u0026upcloud.ServerFirewallRulesFirewallRuleArgs{\n\t\t\t\t\tAction:               pulumi.String(\"accept\"),\n\t\t\t\t\tComment:              pulumi.String(\"Allow SSH from this network\"),\n\t\t\t\t\tDestinationPortEnd:   pulumi.String(\"22\"),\n\t\t\t\t\tDestinationPortStart: pulumi.String(\"22\"),\n\t\t\t\t\tDirection:            pulumi.String(\"in\"),\n\t\t\t\t\tFamily:               pulumi.String(\"IPv4\"),\n\t\t\t\t\tProtocol:             pulumi.String(\"tcp\"),\n\t\t\t\t\tSourceAddressEnd:     pulumi.String(\"192.168.1.255\"),\n\t\t\t\t\tSourceAddressStart:   pulumi.String(\"192.168.1.1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Server;\nimport com.pulumi.upcloud.ServerArgs;\nimport com.pulumi.upcloud.inputs.ServerTemplateArgs;\nimport com.pulumi.upcloud.inputs.ServerNetworkInterfaceArgs;\nimport com.pulumi.upcloud.ServerFirewallRules;\nimport com.pulumi.upcloud.ServerFirewallRulesArgs;\nimport com.pulumi.upcloud.inputs.ServerFirewallRulesFirewallRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // The following example defines a server and then links the server to a single firewall rule. \n        // The list of firewall rules applied to the server can be expanded by providing additional server_firewall_rules blocks.\n        var example = new Server(\"example\", ServerArgs.builder()\n            .firewall(true)\n            .hostname(\"terraform.example.tld\")\n            .zone(\"de-fra1\")\n            .plan(\"1xCPU-1GB\")\n            .template(ServerTemplateArgs.builder()\n                .storage(\"Ubuntu Server 20.04 LTS (Focal Fossa)\")\n                .size(25)\n                .build())\n            .networkInterfaces(ServerNetworkInterfaceArgs.builder()\n                .type(\"utility\")\n                .build())\n            .build());\n\n        var exampleServerFirewallRules = new ServerFirewallRules(\"exampleServerFirewallRules\", ServerFirewallRulesArgs.builder()\n            .serverId(example.id())\n            .firewallRules(ServerFirewallRulesFirewallRuleArgs.builder()\n                .action(\"accept\")\n                .comment(\"Allow SSH from this network\")\n                .destinationPortEnd(\"22\")\n                .destinationPortStart(\"22\")\n                .direction(\"in\")\n                .family(\"IPv4\")\n                .protocol(\"tcp\")\n                .sourceAddressEnd(\"192.168.1.255\")\n                .sourceAddressStart(\"192.168.1.1\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # The following example defines a server and then links the server to a single firewall rule. \n  # The list of firewall rules applied to the server can be expanded by providing additional server_firewall_rules blocks.\n  example:\n    type: upcloud:Server\n    properties:\n      firewall: true\n      hostname: terraform.example.tld\n      zone: de-fra1\n      plan: 1xCPU-1GB\n      template:\n        storage: Ubuntu Server 20.04 LTS (Focal Fossa)\n        size: 25\n      networkInterfaces:\n        - type: utility\n  exampleServerFirewallRules:\n    type: upcloud:ServerFirewallRules\n    name: example\n    properties:\n      serverId: ${example.id}\n      firewallRules:\n        - action: accept\n          comment: Allow SSH from this network\n          destinationPortEnd: '22'\n          destinationPortStart: '22'\n          direction: in\n          family: IPv4\n          protocol: tcp\n          sourceAddressEnd: 192.168.1.255\n          sourceAddressStart: 192.168.1.1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import upcloud:index/serverFirewallRules:ServerFirewallRules my_example_rules 049d7ca2-757e-4fb1-a833-f87ee056547a\n```\n\n",
            "properties": {
                "firewallRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ServerFirewallRulesFirewallRule:ServerFirewallRulesFirewallRule"
                    },
                    "description": "A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.\nTypical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one\ndestination/source-address/port range. A default rule can be created by providing only `action` and `direction`\nattributes. Default rule should be defined last. If used, IP address and port ranges must have both start and end values\nspecified. These can be the same value if only one IP address or port number is specified. Source and destination port\nnumbers can only be set if the protocol is TCP or UDP. The ICMP type may only be set if the protocol is ICMP.\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "The unique id of the server to be protected the firewall rules\n"
                }
            },
            "required": [
                "firewallRules",
                "serverId"
            ],
            "inputProperties": {
                "firewallRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/upcloud:index/ServerFirewallRulesFirewallRule:ServerFirewallRulesFirewallRule"
                    },
                    "description": "A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.\nTypical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one\ndestination/source-address/port range. A default rule can be created by providing only `action` and `direction`\nattributes. Default rule should be defined last. If used, IP address and port ranges must have both start and end values\nspecified. These can be the same value if only one IP address or port number is specified. Source and destination port\nnumbers can only be set if the protocol is TCP or UDP. The ICMP type may only be set if the protocol is ICMP.\n"
                },
                "serverId": {
                    "type": "string",
                    "description": "The unique id of the server to be protected the firewall rules\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "firewallRules",
                "serverId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServerFirewallRules resources.\n",
                "properties": {
                    "firewallRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/ServerFirewallRulesFirewallRule:ServerFirewallRulesFirewallRule"
                        },
                        "description": "A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.\nTypical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one\ndestination/source-address/port range. A default rule can be created by providing only `action` and `direction`\nattributes. Default rule should be defined last. If used, IP address and port ranges must have both start and end values\nspecified. These can be the same value if only one IP address or port number is specified. Source and destination port\nnumbers can only be set if the protocol is TCP or UDP. The ICMP type may only be set if the protocol is ICMP.\n"
                    },
                    "serverId": {
                        "type": "string",
                        "description": "The unique id of the server to be protected the firewall rules\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/serverGroup:ServerGroup": {
            "description": "Server groups allow grouping servers and defining anti-affinity for the servers.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst main = new upcloud.ServerGroup(\"main\", {\n    title: \"main_group\",\n    antiAffinityPolicy: \"yes\",\n    labels: {\n        key1: \"val1\",\n        key2: \"val2\",\n        key3: \"val3\",\n    },\n    members: [\n        \"00b51165-fb58-4b77-bb8c-552277be1764\",\n        \"00d56575-3821-3301-9de4-2b2bc7e35pqf\",\n        \"000012dc-fe8c-a3y6-91f9-0db1215c36cf\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nmain = upcloud.ServerGroup(\"main\",\n    title=\"main_group\",\n    anti_affinity_policy=\"yes\",\n    labels={\n        \"key1\": \"val1\",\n        \"key2\": \"val2\",\n        \"key3\": \"val3\",\n    },\n    members=[\n        \"00b51165-fb58-4b77-bb8c-552277be1764\",\n        \"00d56575-3821-3301-9de4-2b2bc7e35pqf\",\n        \"000012dc-fe8c-a3y6-91f9-0db1215c36cf\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new UpCloud.ServerGroup(\"main\", new()\n    {\n        Title = \"main_group\",\n        AntiAffinityPolicy = \"yes\",\n        Labels = \n        {\n            { \"key1\", \"val1\" },\n            { \"key2\", \"val2\" },\n            { \"key3\", \"val3\" },\n        },\n        Members = new[]\n        {\n            \"00b51165-fb58-4b77-bb8c-552277be1764\",\n            \"00d56575-3821-3301-9de4-2b2bc7e35pqf\",\n            \"000012dc-fe8c-a3y6-91f9-0db1215c36cf\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upcloud.NewServerGroup(ctx, \"main\", \u0026upcloud.ServerGroupArgs{\n\t\t\tTitle:              pulumi.String(\"main_group\"),\n\t\t\tAntiAffinityPolicy: pulumi.String(\"yes\"),\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"key1\": pulumi.String(\"val1\"),\n\t\t\t\t\"key2\": pulumi.String(\"val2\"),\n\t\t\t\t\"key3\": pulumi.String(\"val3\"),\n\t\t\t},\n\t\t\tMembers: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"00b51165-fb58-4b77-bb8c-552277be1764\"),\n\t\t\t\tpulumi.String(\"00d56575-3821-3301-9de4-2b2bc7e35pqf\"),\n\t\t\t\tpulumi.String(\"000012dc-fe8c-a3y6-91f9-0db1215c36cf\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ServerGroup;\nimport com.pulumi.upcloud.ServerGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new ServerGroup(\"main\", ServerGroupArgs.builder()\n            .title(\"main_group\")\n            .antiAffinityPolicy(\"yes\")\n            .labels(Map.ofEntries(\n                Map.entry(\"key1\", \"val1\"),\n                Map.entry(\"key2\", \"val2\"),\n                Map.entry(\"key3\", \"val3\")\n            ))\n            .members(            \n                \"00b51165-fb58-4b77-bb8c-552277be1764\",\n                \"00d56575-3821-3301-9de4-2b2bc7e35pqf\",\n                \"000012dc-fe8c-a3y6-91f9-0db1215c36cf\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  main:\n    type: upcloud:ServerGroup\n    properties:\n      title: main_group\n      antiAffinityPolicy: yes\n      labels:\n        key1: val1\n        key2: val2\n        key3: val3\n      members:\n        - 00b51165-fb58-4b77-bb8c-552277be1764\n        - 00d56575-3821-3301-9de4-2b2bc7e35pqf\n        - 000012dc-fe8c-a3y6-91f9-0db1215c36cf\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import upcloud:index/serverGroup:ServerGroup main ead4544f-10bf-42a3-b98a-a0fea2e2ad14\n```\n\n",
            "properties": {
                "antiAffinityPolicy": {
                    "type": "string",
                    "description": "Defines if a server group is an anti-affinity group. Setting this to `strict` or `yes` will result in all servers in the\ngroup being placed on separate compute hosts. The value can be `strict`, `yes`, or `no`. * `strict` policy doesn't allow\nservers in the same server group to be on the same host * `yes` refers to best-effort policy and tries to put servers on\ndifferent hosts, but this is not guaranteed * `no` refers to having no policy and thus no effect on server host affinity\nTo verify if the anti-affinity policies are met by requesting a server group details from API. For more information\nplease see UpCloud API documentation on server groups. Plese also note that anti-affinity policies are only applied on\nserver start. This means that if anti-affinity policies in server group are not met, you need to manually restart the\nservers in said group, for example via API, UpCloud Control Panel or upctl (UpCloud CLI)\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the server group.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "UUIDs of the servers that are members of this group. Servers can also be attached to the server group via `server_group`\nproperty of `upcloud.Server`. See also `track_members` property.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of your server group\n"
                },
                "trackMembers": {
                    "type": "boolean",
                    "description": "Controls if members of the server group are being tracked in this resource. Set to `false` when using `server_group`\nproperty of `upcloud.Server` to attach servers to the server group to avoid delayed state updates.\n"
                }
            },
            "required": [
                "antiAffinityPolicy",
                "labels",
                "title",
                "trackMembers"
            ],
            "inputProperties": {
                "antiAffinityPolicy": {
                    "type": "string",
                    "description": "Defines if a server group is an anti-affinity group. Setting this to `strict` or `yes` will result in all servers in the\ngroup being placed on separate compute hosts. The value can be `strict`, `yes`, or `no`. * `strict` policy doesn't allow\nservers in the same server group to be on the same host * `yes` refers to best-effort policy and tries to put servers on\ndifferent hosts, but this is not guaranteed * `no` refers to having no policy and thus no effect on server host affinity\nTo verify if the anti-affinity policies are met by requesting a server group details from API. For more information\nplease see UpCloud API documentation on server groups. Plese also note that anti-affinity policies are only applied on\nserver start. This means that if anti-affinity policies in server group are not met, you need to manually restart the\nservers in said group, for example via API, UpCloud Control Panel or upctl (UpCloud CLI)\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the server group.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "UUIDs of the servers that are members of this group. Servers can also be attached to the server group via `server_group`\nproperty of `upcloud.Server`. See also `track_members` property.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of your server group\n"
                },
                "trackMembers": {
                    "type": "boolean",
                    "description": "Controls if members of the server group are being tracked in this resource. Set to `false` when using `server_group`\nproperty of `upcloud.Server` to attach servers to the server group to avoid delayed state updates.\n"
                }
            },
            "requiredInputs": [
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServerGroup resources.\n",
                "properties": {
                    "antiAffinityPolicy": {
                        "type": "string",
                        "description": "Defines if a server group is an anti-affinity group. Setting this to `strict` or `yes` will result in all servers in the\ngroup being placed on separate compute hosts. The value can be `strict`, `yes`, or `no`. * `strict` policy doesn't allow\nservers in the same server group to be on the same host * `yes` refers to best-effort policy and tries to put servers on\ndifferent hosts, but this is not guaranteed * `no` refers to having no policy and thus no effect on server host affinity\nTo verify if the anti-affinity policies are met by requesting a server group details from API. For more information\nplease see UpCloud API documentation on server groups. Plese also note that anti-affinity policies are only applied on\nserver start. This means that if anti-affinity policies in server group are not met, you need to manually restart the\nservers in said group, for example via API, UpCloud Control Panel or upctl (UpCloud CLI)\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the server group.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "UUIDs of the servers that are members of this group. Servers can also be attached to the server group via `server_group`\nproperty of `upcloud.Server`. See also `track_members` property.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of your server group\n"
                    },
                    "trackMembers": {
                        "type": "boolean",
                        "description": "Controls if members of the server group are being tracked in this resource. Set to `false` when using `server_group`\nproperty of `upcloud.Server` to attach servers to the server group to avoid delayed state updates.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/storage:Storage": {
            "description": "Manages UpCloud [Block Storage](https://upcloud.com/products/block-storage) devices.\n\n## Import\n\n```sh\n$ pulumi import upcloud:index/storage:Storage example_storage 0128ae5a-91dd-4ebf-bd1e-304c47f2c652\n```\n\n",
            "properties": {
                "backupRule": {
                    "$ref": "#/types/upcloud:index/StorageBackupRule:StorageBackupRule"
                },
                "clone": {
                    "$ref": "#/types/upcloud:index/StorageClone:StorageClone",
                    "description": "Block defining another storage/template to clone to storage.\n"
                },
                "deleteAutoresizeBackup": {
                    "type": "boolean",
                    "description": "If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after\nsuccess.\n"
                },
                "encrypt": {
                    "type": "boolean",
                    "description": "Sets if the storage is encrypted at rest.\n"
                },
                "filesystemAutoresize": {
                    "type": "boolean",
                    "description": "If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please\nnote that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the\nbackup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless\n`delete_autoresize_backup` option is set to true). Taking and keeping backups incure costs.\n"
                },
                "import": {
                    "$ref": "#/types/upcloud:index/StorageImport:StorageImport",
                    "description": "Block defining external data to import to storage\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the storage.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the storage in gigabytes.\n"
                },
                "systemLabels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "System defined key-value pairs to classify the storage. The keys of system defined labels are prefixed with underscore\nand can not be modified by the user.\n"
                },
                "tier": {
                    "type": "string",
                    "description": "The tier of the storage.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the storage.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the storage.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "required": [
                "deleteAutoresizeBackup",
                "encrypt",
                "filesystemAutoresize",
                "labels",
                "size",
                "systemLabels",
                "tier",
                "title",
                "type",
                "zone"
            ],
            "inputProperties": {
                "backupRule": {
                    "$ref": "#/types/upcloud:index/StorageBackupRule:StorageBackupRule"
                },
                "clone": {
                    "$ref": "#/types/upcloud:index/StorageClone:StorageClone",
                    "description": "Block defining another storage/template to clone to storage.\n"
                },
                "deleteAutoresizeBackup": {
                    "type": "boolean",
                    "description": "If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after\nsuccess.\n"
                },
                "encrypt": {
                    "type": "boolean",
                    "description": "Sets if the storage is encrypted at rest.\n"
                },
                "filesystemAutoresize": {
                    "type": "boolean",
                    "description": "If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please\nnote that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the\nbackup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless\n`delete_autoresize_backup` option is set to true). Taking and keeping backups incure costs.\n"
                },
                "import": {
                    "$ref": "#/types/upcloud:index/StorageImport:StorageImport",
                    "description": "Block defining external data to import to storage\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the storage.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the storage in gigabytes.\n"
                },
                "tier": {
                    "type": "string",
                    "description": "The tier of the storage.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the storage.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                }
            },
            "requiredInputs": [
                "size",
                "title",
                "zone"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Storage resources.\n",
                "properties": {
                    "backupRule": {
                        "$ref": "#/types/upcloud:index/StorageBackupRule:StorageBackupRule"
                    },
                    "clone": {
                        "$ref": "#/types/upcloud:index/StorageClone:StorageClone",
                        "description": "Block defining another storage/template to clone to storage.\n"
                    },
                    "deleteAutoresizeBackup": {
                        "type": "boolean",
                        "description": "If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after\nsuccess.\n"
                    },
                    "encrypt": {
                        "type": "boolean",
                        "description": "Sets if the storage is encrypted at rest.\n"
                    },
                    "filesystemAutoresize": {
                        "type": "boolean",
                        "description": "If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please\nnote that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the\nbackup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless\n`delete_autoresize_backup` option is set to true). Taking and keeping backups incure costs.\n"
                    },
                    "import": {
                        "$ref": "#/types/upcloud:index/StorageImport:StorageImport",
                        "description": "Block defining external data to import to storage\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the storage.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the storage in gigabytes.\n"
                    },
                    "systemLabels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "System defined key-value pairs to classify the storage. The keys of system defined labels are prefixed with underscore\nand can not be modified by the user.\n"
                    },
                    "tier": {
                        "type": "string",
                        "description": "The tier of the storage.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of the storage.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the storage.\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/storageTemplate:StorageTemplate": {
            "description": "Manages UpCloud storage templates. The storage templates are stored in the system as storages with `template` type.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\nconst template = new upcloud.StorageTemplate(\"template\", {\n    sourceStorage: \"e0328f8a-9944-406b-99c3-656dcc03e671\",\n    title: \"custom-storage-template\",\n    labels: {\n        os: \"linux\",\n        usage: \"example\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\ntemplate = upcloud.StorageTemplate(\"template\",\n    source_storage=\"e0328f8a-9944-406b-99c3-656dcc03e671\",\n    title=\"custom-storage-template\",\n    labels={\n        \"os\": \"linux\",\n        \"usage\": \"example\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var template = new UpCloud.StorageTemplate(\"template\", new()\n    {\n        SourceStorage = \"e0328f8a-9944-406b-99c3-656dcc03e671\",\n        Title = \"custom-storage-template\",\n        Labels = \n        {\n            { \"os\", \"linux\" },\n            { \"usage\", \"example\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upcloud.NewStorageTemplate(ctx, \"template\", \u0026upcloud.StorageTemplateArgs{\n\t\t\tSourceStorage: pulumi.String(\"e0328f8a-9944-406b-99c3-656dcc03e671\"),\n\t\t\tTitle:         pulumi.String(\"custom-storage-template\"),\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"os\":    pulumi.String(\"linux\"),\n\t\t\t\t\"usage\": pulumi.String(\"example\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.StorageTemplate;\nimport com.pulumi.upcloud.StorageTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var template = new StorageTemplate(\"template\", StorageTemplateArgs.builder()\n            .sourceStorage(\"e0328f8a-9944-406b-99c3-656dcc03e671\")\n            .title(\"custom-storage-template\")\n            .labels(Map.ofEntries(\n                Map.entry(\"os\", \"linux\"),\n                Map.entry(\"usage\", \"example\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  template:\n    type: upcloud:StorageTemplate\n    properties:\n      sourceStorage: e0328f8a-9944-406b-99c3-656dcc03e671\n      title: custom-storage-template\n      labels:\n        os: linux\n        usage: example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "encrypt": {
                    "type": "boolean",
                    "description": "Sets if the storage is encrypted at rest.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the storage.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the storage in gigabytes.\n"
                },
                "sourceStorage": {
                    "type": "string",
                    "description": "The source storage that is used as a base for this storage template.\n"
                },
                "systemLabels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "System defined key-value pairs to classify the storage. The keys of system defined labels are prefixed with underscore\nand can not be modified by the user.\n"
                },
                "tier": {
                    "type": "string",
                    "description": "The tier of the storage.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the storage.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the storage.\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The zone the storage is in, e.g. `de-fra1`.\n"
                }
            },
            "required": [
                "encrypt",
                "labels",
                "size",
                "sourceStorage",
                "systemLabels",
                "tier",
                "title",
                "type",
                "zone"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "User defined key-value pairs to classify the storage.\n"
                },
                "sourceStorage": {
                    "type": "string",
                    "description": "The source storage that is used as a base for this storage template.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the storage.\n"
                }
            },
            "requiredInputs": [
                "sourceStorage",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageTemplate resources.\n",
                "properties": {
                    "encrypt": {
                        "type": "boolean",
                        "description": "Sets if the storage is encrypted at rest.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "User defined key-value pairs to classify the storage.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the storage in gigabytes.\n"
                    },
                    "sourceStorage": {
                        "type": "string",
                        "description": "The source storage that is used as a base for this storage template.\n"
                    },
                    "systemLabels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "System defined key-value pairs to classify the storage. The keys of system defined labels are prefixed with underscore\nand can not be modified by the user.\n"
                    },
                    "tier": {
                        "type": "string",
                        "description": "The tier of the storage.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of the storage.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the storage.\n"
                    },
                    "zone": {
                        "type": "string",
                        "description": "The zone the storage is in, e.g. `de-fra1`.\n"
                    }
                },
                "type": "object"
            }
        },
        "upcloud:index/tag:Tag": {
            "description": "This resource is deprecated, use tags schema in server resource\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Free form text representing the meaning of the tag\n"
                },
                "name": {
                    "type": "string",
                    "description": "The value representing the tag\n"
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A collection of servers that have been assigned the tag\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Free form text representing the meaning of the tag\n"
                },
                "name": {
                    "type": "string",
                    "description": "The value representing the tag\n",
                    "willReplaceOnChanges": true
                },
                "servers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A collection of servers that have been assigned the tag\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Free form text representing the meaning of the tag\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The value representing the tag\n",
                        "willReplaceOnChanges": true
                    },
                    "servers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A collection of servers that have been assigned the tag\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "upcloud:index/getHosts:getHosts": {
            "description": "Returns a list of available UpCloud hosts. \n\t\tA host identifies the host server that virtual machines are run on. \n\t\tOnly hosts on private cloud to which the calling account has access to are available through this resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\n\nconst allHosts = upcloud.getHosts({});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nall_hosts = upcloud.get_hosts()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var allHosts = UpCloud.GetHosts.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upcloud.GetHosts(ctx, \u0026upcloud.GetHostsArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetHostsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var allHosts = UpcloudFunctions.getHosts(GetHostsArgs.builder()\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  allHosts:\n    fn::invoke:\n      function: upcloud:getHosts\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHosts.\n",
                "properties": {
                    "hosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/getHostsHost:getHostsHost"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getHosts.\n",
                "properties": {
                    "hosts": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getHostsHost:getHostsHost"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The ID of this resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getIpAddresses:getIpAddresses": {
            "description": "Returns a set of IP Addresses that are associated with the UpCloud account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\n\nconst allIpAddresses = upcloud.getIpAddresses({});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nall_ip_addresses = upcloud.get_ip_addresses()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var allIpAddresses = UpCloud.GetIpAddresses.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upcloud.GetIpAddresses(ctx, \u0026upcloud.GetIpAddressesArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetIpAddressesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var allIpAddresses = UpcloudFunctions.getIpAddresses(GetIpAddressesArgs.builder()\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  allIpAddresses:\n    fn::invoke:\n      function: upcloud:getIpAddresses\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getIpAddresses.\n",
                "properties": {
                    "addresses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/getIpAddressesAddress:getIpAddressesAddress"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getIpAddresses.\n",
                "properties": {
                    "addresses": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getIpAddressesAddress:getIpAddressesAddress"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "ID of the resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getKubernetesCluster:getKubernetesCluster": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as kubernetes from \"@pulumi/kubernetes\";\nimport * as local from \"@pulumi/local\";\nimport * as upcloud from \"@pulumi/upcloud\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Use Kubernetes provider to access your Kubernetes cluster\n// Create a network for the Kubernetes cluster\nconst exampleNetwork = new upcloud.Network(\"example\", {\n    name: \"example-network\",\n    zone: \"de-fra1\",\n    ipNetwork: {\n        address: \"172.16.1.0/24\",\n        dhcp: true,\n        family: \"IPv4\",\n    },\n});\n// Create a Kubernetes cluster\nconst exampleKubernetesCluster = new upcloud.KubernetesCluster(\"example\", {\n    controlPlaneIpFilters: [\"0.0.0.0/0\"],\n    name: \"exampleapp\",\n    network: exampleNetwork.id,\n    zone: \"de-fra1\",\n});\n// Read the details of the newly created cluster\nconst example = upcloud.getKubernetesClusterOutput({\n    id: exampleKubernetesCluster.id,\n});\n// Use the Kubernetes provider resources to interact with the cluster\nconst exampleNamespace = new kubernetes.index.Namespace(\"example\", {metadata: [{\n    name: \"example-namespace\",\n}]});\n// In addition, write the kubeconfig to a file to interact with the cluster with `kubectl` or other clients\nconst exampleFile = new local.index.File(\"example\", {\n    content: example.kubeconfig,\n    filename: \"example.conf\",\n});\n```\n```python\nimport pulumi\nimport pulumi_kubernetes as kubernetes\nimport pulumi_local as local\nimport pulumi_upcloud as upcloud\n\n# Use Kubernetes provider to access your Kubernetes cluster\n# Create a network for the Kubernetes cluster\nexample_network = upcloud.Network(\"example\",\n    name=\"example-network\",\n    zone=\"de-fra1\",\n    ip_network={\n        \"address\": \"172.16.1.0/24\",\n        \"dhcp\": True,\n        \"family\": \"IPv4\",\n    })\n# Create a Kubernetes cluster\nexample_kubernetes_cluster = upcloud.KubernetesCluster(\"example\",\n    control_plane_ip_filters=[\"0.0.0.0/0\"],\n    name=\"exampleapp\",\n    network=example_network.id,\n    zone=\"de-fra1\")\n# Read the details of the newly created cluster\nexample = upcloud.get_kubernetes_cluster_output(id=example_kubernetes_cluster.id)\n# Use the Kubernetes provider resources to interact with the cluster\nexample_namespace = kubernetes.index.Namespace(\"example\", metadata=[{\n    name: example-namespace,\n}])\n# In addition, write the kubeconfig to a file to interact with the cluster with `kubectl` or other clients\nexample_file = local.index.File(\"example\",\n    content=example.kubeconfig,\n    filename=example.conf)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Kubernetes = Pulumi.Kubernetes;\nusing Local = Pulumi.Local;\nusing UpCloud = Pulumi.UpCloud;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Use Kubernetes provider to access your Kubernetes cluster\n    // Create a network for the Kubernetes cluster\n    var exampleNetwork = new UpCloud.Network(\"example\", new()\n    {\n        Name = \"example-network\",\n        Zone = \"de-fra1\",\n        IpNetwork = new UpCloud.Inputs.NetworkIpNetworkArgs\n        {\n            Address = \"172.16.1.0/24\",\n            Dhcp = true,\n            Family = \"IPv4\",\n        },\n    });\n\n    // Create a Kubernetes cluster\n    var exampleKubernetesCluster = new UpCloud.KubernetesCluster(\"example\", new()\n    {\n        ControlPlaneIpFilters = new[]\n        {\n            \"0.0.0.0/0\",\n        },\n        Name = \"exampleapp\",\n        Network = exampleNetwork.Id,\n        Zone = \"de-fra1\",\n    });\n\n    // Read the details of the newly created cluster\n    var example = UpCloud.GetKubernetesCluster.Invoke(new()\n    {\n        Id = exampleKubernetesCluster.Id,\n    });\n\n    // Use the Kubernetes provider resources to interact with the cluster\n    var exampleNamespace = new Kubernetes.Index.Namespace(\"example\", new()\n    {\n        Metadata = new[]\n        {\n            \n            {\n                { \"name\", \"example-namespace\" },\n            },\n        },\n    });\n\n    // In addition, write the kubeconfig to a file to interact with the cluster with `kubectl` or other clients\n    var exampleFile = new Local.Index.File(\"example\", new()\n    {\n        Content = example.Apply(getKubernetesClusterResult =\u003e getKubernetesClusterResult.Kubeconfig),\n        Filename = \"example.conf\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi-kubernetes/sdk/go/kubernetes\"\n\t\"github.com/pulumi/pulumi-local/sdk/go/local\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Use Kubernetes provider to access your Kubernetes cluster\n\t\t// Create a network for the Kubernetes cluster\n\t\texampleNetwork, err := upcloud.NewNetwork(ctx, \"example\", \u0026upcloud.NetworkArgs{\n\t\t\tName: pulumi.String(\"example-network\"),\n\t\t\tZone: pulumi.String(\"de-fra1\"),\n\t\t\tIpNetwork: \u0026upcloud.NetworkIpNetworkArgs{\n\t\t\t\tAddress: pulumi.String(\"172.16.1.0/24\"),\n\t\t\t\tDhcp:    pulumi.Bool(true),\n\t\t\t\tFamily:  pulumi.String(\"IPv4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a Kubernetes cluster\n\t\texampleKubernetesCluster, err := upcloud.NewKubernetesCluster(ctx, \"example\", \u0026upcloud.KubernetesClusterArgs{\n\t\t\tControlPlaneIpFilters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"0.0.0.0/0\"),\n\t\t\t},\n\t\t\tName:    pulumi.String(\"exampleapp\"),\n\t\t\tNetwork: exampleNetwork.ID(),\n\t\t\tZone:    pulumi.String(\"de-fra1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Read the details of the newly created cluster\n\t\texample := upcloud.LookupKubernetesClusterOutput(ctx, upcloud.GetKubernetesClusterOutputArgs{\n\t\t\tId: exampleKubernetesCluster.ID(),\n\t\t}, nil)\n\t\t// Use the Kubernetes provider resources to interact with the cluster\n\t\t_, err = kubernetes.NewNamespace(ctx, \"example\", \u0026kubernetes.NamespaceArgs{\n\t\t\tMetadata: []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\": \"example-namespace\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// In addition, write the kubeconfig to a file to interact with the cluster with `kubectl` or other clients\n\t\t_, err = local.NewFile(ctx, \"example\", \u0026local.FileArgs{\n\t\t\tContent:  example.Kubeconfig,\n\t\t\tFilename: \"example.conf\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.Network;\nimport com.pulumi.upcloud.NetworkArgs;\nimport com.pulumi.upcloud.inputs.NetworkIpNetworkArgs;\nimport com.pulumi.upcloud.KubernetesCluster;\nimport com.pulumi.upcloud.KubernetesClusterArgs;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetKubernetesClusterArgs;\nimport com.pulumi.kubernetes.Namespace;\nimport com.pulumi.kubernetes.NamespaceArgs;\nimport com.pulumi.local.File;\nimport com.pulumi.local.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Use Kubernetes provider to access your Kubernetes cluster\n        // Create a network for the Kubernetes cluster\n        var exampleNetwork = new Network(\"exampleNetwork\", NetworkArgs.builder()\n            .name(\"example-network\")\n            .zone(\"de-fra1\")\n            .ipNetwork(NetworkIpNetworkArgs.builder()\n                .address(\"172.16.1.0/24\")\n                .dhcp(true)\n                .family(\"IPv4\")\n                .build())\n            .build());\n\n        // Create a Kubernetes cluster\n        var exampleKubernetesCluster = new KubernetesCluster(\"exampleKubernetesCluster\", KubernetesClusterArgs.builder()\n            .controlPlaneIpFilters(\"0.0.0.0/0\")\n            .name(\"exampleapp\")\n            .network(exampleNetwork.id())\n            .zone(\"de-fra1\")\n            .build());\n\n        // Read the details of the newly created cluster\n        final var example = UpcloudFunctions.getKubernetesCluster(GetKubernetesClusterArgs.builder()\n            .id(exampleKubernetesCluster.id())\n            .build());\n\n        // Use the Kubernetes provider resources to interact with the cluster\n        var exampleNamespace = new Namespace(\"exampleNamespace\", NamespaceArgs.builder()\n            .metadata(List.of(Map.of(\"name\", \"example-namespace\")))\n            .build());\n\n        // In addition, write the kubeconfig to a file to interact with the cluster with `kubectl` or other clients\n        var exampleFile = new File(\"exampleFile\", FileArgs.builder()\n            .content(example.kubeconfig())\n            .filename(\"example.conf\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Use Kubernetes provider to access your Kubernetes cluster\n\n  # Create a network for the Kubernetes cluster\n  exampleNetwork:\n    type: upcloud:Network\n    name: example\n    properties:\n      name: example-network\n      zone: de-fra1\n      ipNetwork:\n        address: 172.16.1.0/24\n        dhcp: true\n        family: IPv4\n  # Create a Kubernetes cluster\n  exampleKubernetesCluster:\n    type: upcloud:KubernetesCluster\n    name: example\n    properties:\n      controlPlaneIpFilters:\n        - 0.0.0.0/0\n      name: exampleapp\n      network: ${exampleNetwork.id}\n      zone: de-fra1\n  # Use the Kubernetes provider resources to interact with the cluster\n  exampleNamespace:\n    type: kubernetes:Namespace\n    name: example\n    properties:\n      metadata:\n        - name: example-namespace\n  # In addition, write the kubeconfig to a file to interact with the cluster with `kubectl` or other clients\n  exampleFile:\n    type: local:File\n    name: example\n    properties:\n      content: ${example.kubeconfig}\n      filename: example.conf\nvariables:\n  # Read the details of the newly created cluster\n  example:\n    fn::invoke:\n      function: upcloud:getKubernetesCluster\n      arguments:\n        id: ${exampleKubernetesCluster.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getKubernetesCluster.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getKubernetesCluster.\n",
                "properties": {
                    "clientCertificate": {
                        "type": "string"
                    },
                    "clientKey": {
                        "secret": true,
                        "type": "string"
                    },
                    "clusterCaCertificate": {
                        "type": "string"
                    },
                    "host": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "kubeconfig": {
                        "secret": true,
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "clientCertificate",
                    "clientKey",
                    "clusterCaCertificate",
                    "host",
                    "id",
                    "kubeconfig",
                    "name"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getLoadBalancerDnsChallengeDomain:getLoadBalancerDnsChallengeDomain": {
            "description": "Returns DNS challenge domain to use when validating domain ownership using ACME challenge method.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\n\nconst _this = upcloud.getLoadBalancerDnsChallengeDomain({});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\nthis = upcloud.get_load_balancer_dns_challenge_domain()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = UpCloud.GetLoadBalancerDnsChallengeDomain.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := upcloud.GetLoadBalancerDnsChallengeDomain(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = UpcloudFunctions.getLoadBalancerDnsChallengeDomain(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      function: upcloud:getLoadBalancerDnsChallengeDomain\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getLoadBalancerDnsChallengeDomain.\n",
                "properties": {
                    "domain": {
                        "description": "The domain to use for DNS challenge validation.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The ID of this resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "domain",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getManagedDatabaseMysqlSessions:getManagedDatabaseMysqlSessions": {
            "description": "Current sessions of a MySQL managed database\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Use data source to gather a list of the active sessions for a Managed MySQL Database\n// Create a Managed MySQL resource\nconst exampleManagedDatabaseMysql = new upcloud.ManagedDatabaseMysql(\"example\", {\n    name: \"mysql-example1\",\n    title: \"mysql-example1\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    zone: \"fi-hel1\",\n});\n// Read the active sessions of the newly created service\nconst example = upcloud.getManagedDatabaseMysqlSessionsOutput({\n    service: exampleManagedDatabaseMysql.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Use data source to gather a list of the active sessions for a Managed MySQL Database\n# Create a Managed MySQL resource\nexample_managed_database_mysql = upcloud.ManagedDatabaseMysql(\"example\",\n    name=\"mysql-example1\",\n    title=\"mysql-example1\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    zone=\"fi-hel1\")\n# Read the active sessions of the newly created service\nexample = upcloud.get_managed_database_mysql_sessions_output(service=example_managed_database_mysql.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Use data source to gather a list of the active sessions for a Managed MySQL Database\n    // Create a Managed MySQL resource\n    var exampleManagedDatabaseMysql = new UpCloud.ManagedDatabaseMysql(\"example\", new()\n    {\n        Name = \"mysql-example1\",\n        Title = \"mysql-example1\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Zone = \"fi-hel1\",\n    });\n\n    // Read the active sessions of the newly created service\n    var example = UpCloud.GetManagedDatabaseMysqlSessions.Invoke(new()\n    {\n        Service = exampleManagedDatabaseMysql.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Use data source to gather a list of the active sessions for a Managed MySQL Database\n\t\t// Create a Managed MySQL resource\n\t\texampleManagedDatabaseMysql, err := upcloud.NewManagedDatabaseMysql(ctx, \"example\", \u0026upcloud.ManagedDatabaseMysqlArgs{\n\t\t\tName:  pulumi.String(\"mysql-example1\"),\n\t\t\tTitle: pulumi.String(\"mysql-example1\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Read the active sessions of the newly created service\n\t\t_ = upcloud.GetManagedDatabaseMysqlSessionsOutput(ctx, upcloud.GetManagedDatabaseMysqlSessionsOutputArgs{\n\t\t\tService: exampleManagedDatabaseMysql.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabaseMysql;\nimport com.pulumi.upcloud.ManagedDatabaseMysqlArgs;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetManagedDatabaseMysqlSessionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Use data source to gather a list of the active sessions for a Managed MySQL Database\n        // Create a Managed MySQL resource\n        var exampleManagedDatabaseMysql = new ManagedDatabaseMysql(\"exampleManagedDatabaseMysql\", ManagedDatabaseMysqlArgs.builder()\n            .name(\"mysql-example1\")\n            .title(\"mysql-example1\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .zone(\"fi-hel1\")\n            .build());\n\n        // Read the active sessions of the newly created service\n        final var example = UpcloudFunctions.getManagedDatabaseMysqlSessions(GetManagedDatabaseMysqlSessionsArgs.builder()\n            .service(exampleManagedDatabaseMysql.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Use data source to gather a list of the active sessions for a Managed MySQL Database\n\n  # Create a Managed MySQL resource\n  exampleManagedDatabaseMysql:\n    type: upcloud:ManagedDatabaseMysql\n    name: example\n    properties:\n      name: mysql-example1\n      title: mysql-example1\n      plan: 1x1xCPU-2GB-25GB\n      zone: fi-hel1\nvariables:\n  # Read the active sessions of the newly created service\n  example:\n    fn::invoke:\n      function: upcloud:getManagedDatabaseMysqlSessions\n      arguments:\n        service: ${exampleManagedDatabaseMysql.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getManagedDatabaseMysqlSessions.\n",
                "properties": {
                    "limit": {
                        "type": "integer"
                    },
                    "offset": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "sessions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabaseMysqlSessionsSession:getManagedDatabaseMysqlSessionsSession"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "service"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getManagedDatabaseMysqlSessions.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "limit": {
                        "type": "integer"
                    },
                    "offset": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "sessions": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabaseMysqlSessionsSession:getManagedDatabaseMysqlSessionsSession"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "service",
                    "sessions",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getManagedDatabaseOpensearchIndices:getManagedDatabaseOpensearchIndices": {
            "description": "OpenSearch indices\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Use data source to gather a list of the indices for a Managed OpenSearch Database\n// Create a Managed OpenSearch resource\nconst exampleManagedDatabaseOpensearch = new upcloud.ManagedDatabaseOpensearch(\"example\", {\n    name: \"opensearch-example\",\n    title: \"opensearch-example\",\n    plan: \"1x2xCPU-4GB-80GB-1D\",\n    zone: \"fi-hel1\",\n    properties: {\n        automaticUtilityNetworkIpFilter: false,\n        publicAccess: false,\n    },\n});\n// Read the available indices of the newly created service\nconst example = upcloud.getManagedDatabaseOpensearchIndicesOutput({\n    service: exampleManagedDatabaseOpensearch.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Use data source to gather a list of the indices for a Managed OpenSearch Database\n# Create a Managed OpenSearch resource\nexample_managed_database_opensearch = upcloud.ManagedDatabaseOpensearch(\"example\",\n    name=\"opensearch-example\",\n    title=\"opensearch-example\",\n    plan=\"1x2xCPU-4GB-80GB-1D\",\n    zone=\"fi-hel1\",\n    properties={\n        \"automatic_utility_network_ip_filter\": False,\n        \"public_access\": False,\n    })\n# Read the available indices of the newly created service\nexample = upcloud.get_managed_database_opensearch_indices_output(service=example_managed_database_opensearch.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Use data source to gather a list of the indices for a Managed OpenSearch Database\n    // Create a Managed OpenSearch resource\n    var exampleManagedDatabaseOpensearch = new UpCloud.ManagedDatabaseOpensearch(\"example\", new()\n    {\n        Name = \"opensearch-example\",\n        Title = \"opensearch-example\",\n        Plan = \"1x2xCPU-4GB-80GB-1D\",\n        Zone = \"fi-hel1\",\n        Properties = new UpCloud.Inputs.ManagedDatabaseOpensearchPropertiesArgs\n        {\n            AutomaticUtilityNetworkIpFilter = false,\n            PublicAccess = false,\n        },\n    });\n\n    // Read the available indices of the newly created service\n    var example = UpCloud.GetManagedDatabaseOpensearchIndices.Invoke(new()\n    {\n        Service = exampleManagedDatabaseOpensearch.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Use data source to gather a list of the indices for a Managed OpenSearch Database\n\t\t// Create a Managed OpenSearch resource\n\t\texampleManagedDatabaseOpensearch, err := upcloud.NewManagedDatabaseOpensearch(ctx, \"example\", \u0026upcloud.ManagedDatabaseOpensearchArgs{\n\t\t\tName:  pulumi.String(\"opensearch-example\"),\n\t\t\tTitle: pulumi.String(\"opensearch-example\"),\n\t\t\tPlan:  pulumi.String(\"1x2xCPU-4GB-80GB-1D\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t\tProperties: \u0026upcloud.ManagedDatabaseOpensearchPropertiesArgs{\n\t\t\t\tAutomaticUtilityNetworkIpFilter: pulumi.Bool(false),\n\t\t\t\tPublicAccess:                    pulumi.Bool(false),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Read the available indices of the newly created service\n\t\t_ = upcloud.GetManagedDatabaseOpensearchIndicesOutput(ctx, upcloud.GetManagedDatabaseOpensearchIndicesOutputArgs{\n\t\t\tService: exampleManagedDatabaseOpensearch.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabaseOpensearch;\nimport com.pulumi.upcloud.ManagedDatabaseOpensearchArgs;\nimport com.pulumi.upcloud.inputs.ManagedDatabaseOpensearchPropertiesArgs;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetManagedDatabaseOpensearchIndicesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Use data source to gather a list of the indices for a Managed OpenSearch Database\n        // Create a Managed OpenSearch resource\n        var exampleManagedDatabaseOpensearch = new ManagedDatabaseOpensearch(\"exampleManagedDatabaseOpensearch\", ManagedDatabaseOpensearchArgs.builder()\n            .name(\"opensearch-example\")\n            .title(\"opensearch-example\")\n            .plan(\"1x2xCPU-4GB-80GB-1D\")\n            .zone(\"fi-hel1\")\n            .properties(ManagedDatabaseOpensearchPropertiesArgs.builder()\n                .automaticUtilityNetworkIpFilter(false)\n                .publicAccess(false)\n                .build())\n            .build());\n\n        // Read the available indices of the newly created service\n        final var example = UpcloudFunctions.getManagedDatabaseOpensearchIndices(GetManagedDatabaseOpensearchIndicesArgs.builder()\n            .service(exampleManagedDatabaseOpensearch.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Use data source to gather a list of the indices for a Managed OpenSearch Database\n\n  # Create a Managed OpenSearch resource\n  exampleManagedDatabaseOpensearch:\n    type: upcloud:ManagedDatabaseOpensearch\n    name: example\n    properties:\n      name: opensearch-example\n      title: opensearch-example\n      plan: 1x2xCPU-4GB-80GB-1D\n      zone: fi-hel1\n      properties:\n        automaticUtilityNetworkIpFilter: false\n        publicAccess: false\nvariables:\n  # Read the available indices of the newly created service\n  example:\n    fn::invoke:\n      function: upcloud:getManagedDatabaseOpensearchIndices\n      arguments:\n        service: ${exampleManagedDatabaseOpensearch.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getManagedDatabaseOpensearchIndices.\n",
                "properties": {
                    "indices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabaseOpensearchIndicesIndex:getManagedDatabaseOpensearchIndicesIndex"
                        }
                    },
                    "service": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "service"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getManagedDatabaseOpensearchIndices.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "indices": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabaseOpensearchIndicesIndex:getManagedDatabaseOpensearchIndicesIndex"
                        },
                        "type": "array"
                    },
                    "service": {
                        "type": "string"
                    }
                },
                "required": [
                    "indices",
                    "service",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getManagedDatabasePostgresqlSessions:getManagedDatabasePostgresqlSessions": {
            "description": "Current sessions of a PostgreSQL managed database\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Use data source to gather a list of the active sessions for a Managed PostgreSQL Database\n// Create a Managed PostgreSQL resource\nconst exampleManagedDatabasePostgresql = new upcloud.ManagedDatabasePostgresql(\"example\", {\n    name: \"mysql-example1\",\n    title: \"mysql-example1\",\n    plan: \"1x1xCPU-2GB-25GB\",\n    zone: \"fi-hel1\",\n});\n// Read the active sessions of the newly created service\nconst example = upcloud.getManagedDatabasePostgresqlSessionsOutput({\n    service: exampleManagedDatabasePostgresql.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Use data source to gather a list of the active sessions for a Managed PostgreSQL Database\n# Create a Managed PostgreSQL resource\nexample_managed_database_postgresql = upcloud.ManagedDatabasePostgresql(\"example\",\n    name=\"mysql-example1\",\n    title=\"mysql-example1\",\n    plan=\"1x1xCPU-2GB-25GB\",\n    zone=\"fi-hel1\")\n# Read the active sessions of the newly created service\nexample = upcloud.get_managed_database_postgresql_sessions_output(service=example_managed_database_postgresql.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Use data source to gather a list of the active sessions for a Managed PostgreSQL Database\n    // Create a Managed PostgreSQL resource\n    var exampleManagedDatabasePostgresql = new UpCloud.ManagedDatabasePostgresql(\"example\", new()\n    {\n        Name = \"mysql-example1\",\n        Title = \"mysql-example1\",\n        Plan = \"1x1xCPU-2GB-25GB\",\n        Zone = \"fi-hel1\",\n    });\n\n    // Read the active sessions of the newly created service\n    var example = UpCloud.GetManagedDatabasePostgresqlSessions.Invoke(new()\n    {\n        Service = exampleManagedDatabasePostgresql.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Use data source to gather a list of the active sessions for a Managed PostgreSQL Database\n\t\t// Create a Managed PostgreSQL resource\n\t\texampleManagedDatabasePostgresql, err := upcloud.NewManagedDatabasePostgresql(ctx, \"example\", \u0026upcloud.ManagedDatabasePostgresqlArgs{\n\t\t\tName:  pulumi.String(\"mysql-example1\"),\n\t\t\tTitle: pulumi.String(\"mysql-example1\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB-25GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Read the active sessions of the newly created service\n\t\t_ = upcloud.GetManagedDatabasePostgresqlSessionsOutput(ctx, upcloud.GetManagedDatabasePostgresqlSessionsOutputArgs{\n\t\t\tService: exampleManagedDatabasePostgresql.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabasePostgresql;\nimport com.pulumi.upcloud.ManagedDatabasePostgresqlArgs;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetManagedDatabasePostgresqlSessionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Use data source to gather a list of the active sessions for a Managed PostgreSQL Database\n        // Create a Managed PostgreSQL resource\n        var exampleManagedDatabasePostgresql = new ManagedDatabasePostgresql(\"exampleManagedDatabasePostgresql\", ManagedDatabasePostgresqlArgs.builder()\n            .name(\"mysql-example1\")\n            .title(\"mysql-example1\")\n            .plan(\"1x1xCPU-2GB-25GB\")\n            .zone(\"fi-hel1\")\n            .build());\n\n        // Read the active sessions of the newly created service\n        final var example = UpcloudFunctions.getManagedDatabasePostgresqlSessions(GetManagedDatabasePostgresqlSessionsArgs.builder()\n            .service(exampleManagedDatabasePostgresql.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Use data source to gather a list of the active sessions for a Managed PostgreSQL Database\n\n  # Create a Managed PostgreSQL resource\n  exampleManagedDatabasePostgresql:\n    type: upcloud:ManagedDatabasePostgresql\n    name: example\n    properties:\n      name: mysql-example1\n      title: mysql-example1\n      plan: 1x1xCPU-2GB-25GB\n      zone: fi-hel1\nvariables:\n  # Read the active sessions of the newly created service\n  example:\n    fn::invoke:\n      function: upcloud:getManagedDatabasePostgresqlSessions\n      arguments:\n        service: ${exampleManagedDatabasePostgresql.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getManagedDatabasePostgresqlSessions.\n",
                "properties": {
                    "limit": {
                        "type": "integer"
                    },
                    "offset": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "sessions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabasePostgresqlSessionsSession:getManagedDatabasePostgresqlSessionsSession"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "service"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getManagedDatabasePostgresqlSessions.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "limit": {
                        "type": "integer"
                    },
                    "offset": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "sessions": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabasePostgresqlSessionsSession:getManagedDatabasePostgresqlSessionsSession"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "service",
                    "sessions",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getManagedDatabaseRedisSessions:getManagedDatabaseRedisSessions": {
            "description": "\u003e Redis is deprecated in favor of Valkey. Please use Valkey for new key value store instances.\n\nCurrent sessions of a Redis managed database\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Use data source to gather a list of the active sessions for a Managed Redis Database\n// Create a Managed Redis resource\nconst exampleManagedDatabaseRedis = new upcloud.ManagedDatabaseRedis(\"example\", {\n    name: \"example\",\n    title: \"example\",\n    plan: \"1x1xCPU-2GB\",\n    zone: \"fi-hel2\",\n});\n// Read the active sessions of the newly created service\nconst example = upcloud.getManagedDatabaseRedisSessionsOutput({\n    service: exampleManagedDatabaseRedis.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Use data source to gather a list of the active sessions for a Managed Redis Database\n# Create a Managed Redis resource\nexample_managed_database_redis = upcloud.ManagedDatabaseRedis(\"example\",\n    name=\"example\",\n    title=\"example\",\n    plan=\"1x1xCPU-2GB\",\n    zone=\"fi-hel2\")\n# Read the active sessions of the newly created service\nexample = upcloud.get_managed_database_redis_sessions_output(service=example_managed_database_redis.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Use data source to gather a list of the active sessions for a Managed Redis Database\n    // Create a Managed Redis resource\n    var exampleManagedDatabaseRedis = new UpCloud.ManagedDatabaseRedis(\"example\", new()\n    {\n        Name = \"example\",\n        Title = \"example\",\n        Plan = \"1x1xCPU-2GB\",\n        Zone = \"fi-hel2\",\n    });\n\n    // Read the active sessions of the newly created service\n    var example = UpCloud.GetManagedDatabaseRedisSessions.Invoke(new()\n    {\n        Service = exampleManagedDatabaseRedis.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Use data source to gather a list of the active sessions for a Managed Redis Database\n\t\t// Create a Managed Redis resource\n\t\texampleManagedDatabaseRedis, err := upcloud.NewManagedDatabaseRedis(ctx, \"example\", \u0026upcloud.ManagedDatabaseRedisArgs{\n\t\t\tName:  pulumi.String(\"example\"),\n\t\t\tTitle: pulumi.String(\"example\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Read the active sessions of the newly created service\n\t\t_ = upcloud.GetManagedDatabaseRedisSessionsOutput(ctx, upcloud.GetManagedDatabaseRedisSessionsOutputArgs{\n\t\t\tService: exampleManagedDatabaseRedis.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabaseRedis;\nimport com.pulumi.upcloud.ManagedDatabaseRedisArgs;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetManagedDatabaseRedisSessionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Use data source to gather a list of the active sessions for a Managed Redis Database\n        // Create a Managed Redis resource\n        var exampleManagedDatabaseRedis = new ManagedDatabaseRedis(\"exampleManagedDatabaseRedis\", ManagedDatabaseRedisArgs.builder()\n            .name(\"example\")\n            .title(\"example\")\n            .plan(\"1x1xCPU-2GB\")\n            .zone(\"fi-hel2\")\n            .build());\n\n        // Read the active sessions of the newly created service\n        final var example = UpcloudFunctions.getManagedDatabaseRedisSessions(GetManagedDatabaseRedisSessionsArgs.builder()\n            .service(exampleManagedDatabaseRedis.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Use data source to gather a list of the active sessions for a Managed Redis Database\n\n  # Create a Managed Redis resource\n  exampleManagedDatabaseRedis:\n    type: upcloud:ManagedDatabaseRedis\n    name: example\n    properties:\n      name: example\n      title: example\n      plan: 1x1xCPU-2GB\n      zone: fi-hel2\nvariables:\n  # Read the active sessions of the newly created service\n  example:\n    fn::invoke:\n      function: upcloud:getManagedDatabaseRedisSessions\n      arguments:\n        service: ${exampleManagedDatabaseRedis.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getManagedDatabaseRedisSessions.\n",
                "properties": {
                    "limit": {
                        "type": "integer"
                    },
                    "offset": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "sessions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabaseRedisSessionsSession:getManagedDatabaseRedisSessionsSession"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "service"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getManagedDatabaseRedisSessions.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "limit": {
                        "type": "integer"
                    },
                    "offset": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "sessions": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabaseRedisSessionsSession:getManagedDatabaseRedisSessionsSession"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "service",
                    "sessions",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getManagedDatabaseValkeySessions:getManagedDatabaseValkeySessions": {
            "description": "Current sessions of a Valkey managed database\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Use data source to gather a list of the active sessions for a Managed Valkey Database\n// Create a Managed Valkey resource\nconst exampleManagedDatabaseValkey = new upcloud.ManagedDatabaseValkey(\"example\", {\n    name: \"example\",\n    title: \"example\",\n    plan: \"1x1xCPU-2GB\",\n    zone: \"fi-hel2\",\n});\n// Read the active sessions of the newly created service\nconst example = upcloud.getManagedDatabaseValkeySessionsOutput({\n    service: exampleManagedDatabaseValkey.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Use data source to gather a list of the active sessions for a Managed Valkey Database\n# Create a Managed Valkey resource\nexample_managed_database_valkey = upcloud.ManagedDatabaseValkey(\"example\",\n    name=\"example\",\n    title=\"example\",\n    plan=\"1x1xCPU-2GB\",\n    zone=\"fi-hel2\")\n# Read the active sessions of the newly created service\nexample = upcloud.get_managed_database_valkey_sessions_output(service=example_managed_database_valkey.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Use data source to gather a list of the active sessions for a Managed Valkey Database\n    // Create a Managed Valkey resource\n    var exampleManagedDatabaseValkey = new UpCloud.ManagedDatabaseValkey(\"example\", new()\n    {\n        Name = \"example\",\n        Title = \"example\",\n        Plan = \"1x1xCPU-2GB\",\n        Zone = \"fi-hel2\",\n    });\n\n    // Read the active sessions of the newly created service\n    var example = UpCloud.GetManagedDatabaseValkeySessions.Invoke(new()\n    {\n        Service = exampleManagedDatabaseValkey.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Use data source to gather a list of the active sessions for a Managed Valkey Database\n\t\t// Create a Managed Valkey resource\n\t\texampleManagedDatabaseValkey, err := upcloud.NewManagedDatabaseValkey(ctx, \"example\", \u0026upcloud.ManagedDatabaseValkeyArgs{\n\t\t\tName:  pulumi.String(\"example\"),\n\t\t\tTitle: pulumi.String(\"example\"),\n\t\t\tPlan:  pulumi.String(\"1x1xCPU-2GB\"),\n\t\t\tZone:  pulumi.String(\"fi-hel2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Read the active sessions of the newly created service\n\t\t_ = upcloud.GetManagedDatabaseValkeySessionsOutput(ctx, upcloud.GetManagedDatabaseValkeySessionsOutputArgs{\n\t\t\tService: exampleManagedDatabaseValkey.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.ManagedDatabaseValkey;\nimport com.pulumi.upcloud.ManagedDatabaseValkeyArgs;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetManagedDatabaseValkeySessionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Use data source to gather a list of the active sessions for a Managed Valkey Database\n        // Create a Managed Valkey resource\n        var exampleManagedDatabaseValkey = new ManagedDatabaseValkey(\"exampleManagedDatabaseValkey\", ManagedDatabaseValkeyArgs.builder()\n            .name(\"example\")\n            .title(\"example\")\n            .plan(\"1x1xCPU-2GB\")\n            .zone(\"fi-hel2\")\n            .build());\n\n        // Read the active sessions of the newly created service\n        final var example = UpcloudFunctions.getManagedDatabaseValkeySessions(GetManagedDatabaseValkeySessionsArgs.builder()\n            .service(exampleManagedDatabaseValkey.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Use data source to gather a list of the active sessions for a Managed Valkey Database\n\n  # Create a Managed Valkey resource\n  exampleManagedDatabaseValkey:\n    type: upcloud:ManagedDatabaseValkey\n    name: example\n    properties:\n      name: example\n      title: example\n      plan: 1x1xCPU-2GB\n      zone: fi-hel2\nvariables:\n  # Read the active sessions of the newly created service\n  example:\n    fn::invoke:\n      function: upcloud:getManagedDatabaseValkeySessions\n      arguments:\n        service: ${exampleManagedDatabaseValkey.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getManagedDatabaseValkeySessions.\n",
                "properties": {
                    "limit": {
                        "type": "integer"
                    },
                    "offset": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "sessions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabaseValkeySessionsSession:getManagedDatabaseValkeySessionsSession"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "service"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getManagedDatabaseValkeySessions.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "limit": {
                        "type": "integer"
                    },
                    "offset": {
                        "type": "integer"
                    },
                    "order": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "sessions": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedDatabaseValkeySessionsSession:getManagedDatabaseValkeySessionsSession"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "service",
                    "sessions",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getManagedObjectStoragePolicies:getManagedObjectStoragePolicies": {
            "description": "Policies available for a Managed Object Storage resource. See `managed_object_storage_user_policy` for attaching to a user.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getManagedObjectStoragePolicies.\n",
                "properties": {
                    "serviceUuid": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "serviceUuid"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getManagedObjectStoragePolicies.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "policies": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedObjectStoragePoliciesPolicy:getManagedObjectStoragePoliciesPolicy"
                        },
                        "type": "array"
                    },
                    "serviceUuid": {
                        "type": "string"
                    }
                },
                "required": [
                    "policies",
                    "serviceUuid",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getManagedObjectStorageRegions:getManagedObjectStorageRegions": {
            "description": "Returns a list of available Managed Object Storage regions.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getManagedObjectStorageRegions.\n",
                "properties": {
                    "regions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedObjectStorageRegionsRegion:getManagedObjectStorageRegionsRegion"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getManagedObjectStorageRegions.\n",
                "properties": {
                    "id": {
                        "description": "The ID of this resource.\n",
                        "type": "string"
                    },
                    "regions": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getManagedObjectStorageRegionsRegion:getManagedObjectStorageRegionsRegion"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getNetworks:getNetworks": {
            "description": "Use this data source to get the available UpCloud networks.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworks.\n",
                "properties": {
                    "filterName": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworks.\n",
                "properties": {
                    "filterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "networks": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getNetworksNetwork:getNetworksNetwork"
                        },
                        "type": "array"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "required": [
                    "networks",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getStorage:getStorage": {
            "description": "Provides information on UpCloud [Block Storage](https://upcloud.com/products/block-storage) devices.\n\nData source can be used to map storage to other resource based on the ID or just to read some other storage property like zone information. Storage types are: `normal`, `backup`, `cdrom`, and `template`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as upcloud from \"@pulumi/upcloud\";\nimport * as upcloud from \"@upcloud/pulumi-upcloud\";\n\n// Build server with your latest custom image \n//\n// Note that when applied new updated image will cause replacement of the old server (debian.example.tld) \n// with the new server created based on the updated image.This can cause posible data loss \n// if it hasn't been taken into account when planning the service.\nconst appImage = upcloud.getStorage({\n    type: \"template\",\n    nameRegex: \"^app_image.*\",\n    mostRecent: true,\n});\nconst example = new upcloud.Server(\"example\", {\n    hostname: \"debian.example.tld\",\n    zone: \"fi-hel1\",\n    networkInterfaces: [{\n        type: \"public\",\n    }],\n    template: {\n        storage: appImage.then(appImage =\u003e appImage.id),\n    },\n});\n// Build only new servers with your latest custom image \n//\n// Use the lifecycle meta-argument to ignore changes in server's template triggered by new image version\nconst example2 = new upcloud.Server(\"example2\", {\n    hostname: \"debian.example2.tld\",\n    zone: \"fi-hel1\",\n    networkInterfaces: [{\n        type: \"public\",\n    }],\n    template: {\n        storage: appImage.then(appImage =\u003e appImage.id),\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_upcloud as upcloud\n\n# Build server with your latest custom image \n#\n# Note that when applied new updated image will cause replacement of the old server (debian.example.tld) \n# with the new server created based on the updated image.This can cause posible data loss \n# if it hasn't been taken into account when planning the service.\napp_image = upcloud.get_storage(type=\"template\",\n    name_regex=\"^app_image.*\",\n    most_recent=True)\nexample = upcloud.Server(\"example\",\n    hostname=\"debian.example.tld\",\n    zone=\"fi-hel1\",\n    network_interfaces=[{\n        \"type\": \"public\",\n    }],\n    template={\n        \"storage\": app_image.id,\n    })\n# Build only new servers with your latest custom image \n#\n# Use the lifecycle meta-argument to ignore changes in server's template triggered by new image version\nexample2 = upcloud.Server(\"example2\",\n    hostname=\"debian.example2.tld\",\n    zone=\"fi-hel1\",\n    network_interfaces=[{\n        \"type\": \"public\",\n    }],\n    template={\n        \"storage\": app_image.id,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing UpCloud = Pulumi.UpCloud;\nusing UpCloud = UpCloud.Pulumi.UpCloud;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Build server with your latest custom image \n    //\n    // Note that when applied new updated image will cause replacement of the old server (debian.example.tld) \n    // with the new server created based on the updated image.This can cause posible data loss \n    // if it hasn't been taken into account when planning the service.\n    var appImage = UpCloud.GetStorage.Invoke(new()\n    {\n        Type = \"template\",\n        NameRegex = \"^app_image.*\",\n        MostRecent = true,\n    });\n\n    var example = new UpCloud.Server(\"example\", new()\n    {\n        Hostname = \"debian.example.tld\",\n        Zone = \"fi-hel1\",\n        NetworkInterfaces = new[]\n        {\n            new UpCloud.Inputs.ServerNetworkInterfaceArgs\n            {\n                Type = \"public\",\n            },\n        },\n        Template = new UpCloud.Inputs.ServerTemplateArgs\n        {\n            Storage = appImage.Apply(getStorageResult =\u003e getStorageResult.Id),\n        },\n    });\n\n    // Build only new servers with your latest custom image \n    //\n    // Use the lifecycle meta-argument to ignore changes in server's template triggered by new image version\n    var example2 = new UpCloud.Server(\"example2\", new()\n    {\n        Hostname = \"debian.example2.tld\",\n        Zone = \"fi-hel1\",\n        NetworkInterfaces = new[]\n        {\n            new UpCloud.Inputs.ServerNetworkInterfaceArgs\n            {\n                Type = \"public\",\n            },\n        },\n        Template = new UpCloud.Inputs.ServerTemplateArgs\n        {\n            Storage = appImage.Apply(getStorageResult =\u003e getStorageResult.Id),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Build server with your latest custom image\n\t\t//\n\t\t// Note that when applied new updated image will cause replacement of the old server (debian.example.tld)\n\t\t// with the new server created based on the updated image.This can cause posible data loss\n\t\t// if it hasn't been taken into account when planning the service.\n\t\tappImage, err := upcloud.LookupStorage(ctx, \u0026upcloud.LookupStorageArgs{\n\t\t\tType:       pulumi.StringRef(\"template\"),\n\t\t\tNameRegex:  pulumi.StringRef(\"^app_image.*\"),\n\t\t\tMostRecent: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = upcloud.NewServer(ctx, \"example\", \u0026upcloud.ServerArgs{\n\t\t\tHostname: pulumi.String(\"debian.example.tld\"),\n\t\t\tZone:     pulumi.String(\"fi-hel1\"),\n\t\t\tNetworkInterfaces: upcloud.ServerNetworkInterfaceArray{\n\t\t\t\t\u0026upcloud.ServerNetworkInterfaceArgs{\n\t\t\t\t\tType: pulumi.String(\"public\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTemplate: \u0026upcloud.ServerTemplateArgs{\n\t\t\t\tStorage: pulumi.String(appImage.Id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Build only new servers with your latest custom image\n\t\t//\n\t\t// Use the lifecycle meta-argument to ignore changes in server's template triggered by new image version\n\t\t_, err = upcloud.NewServer(ctx, \"example2\", \u0026upcloud.ServerArgs{\n\t\t\tHostname: pulumi.String(\"debian.example2.tld\"),\n\t\t\tZone:     pulumi.String(\"fi-hel1\"),\n\t\t\tNetworkInterfaces: upcloud.ServerNetworkInterfaceArray{\n\t\t\t\t\u0026upcloud.ServerNetworkInterfaceArgs{\n\t\t\t\t\tType: pulumi.String(\"public\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tTemplate: \u0026upcloud.ServerTemplateArgs{\n\t\t\t\tStorage: pulumi.String(appImage.Id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.upcloud.UpcloudFunctions;\nimport com.pulumi.upcloud.inputs.GetStorageArgs;\nimport com.pulumi.upcloud.Server;\nimport com.pulumi.upcloud.ServerArgs;\nimport com.pulumi.upcloud.inputs.ServerNetworkInterfaceArgs;\nimport com.pulumi.upcloud.inputs.ServerTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Build server with your latest custom image \n        //\n        // Note that when applied new updated image will cause replacement of the old server (debian.example.tld) \n        // with the new server created based on the updated image.This can cause posible data loss \n        // if it hasn't been taken into account when planning the service.\n        final var appImage = UpcloudFunctions.getStorage(GetStorageArgs.builder()\n            .type(\"template\")\n            .nameRegex(\"^app_image.*\")\n            .mostRecent(true)\n            .build());\n\n        var example = new Server(\"example\", ServerArgs.builder()\n            .hostname(\"debian.example.tld\")\n            .zone(\"fi-hel1\")\n            .networkInterfaces(ServerNetworkInterfaceArgs.builder()\n                .type(\"public\")\n                .build())\n            .template(ServerTemplateArgs.builder()\n                .storage(appImage.id())\n                .build())\n            .build());\n\n        // Build only new servers with your latest custom image \n        //\n        // Use the lifecycle meta-argument to ignore changes in server's template triggered by new image version\n        var example2 = new Server(\"example2\", ServerArgs.builder()\n            .hostname(\"debian.example2.tld\")\n            .zone(\"fi-hel1\")\n            .networkInterfaces(ServerNetworkInterfaceArgs.builder()\n                .type(\"public\")\n                .build())\n            .template(ServerTemplateArgs.builder()\n                .storage(appImage.id())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: upcloud:Server\n    properties:\n      hostname: debian.example.tld\n      zone: fi-hel1\n      networkInterfaces:\n        - type: public\n      template:\n        storage: ${appImage.id}\n  # Build only new servers with your latest custom image \n  #\n  # Use the lifecycle meta-argument to ignore changes in server's template triggered by new image version\n  example2:\n    type: upcloud:Server\n    properties:\n      hostname: debian.example2.tld\n      zone: fi-hel1\n      networkInterfaces:\n        - type: public\n      template:\n        storage: ${appImage.id}\nvariables:\n  # Build server with your latest custom image \n  #\n  # Note that when applied new updated image will cause replacement of the old server (debian.example.tld) \n  # with the new server created based on the updated image.This can cause posible data loss \n  # if it hasn't been taken into account when planning the service.\n  appImage:\n    fn::invoke:\n      function: upcloud:getStorage\n      arguments:\n        type: template\n        nameRegex: ^app_image.*\n        mostRecent: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getStorage.\n",
                "properties": {
                    "accessType": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "mostRecent": {
                        "type": "boolean",
                        "deprecationMessage": "Use exact title or UUID to limit the number of matching storages. Note that if you have multiple storages with the same title, you should use UUID to select the storage."
                    },
                    "name": {
                        "type": "string",
                        "deprecationMessage": "Contains the same value as `title`. Use `title` instead."
                    },
                    "nameRegex": {
                        "type": "string",
                        "deprecationMessage": "Use exact title or UUID instead."
                    },
                    "title": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getStorage.\n",
                "properties": {
                    "accessType": {
                        "type": "string"
                    },
                    "encrypt": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string"
                    },
                    "labels": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "mostRecent": {
                        "deprecationMessage": "Use exact title or UUID to limit the number of matching storages. Note that if you have multiple storages with the same title, you should use UUID to select the storage.",
                        "type": "boolean"
                    },
                    "name": {
                        "deprecationMessage": "Contains the same value as `title`. Use `title` instead.",
                        "type": "string"
                    },
                    "nameRegex": {
                        "deprecationMessage": "Use exact title or UUID instead.",
                        "type": "string"
                    },
                    "size": {
                        "type": "integer"
                    },
                    "state": {
                        "type": "string"
                    },
                    "systemLabels": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "tier": {
                        "type": "string"
                    },
                    "title": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "zone": {
                        "type": "string"
                    }
                },
                "required": [
                    "accessType",
                    "encrypt",
                    "id",
                    "labels",
                    "size",
                    "state",
                    "systemLabels",
                    "tier",
                    "title",
                    "type",
                    "zone"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getTags:getTags": {
            "description": "Data-source is deprecated.\n",
            "outputs": {
                "description": "A collection of values returned by getTags.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "tags": {
                        "items": {
                            "$ref": "#/types/upcloud:index/getTagsTag:getTagsTag"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "tags",
                    "id"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getZone:getZone": {
            "description": "Provides details on given zone.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZone.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "deprecationMessage": "Contains the same value as `id`. Use `id` instead."
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getZone.\n",
                "properties": {
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "deprecationMessage": "Contains the same value as `id`. Use `id` instead.",
                        "type": "string"
                    },
                    "parentZone": {
                        "type": "string"
                    },
                    "public": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "description",
                    "id",
                    "name",
                    "parentZone",
                    "public"
                ],
                "type": "object"
            }
        },
        "upcloud:index/getZones:getZones": {
            "description": "Returns a list of available UpCloud zones.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getZones.\n",
                "properties": {
                    "filterType": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getZones.\n",
                "properties": {
                    "filterType": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "zoneIds": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "id",
                    "zoneIds"
                ],
                "type": "object"
            }
        }
    }
}