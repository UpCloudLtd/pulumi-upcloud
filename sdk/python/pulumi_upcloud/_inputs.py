# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'GatewayAddressArgs',
    'GatewayAddressArgsDict',
    'GatewayConnectionLocalRouteArgs',
    'GatewayConnectionLocalRouteArgsDict',
    'GatewayConnectionRemoteRouteArgs',
    'GatewayConnectionRemoteRouteArgsDict',
    'GatewayConnectionTunnelIpsecAuthPskArgs',
    'GatewayConnectionTunnelIpsecAuthPskArgsDict',
    'GatewayConnectionTunnelIpsecPropertiesArgs',
    'GatewayConnectionTunnelIpsecPropertiesArgsDict',
    'GatewayRouterArgs',
    'GatewayRouterArgsDict',
    'KubernetesNodeGroupCustomPlanArgs',
    'KubernetesNodeGroupCustomPlanArgsDict',
    'KubernetesNodeGroupKubeletArgArgs',
    'KubernetesNodeGroupKubeletArgArgsDict',
    'KubernetesNodeGroupTaintArgs',
    'KubernetesNodeGroupTaintArgsDict',
    'LoadbalancerBackendPropertiesArgs',
    'LoadbalancerBackendPropertiesArgsDict',
    'LoadbalancerFrontendNetworkArgs',
    'LoadbalancerFrontendNetworkArgsDict',
    'LoadbalancerFrontendPropertiesArgs',
    'LoadbalancerFrontendPropertiesArgsDict',
    'LoadbalancerFrontendRuleActionsArgs',
    'LoadbalancerFrontendRuleActionsArgsDict',
    'LoadbalancerFrontendRuleActionsHttpRedirectArgs',
    'LoadbalancerFrontendRuleActionsHttpRedirectArgsDict',
    'LoadbalancerFrontendRuleActionsHttpReturnArgs',
    'LoadbalancerFrontendRuleActionsHttpReturnArgsDict',
    'LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs',
    'LoadbalancerFrontendRuleActionsSetForwardedHeaderArgsDict',
    'LoadbalancerFrontendRuleActionsSetRequestHeaderArgs',
    'LoadbalancerFrontendRuleActionsSetRequestHeaderArgsDict',
    'LoadbalancerFrontendRuleActionsSetResponseHeaderArgs',
    'LoadbalancerFrontendRuleActionsSetResponseHeaderArgsDict',
    'LoadbalancerFrontendRuleActionsTcpRejectArgs',
    'LoadbalancerFrontendRuleActionsTcpRejectArgsDict',
    'LoadbalancerFrontendRuleActionsUseBackendArgs',
    'LoadbalancerFrontendRuleActionsUseBackendArgsDict',
    'LoadbalancerFrontendRuleMatchersArgs',
    'LoadbalancerFrontendRuleMatchersArgsDict',
    'LoadbalancerFrontendRuleMatchersBodySizeArgs',
    'LoadbalancerFrontendRuleMatchersBodySizeArgsDict',
    'LoadbalancerFrontendRuleMatchersBodySizeRangeArgs',
    'LoadbalancerFrontendRuleMatchersBodySizeRangeArgsDict',
    'LoadbalancerFrontendRuleMatchersCookieArgs',
    'LoadbalancerFrontendRuleMatchersCookieArgsDict',
    'LoadbalancerFrontendRuleMatchersHeaderArgs',
    'LoadbalancerFrontendRuleMatchersHeaderArgsDict',
    'LoadbalancerFrontendRuleMatchersHostArgs',
    'LoadbalancerFrontendRuleMatchersHostArgsDict',
    'LoadbalancerFrontendRuleMatchersHttpMethodArgs',
    'LoadbalancerFrontendRuleMatchersHttpMethodArgsDict',
    'LoadbalancerFrontendRuleMatchersHttpStatusArgs',
    'LoadbalancerFrontendRuleMatchersHttpStatusArgsDict',
    'LoadbalancerFrontendRuleMatchersHttpStatusRangeArgs',
    'LoadbalancerFrontendRuleMatchersHttpStatusRangeArgsDict',
    'LoadbalancerFrontendRuleMatchersNumMembersUpArgs',
    'LoadbalancerFrontendRuleMatchersNumMembersUpArgsDict',
    'LoadbalancerFrontendRuleMatchersPathArgs',
    'LoadbalancerFrontendRuleMatchersPathArgsDict',
    'LoadbalancerFrontendRuleMatchersRequestHeaderArgs',
    'LoadbalancerFrontendRuleMatchersRequestHeaderArgsDict',
    'LoadbalancerFrontendRuleMatchersResponseHeaderArgs',
    'LoadbalancerFrontendRuleMatchersResponseHeaderArgsDict',
    'LoadbalancerFrontendRuleMatchersSrcIpArgs',
    'LoadbalancerFrontendRuleMatchersSrcIpArgsDict',
    'LoadbalancerFrontendRuleMatchersSrcPortArgs',
    'LoadbalancerFrontendRuleMatchersSrcPortArgsDict',
    'LoadbalancerFrontendRuleMatchersSrcPortRangeArgs',
    'LoadbalancerFrontendRuleMatchersSrcPortRangeArgsDict',
    'LoadbalancerFrontendRuleMatchersUrlArgs',
    'LoadbalancerFrontendRuleMatchersUrlArgsDict',
    'LoadbalancerFrontendRuleMatchersUrlParamArgs',
    'LoadbalancerFrontendRuleMatchersUrlParamArgsDict',
    'LoadbalancerFrontendRuleMatchersUrlQueryArgs',
    'LoadbalancerFrontendRuleMatchersUrlQueryArgsDict',
    'LoadbalancerNetworkArgs',
    'LoadbalancerNetworkArgsDict',
    'LoadbalancerNodeArgs',
    'LoadbalancerNodeArgsDict',
    'LoadbalancerNodeNetworkArgs',
    'LoadbalancerNodeNetworkArgsDict',
    'LoadbalancerNodeNetworkIpAddressArgs',
    'LoadbalancerNodeNetworkIpAddressArgsDict',
    'ManagedDatabaseMysqlComponentArgs',
    'ManagedDatabaseMysqlComponentArgsDict',
    'ManagedDatabaseMysqlNetworkArgs',
    'ManagedDatabaseMysqlNetworkArgsDict',
    'ManagedDatabaseMysqlNodeStateArgs',
    'ManagedDatabaseMysqlNodeStateArgsDict',
    'ManagedDatabaseMysqlPropertiesArgs',
    'ManagedDatabaseMysqlPropertiesArgsDict',
    'ManagedDatabaseMysqlPropertiesMigrationArgs',
    'ManagedDatabaseMysqlPropertiesMigrationArgsDict',
    'ManagedDatabaseOpensearchComponentArgs',
    'ManagedDatabaseOpensearchComponentArgsDict',
    'ManagedDatabaseOpensearchNetworkArgs',
    'ManagedDatabaseOpensearchNetworkArgsDict',
    'ManagedDatabaseOpensearchNodeStateArgs',
    'ManagedDatabaseOpensearchNodeStateArgsDict',
    'ManagedDatabaseOpensearchPropertiesArgs',
    'ManagedDatabaseOpensearchPropertiesArgsDict',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgsDict',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgsDict',
    'ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgs',
    'ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgsDict',
    'ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgs',
    'ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgsDict',
    'ManagedDatabaseOpensearchPropertiesDiskWatermarksArgs',
    'ManagedDatabaseOpensearchPropertiesDiskWatermarksArgsDict',
    'ManagedDatabaseOpensearchPropertiesIndexRollupArgs',
    'ManagedDatabaseOpensearchPropertiesIndexRollupArgsDict',
    'ManagedDatabaseOpensearchPropertiesIndexTemplateArgs',
    'ManagedDatabaseOpensearchPropertiesIndexTemplateArgsDict',
    'ManagedDatabaseOpensearchPropertiesOpenidArgs',
    'ManagedDatabaseOpensearchPropertiesOpenidArgsDict',
    'ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs',
    'ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgsDict',
    'ManagedDatabaseOpensearchPropertiesSamlArgs',
    'ManagedDatabaseOpensearchPropertiesSamlArgsDict',
    'ManagedDatabaseOpensearchPropertiesSearchBackpressureArgs',
    'ManagedDatabaseOpensearchPropertiesSearchBackpressureArgsDict',
    'ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgs',
    'ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgsDict',
    'ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgs',
    'ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgsDict',
    'ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgs',
    'ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgsDict',
    'ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgs',
    'ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgsDict',
    'ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgs',
    'ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgsDict',
    'ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgs',
    'ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgsDict',
    'ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgs',
    'ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgsDict',
    'ManagedDatabaseOpensearchPropertiesSegrepArgs',
    'ManagedDatabaseOpensearchPropertiesSegrepArgsDict',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgs',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgsDict',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgs',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgsDict',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgs',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgsDict',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgs',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgsDict',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgs',
    'ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgsDict',
    'ManagedDatabasePostgresqlComponentArgs',
    'ManagedDatabasePostgresqlComponentArgsDict',
    'ManagedDatabasePostgresqlNetworkArgs',
    'ManagedDatabasePostgresqlNetworkArgsDict',
    'ManagedDatabasePostgresqlNodeStateArgs',
    'ManagedDatabasePostgresqlNodeStateArgsDict',
    'ManagedDatabasePostgresqlPropertiesArgs',
    'ManagedDatabasePostgresqlPropertiesArgsDict',
    'ManagedDatabasePostgresqlPropertiesMigrationArgs',
    'ManagedDatabasePostgresqlPropertiesMigrationArgsDict',
    'ManagedDatabasePostgresqlPropertiesPgauditArgs',
    'ManagedDatabasePostgresqlPropertiesPgauditArgsDict',
    'ManagedDatabasePostgresqlPropertiesPgbouncerArgs',
    'ManagedDatabasePostgresqlPropertiesPgbouncerArgsDict',
    'ManagedDatabasePostgresqlPropertiesPglookoutArgs',
    'ManagedDatabasePostgresqlPropertiesPglookoutArgsDict',
    'ManagedDatabasePostgresqlPropertiesTimescaledbArgs',
    'ManagedDatabasePostgresqlPropertiesTimescaledbArgsDict',
    'ManagedDatabaseRedisComponentArgs',
    'ManagedDatabaseRedisComponentArgsDict',
    'ManagedDatabaseRedisNetworkArgs',
    'ManagedDatabaseRedisNetworkArgsDict',
    'ManagedDatabaseRedisNodeStateArgs',
    'ManagedDatabaseRedisNodeStateArgsDict',
    'ManagedDatabaseRedisPropertiesArgs',
    'ManagedDatabaseRedisPropertiesArgsDict',
    'ManagedDatabaseRedisPropertiesMigrationArgs',
    'ManagedDatabaseRedisPropertiesMigrationArgsDict',
    'ManagedDatabaseUserOpensearchAccessControlArgs',
    'ManagedDatabaseUserOpensearchAccessControlArgsDict',
    'ManagedDatabaseUserOpensearchAccessControlRuleArgs',
    'ManagedDatabaseUserOpensearchAccessControlRuleArgsDict',
    'ManagedDatabaseUserPgAccessControlArgs',
    'ManagedDatabaseUserPgAccessControlArgsDict',
    'ManagedDatabaseUserRedisAccessControlArgs',
    'ManagedDatabaseUserRedisAccessControlArgsDict',
    'ManagedDatabaseUserValkeyAccessControlArgs',
    'ManagedDatabaseUserValkeyAccessControlArgsDict',
    'ManagedDatabaseValkeyComponentArgs',
    'ManagedDatabaseValkeyComponentArgsDict',
    'ManagedDatabaseValkeyNetworkArgs',
    'ManagedDatabaseValkeyNetworkArgsDict',
    'ManagedDatabaseValkeyNodeStateArgs',
    'ManagedDatabaseValkeyNodeStateArgsDict',
    'ManagedDatabaseValkeyPropertiesArgs',
    'ManagedDatabaseValkeyPropertiesArgsDict',
    'ManagedDatabaseValkeyPropertiesMigrationArgs',
    'ManagedDatabaseValkeyPropertiesMigrationArgsDict',
    'ManagedObjectStorageEndpointArgs',
    'ManagedObjectStorageEndpointArgsDict',
    'ManagedObjectStorageNetworkArgs',
    'ManagedObjectStorageNetworkArgsDict',
    'NetworkIpNetworkArgs',
    'NetworkIpNetworkArgsDict',
    'NetworkPeeringNetworkArgs',
    'NetworkPeeringNetworkArgsDict',
    'NetworkPeeringPeerNetworkArgs',
    'NetworkPeeringPeerNetworkArgsDict',
    'ObjectStorageBucketArgs',
    'ObjectStorageBucketArgsDict',
    'RouterStaticRouteArgs',
    'RouterStaticRouteArgsDict',
    'ServerFirewallRulesFirewallRuleArgs',
    'ServerFirewallRulesFirewallRuleArgsDict',
    'ServerLoginArgs',
    'ServerLoginArgsDict',
    'ServerNetworkInterfaceArgs',
    'ServerNetworkInterfaceArgsDict',
    'ServerNetworkInterfaceAdditionalIpAddressArgs',
    'ServerNetworkInterfaceAdditionalIpAddressArgsDict',
    'ServerSimpleBackupArgs',
    'ServerSimpleBackupArgsDict',
    'ServerStorageDeviceArgs',
    'ServerStorageDeviceArgsDict',
    'ServerTemplateArgs',
    'ServerTemplateArgsDict',
    'ServerTemplateBackupRuleArgs',
    'ServerTemplateBackupRuleArgsDict',
    'StorageBackupRuleArgs',
    'StorageBackupRuleArgsDict',
    'StorageCloneArgs',
    'StorageCloneArgsDict',
    'StorageImportArgs',
    'StorageImportArgsDict',
    'GetHostsHostArgs',
    'GetHostsHostArgsDict',
    'GetHostsHostStatisticArgs',
    'GetHostsHostStatisticArgsDict',
    'GetIpAddressesAddressArgs',
    'GetIpAddressesAddressArgsDict',
    'GetManagedDatabaseMysqlSessionsSessionArgs',
    'GetManagedDatabaseMysqlSessionsSessionArgsDict',
    'GetManagedDatabaseOpensearchIndicesIndexArgs',
    'GetManagedDatabaseOpensearchIndicesIndexArgsDict',
    'GetManagedDatabasePostgresqlSessionsSessionArgs',
    'GetManagedDatabasePostgresqlSessionsSessionArgsDict',
    'GetManagedDatabaseRedisSessionsSessionArgs',
    'GetManagedDatabaseRedisSessionsSessionArgsDict',
    'GetManagedDatabaseValkeySessionsSessionArgs',
    'GetManagedDatabaseValkeySessionsSessionArgsDict',
    'GetManagedObjectStorageRegionsRegionArgs',
    'GetManagedObjectStorageRegionsRegionArgsDict',
]

MYPY = False

if not MYPY:
    class GatewayAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[builtins.str]]
        """
        IP addresss
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the IP address
        """
elif False:
    GatewayAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] address: IP addresss
        :param pulumi.Input[builtins.str] name: Name of the IP address
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP addresss
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewayConnectionLocalRouteArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the route
        """
        static_network: pulumi.Input[builtins.str]
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of route; currently the only supported type is 'static'
        """
elif False:
    GatewayConnectionLocalRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayConnectionLocalRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 static_network: pulumi.Input[builtins.str],
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the route
        :param pulumi.Input[builtins.str] static_network: Destination prefix of the route; needs to be a valid IPv4 prefix
        :param pulumi.Input[builtins.str] type: Type of route; currently the only supported type is 'static'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "static_network", static_network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the route
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="staticNetwork")
    def static_network(self) -> pulumi.Input[builtins.str]:
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        return pulumi.get(self, "static_network")

    @static_network.setter
    def static_network(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "static_network", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of route; currently the only supported type is 'static'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayConnectionRemoteRouteArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the route
        """
        static_network: pulumi.Input[builtins.str]
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of route; currently the only supported type is 'static'
        """
elif False:
    GatewayConnectionRemoteRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayConnectionRemoteRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 static_network: pulumi.Input[builtins.str],
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the route
        :param pulumi.Input[builtins.str] static_network: Destination prefix of the route; needs to be a valid IPv4 prefix
        :param pulumi.Input[builtins.str] type: Type of route; currently the only supported type is 'static'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "static_network", static_network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the route
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="staticNetwork")
    def static_network(self) -> pulumi.Input[builtins.str]:
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        return pulumi.get(self, "static_network")

    @static_network.setter
    def static_network(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "static_network", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of route; currently the only supported type is 'static'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayConnectionTunnelIpsecAuthPskArgsDict(TypedDict):
        psk: pulumi.Input[builtins.str]
        """
        The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.
        """
elif False:
    GatewayConnectionTunnelIpsecAuthPskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayConnectionTunnelIpsecAuthPskArgs:
    def __init__(__self__, *,
                 psk: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] psk: The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.
        """
        pulumi.set(__self__, "psk", psk)

    @property
    @pulumi.getter
    def psk(self) -> pulumi.Input[builtins.str]:
        """
        The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.
        """
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "psk", value)


if not MYPY:
    class GatewayConnectionTunnelIpsecPropertiesArgsDict(TypedDict):
        child_rekey_time: NotRequired[pulumi.Input[builtins.int]]
        """
        IKE child SA rekey time in seconds.
        """
        dpd_delay: NotRequired[pulumi.Input[builtins.int]]
        """
        Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.
        """
        dpd_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Timeout period for DPD reply before considering the peer to be dead, in seconds.
        """
        ike_lifetime: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum IKE SA lifetime in seconds.
        """
        phase1_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of Phase 1: Proposal algorithms.
        """
        phase1_dh_group_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        List of Phase 1 Diffie-Hellman group numbers.
        """
        phase1_integrity_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of Phase 1 integrity algorithms.
        """
        phase2_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of Phase 2: Security Association algorithms.
        """
        phase2_dh_group_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        List of Phase 2 Diffie-Hellman group numbers.
        """
        phase2_integrity_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of Phase 2 integrity algorithms.
        """
        rekey_time: NotRequired[pulumi.Input[builtins.int]]
        """
        IKE SA rekey time in seconds.
        """
elif False:
    GatewayConnectionTunnelIpsecPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayConnectionTunnelIpsecPropertiesArgs:
    def __init__(__self__, *,
                 child_rekey_time: Optional[pulumi.Input[builtins.int]] = None,
                 dpd_delay: Optional[pulumi.Input[builtins.int]] = None,
                 dpd_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 ike_lifetime: Optional[pulumi.Input[builtins.int]] = None,
                 phase1_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 phase1_dh_group_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 phase1_integrity_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 phase2_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 phase2_dh_group_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 phase2_integrity_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rekey_time: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] child_rekey_time: IKE child SA rekey time in seconds.
        :param pulumi.Input[builtins.int] dpd_delay: Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.
        :param pulumi.Input[builtins.int] dpd_timeout: Timeout period for DPD reply before considering the peer to be dead, in seconds.
        :param pulumi.Input[builtins.int] ike_lifetime: Maximum IKE SA lifetime in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] phase1_algorithms: List of Phase 1: Proposal algorithms.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] phase1_dh_group_numbers: List of Phase 1 Diffie-Hellman group numbers.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] phase1_integrity_algorithms: List of Phase 1 integrity algorithms.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] phase2_algorithms: List of Phase 2: Security Association algorithms.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] phase2_dh_group_numbers: List of Phase 2 Diffie-Hellman group numbers.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] phase2_integrity_algorithms: List of Phase 2 integrity algorithms.
        :param pulumi.Input[builtins.int] rekey_time: IKE SA rekey time in seconds.
        """
        if child_rekey_time is not None:
            pulumi.set(__self__, "child_rekey_time", child_rekey_time)
        if dpd_delay is not None:
            pulumi.set(__self__, "dpd_delay", dpd_delay)
        if dpd_timeout is not None:
            pulumi.set(__self__, "dpd_timeout", dpd_timeout)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if phase1_algorithms is not None:
            pulumi.set(__self__, "phase1_algorithms", phase1_algorithms)
        if phase1_dh_group_numbers is not None:
            pulumi.set(__self__, "phase1_dh_group_numbers", phase1_dh_group_numbers)
        if phase1_integrity_algorithms is not None:
            pulumi.set(__self__, "phase1_integrity_algorithms", phase1_integrity_algorithms)
        if phase2_algorithms is not None:
            pulumi.set(__self__, "phase2_algorithms", phase2_algorithms)
        if phase2_dh_group_numbers is not None:
            pulumi.set(__self__, "phase2_dh_group_numbers", phase2_dh_group_numbers)
        if phase2_integrity_algorithms is not None:
            pulumi.set(__self__, "phase2_integrity_algorithms", phase2_integrity_algorithms)
        if rekey_time is not None:
            pulumi.set(__self__, "rekey_time", rekey_time)

    @property
    @pulumi.getter(name="childRekeyTime")
    def child_rekey_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        IKE child SA rekey time in seconds.
        """
        return pulumi.get(self, "child_rekey_time")

    @child_rekey_time.setter
    def child_rekey_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "child_rekey_time", value)

    @property
    @pulumi.getter(name="dpdDelay")
    def dpd_delay(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.
        """
        return pulumi.get(self, "dpd_delay")

    @dpd_delay.setter
    def dpd_delay(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dpd_delay", value)

    @property
    @pulumi.getter(name="dpdTimeout")
    def dpd_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Timeout period for DPD reply before considering the peer to be dead, in seconds.
        """
        return pulumi.get(self, "dpd_timeout")

    @dpd_timeout.setter
    def dpd_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dpd_timeout", value)

    @property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum IKE SA lifetime in seconds.
        """
        return pulumi.get(self, "ike_lifetime")

    @ike_lifetime.setter
    def ike_lifetime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ike_lifetime", value)

    @property
    @pulumi.getter(name="phase1Algorithms")
    def phase1_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of Phase 1: Proposal algorithms.
        """
        return pulumi.get(self, "phase1_algorithms")

    @phase1_algorithms.setter
    def phase1_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "phase1_algorithms", value)

    @property
    @pulumi.getter(name="phase1DhGroupNumbers")
    def phase1_dh_group_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        List of Phase 1 Diffie-Hellman group numbers.
        """
        return pulumi.get(self, "phase1_dh_group_numbers")

    @phase1_dh_group_numbers.setter
    def phase1_dh_group_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "phase1_dh_group_numbers", value)

    @property
    @pulumi.getter(name="phase1IntegrityAlgorithms")
    def phase1_integrity_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of Phase 1 integrity algorithms.
        """
        return pulumi.get(self, "phase1_integrity_algorithms")

    @phase1_integrity_algorithms.setter
    def phase1_integrity_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "phase1_integrity_algorithms", value)

    @property
    @pulumi.getter(name="phase2Algorithms")
    def phase2_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of Phase 2: Security Association algorithms.
        """
        return pulumi.get(self, "phase2_algorithms")

    @phase2_algorithms.setter
    def phase2_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "phase2_algorithms", value)

    @property
    @pulumi.getter(name="phase2DhGroupNumbers")
    def phase2_dh_group_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        List of Phase 2 Diffie-Hellman group numbers.
        """
        return pulumi.get(self, "phase2_dh_group_numbers")

    @phase2_dh_group_numbers.setter
    def phase2_dh_group_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "phase2_dh_group_numbers", value)

    @property
    @pulumi.getter(name="phase2IntegrityAlgorithms")
    def phase2_integrity_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of Phase 2 integrity algorithms.
        """
        return pulumi.get(self, "phase2_integrity_algorithms")

    @phase2_integrity_algorithms.setter
    def phase2_integrity_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "phase2_integrity_algorithms", value)

    @property
    @pulumi.getter(name="rekeyTime")
    def rekey_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        IKE SA rekey time in seconds.
        """
        return pulumi.get(self, "rekey_time")

    @rekey_time.setter
    def rekey_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rekey_time", value)


if not MYPY:
    class GatewayRouterArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        ID of the router attached to the gateway.
        """
elif False:
    GatewayRouterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] id: ID of the router attached to the gateway.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        ID of the router attached to the gateway.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class KubernetesNodeGroupCustomPlanArgsDict(TypedDict):
        cores: pulumi.Input[builtins.int]
        """
        The number of CPU cores dedicated to individual node group nodes when using custom plan
        """
        memory: pulumi.Input[builtins.int]
        """
        The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
        """
        storage_size: pulumi.Input[builtins.int]
        """
        The size of the storage device in gigabytes.
        """
        storage_tier: NotRequired[pulumi.Input[builtins.str]]
        """
        The storage tier to use. Defaults to maxiops
        """
elif False:
    KubernetesNodeGroupCustomPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupCustomPlanArgs:
    def __init__(__self__, *,
                 cores: pulumi.Input[builtins.int],
                 memory: pulumi.Input[builtins.int],
                 storage_size: pulumi.Input[builtins.int],
                 storage_tier: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] cores: The number of CPU cores dedicated to individual node group nodes when using custom plan
        :param pulumi.Input[builtins.int] memory: The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
        :param pulumi.Input[builtins.int] storage_size: The size of the storage device in gigabytes.
        :param pulumi.Input[builtins.str] storage_tier: The storage tier to use. Defaults to maxiops
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "storage_size", storage_size)
        if storage_tier is not None:
            pulumi.set(__self__, "storage_tier", storage_tier)

    @property
    @pulumi.getter
    def cores(self) -> pulumi.Input[builtins.int]:
        """
        The number of CPU cores dedicated to individual node group nodes when using custom plan
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[builtins.int]:
        """
        The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> pulumi.Input[builtins.int]:
        """
        The size of the storage device in gigabytes.
        """
        return pulumi.get(self, "storage_size")

    @storage_size.setter
    def storage_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "storage_size", value)

    @property
    @pulumi.getter(name="storageTier")
    def storage_tier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The storage tier to use. Defaults to maxiops
        """
        return pulumi.get(self, "storage_tier")

    @storage_tier.setter
    def storage_tier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_tier", value)


if not MYPY:
    class KubernetesNodeGroupKubeletArgArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Kubelet argument key.
        """
        value: pulumi.Input[builtins.str]
        """
        Kubelet argument value.
        """
elif False:
    KubernetesNodeGroupKubeletArgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupKubeletArgArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: Kubelet argument key.
        :param pulumi.Input[builtins.str] value: Kubelet argument value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Kubelet argument key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Kubelet argument value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class KubernetesNodeGroupTaintArgsDict(TypedDict):
        effect: pulumi.Input[builtins.str]
        """
        Taint effect.
        """
        key: pulumi.Input[builtins.str]
        """
        Taint key.
        """
        value: pulumi.Input[builtins.str]
        """
        Taint value.
        """
elif False:
    KubernetesNodeGroupTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] effect: Taint effect.
        :param pulumi.Input[builtins.str] key: Taint key.
        :param pulumi.Input[builtins.str] value: Taint value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[builtins.str]:
        """
        Taint effect.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Taint key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerBackendPropertiesArgsDict(TypedDict):
        health_check_expected_status: NotRequired[pulumi.Input[builtins.int]]
        """
        Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.
        """
        health_check_fall: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets how many failed health checks are allowed until the backend member is taken off from the rotation.
        """
        health_check_interval: NotRequired[pulumi.Input[builtins.int]]
        """
        Interval between health checks in seconds.
        """
        health_check_rise: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets how many successful health checks are required to put the backend member back into rotation.
        """
        health_check_tls_verify: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.
        """
        health_check_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Health check type.
        """
        health_check_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.
        """
        http2_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.
        """
        outbound_proxy_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.
        """
        sticky_session_cookie_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Sets sticky session cookie name. Empty string disables sticky session.
        """
        timeout_server: NotRequired[pulumi.Input[builtins.int]]
        """
        Backend server timeout in seconds.
        """
        timeout_tunnel: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum inactivity time on the client and server side for tunnels in seconds.
        """
        tls_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables TLS connection from the load balancer to backend servers.
        """
        tls_use_system_ca: NotRequired[pulumi.Input[builtins.bool]]
        """
        If enabled, then the system CA certificate bundle will be used for the certificate verification.
        """
        tls_verify: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.
        """
elif False:
    LoadbalancerBackendPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerBackendPropertiesArgs:
    def __init__(__self__, *,
                 health_check_expected_status: Optional[pulumi.Input[builtins.int]] = None,
                 health_check_fall: Optional[pulumi.Input[builtins.int]] = None,
                 health_check_interval: Optional[pulumi.Input[builtins.int]] = None,
                 health_check_rise: Optional[pulumi.Input[builtins.int]] = None,
                 health_check_tls_verify: Optional[pulumi.Input[builtins.bool]] = None,
                 health_check_type: Optional[pulumi.Input[builtins.str]] = None,
                 health_check_url: Optional[pulumi.Input[builtins.str]] = None,
                 http2_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 outbound_proxy_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 sticky_session_cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 timeout_server: Optional[pulumi.Input[builtins.int]] = None,
                 timeout_tunnel: Optional[pulumi.Input[builtins.int]] = None,
                 tls_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 tls_use_system_ca: Optional[pulumi.Input[builtins.bool]] = None,
                 tls_verify: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] health_check_expected_status: Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.
        :param pulumi.Input[builtins.int] health_check_fall: Sets how many failed health checks are allowed until the backend member is taken off from the rotation.
        :param pulumi.Input[builtins.int] health_check_interval: Interval between health checks in seconds.
        :param pulumi.Input[builtins.int] health_check_rise: Sets how many successful health checks are required to put the backend member back into rotation.
        :param pulumi.Input[builtins.bool] health_check_tls_verify: Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.
        :param pulumi.Input[builtins.str] health_check_type: Health check type.
        :param pulumi.Input[builtins.str] health_check_url: Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.
        :param pulumi.Input[builtins.bool] http2_enabled: Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.
        :param pulumi.Input[builtins.str] outbound_proxy_protocol: Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.
        :param pulumi.Input[builtins.str] sticky_session_cookie_name: Sets sticky session cookie name. Empty string disables sticky session.
        :param pulumi.Input[builtins.int] timeout_server: Backend server timeout in seconds.
        :param pulumi.Input[builtins.int] timeout_tunnel: Maximum inactivity time on the client and server side for tunnels in seconds.
        :param pulumi.Input[builtins.bool] tls_enabled: Enables TLS connection from the load balancer to backend servers.
        :param pulumi.Input[builtins.bool] tls_use_system_ca: If enabled, then the system CA certificate bundle will be used for the certificate verification.
        :param pulumi.Input[builtins.bool] tls_verify: Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.
        """
        if health_check_expected_status is not None:
            pulumi.set(__self__, "health_check_expected_status", health_check_expected_status)
        if health_check_fall is not None:
            pulumi.set(__self__, "health_check_fall", health_check_fall)
        if health_check_interval is not None:
            pulumi.set(__self__, "health_check_interval", health_check_interval)
        if health_check_rise is not None:
            pulumi.set(__self__, "health_check_rise", health_check_rise)
        if health_check_tls_verify is not None:
            pulumi.set(__self__, "health_check_tls_verify", health_check_tls_verify)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)
        if health_check_url is not None:
            pulumi.set(__self__, "health_check_url", health_check_url)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if outbound_proxy_protocol is not None:
            pulumi.set(__self__, "outbound_proxy_protocol", outbound_proxy_protocol)
        if sticky_session_cookie_name is not None:
            pulumi.set(__self__, "sticky_session_cookie_name", sticky_session_cookie_name)
        if timeout_server is not None:
            pulumi.set(__self__, "timeout_server", timeout_server)
        if timeout_tunnel is not None:
            pulumi.set(__self__, "timeout_tunnel", timeout_tunnel)
        if tls_enabled is not None:
            pulumi.set(__self__, "tls_enabled", tls_enabled)
        if tls_use_system_ca is not None:
            pulumi.set(__self__, "tls_use_system_ca", tls_use_system_ca)
        if tls_verify is not None:
            pulumi.set(__self__, "tls_verify", tls_verify)

    @property
    @pulumi.getter(name="healthCheckExpectedStatus")
    def health_check_expected_status(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.
        """
        return pulumi.get(self, "health_check_expected_status")

    @health_check_expected_status.setter
    def health_check_expected_status(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "health_check_expected_status", value)

    @property
    @pulumi.getter(name="healthCheckFall")
    def health_check_fall(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets how many failed health checks are allowed until the backend member is taken off from the rotation.
        """
        return pulumi.get(self, "health_check_fall")

    @health_check_fall.setter
    def health_check_fall(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "health_check_fall", value)

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Interval between health checks in seconds.
        """
        return pulumi.get(self, "health_check_interval")

    @health_check_interval.setter
    def health_check_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "health_check_interval", value)

    @property
    @pulumi.getter(name="healthCheckRise")
    def health_check_rise(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets how many successful health checks are required to put the backend member back into rotation.
        """
        return pulumi.get(self, "health_check_rise")

    @health_check_rise.setter
    def health_check_rise(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "health_check_rise", value)

    @property
    @pulumi.getter(name="healthCheckTlsVerify")
    def health_check_tls_verify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.
        """
        return pulumi.get(self, "health_check_tls_verify")

    @health_check_tls_verify.setter
    def health_check_tls_verify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "health_check_tls_verify", value)

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Health check type.
        """
        return pulumi.get(self, "health_check_type")

    @health_check_type.setter
    def health_check_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_check_type", value)

    @property
    @pulumi.getter(name="healthCheckUrl")
    def health_check_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.
        """
        return pulumi.get(self, "health_check_url")

    @health_check_url.setter
    def health_check_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_check_url", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="outboundProxyProtocol")
    def outbound_proxy_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.
        """
        return pulumi.get(self, "outbound_proxy_protocol")

    @outbound_proxy_protocol.setter
    def outbound_proxy_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "outbound_proxy_protocol", value)

    @property
    @pulumi.getter(name="stickySessionCookieName")
    def sticky_session_cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sets sticky session cookie name. Empty string disables sticky session.
        """
        return pulumi.get(self, "sticky_session_cookie_name")

    @sticky_session_cookie_name.setter
    def sticky_session_cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sticky_session_cookie_name", value)

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Backend server timeout in seconds.
        """
        return pulumi.get(self, "timeout_server")

    @timeout_server.setter
    def timeout_server(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_server", value)

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum inactivity time on the client and server side for tunnels in seconds.
        """
        return pulumi.get(self, "timeout_tunnel")

    @timeout_tunnel.setter
    def timeout_tunnel(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_tunnel", value)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables TLS connection from the load balancer to backend servers.
        """
        return pulumi.get(self, "tls_enabled")

    @tls_enabled.setter
    def tls_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "tls_enabled", value)

    @property
    @pulumi.getter(name="tlsUseSystemCa")
    def tls_use_system_ca(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If enabled, then the system CA certificate bundle will be used for the certificate verification.
        """
        return pulumi.get(self, "tls_use_system_ca")

    @tls_use_system_ca.setter
    def tls_use_system_ca(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "tls_use_system_ca", value)

    @property
    @pulumi.getter(name="tlsVerify")
    def tls_verify(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.
        """
        return pulumi.get(self, "tls_verify")

    @tls_verify.setter
    def tls_verify(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "tls_verify", value)


if not MYPY:
    class LoadbalancerFrontendNetworkArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the load balancer network.
        """
elif False:
    LoadbalancerFrontendNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendNetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: Name of the load balancer network.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the load balancer network.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LoadbalancerFrontendPropertiesArgsDict(TypedDict):
        http2_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable HTTP/2 support.
        """
        inbound_proxy_protocol: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable inbound proxy protocol support.
        """
        timeout_client: NotRequired[pulumi.Input[builtins.int]]
        """
        Client request timeout in seconds.
        """
elif False:
    LoadbalancerFrontendPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendPropertiesArgs:
    def __init__(__self__, *,
                 http2_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 inbound_proxy_protocol: Optional[pulumi.Input[builtins.bool]] = None,
                 timeout_client: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] http2_enabled: Enable or disable HTTP/2 support.
        :param pulumi.Input[builtins.bool] inbound_proxy_protocol: Enable or disable inbound proxy protocol support.
        :param pulumi.Input[builtins.int] timeout_client: Client request timeout in seconds.
        """
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if inbound_proxy_protocol is not None:
            pulumi.set(__self__, "inbound_proxy_protocol", inbound_proxy_protocol)
        if timeout_client is not None:
            pulumi.set(__self__, "timeout_client", timeout_client)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable HTTP/2 support.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="inboundProxyProtocol")
    def inbound_proxy_protocol(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable inbound proxy protocol support.
        """
        return pulumi.get(self, "inbound_proxy_protocol")

    @inbound_proxy_protocol.setter
    def inbound_proxy_protocol(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inbound_proxy_protocol", value)

    @property
    @pulumi.getter(name="timeoutClient")
    def timeout_client(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Client request timeout in seconds.
        """
        return pulumi.get(self, "timeout_client")

    @timeout_client.setter
    def timeout_client(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_client", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsArgsDict(TypedDict):
        http_redirects: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgsDict']]]]
        """
        Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.
        """
        http_returns: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgsDict']]]]
        """
        Returns HTTP response with specified HTTP status.
        """
        set_forwarded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgsDict']]]]
        """
        Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests
        """
        set_request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetRequestHeaderArgsDict']]]]
        """
        Set request header
        """
        set_response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetResponseHeaderArgsDict']]]]
        """
        Set response header
        """
        tcp_rejects: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgsDict']]]]
        """
        Terminates a connection.
        """
        use_backends: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgsDict']]]]
        """
        Routes traffic to specified `backend`.
        """
elif False:
    LoadbalancerFrontendRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsArgs:
    def __init__(__self__, *,
                 http_redirects: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgs']]]] = None,
                 http_returns: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgs']]]] = None,
                 set_forwarded_headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs']]]] = None,
                 set_request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetRequestHeaderArgs']]]] = None,
                 set_response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetResponseHeaderArgs']]]] = None,
                 tcp_rejects: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgs']]]] = None,
                 use_backends: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgs']]] http_redirects: Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgs']]] http_returns: Returns HTTP response with specified HTTP status.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs']]] set_forwarded_headers: Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetRequestHeaderArgs']]] set_request_headers: Set request header
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetResponseHeaderArgs']]] set_response_headers: Set response header
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgs']]] tcp_rejects: Terminates a connection.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgs']]] use_backends: Routes traffic to specified `backend`.
        """
        if http_redirects is not None:
            pulumi.set(__self__, "http_redirects", http_redirects)
        if http_returns is not None:
            pulumi.set(__self__, "http_returns", http_returns)
        if set_forwarded_headers is not None:
            pulumi.set(__self__, "set_forwarded_headers", set_forwarded_headers)
        if set_request_headers is not None:
            pulumi.set(__self__, "set_request_headers", set_request_headers)
        if set_response_headers is not None:
            pulumi.set(__self__, "set_response_headers", set_response_headers)
        if tcp_rejects is not None:
            pulumi.set(__self__, "tcp_rejects", tcp_rejects)
        if use_backends is not None:
            pulumi.set(__self__, "use_backends", use_backends)

    @property
    @pulumi.getter(name="httpRedirects")
    def http_redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgs']]]]:
        """
        Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.
        """
        return pulumi.get(self, "http_redirects")

    @http_redirects.setter
    def http_redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgs']]]]):
        pulumi.set(self, "http_redirects", value)

    @property
    @pulumi.getter(name="httpReturns")
    def http_returns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgs']]]]:
        """
        Returns HTTP response with specified HTTP status.
        """
        return pulumi.get(self, "http_returns")

    @http_returns.setter
    def http_returns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgs']]]]):
        pulumi.set(self, "http_returns", value)

    @property
    @pulumi.getter(name="setForwardedHeaders")
    def set_forwarded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs']]]]:
        """
        Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests
        """
        return pulumi.get(self, "set_forwarded_headers")

    @set_forwarded_headers.setter
    def set_forwarded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs']]]]):
        pulumi.set(self, "set_forwarded_headers", value)

    @property
    @pulumi.getter(name="setRequestHeaders")
    def set_request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetRequestHeaderArgs']]]]:
        """
        Set request header
        """
        return pulumi.get(self, "set_request_headers")

    @set_request_headers.setter
    def set_request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetRequestHeaderArgs']]]]):
        pulumi.set(self, "set_request_headers", value)

    @property
    @pulumi.getter(name="setResponseHeaders")
    def set_response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetResponseHeaderArgs']]]]:
        """
        Set response header
        """
        return pulumi.get(self, "set_response_headers")

    @set_response_headers.setter
    def set_response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetResponseHeaderArgs']]]]):
        pulumi.set(self, "set_response_headers", value)

    @property
    @pulumi.getter(name="tcpRejects")
    def tcp_rejects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgs']]]]:
        """
        Terminates a connection.
        """
        return pulumi.get(self, "tcp_rejects")

    @tcp_rejects.setter
    def tcp_rejects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgs']]]]):
        pulumi.set(self, "tcp_rejects", value)

    @property
    @pulumi.getter(name="useBackends")
    def use_backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgs']]]]:
        """
        Routes traffic to specified `backend`.
        """
        return pulumi.get(self, "use_backends")

    @use_backends.setter
    def use_backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgs']]]]):
        pulumi.set(self, "use_backends", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsHttpRedirectArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[builtins.str]]
        """
        Target location.
        """
        scheme: NotRequired[pulumi.Input[builtins.str]]
        """
        Target scheme.
        """
        status: NotRequired[pulumi.Input[builtins.int]]
        """
        HTTP status code.
        """
elif False:
    LoadbalancerFrontendRuleActionsHttpRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsHttpRedirectArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[builtins.str]] = None,
                 scheme: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] location: Target location.
        :param pulumi.Input[builtins.str] scheme: Target scheme.
        :param pulumi.Input[builtins.int] status: HTTP status code.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Target location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Target scheme.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsHttpReturnArgsDict(TypedDict):
        content_type: pulumi.Input[builtins.str]
        """
        Content type.
        """
        payload: pulumi.Input[builtins.str]
        """
        The payload.
        """
        status: pulumi.Input[builtins.int]
        """
        HTTP status code.
        """
elif False:
    LoadbalancerFrontendRuleActionsHttpReturnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsHttpReturnArgs:
    def __init__(__self__, *,
                 content_type: pulumi.Input[builtins.str],
                 payload: pulumi.Input[builtins.str],
                 status: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] content_type: Content type.
        :param pulumi.Input[builtins.str] payload: The payload.
        :param pulumi.Input[builtins.int] status: HTTP status code.
        """
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[builtins.str]:
        """
        Content type.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def payload(self) -> pulumi.Input[builtins.str]:
        """
        The payload.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[builtins.int]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "status", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsSetForwardedHeaderArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    LoadbalancerFrontendRuleActionsSetForwardedHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[builtins.bool]] = None):
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsSetRequestHeaderArgsDict(TypedDict):
        header: pulumi.Input[builtins.str]
        """
        Header name.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Header value.
        """
elif False:
    LoadbalancerFrontendRuleActionsSetRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsSetRequestHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[builtins.str],
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] header: Header name.
        :param pulumi.Input[builtins.str] value: Header value.
        """
        pulumi.set(__self__, "header", header)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[builtins.str]:
        """
        Header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsSetResponseHeaderArgsDict(TypedDict):
        header: pulumi.Input[builtins.str]
        """
        Header name.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Header value.
        """
elif False:
    LoadbalancerFrontendRuleActionsSetResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsSetResponseHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[builtins.str],
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] header: Header name.
        :param pulumi.Input[builtins.str] value: Header value.
        """
        pulumi.set(__self__, "header", header)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[builtins.str]:
        """
        Header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Header value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsTcpRejectArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the rule is active.
        """
elif False:
    LoadbalancerFrontendRuleActionsTcpRejectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsTcpRejectArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] active: Indicates if the rule is active.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the rule is active.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsUseBackendArgsDict(TypedDict):
        backend_name: pulumi.Input[builtins.str]
        """
        The name of the backend where traffic will be routed.
        """
elif False:
    LoadbalancerFrontendRuleActionsUseBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsUseBackendArgs:
    def __init__(__self__, *,
                 backend_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] backend_name: The name of the backend where traffic will be routed.
        """
        pulumi.set(__self__, "backend_name", backend_name)

    @property
    @pulumi.getter(name="backendName")
    def backend_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the backend where traffic will be routed.
        """
        return pulumi.get(self, "backend_name")

    @backend_name.setter
    def backend_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "backend_name", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersArgsDict(TypedDict):
        body_size_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgsDict']]]]
        """
        Matches by range of HTTP request body sizes.
        """
        body_sizes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgsDict']]]]
        """
        Matches by HTTP request body size.
        """
        cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgsDict']]]]
        """
        Matches by HTTP cookie value. Cookie name must be provided.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgsDict']]]]
        """
        Matches by HTTP header value. Header name must be provided.
        """
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgsDict']]]]
        """
        Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.
        """
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgsDict']]]]
        """
        Matches by HTTP method.
        """
        http_status_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusRangeArgsDict']]]]
        """
        Matches by range of HTTP statuses.
        """
        http_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusArgsDict']]]]
        """
        Matches by HTTP status.
        """
        num_members_ups: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgsDict']]]]
        """
        Matches by number of healthy backend members.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgsDict']]]]
        """
        Matches by URL path.
        """
        request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersRequestHeaderArgsDict']]]]
        """
        Matches by HTTP request header value. Header name must be provided.
        """
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersResponseHeaderArgsDict']]]]
        """
        Matches by HTTP response header value. Header name must be provided.
        """
        src_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgsDict']]]]
        """
        Matches by source IP address.
        """
        src_port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgsDict']]]]
        """
        Matches by range of source port numbers.
        """
        src_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgsDict']]]]
        """
        Matches by source port number.
        """
        url_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgsDict']]]]
        """
        Matches by URL query parameter value. Query parameter name must be provided
        """
        url_queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgsDict']]]]
        """
        Matches by URL query string.
        """
        urls: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgsDict']]]]
        """
        Matches by URL without schema, e.g. `example.com/dashboard`.
        """
elif False:
    LoadbalancerFrontendRuleMatchersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersArgs:
    def __init__(__self__, *,
                 body_size_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs']]]] = None,
                 body_sizes: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgs']]]] = None,
                 cookies: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgs']]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgs']]]] = None,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgs']]]] = None,
                 http_status_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusRangeArgs']]]] = None,
                 http_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusArgs']]]] = None,
                 num_members_ups: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgs']]]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgs']]]] = None,
                 request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersRequestHeaderArgs']]]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersResponseHeaderArgs']]]] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgs']]]] = None,
                 src_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs']]]] = None,
                 src_ports: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgs']]]] = None,
                 url_params: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgs']]]] = None,
                 url_queries: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgs']]]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs']]] body_size_ranges: Matches by range of HTTP request body sizes.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgs']]] body_sizes: Matches by HTTP request body size.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgs']]] cookies: Matches by HTTP cookie value. Cookie name must be provided.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgs']]] headers: Matches by HTTP header value. Header name must be provided.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgs']]] hosts: Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgs']]] http_methods: Matches by HTTP method.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusRangeArgs']]] http_status_ranges: Matches by range of HTTP statuses.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusArgs']]] http_statuses: Matches by HTTP status.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgs']]] num_members_ups: Matches by number of healthy backend members.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgs']]] paths: Matches by URL path.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersRequestHeaderArgs']]] request_headers: Matches by HTTP request header value. Header name must be provided.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersResponseHeaderArgs']]] response_headers: Matches by HTTP response header value. Header name must be provided.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgs']]] src_ips: Matches by source IP address.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs']]] src_port_ranges: Matches by range of source port numbers.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgs']]] src_ports: Matches by source port number.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgs']]] url_params: Matches by URL query parameter value. Query parameter name must be provided
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgs']]] url_queries: Matches by URL query string.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgs']]] urls: Matches by URL without schema, e.g. `example.com/dashboard`.
        """
        if body_size_ranges is not None:
            pulumi.set(__self__, "body_size_ranges", body_size_ranges)
        if body_sizes is not None:
            pulumi.set(__self__, "body_sizes", body_sizes)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if headers is not None:
            warnings.warn("""Use `request_header` instead.""", DeprecationWarning)
            pulumi.log.warn("""headers is deprecated: Use `request_header` instead.""")
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if http_status_ranges is not None:
            pulumi.set(__self__, "http_status_ranges", http_status_ranges)
        if http_statuses is not None:
            pulumi.set(__self__, "http_statuses", http_statuses)
        if num_members_ups is not None:
            pulumi.set(__self__, "num_members_ups", num_members_ups)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)
        if src_ips is not None:
            pulumi.set(__self__, "src_ips", src_ips)
        if src_port_ranges is not None:
            pulumi.set(__self__, "src_port_ranges", src_port_ranges)
        if src_ports is not None:
            pulumi.set(__self__, "src_ports", src_ports)
        if url_params is not None:
            pulumi.set(__self__, "url_params", url_params)
        if url_queries is not None:
            pulumi.set(__self__, "url_queries", url_queries)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="bodySizeRanges")
    def body_size_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs']]]]:
        """
        Matches by range of HTTP request body sizes.
        """
        return pulumi.get(self, "body_size_ranges")

    @body_size_ranges.setter
    def body_size_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs']]]]):
        pulumi.set(self, "body_size_ranges", value)

    @property
    @pulumi.getter(name="bodySizes")
    def body_sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgs']]]]:
        """
        Matches by HTTP request body size.
        """
        return pulumi.get(self, "body_sizes")

    @body_sizes.setter
    def body_sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgs']]]]):
        pulumi.set(self, "body_sizes", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgs']]]]:
        """
        Matches by HTTP cookie value. Cookie name must be provided.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgs']]]]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `request_header` instead.""")
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgs']]]]:
        """
        Matches by HTTP header value. Header name must be provided.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgs']]]]:
        """
        Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgs']]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgs']]]]:
        """
        Matches by HTTP method.
        """
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgs']]]]):
        pulumi.set(self, "http_methods", value)

    @property
    @pulumi.getter(name="httpStatusRanges")
    def http_status_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusRangeArgs']]]]:
        """
        Matches by range of HTTP statuses.
        """
        return pulumi.get(self, "http_status_ranges")

    @http_status_ranges.setter
    def http_status_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusRangeArgs']]]]):
        pulumi.set(self, "http_status_ranges", value)

    @property
    @pulumi.getter(name="httpStatuses")
    def http_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusArgs']]]]:
        """
        Matches by HTTP status.
        """
        return pulumi.get(self, "http_statuses")

    @http_statuses.setter
    def http_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpStatusArgs']]]]):
        pulumi.set(self, "http_statuses", value)

    @property
    @pulumi.getter(name="numMembersUps")
    def num_members_ups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgs']]]]:
        """
        Matches by number of healthy backend members.
        """
        return pulumi.get(self, "num_members_ups")

    @num_members_ups.setter
    def num_members_ups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgs']]]]):
        pulumi.set(self, "num_members_ups", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgs']]]]:
        """
        Matches by URL path.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgs']]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersRequestHeaderArgs']]]]:
        """
        Matches by HTTP request header value. Header name must be provided.
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersRequestHeaderArgs']]]]):
        pulumi.set(self, "request_headers", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersResponseHeaderArgs']]]]:
        """
        Matches by HTTP response header value. Header name must be provided.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgs']]]]:
        """
        Matches by source IP address.
        """
        return pulumi.get(self, "src_ips")

    @src_ips.setter
    def src_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgs']]]]):
        pulumi.set(self, "src_ips", value)

    @property
    @pulumi.getter(name="srcPortRanges")
    def src_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs']]]]:
        """
        Matches by range of source port numbers.
        """
        return pulumi.get(self, "src_port_ranges")

    @src_port_ranges.setter
    def src_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs']]]]):
        pulumi.set(self, "src_port_ranges", value)

    @property
    @pulumi.getter(name="srcPorts")
    def src_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgs']]]]:
        """
        Matches by source port number.
        """
        return pulumi.get(self, "src_ports")

    @src_ports.setter
    def src_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgs']]]]):
        pulumi.set(self, "src_ports", value)

    @property
    @pulumi.getter(name="urlParams")
    def url_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgs']]]]:
        """
        Matches by URL query parameter value. Query parameter name must be provided
        """
        return pulumi.get(self, "url_params")

    @url_params.setter
    def url_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgs']]]]):
        pulumi.set(self, "url_params", value)

    @property
    @pulumi.getter(name="urlQueries")
    def url_queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgs']]]]:
        """
        Matches by URL query string.
        """
        return pulumi.get(self, "url_queries")

    @url_queries.setter
    def url_queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgs']]]]):
        pulumi.set(self, "url_queries", value)

    @property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgs']]]]:
        """
        Matches by URL without schema, e.g. `example.com/dashboard`.
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgs']]]]):
        pulumi.set(self, "urls", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersBodySizeArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        value: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersBodySizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersBodySizeArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.int],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param pulumi.Input[builtins.int] value: Integer value.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersBodySizeRangeArgsDict(TypedDict):
        range_end: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        range_start: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersBodySizeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersBodySizeRangeArgs:
    def __init__(__self__, *,
                 range_end: pulumi.Input[builtins.int],
                 range_start: pulumi.Input[builtins.int],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] range_end: Integer value.
        :param pulumi.Input[builtins.int] range_start: Integer value.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_end")

    @range_end.setter
    def range_end(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "range_end", value)

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_start")

    @range_start.setter
    def range_start(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "range_start", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersCookieArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the argument.
        """
        ignore_case: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersCookieArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 ignore_case: Optional[pulumi.Input[builtins.bool]] = None,
                 inverse: Optional[pulumi.Input[builtins.bool]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[builtins.str] name: Name of the argument.
        :param pulumi.Input[builtins.bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[builtins.str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersHeaderArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the argument.
        """
        ignore_case: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersHeaderArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 ignore_case: Optional[pulumi.Input[builtins.bool]] = None,
                 inverse: Optional[pulumi.Input[builtins.bool]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[builtins.str] name: Name of the argument.
        :param pulumi.Input[builtins.bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[builtins.str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersHostArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        String value.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersHostArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] value: String value.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersHttpMethodArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersHttpMethodArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] value: String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersHttpStatusArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        value: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersHttpStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersHttpStatusArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.int],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param pulumi.Input[builtins.int] value: Integer value.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersHttpStatusRangeArgsDict(TypedDict):
        range_end: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        range_start: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersHttpStatusRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersHttpStatusRangeArgs:
    def __init__(__self__, *,
                 range_end: pulumi.Input[builtins.int],
                 range_start: pulumi.Input[builtins.int],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] range_end: Integer value.
        :param pulumi.Input[builtins.int] range_start: Integer value.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_end")

    @range_end.setter
    def range_end(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "range_end", value)

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_start")

    @range_start.setter
    def range_start(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "range_start", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersNumMembersUpArgsDict(TypedDict):
        backend_name: pulumi.Input[builtins.str]
        """
        The name of the `backend`.
        """
        method: pulumi.Input[builtins.str]
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        value: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersNumMembersUpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersNumMembersUpArgs:
    def __init__(__self__, *,
                 backend_name: pulumi.Input[builtins.str],
                 method: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.int],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] backend_name: The name of the `backend`.
        :param pulumi.Input[builtins.str] method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param pulumi.Input[builtins.int] value: Integer value.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "backend_name", backend_name)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="backendName")
    def backend_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the `backend`.
        """
        return pulumi.get(self, "backend_name")

    @backend_name.setter
    def backend_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "backend_name", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersPathArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        ignore_case: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersPathArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 ignore_case: Optional[pulumi.Input[builtins.bool]] = None,
                 inverse: Optional[pulumi.Input[builtins.bool]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[builtins.bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[builtins.str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersRequestHeaderArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the argument.
        """
        ignore_case: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersRequestHeaderArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 ignore_case: Optional[pulumi.Input[builtins.bool]] = None,
                 inverse: Optional[pulumi.Input[builtins.bool]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[builtins.str] name: Name of the argument.
        :param pulumi.Input[builtins.bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[builtins.str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersResponseHeaderArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the argument.
        """
        ignore_case: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersResponseHeaderArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 ignore_case: Optional[pulumi.Input[builtins.bool]] = None,
                 inverse: Optional[pulumi.Input[builtins.bool]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[builtins.str] name: Name of the argument.
        :param pulumi.Input[builtins.bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[builtins.str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersSrcIpArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersSrcIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersSrcIpArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] value: IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersSrcPortArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        value: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersSrcPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersSrcPortArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.int],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param pulumi.Input[builtins.int] value: Integer value.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersSrcPortRangeArgsDict(TypedDict):
        range_end: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        range_start: pulumi.Input[builtins.int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersSrcPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersSrcPortRangeArgs:
    def __init__(__self__, *,
                 range_end: pulumi.Input[builtins.int],
                 range_start: pulumi.Input[builtins.int],
                 inverse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] range_end: Integer value.
        :param pulumi.Input[builtins.int] range_start: Integer value.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_end")

    @range_end.setter
    def range_end(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "range_end", value)

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> pulumi.Input[builtins.int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_start")

    @range_start.setter
    def range_start(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "range_start", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersUrlArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        ignore_case: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersUrlArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 ignore_case: Optional[pulumi.Input[builtins.bool]] = None,
                 inverse: Optional[pulumi.Input[builtins.bool]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[builtins.bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[builtins.str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersUrlParamArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the argument.
        """
        ignore_case: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersUrlParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersUrlParamArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 ignore_case: Optional[pulumi.Input[builtins.bool]] = None,
                 inverse: Optional[pulumi.Input[builtins.bool]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[builtins.str] name: Name of the argument.
        :param pulumi.Input[builtins.bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[builtins.str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersUrlQueryArgsDict(TypedDict):
        method: pulumi.Input[builtins.str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        ignore_case: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersUrlQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersUrlQueryArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[builtins.str],
                 ignore_case: Optional[pulumi.Input[builtins.bool]] = None,
                 inverse: Optional[pulumi.Input[builtins.bool]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[builtins.bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[builtins.bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[builtins.str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerNetworkArgsDict(TypedDict):
        family: pulumi.Input[builtins.str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the network. Only one public network can be attached and at least one private network must be attached.
        """
        dns_name: NotRequired[pulumi.Input[builtins.str]]
        """
        DNS name of the load balancer network
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The unique identifier of the network.
        """
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.
        """
elif False:
    LoadbalancerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 dns_name: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[builtins.str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[builtins.str] type: The type of the network. Only one public network can be attached and at least one private network must be attached.
        :param pulumi.Input[builtins.str] dns_name: DNS name of the load balancer network
        :param pulumi.Input[builtins.str] id: The unique identifier of the network.
        :param pulumi.Input[builtins.str] network: Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the network. Only one public network can be attached and at least one private network must be attached.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        DNS name of the load balancer network
        """
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The unique identifier of the network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)


if not MYPY:
    class LoadbalancerNodeArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgsDict']]]]
        """
        Networks attached to the node
        """
        operational_state: NotRequired[pulumi.Input[builtins.str]]
        """
        Node's operational state. Managed by the system.
        """
elif False:
    LoadbalancerNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerNodeArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgs']]]] = None,
                 operational_state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgs']]] networks: Networks attached to the node
        :param pulumi.Input[builtins.str] operational_state: Node's operational state. Managed by the system.
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgs']]]]:
        """
        Networks attached to the node
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgs']]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Node's operational state. Managed by the system.
        """
        return pulumi.get(self, "operational_state")

    @operational_state.setter
    def operational_state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operational_state", value)


if not MYPY:
    class LoadbalancerNodeNetworkArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgsDict']]]]
        """
        IP addresses attached to the network
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the network
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the network
        """
elif False:
    LoadbalancerNodeNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerNodeNetworkArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgs']]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgs']]] ip_addresses: IP addresses attached to the network
        :param pulumi.Input[builtins.str] name: The name of the network
        :param pulumi.Input[builtins.str] type: The type of the network
        """
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgs']]]]:
        """
        IP addresses attached to the network
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the network
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the network
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LoadbalancerNodeNetworkIpAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[builtins.str]]
        """
        Node's IP address
        """
        listen: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the node listens to the traffic
        """
elif False:
    LoadbalancerNodeNetworkIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerNodeNetworkIpAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[builtins.str]] = None,
                 listen: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] address: Node's IP address
        :param pulumi.Input[builtins.bool] listen: Whether the node listens to the traffic
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if listen is not None:
            pulumi.set(__self__, "listen", listen)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Node's IP address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def listen(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the node listens to the traffic
        """
        return pulumi.get(self, "listen")

    @listen.setter
    def listen(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "listen", value)


if not MYPY:
    class ManagedDatabaseMysqlComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[builtins.str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[builtins.str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabaseMysqlComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 route: Optional[pulumi.Input[builtins.str]] = None,
                 usage: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] component: Type of the component
        :param pulumi.Input[builtins.str] host: Hostname of the component
        :param pulumi.Input[builtins.int] port: Port number of the component
        :param pulumi.Input[builtins.str] route: Component network route type
        :param pulumi.Input[builtins.str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabaseMysqlNetworkArgsDict(TypedDict):
        family: pulumi.Input[builtins.str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[builtins.str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabaseMysqlNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 uuid: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[builtins.str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[builtins.str] type: The type of the network. Must be private.
        :param pulumi.Input[builtins.str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[builtins.str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabaseMysqlNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the node
        """
elif False:
    ManagedDatabaseMysqlNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name plus a node iteration
        :param pulumi.Input[builtins.str] role: Role of the node
        :param pulumi.Input[builtins.str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabaseMysqlPropertiesArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        admin_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[builtins.bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        backup_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        backup_minute: NotRequired[pulumi.Input[builtins.int]]
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        binlog_retention_period: NotRequired[pulumi.Input[builtins.int]]
        """
        The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        """
        connect_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
        """
        default_time_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
        """
        group_concat_max_len: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum permitted result length in bytes for the GROUP_CONCAT() function.
        """
        information_schema_stats_expiry: NotRequired[pulumi.Input[builtins.int]]
        """
        The time, in seconds, before cached statistics expire.
        """
        innodb_change_buffer_max_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
        """
        innodb_flush_neighbors: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
        """
        innodb_ft_min_token_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
        """
        innodb_ft_server_stopword_table: NotRequired[pulumi.Input[builtins.str]]
        """
        This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
        """
        innodb_lock_wait_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
        """
        innodb_log_buffer_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
        """
        innodb_online_alter_log_max_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
        """
        innodb_print_all_deadlocks: NotRequired[pulumi.Input[builtins.bool]]
        """
        When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
        """
        innodb_read_io_threads: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        innodb_rollback_on_timeout: NotRequired[pulumi.Input[builtins.bool]]
        """
        When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
        """
        innodb_thread_concurrency: NotRequired[pulumi.Input[builtins.int]]
        """
        Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
        """
        innodb_write_io_threads: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        interactive_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of seconds the server waits for activity on an interactive connection before closing it.
        """
        internal_tmp_mem_storage_engine: NotRequired[pulumi.Input[builtins.str]]
        """
        The storage engine for in-memory internal temporary tables.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        log_output: NotRequired[pulumi.Input[builtins.str]]
        """
        The slow log output destination when slow_query_log is ON. To enable MySQL AI Insights, choose INSIGHTS. To use MySQL AI Insights and the mysql.slow_log table at the same time, choose INSIGHTS,TABLE. To only use the mysql.slow_log table, choose TABLE. To silence slow logs, choose NONE.
        """
        long_query_time: NotRequired[pulumi.Input[builtins.float]]
        """
        The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute.
        """
        max_allowed_packet: NotRequired[pulumi.Input[builtins.int]]
        """
        Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
        """
        max_heap_table_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
        """
        migration: NotRequired[pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgsDict']]
        """
        Migrate data from existing server.
        """
        net_buffer_length: NotRequired[pulumi.Input[builtins.int]]
        """
        Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
        """
        net_read_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of seconds to wait for more data from a connection before aborting the read.
        """
        net_write_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of seconds to wait for a block to be written to a connection before aborting the write.
        """
        public_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        service_log: NotRequired[pulumi.Input[builtins.bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        slow_query_log: NotRequired[pulumi.Input[builtins.bool]]
        """
        Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table.
        """
        sort_buffer_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
        """
        sql_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
        """
        sql_require_primary_key: NotRequired[pulumi.Input[builtins.bool]]
        """
        Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        """
        tmp_table_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        MySQL major version.
        """
        wait_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
elif False:
    ManagedDatabaseMysqlPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlPropertiesArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[builtins.str]] = None,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 backup_hour: Optional[pulumi.Input[builtins.int]] = None,
                 backup_minute: Optional[pulumi.Input[builtins.int]] = None,
                 binlog_retention_period: Optional[pulumi.Input[builtins.int]] = None,
                 connect_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 default_time_zone: Optional[pulumi.Input[builtins.str]] = None,
                 group_concat_max_len: Optional[pulumi.Input[builtins.int]] = None,
                 information_schema_stats_expiry: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_change_buffer_max_size: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_flush_neighbors: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_ft_min_token_size: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_ft_server_stopword_table: Optional[pulumi.Input[builtins.str]] = None,
                 innodb_lock_wait_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_log_buffer_size: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_online_alter_log_max_size: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_print_all_deadlocks: Optional[pulumi.Input[builtins.bool]] = None,
                 innodb_read_io_threads: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_rollback_on_timeout: Optional[pulumi.Input[builtins.bool]] = None,
                 innodb_thread_concurrency: Optional[pulumi.Input[builtins.int]] = None,
                 innodb_write_io_threads: Optional[pulumi.Input[builtins.int]] = None,
                 interactive_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 internal_tmp_mem_storage_engine: Optional[pulumi.Input[builtins.str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 log_output: Optional[pulumi.Input[builtins.str]] = None,
                 long_query_time: Optional[pulumi.Input[builtins.float]] = None,
                 max_allowed_packet: Optional[pulumi.Input[builtins.int]] = None,
                 max_heap_table_size: Optional[pulumi.Input[builtins.int]] = None,
                 migration: Optional[pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgs']] = None,
                 net_buffer_length: Optional[pulumi.Input[builtins.int]] = None,
                 net_read_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 net_write_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 public_access: Optional[pulumi.Input[builtins.bool]] = None,
                 service_log: Optional[pulumi.Input[builtins.bool]] = None,
                 slow_query_log: Optional[pulumi.Input[builtins.bool]] = None,
                 sort_buffer_size: Optional[pulumi.Input[builtins.int]] = None,
                 sql_mode: Optional[pulumi.Input[builtins.str]] = None,
                 sql_require_primary_key: Optional[pulumi.Input[builtins.bool]] = None,
                 tmp_table_size: Optional[pulumi.Input[builtins.int]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None,
                 wait_timeout: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] admin_password: Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        :param pulumi.Input[builtins.str] admin_username: Custom username for admin user. This must be set only when a new service is being created.
        :param pulumi.Input[builtins.bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[builtins.int] backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[builtins.int] backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[builtins.int] binlog_retention_period: The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        :param pulumi.Input[builtins.int] connect_timeout: The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
        :param pulumi.Input[builtins.str] default_time_zone: Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
        :param pulumi.Input[builtins.int] group_concat_max_len: The maximum permitted result length in bytes for the GROUP_CONCAT() function.
        :param pulumi.Input[builtins.int] information_schema_stats_expiry: The time, in seconds, before cached statistics expire.
        :param pulumi.Input[builtins.int] innodb_change_buffer_max_size: Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
        :param pulumi.Input[builtins.int] innodb_flush_neighbors: Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
        :param pulumi.Input[builtins.int] innodb_ft_min_token_size: Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[builtins.str] innodb_ft_server_stopword_table: This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
        :param pulumi.Input[builtins.int] innodb_lock_wait_timeout: The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
        :param pulumi.Input[builtins.int] innodb_log_buffer_size: The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
        :param pulumi.Input[builtins.int] innodb_online_alter_log_max_size: The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
        :param pulumi.Input[builtins.bool] innodb_print_all_deadlocks: When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
        :param pulumi.Input[builtins.int] innodb_read_io_threads: The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[builtins.bool] innodb_rollback_on_timeout: When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[builtins.int] innodb_thread_concurrency: Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
        :param pulumi.Input[builtins.int] innodb_write_io_threads: The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[builtins.int] interactive_timeout: The number of seconds the server waits for activity on an interactive connection before closing it.
        :param pulumi.Input[builtins.str] internal_tmp_mem_storage_engine: The storage engine for in-memory internal temporary tables.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input[builtins.str] log_output: The slow log output destination when slow_query_log is ON. To enable MySQL AI Insights, choose INSIGHTS. To use MySQL AI Insights and the mysql.slow_log table at the same time, choose INSIGHTS,TABLE. To only use the mysql.slow_log table, choose TABLE. To silence slow logs, choose NONE.
        :param pulumi.Input[builtins.float] long_query_time: The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute.
        :param pulumi.Input[builtins.int] max_allowed_packet: Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
        :param pulumi.Input[builtins.int] max_heap_table_size: Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
        :param pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgs'] migration: Migrate data from existing server.
        :param pulumi.Input[builtins.int] net_buffer_length: Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[builtins.int] net_read_timeout: The number of seconds to wait for more data from a connection before aborting the read.
        :param pulumi.Input[builtins.int] net_write_timeout: The number of seconds to wait for a block to be written to a connection before aborting the write.
        :param pulumi.Input[builtins.bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[builtins.bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param pulumi.Input[builtins.bool] slow_query_log: Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table.
        :param pulumi.Input[builtins.int] sort_buffer_size: Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
        :param pulumi.Input[builtins.str] sql_mode: Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
        :param pulumi.Input[builtins.bool] sql_require_primary_key: Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        :param pulumi.Input[builtins.int] tmp_table_size: Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        :param pulumi.Input[builtins.str] version: MySQL major version.
        :param pulumi.Input[builtins.int] wait_timeout: The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if binlog_retention_period is not None:
            pulumi.set(__self__, "binlog_retention_period", binlog_retention_period)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if default_time_zone is not None:
            pulumi.set(__self__, "default_time_zone", default_time_zone)
        if group_concat_max_len is not None:
            pulumi.set(__self__, "group_concat_max_len", group_concat_max_len)
        if information_schema_stats_expiry is not None:
            pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        if innodb_change_buffer_max_size is not None:
            pulumi.set(__self__, "innodb_change_buffer_max_size", innodb_change_buffer_max_size)
        if innodb_flush_neighbors is not None:
            pulumi.set(__self__, "innodb_flush_neighbors", innodb_flush_neighbors)
        if innodb_ft_min_token_size is not None:
            pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        if innodb_ft_server_stopword_table is not None:
            pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        if innodb_lock_wait_timeout is not None:
            pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        if innodb_log_buffer_size is not None:
            pulumi.set(__self__, "innodb_log_buffer_size", innodb_log_buffer_size)
        if innodb_online_alter_log_max_size is not None:
            pulumi.set(__self__, "innodb_online_alter_log_max_size", innodb_online_alter_log_max_size)
        if innodb_print_all_deadlocks is not None:
            pulumi.set(__self__, "innodb_print_all_deadlocks", innodb_print_all_deadlocks)
        if innodb_read_io_threads is not None:
            pulumi.set(__self__, "innodb_read_io_threads", innodb_read_io_threads)
        if innodb_rollback_on_timeout is not None:
            pulumi.set(__self__, "innodb_rollback_on_timeout", innodb_rollback_on_timeout)
        if innodb_thread_concurrency is not None:
            pulumi.set(__self__, "innodb_thread_concurrency", innodb_thread_concurrency)
        if innodb_write_io_threads is not None:
            pulumi.set(__self__, "innodb_write_io_threads", innodb_write_io_threads)
        if interactive_timeout is not None:
            pulumi.set(__self__, "interactive_timeout", interactive_timeout)
        if internal_tmp_mem_storage_engine is not None:
            pulumi.set(__self__, "internal_tmp_mem_storage_engine", internal_tmp_mem_storage_engine)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if log_output is not None:
            pulumi.set(__self__, "log_output", log_output)
        if long_query_time is not None:
            pulumi.set(__self__, "long_query_time", long_query_time)
        if max_allowed_packet is not None:
            pulumi.set(__self__, "max_allowed_packet", max_allowed_packet)
        if max_heap_table_size is not None:
            pulumi.set(__self__, "max_heap_table_size", max_heap_table_size)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if net_buffer_length is not None:
            pulumi.set(__self__, "net_buffer_length", net_buffer_length)
        if net_read_timeout is not None:
            pulumi.set(__self__, "net_read_timeout", net_read_timeout)
        if net_write_timeout is not None:
            pulumi.set(__self__, "net_write_timeout", net_write_timeout)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if slow_query_log is not None:
            pulumi.set(__self__, "slow_query_log", slow_query_log)
        if sort_buffer_size is not None:
            pulumi.set(__self__, "sort_buffer_size", sort_buffer_size)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if sql_require_primary_key is not None:
            pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        if tmp_table_size is not None:
            pulumi.set(__self__, "tmp_table_size", tmp_table_size)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if wait_timeout is not None:
            pulumi.set(__self__, "wait_timeout", wait_timeout)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @backup_hour.setter
    def backup_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_hour", value)

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @backup_minute.setter
    def backup_minute(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_minute", value)

    @property
    @pulumi.getter(name="binlogRetentionPeriod")
    def binlog_retention_period(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        """
        return pulumi.get(self, "binlog_retention_period")

    @binlog_retention_period.setter
    def binlog_retention_period(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "binlog_retention_period", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="defaultTimeZone")
    def default_time_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
        """
        return pulumi.get(self, "default_time_zone")

    @default_time_zone.setter
    def default_time_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_time_zone", value)

    @property
    @pulumi.getter(name="groupConcatMaxLen")
    def group_concat_max_len(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum permitted result length in bytes for the GROUP_CONCAT() function.
        """
        return pulumi.get(self, "group_concat_max_len")

    @group_concat_max_len.setter
    def group_concat_max_len(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "group_concat_max_len", value)

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time, in seconds, before cached statistics expire.
        """
        return pulumi.get(self, "information_schema_stats_expiry")

    @information_schema_stats_expiry.setter
    def information_schema_stats_expiry(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "information_schema_stats_expiry", value)

    @property
    @pulumi.getter(name="innodbChangeBufferMaxSize")
    def innodb_change_buffer_max_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
        """
        return pulumi.get(self, "innodb_change_buffer_max_size")

    @innodb_change_buffer_max_size.setter
    def innodb_change_buffer_max_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_change_buffer_max_size", value)

    @property
    @pulumi.getter(name="innodbFlushNeighbors")
    def innodb_flush_neighbors(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
        """
        return pulumi.get(self, "innodb_flush_neighbors")

    @innodb_flush_neighbors.setter
    def innodb_flush_neighbors(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_flush_neighbors", value)

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_ft_min_token_size")

    @innodb_ft_min_token_size.setter
    def innodb_ft_min_token_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_ft_min_token_size", value)

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
        """
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @innodb_ft_server_stopword_table.setter
    def innodb_ft_server_stopword_table(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "innodb_ft_server_stopword_table", value)

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
        """
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @innodb_lock_wait_timeout.setter
    def innodb_lock_wait_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_lock_wait_timeout", value)

    @property
    @pulumi.getter(name="innodbLogBufferSize")
    def innodb_log_buffer_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
        """
        return pulumi.get(self, "innodb_log_buffer_size")

    @innodb_log_buffer_size.setter
    def innodb_log_buffer_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_log_buffer_size", value)

    @property
    @pulumi.getter(name="innodbOnlineAlterLogMaxSize")
    def innodb_online_alter_log_max_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
        """
        return pulumi.get(self, "innodb_online_alter_log_max_size")

    @innodb_online_alter_log_max_size.setter
    def innodb_online_alter_log_max_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_online_alter_log_max_size", value)

    @property
    @pulumi.getter(name="innodbPrintAllDeadlocks")
    def innodb_print_all_deadlocks(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
        """
        return pulumi.get(self, "innodb_print_all_deadlocks")

    @innodb_print_all_deadlocks.setter
    def innodb_print_all_deadlocks(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "innodb_print_all_deadlocks", value)

    @property
    @pulumi.getter(name="innodbReadIoThreads")
    def innodb_read_io_threads(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_read_io_threads")

    @innodb_read_io_threads.setter
    def innodb_read_io_threads(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_read_io_threads", value)

    @property
    @pulumi.getter(name="innodbRollbackOnTimeout")
    def innodb_rollback_on_timeout(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_rollback_on_timeout")

    @innodb_rollback_on_timeout.setter
    def innodb_rollback_on_timeout(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "innodb_rollback_on_timeout", value)

    @property
    @pulumi.getter(name="innodbThreadConcurrency")
    def innodb_thread_concurrency(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
        """
        return pulumi.get(self, "innodb_thread_concurrency")

    @innodb_thread_concurrency.setter
    def innodb_thread_concurrency(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_thread_concurrency", value)

    @property
    @pulumi.getter(name="innodbWriteIoThreads")
    def innodb_write_io_threads(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_write_io_threads")

    @innodb_write_io_threads.setter
    def innodb_write_io_threads(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "innodb_write_io_threads", value)

    @property
    @pulumi.getter(name="interactiveTimeout")
    def interactive_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of seconds the server waits for activity on an interactive connection before closing it.
        """
        return pulumi.get(self, "interactive_timeout")

    @interactive_timeout.setter
    def interactive_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interactive_timeout", value)

    @property
    @pulumi.getter(name="internalTmpMemStorageEngine")
    def internal_tmp_mem_storage_engine(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The storage engine for in-memory internal temporary tables.
        """
        return pulumi.get(self, "internal_tmp_mem_storage_engine")

    @internal_tmp_mem_storage_engine.setter
    def internal_tmp_mem_storage_engine(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_tmp_mem_storage_engine", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="logOutput")
    def log_output(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The slow log output destination when slow_query_log is ON. To enable MySQL AI Insights, choose INSIGHTS. To use MySQL AI Insights and the mysql.slow_log table at the same time, choose INSIGHTS,TABLE. To only use the mysql.slow_log table, choose TABLE. To silence slow logs, choose NONE.
        """
        return pulumi.get(self, "log_output")

    @log_output.setter
    def log_output(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "log_output", value)

    @property
    @pulumi.getter(name="longQueryTime")
    def long_query_time(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute.
        """
        return pulumi.get(self, "long_query_time")

    @long_query_time.setter
    def long_query_time(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "long_query_time", value)

    @property
    @pulumi.getter(name="maxAllowedPacket")
    def max_allowed_packet(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
        """
        return pulumi.get(self, "max_allowed_packet")

    @max_allowed_packet.setter
    def max_allowed_packet(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_allowed_packet", value)

    @property
    @pulumi.getter(name="maxHeapTableSize")
    def max_heap_table_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
        """
        return pulumi.get(self, "max_heap_table_size")

    @max_heap_table_size.setter
    def max_heap_table_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_heap_table_size", value)

    @property
    @pulumi.getter
    def migration(self) -> Optional[pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgs']]:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @migration.setter
    def migration(self, value: Optional[pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgs']]):
        pulumi.set(self, "migration", value)

    @property
    @pulumi.getter(name="netBufferLength")
    def net_buffer_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "net_buffer_length")

    @net_buffer_length.setter
    def net_buffer_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "net_buffer_length", value)

    @property
    @pulumi.getter(name="netReadTimeout")
    def net_read_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of seconds to wait for more data from a connection before aborting the read.
        """
        return pulumi.get(self, "net_read_timeout")

    @net_read_timeout.setter
    def net_read_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "net_read_timeout", value)

    @property
    @pulumi.getter(name="netWriteTimeout")
    def net_write_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of seconds to wait for a block to be written to a connection before aborting the write.
        """
        return pulumi.get(self, "net_write_timeout")

    @net_write_timeout.setter
    def net_write_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "net_write_timeout", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "service_log", value)

    @property
    @pulumi.getter(name="slowQueryLog")
    def slow_query_log(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table.
        """
        return pulumi.get(self, "slow_query_log")

    @slow_query_log.setter
    def slow_query_log(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "slow_query_log", value)

    @property
    @pulumi.getter(name="sortBufferSize")
    def sort_buffer_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
        """
        return pulumi.get(self, "sort_buffer_size")

    @sort_buffer_size.setter
    def sort_buffer_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "sort_buffer_size", value)

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
        """
        return pulumi.get(self, "sql_mode")

    @sql_mode.setter
    def sql_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sql_mode", value)

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        """
        return pulumi.get(self, "sql_require_primary_key")

    @sql_require_primary_key.setter
    def sql_require_primary_key(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "sql_require_primary_key", value)

    @property
    @pulumi.getter(name="tmpTableSize")
    def tmp_table_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        """
        return pulumi.get(self, "tmp_table_size")

    @tmp_table_size.setter
    def tmp_table_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "tmp_table_size", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        MySQL major version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="waitTimeout")
    def wait_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
        return pulumi.get(self, "wait_timeout")

    @wait_timeout.setter
    def wait_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "wait_timeout", value)


if not MYPY:
    class ManagedDatabaseMysqlPropertiesMigrationArgsDict(TypedDict):
        dbname: NotRequired[pulumi.Input[builtins.str]]
        """
        Database name for bootstrapping the initial connection.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname or IP address of the server where to migrate data from.
        """
        ignore_dbs: NotRequired[pulumi.Input[builtins.str]]
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        ignore_roles: NotRequired[pulumi.Input[builtins.str]]
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        method: NotRequired[pulumi.Input[builtins.str]]
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password for authentication with the server where to migrate data from.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the server where to migrate data from.
        """
        ssl: NotRequired[pulumi.Input[builtins.bool]]
        """
        The server where to migrate data from is secured with SSL.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        User name for authentication with the server where to migrate data from.
        """
elif False:
    ManagedDatabaseMysqlPropertiesMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlPropertiesMigrationArgs:
    def __init__(__self__, *,
                 dbname: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_dbs: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_roles: Optional[pulumi.Input[builtins.str]] = None,
                 method: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 ssl: Optional[pulumi.Input[builtins.bool]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] dbname: Database name for bootstrapping the initial connection.
        :param pulumi.Input[builtins.str] host: Hostname or IP address of the server where to migrate data from.
        :param pulumi.Input[builtins.str] ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param pulumi.Input[builtins.str] ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param pulumi.Input[builtins.str] method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param pulumi.Input[builtins.str] password: Password for authentication with the server where to migrate data from.
        :param pulumi.Input[builtins.int] port: Port number of the server where to migrate data from.
        :param pulumi.Input[builtins.bool] ssl: The server where to migrate data from is secured with SSL.
        :param pulumi.Input[builtins.str] username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @ignore_dbs.setter
    def ignore_dbs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ignore_dbs", value)

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @ignore_roles.setter
    def ignore_roles(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ignore_roles", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ManagedDatabaseOpensearchComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[builtins.str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[builtins.str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabaseOpensearchComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 route: Optional[pulumi.Input[builtins.str]] = None,
                 usage: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] component: Type of the component
        :param pulumi.Input[builtins.str] host: Hostname of the component
        :param pulumi.Input[builtins.int] port: Port number of the component
        :param pulumi.Input[builtins.str] route: Component network route type
        :param pulumi.Input[builtins.str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabaseOpensearchNetworkArgsDict(TypedDict):
        family: pulumi.Input[builtins.str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[builtins.str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabaseOpensearchNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 uuid: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[builtins.str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[builtins.str] type: The type of the network. Must be private.
        :param pulumi.Input[builtins.str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[builtins.str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabaseOpensearchNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the node
        """
elif False:
    ManagedDatabaseOpensearchNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name plus a node iteration
        :param pulumi.Input[builtins.str] role: Role of the node
        :param pulumi.Input[builtins.str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesArgsDict(TypedDict):
        action_auto_create_index_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.
        """
        action_destructive_requires_name: NotRequired[pulumi.Input[builtins.bool]]
        """
        Require explicit index names when deleting.
        """
        auth_failure_listeners: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgsDict']]
        """
        Opensearch Security Plugin Settings.
        """
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[builtins.bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        cluster_max_shards_per_node: NotRequired[pulumi.Input[builtins.int]]
        """
        Controls the number of shards allowed in the cluster per data node.
        """
        cluster_routing_allocation_balance_prefer_primary: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, OpenSearch attempts to evenly distribute the primary shards between the cluster nodes. Enabling this setting does not always guarantee an equal number of primary shards on each node, especially in the event of a failover. Changing this setting to false after it was set to true does not invoke redistribution of primary shards. Default is false.
        """
        cluster_routing_allocation_node_concurrent_recoveries: NotRequired[pulumi.Input[builtins.int]]
        """
        Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to node cpu count * 2.
        """
        cluster_search_request_slowlog: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgsDict']]
        custom_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
        """
        disk_watermarks: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesDiskWatermarksArgsDict']]
        """
        Watermark settings.
        """
        elasticsearch_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Elasticsearch major version.
        """
        email_sender_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.
        """
        email_sender_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.
        """
        email_sender_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Sender username for Opensearch alerts.
        """
        enable_remote_backed_storage: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable remote-backed storage.
        """
        enable_searchable_snapshots: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable searchable snapshots.
        """
        enable_security_audit: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable/Disable security audit.
        """
        http_max_content_length: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
        """
        http_max_header_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The max size of allowed headers, in bytes.
        """
        http_max_initial_line_length: NotRequired[pulumi.Input[builtins.int]]
        """
        The max length of an HTTP URL, in bytes.
        """
        index_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Index patterns.
        """
        index_rollup: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgsDict']]
        """
        Index rollup settings.
        """
        index_template: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgsDict']]
        """
        Template settings for all new indexes.
        """
        indices_fielddata_cache_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
        """
        indices_memory_index_buffer_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
        """
        indices_memory_max_index_buffer_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.
        """
        indices_memory_min_index_buffer_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.
        """
        indices_queries_cache_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
        """
        indices_query_bool_max_clause_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
        """
        indices_recovery_max_bytes_per_sec: NotRequired[pulumi.Input[builtins.int]]
        """
        Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.
        """
        indices_recovery_max_concurrent_file_chunks: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of file chunks sent in parallel for each recovery. Defaults to 2.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        ism_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether ISM is enabled or not.
        """
        ism_history_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.
        """
        ism_history_max_age: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum age before rolling over the audit history index in hours.
        """
        ism_history_max_docs: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of documents before rolling over the audit history index.
        """
        ism_history_rollover_check_period: NotRequired[pulumi.Input[builtins.int]]
        """
        The time between rollover checks for the audit history index in hours.
        """
        ism_history_rollover_retention_period: NotRequired[pulumi.Input[builtins.int]]
        """
        How long audit history indices are kept in days.
        """
        keep_index_refresh_interval: NotRequired[pulumi.Input[builtins.bool]]
        """
        Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        knn_memory_circuit_breaker_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable KNN memory circuit breaker. Defaults to true.
        """
        knn_memory_circuit_breaker_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.
        """
        openid: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgsDict']]
        """
        OpenSearch OpenID Connect Configuration.
        """
        opensearch_dashboards: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgsDict']]
        """
        OpenSearch Dashboards settings.
        """
        override_main_response_version: NotRequired[pulumi.Input[builtins.bool]]
        """
        Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.
        """
        plugins_alerting_filter_by_backend_roles: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.
        """
        public_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        reindex_remote_whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
        """
        saml: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgsDict']]
        """
        OpenSearch SAML configuration.
        """
        script_max_compilations_rate: NotRequired[pulumi.Input[builtins.str]]
        """
        Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.
        """
        search_backpressure: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureArgsDict']]
        """
        Search Backpressure Settings.
        """
        search_insights_top_queries: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgsDict']]
        search_max_buckets: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
        """
        segrep: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSegrepArgsDict']]
        """
        Segment Replication Backpressure Settings.
        """
        service_log: NotRequired[pulumi.Input[builtins.bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        shard_indexing_pressure: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgsDict']]
        """
        Shard indexing back pressure settings.
        """
        thread_pool_analyze_queue_size: NotRequired[pulumi.Input[builtins.int]]
        """
        analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_analyze_size: NotRequired[pulumi.Input[builtins.int]]
        """
        analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_force_merge_size: NotRequired[pulumi.Input[builtins.int]]
        """
        force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_get_queue_size: NotRequired[pulumi.Input[builtins.int]]
        """
        get thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_get_size: NotRequired[pulumi.Input[builtins.int]]
        """
        get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_search_queue_size: NotRequired[pulumi.Input[builtins.int]]
        """
        search thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_search_size: NotRequired[pulumi.Input[builtins.int]]
        """
        search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_search_throttled_queue_size: NotRequired[pulumi.Input[builtins.int]]
        """
        search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_search_throttled_size: NotRequired[pulumi.Input[builtins.int]]
        """
        search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_write_queue_size: NotRequired[pulumi.Input[builtins.int]]
        """
        write thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_write_size: NotRequired[pulumi.Input[builtins.int]]
        """
        write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        OpenSearch major version.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesArgs:
    def __init__(__self__, *,
                 action_auto_create_index_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 action_destructive_requires_name: Optional[pulumi.Input[builtins.bool]] = None,
                 auth_failure_listeners: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs']] = None,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 cluster_max_shards_per_node: Optional[pulumi.Input[builtins.int]] = None,
                 cluster_routing_allocation_balance_prefer_primary: Optional[pulumi.Input[builtins.bool]] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[pulumi.Input[builtins.int]] = None,
                 cluster_search_request_slowlog: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgs']] = None,
                 custom_domain: Optional[pulumi.Input[builtins.str]] = None,
                 disk_watermarks: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesDiskWatermarksArgs']] = None,
                 elasticsearch_version: Optional[pulumi.Input[builtins.str]] = None,
                 email_sender_name: Optional[pulumi.Input[builtins.str]] = None,
                 email_sender_password: Optional[pulumi.Input[builtins.str]] = None,
                 email_sender_username: Optional[pulumi.Input[builtins.str]] = None,
                 enable_remote_backed_storage: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_searchable_snapshots: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_security_audit: Optional[pulumi.Input[builtins.bool]] = None,
                 http_max_content_length: Optional[pulumi.Input[builtins.int]] = None,
                 http_max_header_size: Optional[pulumi.Input[builtins.int]] = None,
                 http_max_initial_line_length: Optional[pulumi.Input[builtins.int]] = None,
                 index_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 index_rollup: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgs']] = None,
                 index_template: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgs']] = None,
                 indices_fielddata_cache_size: Optional[pulumi.Input[builtins.int]] = None,
                 indices_memory_index_buffer_size: Optional[pulumi.Input[builtins.int]] = None,
                 indices_memory_max_index_buffer_size: Optional[pulumi.Input[builtins.int]] = None,
                 indices_memory_min_index_buffer_size: Optional[pulumi.Input[builtins.int]] = None,
                 indices_queries_cache_size: Optional[pulumi.Input[builtins.int]] = None,
                 indices_query_bool_max_clause_count: Optional[pulumi.Input[builtins.int]] = None,
                 indices_recovery_max_bytes_per_sec: Optional[pulumi.Input[builtins.int]] = None,
                 indices_recovery_max_concurrent_file_chunks: Optional[pulumi.Input[builtins.int]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 ism_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 ism_history_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 ism_history_max_age: Optional[pulumi.Input[builtins.int]] = None,
                 ism_history_max_docs: Optional[pulumi.Input[builtins.int]] = None,
                 ism_history_rollover_check_period: Optional[pulumi.Input[builtins.int]] = None,
                 ism_history_rollover_retention_period: Optional[pulumi.Input[builtins.int]] = None,
                 keep_index_refresh_interval: Optional[pulumi.Input[builtins.bool]] = None,
                 knn_memory_circuit_breaker_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 knn_memory_circuit_breaker_limit: Optional[pulumi.Input[builtins.int]] = None,
                 openid: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgs']] = None,
                 opensearch_dashboards: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs']] = None,
                 override_main_response_version: Optional[pulumi.Input[builtins.bool]] = None,
                 plugins_alerting_filter_by_backend_roles: Optional[pulumi.Input[builtins.bool]] = None,
                 public_access: Optional[pulumi.Input[builtins.bool]] = None,
                 reindex_remote_whitelists: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 saml: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgs']] = None,
                 script_max_compilations_rate: Optional[pulumi.Input[builtins.str]] = None,
                 search_backpressure: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureArgs']] = None,
                 search_insights_top_queries: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgs']] = None,
                 search_max_buckets: Optional[pulumi.Input[builtins.int]] = None,
                 segrep: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSegrepArgs']] = None,
                 service_log: Optional[pulumi.Input[builtins.bool]] = None,
                 shard_indexing_pressure: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgs']] = None,
                 thread_pool_analyze_queue_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_analyze_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_force_merge_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_get_queue_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_get_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_search_queue_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_search_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_search_throttled_queue_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_search_throttled_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_write_queue_size: Optional[pulumi.Input[builtins.int]] = None,
                 thread_pool_write_size: Optional[pulumi.Input[builtins.int]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] action_auto_create_index_enabled: action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.
        :param pulumi.Input[builtins.bool] action_destructive_requires_name: Require explicit index names when deleting.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs'] auth_failure_listeners: Opensearch Security Plugin Settings.
        :param pulumi.Input[builtins.bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[builtins.int] cluster_max_shards_per_node: Controls the number of shards allowed in the cluster per data node.
        :param pulumi.Input[builtins.bool] cluster_routing_allocation_balance_prefer_primary: When set to true, OpenSearch attempts to evenly distribute the primary shards between the cluster nodes. Enabling this setting does not always guarantee an equal number of primary shards on each node, especially in the event of a failover. Changing this setting to false after it was set to true does not invoke redistribution of primary shards. Default is false.
        :param pulumi.Input[builtins.int] cluster_routing_allocation_node_concurrent_recoveries: Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to node cpu count * 2.
        :param pulumi.Input[builtins.str] custom_domain: Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesDiskWatermarksArgs'] disk_watermarks: Watermark settings.
        :param pulumi.Input[builtins.str] elasticsearch_version: Elasticsearch major version.
        :param pulumi.Input[builtins.str] email_sender_name: Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.
        :param pulumi.Input[builtins.str] email_sender_password: Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.
        :param pulumi.Input[builtins.str] email_sender_username: Sender username for Opensearch alerts.
        :param pulumi.Input[builtins.bool] enable_remote_backed_storage: Enable remote-backed storage.
        :param pulumi.Input[builtins.bool] enable_searchable_snapshots: Enable searchable snapshots.
        :param pulumi.Input[builtins.bool] enable_security_audit: Enable/Disable security audit.
        :param pulumi.Input[builtins.int] http_max_content_length: Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
        :param pulumi.Input[builtins.int] http_max_header_size: The max size of allowed headers, in bytes.
        :param pulumi.Input[builtins.int] http_max_initial_line_length: The max length of an HTTP URL, in bytes.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] index_patterns: Index patterns.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgs'] index_rollup: Index rollup settings.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgs'] index_template: Template settings for all new indexes.
        :param pulumi.Input[builtins.int] indices_fielddata_cache_size: Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
        :param pulumi.Input[builtins.int] indices_memory_index_buffer_size: Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
        :param pulumi.Input[builtins.int] indices_memory_max_index_buffer_size: Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.
        :param pulumi.Input[builtins.int] indices_memory_min_index_buffer_size: Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.
        :param pulumi.Input[builtins.int] indices_queries_cache_size: Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
        :param pulumi.Input[builtins.int] indices_query_bool_max_clause_count: Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
        :param pulumi.Input[builtins.int] indices_recovery_max_bytes_per_sec: Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.
        :param pulumi.Input[builtins.int] indices_recovery_max_concurrent_file_chunks: Number of file chunks sent in parallel for each recovery. Defaults to 2.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input[builtins.bool] ism_enabled: Specifies whether ISM is enabled or not.
        :param pulumi.Input[builtins.bool] ism_history_enabled: Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.
        :param pulumi.Input[builtins.int] ism_history_max_age: The maximum age before rolling over the audit history index in hours.
        :param pulumi.Input[builtins.int] ism_history_max_docs: The maximum number of documents before rolling over the audit history index.
        :param pulumi.Input[builtins.int] ism_history_rollover_check_period: The time between rollover checks for the audit history index in hours.
        :param pulumi.Input[builtins.int] ism_history_rollover_retention_period: How long audit history indices are kept in days.
        :param pulumi.Input[builtins.bool] keep_index_refresh_interval: Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param pulumi.Input[builtins.bool] knn_memory_circuit_breaker_enabled: Enable or disable KNN memory circuit breaker. Defaults to true.
        :param pulumi.Input[builtins.int] knn_memory_circuit_breaker_limit: Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgs'] openid: OpenSearch OpenID Connect Configuration.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs'] opensearch_dashboards: OpenSearch Dashboards settings.
        :param pulumi.Input[builtins.bool] override_main_response_version: Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.
        :param pulumi.Input[builtins.bool] plugins_alerting_filter_by_backend_roles: Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.
        :param pulumi.Input[builtins.bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] reindex_remote_whitelists: Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgs'] saml: OpenSearch SAML configuration.
        :param pulumi.Input[builtins.str] script_max_compilations_rate: Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureArgs'] search_backpressure: Search Backpressure Settings.
        :param pulumi.Input[builtins.int] search_max_buckets: Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSegrepArgs'] segrep: Segment Replication Backpressure Settings.
        :param pulumi.Input[builtins.bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgs'] shard_indexing_pressure: Shard indexing back pressure settings.
        :param pulumi.Input[builtins.int] thread_pool_analyze_queue_size: analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[builtins.int] thread_pool_analyze_size: analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[builtins.int] thread_pool_force_merge_size: force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[builtins.int] thread_pool_get_queue_size: get thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[builtins.int] thread_pool_get_size: get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[builtins.int] thread_pool_search_queue_size: search thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[builtins.int] thread_pool_search_size: search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[builtins.int] thread_pool_search_throttled_queue_size: search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[builtins.int] thread_pool_search_throttled_size: search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[builtins.int] thread_pool_write_queue_size: write thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[builtins.int] thread_pool_write_size: write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[builtins.str] version: OpenSearch major version.
        """
        if action_auto_create_index_enabled is not None:
            pulumi.set(__self__, "action_auto_create_index_enabled", action_auto_create_index_enabled)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if auth_failure_listeners is not None:
            pulumi.set(__self__, "auth_failure_listeners", auth_failure_listeners)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_routing_allocation_balance_prefer_primary is not None:
            pulumi.set(__self__, "cluster_routing_allocation_balance_prefer_primary", cluster_routing_allocation_balance_prefer_primary)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if cluster_search_request_slowlog is not None:
            pulumi.set(__self__, "cluster_search_request_slowlog", cluster_search_request_slowlog)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if disk_watermarks is not None:
            pulumi.set(__self__, "disk_watermarks", disk_watermarks)
        if elasticsearch_version is not None:
            pulumi.set(__self__, "elasticsearch_version", elasticsearch_version)
        if email_sender_name is not None:
            pulumi.set(__self__, "email_sender_name", email_sender_name)
        if email_sender_password is not None:
            pulumi.set(__self__, "email_sender_password", email_sender_password)
        if email_sender_username is not None:
            pulumi.set(__self__, "email_sender_username", email_sender_username)
        if enable_remote_backed_storage is not None:
            pulumi.set(__self__, "enable_remote_backed_storage", enable_remote_backed_storage)
        if enable_searchable_snapshots is not None:
            pulumi.set(__self__, "enable_searchable_snapshots", enable_searchable_snapshots)
        if enable_security_audit is not None:
            pulumi.set(__self__, "enable_security_audit", enable_security_audit)
        if http_max_content_length is not None:
            pulumi.set(__self__, "http_max_content_length", http_max_content_length)
        if http_max_header_size is not None:
            pulumi.set(__self__, "http_max_header_size", http_max_header_size)
        if http_max_initial_line_length is not None:
            pulumi.set(__self__, "http_max_initial_line_length", http_max_initial_line_length)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_rollup is not None:
            pulumi.set(__self__, "index_rollup", index_rollup)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if indices_fielddata_cache_size is not None:
            pulumi.set(__self__, "indices_fielddata_cache_size", indices_fielddata_cache_size)
        if indices_memory_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_index_buffer_size", indices_memory_index_buffer_size)
        if indices_memory_max_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_max_index_buffer_size", indices_memory_max_index_buffer_size)
        if indices_memory_min_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_min_index_buffer_size", indices_memory_min_index_buffer_size)
        if indices_queries_cache_size is not None:
            pulumi.set(__self__, "indices_queries_cache_size", indices_queries_cache_size)
        if indices_query_bool_max_clause_count is not None:
            pulumi.set(__self__, "indices_query_bool_max_clause_count", indices_query_bool_max_clause_count)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if indices_recovery_max_concurrent_file_chunks is not None:
            pulumi.set(__self__, "indices_recovery_max_concurrent_file_chunks", indices_recovery_max_concurrent_file_chunks)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if ism_enabled is not None:
            pulumi.set(__self__, "ism_enabled", ism_enabled)
        if ism_history_enabled is not None:
            pulumi.set(__self__, "ism_history_enabled", ism_history_enabled)
        if ism_history_max_age is not None:
            pulumi.set(__self__, "ism_history_max_age", ism_history_max_age)
        if ism_history_max_docs is not None:
            pulumi.set(__self__, "ism_history_max_docs", ism_history_max_docs)
        if ism_history_rollover_check_period is not None:
            pulumi.set(__self__, "ism_history_rollover_check_period", ism_history_rollover_check_period)
        if ism_history_rollover_retention_period is not None:
            pulumi.set(__self__, "ism_history_rollover_retention_period", ism_history_rollover_retention_period)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if knn_memory_circuit_breaker_enabled is not None:
            pulumi.set(__self__, "knn_memory_circuit_breaker_enabled", knn_memory_circuit_breaker_enabled)
        if knn_memory_circuit_breaker_limit is not None:
            pulumi.set(__self__, "knn_memory_circuit_breaker_limit", knn_memory_circuit_breaker_limit)
        if openid is not None:
            pulumi.set(__self__, "openid", openid)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if override_main_response_version is not None:
            pulumi.set(__self__, "override_main_response_version", override_main_response_version)
        if plugins_alerting_filter_by_backend_roles is not None:
            pulumi.set(__self__, "plugins_alerting_filter_by_backend_roles", plugins_alerting_filter_by_backend_roles)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if reindex_remote_whitelists is not None:
            pulumi.set(__self__, "reindex_remote_whitelists", reindex_remote_whitelists)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_backpressure is not None:
            pulumi.set(__self__, "search_backpressure", search_backpressure)
        if search_insights_top_queries is not None:
            pulumi.set(__self__, "search_insights_top_queries", search_insights_top_queries)
        if search_max_buckets is not None:
            pulumi.set(__self__, "search_max_buckets", search_max_buckets)
        if segrep is not None:
            pulumi.set(__self__, "segrep", segrep)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if shard_indexing_pressure is not None:
            pulumi.set(__self__, "shard_indexing_pressure", shard_indexing_pressure)
        if thread_pool_analyze_queue_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_queue_size", thread_pool_analyze_queue_size)
        if thread_pool_analyze_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_size", thread_pool_analyze_size)
        if thread_pool_force_merge_size is not None:
            pulumi.set(__self__, "thread_pool_force_merge_size", thread_pool_force_merge_size)
        if thread_pool_get_queue_size is not None:
            pulumi.set(__self__, "thread_pool_get_queue_size", thread_pool_get_queue_size)
        if thread_pool_get_size is not None:
            pulumi.set(__self__, "thread_pool_get_size", thread_pool_get_size)
        if thread_pool_search_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_queue_size", thread_pool_search_queue_size)
        if thread_pool_search_size is not None:
            pulumi.set(__self__, "thread_pool_search_size", thread_pool_search_size)
        if thread_pool_search_throttled_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_queue_size", thread_pool_search_throttled_queue_size)
        if thread_pool_search_throttled_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_size", thread_pool_search_throttled_size)
        if thread_pool_write_queue_size is not None:
            pulumi.set(__self__, "thread_pool_write_queue_size", thread_pool_write_queue_size)
        if thread_pool_write_size is not None:
            pulumi.set(__self__, "thread_pool_write_size", thread_pool_write_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="actionAutoCreateIndexEnabled")
    def action_auto_create_index_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.
        """
        return pulumi.get(self, "action_auto_create_index_enabled")

    @action_auto_create_index_enabled.setter
    def action_auto_create_index_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "action_auto_create_index_enabled", value)

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Require explicit index names when deleting.
        """
        return pulumi.get(self, "action_destructive_requires_name")

    @action_destructive_requires_name.setter
    def action_destructive_requires_name(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "action_destructive_requires_name", value)

    @property
    @pulumi.getter(name="authFailureListeners")
    def auth_failure_listeners(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs']]:
        """
        Opensearch Security Plugin Settings.
        """
        return pulumi.get(self, "auth_failure_listeners")

    @auth_failure_listeners.setter
    def auth_failure_listeners(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs']]):
        pulumi.set(self, "auth_failure_listeners", value)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Controls the number of shards allowed in the cluster per data node.
        """
        return pulumi.get(self, "cluster_max_shards_per_node")

    @cluster_max_shards_per_node.setter
    def cluster_max_shards_per_node(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cluster_max_shards_per_node", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalancePreferPrimary")
    def cluster_routing_allocation_balance_prefer_primary(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, OpenSearch attempts to evenly distribute the primary shards between the cluster nodes. Enabling this setting does not always guarantee an equal number of primary shards on each node, especially in the event of a failover. Changing this setting to false after it was set to true does not invoke redistribution of primary shards. Default is false.
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_prefer_primary")

    @cluster_routing_allocation_balance_prefer_primary.setter
    def cluster_routing_allocation_balance_prefer_primary(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cluster_routing_allocation_balance_prefer_primary", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to node cpu count * 2.
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @cluster_routing_allocation_node_concurrent_recoveries.setter
    def cluster_routing_allocation_node_concurrent_recoveries(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cluster_routing_allocation_node_concurrent_recoveries", value)

    @property
    @pulumi.getter(name="clusterSearchRequestSlowlog")
    def cluster_search_request_slowlog(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgs']]:
        return pulumi.get(self, "cluster_search_request_slowlog")

    @cluster_search_request_slowlog.setter
    def cluster_search_request_slowlog(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgs']]):
        pulumi.set(self, "cluster_search_request_slowlog", value)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
        """
        return pulumi.get(self, "custom_domain")

    @custom_domain.setter
    def custom_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_domain", value)

    @property
    @pulumi.getter(name="diskWatermarks")
    def disk_watermarks(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesDiskWatermarksArgs']]:
        """
        Watermark settings.
        """
        return pulumi.get(self, "disk_watermarks")

    @disk_watermarks.setter
    def disk_watermarks(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesDiskWatermarksArgs']]):
        pulumi.set(self, "disk_watermarks", value)

    @property
    @pulumi.getter(name="elasticsearchVersion")
    def elasticsearch_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Elasticsearch major version.
        """
        return pulumi.get(self, "elasticsearch_version")

    @elasticsearch_version.setter
    def elasticsearch_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "elasticsearch_version", value)

    @property
    @pulumi.getter(name="emailSenderName")
    def email_sender_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.
        """
        return pulumi.get(self, "email_sender_name")

    @email_sender_name.setter
    def email_sender_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_sender_name", value)

    @property
    @pulumi.getter(name="emailSenderPassword")
    def email_sender_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.
        """
        return pulumi.get(self, "email_sender_password")

    @email_sender_password.setter
    def email_sender_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_sender_password", value)

    @property
    @pulumi.getter(name="emailSenderUsername")
    def email_sender_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sender username for Opensearch alerts.
        """
        return pulumi.get(self, "email_sender_username")

    @email_sender_username.setter
    def email_sender_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email_sender_username", value)

    @property
    @pulumi.getter(name="enableRemoteBackedStorage")
    def enable_remote_backed_storage(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable remote-backed storage.
        """
        return pulumi.get(self, "enable_remote_backed_storage")

    @enable_remote_backed_storage.setter
    def enable_remote_backed_storage(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_remote_backed_storage", value)

    @property
    @pulumi.getter(name="enableSearchableSnapshots")
    def enable_searchable_snapshots(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable searchable snapshots.
        """
        return pulumi.get(self, "enable_searchable_snapshots")

    @enable_searchable_snapshots.setter
    def enable_searchable_snapshots(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_searchable_snapshots", value)

    @property
    @pulumi.getter(name="enableSecurityAudit")
    def enable_security_audit(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable/Disable security audit.
        """
        return pulumi.get(self, "enable_security_audit")

    @enable_security_audit.setter
    def enable_security_audit(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_security_audit", value)

    @property
    @pulumi.getter(name="httpMaxContentLength")
    def http_max_content_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
        """
        return pulumi.get(self, "http_max_content_length")

    @http_max_content_length.setter
    def http_max_content_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http_max_content_length", value)

    @property
    @pulumi.getter(name="httpMaxHeaderSize")
    def http_max_header_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The max size of allowed headers, in bytes.
        """
        return pulumi.get(self, "http_max_header_size")

    @http_max_header_size.setter
    def http_max_header_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http_max_header_size", value)

    @property
    @pulumi.getter(name="httpMaxInitialLineLength")
    def http_max_initial_line_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The max length of an HTTP URL, in bytes.
        """
        return pulumi.get(self, "http_max_initial_line_length")

    @http_max_initial_line_length.setter
    def http_max_initial_line_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http_max_initial_line_length", value)

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Index patterns.
        """
        return pulumi.get(self, "index_patterns")

    @index_patterns.setter
    def index_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "index_patterns", value)

    @property
    @pulumi.getter(name="indexRollup")
    def index_rollup(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgs']]:
        """
        Index rollup settings.
        """
        return pulumi.get(self, "index_rollup")

    @index_rollup.setter
    def index_rollup(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgs']]):
        pulumi.set(self, "index_rollup", value)

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgs']]:
        """
        Template settings for all new indexes.
        """
        return pulumi.get(self, "index_template")

    @index_template.setter
    def index_template(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgs']]):
        pulumi.set(self, "index_template", value)

    @property
    @pulumi.getter(name="indicesFielddataCacheSize")
    def indices_fielddata_cache_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
        """
        return pulumi.get(self, "indices_fielddata_cache_size")

    @indices_fielddata_cache_size.setter
    def indices_fielddata_cache_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "indices_fielddata_cache_size", value)

    @property
    @pulumi.getter(name="indicesMemoryIndexBufferSize")
    def indices_memory_index_buffer_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
        """
        return pulumi.get(self, "indices_memory_index_buffer_size")

    @indices_memory_index_buffer_size.setter
    def indices_memory_index_buffer_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "indices_memory_index_buffer_size", value)

    @property
    @pulumi.getter(name="indicesMemoryMaxIndexBufferSize")
    def indices_memory_max_index_buffer_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.
        """
        return pulumi.get(self, "indices_memory_max_index_buffer_size")

    @indices_memory_max_index_buffer_size.setter
    def indices_memory_max_index_buffer_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "indices_memory_max_index_buffer_size", value)

    @property
    @pulumi.getter(name="indicesMemoryMinIndexBufferSize")
    def indices_memory_min_index_buffer_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.
        """
        return pulumi.get(self, "indices_memory_min_index_buffer_size")

    @indices_memory_min_index_buffer_size.setter
    def indices_memory_min_index_buffer_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "indices_memory_min_index_buffer_size", value)

    @property
    @pulumi.getter(name="indicesQueriesCacheSize")
    def indices_queries_cache_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
        """
        return pulumi.get(self, "indices_queries_cache_size")

    @indices_queries_cache_size.setter
    def indices_queries_cache_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "indices_queries_cache_size", value)

    @property
    @pulumi.getter(name="indicesQueryBoolMaxClauseCount")
    def indices_query_bool_max_clause_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
        """
        return pulumi.get(self, "indices_query_bool_max_clause_count")

    @indices_query_bool_max_clause_count.setter
    def indices_query_bool_max_clause_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "indices_query_bool_max_clause_count", value)

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.
        """
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @indices_recovery_max_bytes_per_sec.setter
    def indices_recovery_max_bytes_per_sec(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "indices_recovery_max_bytes_per_sec", value)

    @property
    @pulumi.getter(name="indicesRecoveryMaxConcurrentFileChunks")
    def indices_recovery_max_concurrent_file_chunks(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of file chunks sent in parallel for each recovery. Defaults to 2.
        """
        return pulumi.get(self, "indices_recovery_max_concurrent_file_chunks")

    @indices_recovery_max_concurrent_file_chunks.setter
    def indices_recovery_max_concurrent_file_chunks(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "indices_recovery_max_concurrent_file_chunks", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="ismEnabled")
    def ism_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether ISM is enabled or not.
        """
        return pulumi.get(self, "ism_enabled")

    @ism_enabled.setter
    def ism_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ism_enabled", value)

    @property
    @pulumi.getter(name="ismHistoryEnabled")
    def ism_history_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.
        """
        return pulumi.get(self, "ism_history_enabled")

    @ism_history_enabled.setter
    def ism_history_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ism_history_enabled", value)

    @property
    @pulumi.getter(name="ismHistoryMaxAge")
    def ism_history_max_age(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum age before rolling over the audit history index in hours.
        """
        return pulumi.get(self, "ism_history_max_age")

    @ism_history_max_age.setter
    def ism_history_max_age(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ism_history_max_age", value)

    @property
    @pulumi.getter(name="ismHistoryMaxDocs")
    def ism_history_max_docs(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of documents before rolling over the audit history index.
        """
        return pulumi.get(self, "ism_history_max_docs")

    @ism_history_max_docs.setter
    def ism_history_max_docs(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ism_history_max_docs", value)

    @property
    @pulumi.getter(name="ismHistoryRolloverCheckPeriod")
    def ism_history_rollover_check_period(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time between rollover checks for the audit history index in hours.
        """
        return pulumi.get(self, "ism_history_rollover_check_period")

    @ism_history_rollover_check_period.setter
    def ism_history_rollover_check_period(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ism_history_rollover_check_period", value)

    @property
    @pulumi.getter(name="ismHistoryRolloverRetentionPeriod")
    def ism_history_rollover_retention_period(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How long audit history indices are kept in days.
        """
        return pulumi.get(self, "ism_history_rollover_retention_period")

    @ism_history_rollover_retention_period.setter
    def ism_history_rollover_retention_period(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ism_history_rollover_retention_period", value)

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @keep_index_refresh_interval.setter
    def keep_index_refresh_interval(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "keep_index_refresh_interval", value)

    @property
    @pulumi.getter(name="knnMemoryCircuitBreakerEnabled")
    def knn_memory_circuit_breaker_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable KNN memory circuit breaker. Defaults to true.
        """
        return pulumi.get(self, "knn_memory_circuit_breaker_enabled")

    @knn_memory_circuit_breaker_enabled.setter
    def knn_memory_circuit_breaker_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "knn_memory_circuit_breaker_enabled", value)

    @property
    @pulumi.getter(name="knnMemoryCircuitBreakerLimit")
    def knn_memory_circuit_breaker_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.
        """
        return pulumi.get(self, "knn_memory_circuit_breaker_limit")

    @knn_memory_circuit_breaker_limit.setter
    def knn_memory_circuit_breaker_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "knn_memory_circuit_breaker_limit", value)

    @property
    @pulumi.getter
    def openid(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgs']]:
        """
        OpenSearch OpenID Connect Configuration.
        """
        return pulumi.get(self, "openid")

    @openid.setter
    def openid(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgs']]):
        pulumi.set(self, "openid", value)

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs']]:
        """
        OpenSearch Dashboards settings.
        """
        return pulumi.get(self, "opensearch_dashboards")

    @opensearch_dashboards.setter
    def opensearch_dashboards(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs']]):
        pulumi.set(self, "opensearch_dashboards", value)

    @property
    @pulumi.getter(name="overrideMainResponseVersion")
    def override_main_response_version(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.
        """
        return pulumi.get(self, "override_main_response_version")

    @override_main_response_version.setter
    def override_main_response_version(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "override_main_response_version", value)

    @property
    @pulumi.getter(name="pluginsAlertingFilterByBackendRoles")
    def plugins_alerting_filter_by_backend_roles(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.
        """
        return pulumi.get(self, "plugins_alerting_filter_by_backend_roles")

    @plugins_alerting_filter_by_backend_roles.setter
    def plugins_alerting_filter_by_backend_roles(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "plugins_alerting_filter_by_backend_roles", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="reindexRemoteWhitelists")
    def reindex_remote_whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
        """
        return pulumi.get(self, "reindex_remote_whitelists")

    @reindex_remote_whitelists.setter
    def reindex_remote_whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "reindex_remote_whitelists", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgs']]:
        """
        OpenSearch SAML configuration.
        """
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.
        """
        return pulumi.get(self, "script_max_compilations_rate")

    @script_max_compilations_rate.setter
    def script_max_compilations_rate(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "script_max_compilations_rate", value)

    @property
    @pulumi.getter(name="searchBackpressure")
    def search_backpressure(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureArgs']]:
        """
        Search Backpressure Settings.
        """
        return pulumi.get(self, "search_backpressure")

    @search_backpressure.setter
    def search_backpressure(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureArgs']]):
        pulumi.set(self, "search_backpressure", value)

    @property
    @pulumi.getter(name="searchInsightsTopQueries")
    def search_insights_top_queries(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgs']]:
        return pulumi.get(self, "search_insights_top_queries")

    @search_insights_top_queries.setter
    def search_insights_top_queries(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgs']]):
        pulumi.set(self, "search_insights_top_queries", value)

    @property
    @pulumi.getter(name="searchMaxBuckets")
    def search_max_buckets(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
        """
        return pulumi.get(self, "search_max_buckets")

    @search_max_buckets.setter
    def search_max_buckets(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "search_max_buckets", value)

    @property
    @pulumi.getter
    def segrep(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSegrepArgs']]:
        """
        Segment Replication Backpressure Settings.
        """
        return pulumi.get(self, "segrep")

    @segrep.setter
    def segrep(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSegrepArgs']]):
        pulumi.set(self, "segrep", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "service_log", value)

    @property
    @pulumi.getter(name="shardIndexingPressure")
    def shard_indexing_pressure(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgs']]:
        """
        Shard indexing back pressure settings.
        """
        return pulumi.get(self, "shard_indexing_pressure")

    @shard_indexing_pressure.setter
    def shard_indexing_pressure(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgs']]):
        pulumi.set(self, "shard_indexing_pressure", value)

    @property
    @pulumi.getter(name="threadPoolAnalyzeQueueSize")
    def thread_pool_analyze_queue_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_analyze_queue_size")

    @thread_pool_analyze_queue_size.setter
    def thread_pool_analyze_queue_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_analyze_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolAnalyzeSize")
    def thread_pool_analyze_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_analyze_size")

    @thread_pool_analyze_size.setter
    def thread_pool_analyze_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_analyze_size", value)

    @property
    @pulumi.getter(name="threadPoolForceMergeSize")
    def thread_pool_force_merge_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_force_merge_size")

    @thread_pool_force_merge_size.setter
    def thread_pool_force_merge_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_force_merge_size", value)

    @property
    @pulumi.getter(name="threadPoolGetQueueSize")
    def thread_pool_get_queue_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        get thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_get_queue_size")

    @thread_pool_get_queue_size.setter
    def thread_pool_get_queue_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_get_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolGetSize")
    def thread_pool_get_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_get_size")

    @thread_pool_get_size.setter
    def thread_pool_get_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_get_size", value)

    @property
    @pulumi.getter(name="threadPoolSearchQueueSize")
    def thread_pool_search_queue_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        search thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_search_queue_size")

    @thread_pool_search_queue_size.setter
    def thread_pool_search_queue_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_search_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolSearchSize")
    def thread_pool_search_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_search_size")

    @thread_pool_search_size.setter
    def thread_pool_search_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_search_size", value)

    @property
    @pulumi.getter(name="threadPoolSearchThrottledQueueSize")
    def thread_pool_search_throttled_queue_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_search_throttled_queue_size")

    @thread_pool_search_throttled_queue_size.setter
    def thread_pool_search_throttled_queue_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_search_throttled_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolSearchThrottledSize")
    def thread_pool_search_throttled_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_search_throttled_size")

    @thread_pool_search_throttled_size.setter
    def thread_pool_search_throttled_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_search_throttled_size", value)

    @property
    @pulumi.getter(name="threadPoolWriteQueueSize")
    def thread_pool_write_queue_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        write thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_write_queue_size")

    @thread_pool_write_queue_size.setter
    def thread_pool_write_queue_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_write_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolWriteSize")
    def thread_pool_write_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_write_size")

    @thread_pool_write_size.setter
    def thread_pool_write_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "thread_pool_write_size", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        OpenSearch major version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgsDict(TypedDict):
        internal_authentication_backend_limiting: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgsDict']]
elif False:
    ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs:
    def __init__(__self__, *,
                 internal_authentication_backend_limiting: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs']] = None):
        if internal_authentication_backend_limiting is not None:
            pulumi.set(__self__, "internal_authentication_backend_limiting", internal_authentication_backend_limiting)

    @property
    @pulumi.getter(name="internalAuthenticationBackendLimiting")
    def internal_authentication_backend_limiting(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs']]:
        return pulumi.get(self, "internal_authentication_backend_limiting")

    @internal_authentication_backend_limiting.setter
    def internal_authentication_backend_limiting(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs']]):
        pulumi.set(self, "internal_authentication_backend_limiting", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgsDict(TypedDict):
        allowed_tries: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of login attempts allowed before login is blocked.
        """
        authentication_backend: NotRequired[pulumi.Input[builtins.str]]
        """
        The internal backend. Enter `internal`.
        """
        block_expiry_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The duration of time that login remains blocked after a failed login.
        """
        max_blocked_clients: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of blocked IP addresses.
        """
        max_tracked_clients: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of tracked IP addresses that have failed login.
        """
        time_window_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The window of time in which the value for `allowed_tries` is enforced.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of rate limiting.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs:
    def __init__(__self__, *,
                 allowed_tries: Optional[pulumi.Input[builtins.int]] = None,
                 authentication_backend: Optional[pulumi.Input[builtins.str]] = None,
                 block_expiry_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 max_blocked_clients: Optional[pulumi.Input[builtins.int]] = None,
                 max_tracked_clients: Optional[pulumi.Input[builtins.int]] = None,
                 time_window_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] allowed_tries: The number of login attempts allowed before login is blocked.
        :param pulumi.Input[builtins.str] authentication_backend: The internal backend. Enter `internal`.
        :param pulumi.Input[builtins.int] block_expiry_seconds: The duration of time that login remains blocked after a failed login.
        :param pulumi.Input[builtins.int] max_blocked_clients: The maximum number of blocked IP addresses.
        :param pulumi.Input[builtins.int] max_tracked_clients: The maximum number of tracked IP addresses that have failed login.
        :param pulumi.Input[builtins.int] time_window_seconds: The window of time in which the value for `allowed_tries` is enforced.
        :param pulumi.Input[builtins.str] type: The type of rate limiting.
        """
        if allowed_tries is not None:
            pulumi.set(__self__, "allowed_tries", allowed_tries)
        if authentication_backend is not None:
            pulumi.set(__self__, "authentication_backend", authentication_backend)
        if block_expiry_seconds is not None:
            pulumi.set(__self__, "block_expiry_seconds", block_expiry_seconds)
        if max_blocked_clients is not None:
            pulumi.set(__self__, "max_blocked_clients", max_blocked_clients)
        if max_tracked_clients is not None:
            pulumi.set(__self__, "max_tracked_clients", max_tracked_clients)
        if time_window_seconds is not None:
            pulumi.set(__self__, "time_window_seconds", time_window_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedTries")
    def allowed_tries(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of login attempts allowed before login is blocked.
        """
        return pulumi.get(self, "allowed_tries")

    @allowed_tries.setter
    def allowed_tries(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "allowed_tries", value)

    @property
    @pulumi.getter(name="authenticationBackend")
    def authentication_backend(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The internal backend. Enter `internal`.
        """
        return pulumi.get(self, "authentication_backend")

    @authentication_backend.setter
    def authentication_backend(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authentication_backend", value)

    @property
    @pulumi.getter(name="blockExpirySeconds")
    def block_expiry_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The duration of time that login remains blocked after a failed login.
        """
        return pulumi.get(self, "block_expiry_seconds")

    @block_expiry_seconds.setter
    def block_expiry_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "block_expiry_seconds", value)

    @property
    @pulumi.getter(name="maxBlockedClients")
    def max_blocked_clients(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of blocked IP addresses.
        """
        return pulumi.get(self, "max_blocked_clients")

    @max_blocked_clients.setter
    def max_blocked_clients(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_blocked_clients", value)

    @property
    @pulumi.getter(name="maxTrackedClients")
    def max_tracked_clients(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of tracked IP addresses that have failed login.
        """
        return pulumi.get(self, "max_tracked_clients")

    @max_tracked_clients.setter
    def max_tracked_clients(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_tracked_clients", value)

    @property
    @pulumi.getter(name="timeWindowSeconds")
    def time_window_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The window of time in which the value for `allowed_tries` is enforced.
        """
        return pulumi.get(self, "time_window_seconds")

    @time_window_seconds.setter
    def time_window_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "time_window_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of rate limiting.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[builtins.str]]
        """
        Log level.
        """
        threshold: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgsDict']]
elif False:
    ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[builtins.str]] = None,
                 threshold: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgs']] = None):
        """
        :param pulumi.Input[builtins.str] level: Log level.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgs']]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgs']]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgsDict(TypedDict):
        debug: NotRequired[pulumi.Input[builtins.str]]
        """
        Debug threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
        info: NotRequired[pulumi.Input[builtins.str]]
        """
        Info threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
        trace: NotRequired[pulumi.Input[builtins.str]]
        """
        Trace threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
        warn: NotRequired[pulumi.Input[builtins.str]]
        """
        Warning threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesClusterSearchRequestSlowlogThresholdArgs:
    def __init__(__self__, *,
                 debug: Optional[pulumi.Input[builtins.str]] = None,
                 info: Optional[pulumi.Input[builtins.str]] = None,
                 trace: Optional[pulumi.Input[builtins.str]] = None,
                 warn: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] debug: Debug threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        :param pulumi.Input[builtins.str] info: Info threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        :param pulumi.Input[builtins.str] trace: Trace threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        :param pulumi.Input[builtins.str] warn: Warning threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if info is not None:
            pulumi.set(__self__, "info", info)
        if trace is not None:
            pulumi.set(__self__, "trace", trace)
        if warn is not None:
            pulumi.set(__self__, "warn", warn)

    @property
    @pulumi.getter
    def debug(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Debug threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "debug", value)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Info threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter
    def trace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Trace threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
        return pulumi.get(self, "trace")

    @trace.setter
    def trace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "trace", value)

    @property
    @pulumi.getter
    def warn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Warning threshold for total request took time. The value should be in the form count and unit, where unit one of (s,m,h,d,nanos,ms,micros) or -1. Default is -1.
        """
        return pulumi.get(self, "warn")

    @warn.setter
    def warn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "warn", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesDiskWatermarksArgsDict(TypedDict):
        flood_stage: NotRequired[pulumi.Input[builtins.int]]
        """
        Flood stage watermark (percentage). The flood stage watermark for disk usage.
        """
        high: NotRequired[pulumi.Input[builtins.int]]
        """
        High watermark (percentage). The high watermark for disk usage.
        """
        low: NotRequired[pulumi.Input[builtins.int]]
        """
        Low watermark (percentage). The low watermark for disk usage.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesDiskWatermarksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesDiskWatermarksArgs:
    def __init__(__self__, *,
                 flood_stage: Optional[pulumi.Input[builtins.int]] = None,
                 high: Optional[pulumi.Input[builtins.int]] = None,
                 low: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] flood_stage: Flood stage watermark (percentage). The flood stage watermark for disk usage.
        :param pulumi.Input[builtins.int] high: High watermark (percentage). The high watermark for disk usage.
        :param pulumi.Input[builtins.int] low: Low watermark (percentage). The low watermark for disk usage.
        """
        if flood_stage is not None:
            pulumi.set(__self__, "flood_stage", flood_stage)
        if high is not None:
            pulumi.set(__self__, "high", high)
        if low is not None:
            pulumi.set(__self__, "low", low)

    @property
    @pulumi.getter(name="floodStage")
    def flood_stage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Flood stage watermark (percentage). The flood stage watermark for disk usage.
        """
        return pulumi.get(self, "flood_stage")

    @flood_stage.setter
    def flood_stage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "flood_stage", value)

    @property
    @pulumi.getter
    def high(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        High watermark (percentage). The high watermark for disk usage.
        """
        return pulumi.get(self, "high")

    @high.setter
    def high(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "high", value)

    @property
    @pulumi.getter
    def low(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Low watermark (percentage). The low watermark for disk usage.
        """
        return pulumi.get(self, "low")

    @low.setter
    def low(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "low", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesIndexRollupArgsDict(TypedDict):
        rollup_dashboards_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.
        """
        rollup_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.
        """
        rollup_search_backoff_count: NotRequired[pulumi.Input[builtins.int]]
        """
        plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.
        """
        rollup_search_backoff_millis: NotRequired[pulumi.Input[builtins.int]]
        """
        plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.
        """
        rollup_search_search_all_jobs: NotRequired[pulumi.Input[builtins.bool]]
        """
        plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesIndexRollupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesIndexRollupArgs:
    def __init__(__self__, *,
                 rollup_dashboards_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 rollup_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 rollup_search_backoff_count: Optional[pulumi.Input[builtins.int]] = None,
                 rollup_search_backoff_millis: Optional[pulumi.Input[builtins.int]] = None,
                 rollup_search_search_all_jobs: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] rollup_dashboards_enabled: plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.
        :param pulumi.Input[builtins.bool] rollup_enabled: plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.
        :param pulumi.Input[builtins.int] rollup_search_backoff_count: plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.
        :param pulumi.Input[builtins.int] rollup_search_backoff_millis: plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.
        :param pulumi.Input[builtins.bool] rollup_search_search_all_jobs: plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.
        """
        if rollup_dashboards_enabled is not None:
            pulumi.set(__self__, "rollup_dashboards_enabled", rollup_dashboards_enabled)
        if rollup_enabled is not None:
            pulumi.set(__self__, "rollup_enabled", rollup_enabled)
        if rollup_search_backoff_count is not None:
            pulumi.set(__self__, "rollup_search_backoff_count", rollup_search_backoff_count)
        if rollup_search_backoff_millis is not None:
            pulumi.set(__self__, "rollup_search_backoff_millis", rollup_search_backoff_millis)
        if rollup_search_search_all_jobs is not None:
            pulumi.set(__self__, "rollup_search_search_all_jobs", rollup_search_search_all_jobs)

    @property
    @pulumi.getter(name="rollupDashboardsEnabled")
    def rollup_dashboards_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.
        """
        return pulumi.get(self, "rollup_dashboards_enabled")

    @rollup_dashboards_enabled.setter
    def rollup_dashboards_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rollup_dashboards_enabled", value)

    @property
    @pulumi.getter(name="rollupEnabled")
    def rollup_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.
        """
        return pulumi.get(self, "rollup_enabled")

    @rollup_enabled.setter
    def rollup_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rollup_enabled", value)

    @property
    @pulumi.getter(name="rollupSearchBackoffCount")
    def rollup_search_backoff_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.
        """
        return pulumi.get(self, "rollup_search_backoff_count")

    @rollup_search_backoff_count.setter
    def rollup_search_backoff_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rollup_search_backoff_count", value)

    @property
    @pulumi.getter(name="rollupSearchBackoffMillis")
    def rollup_search_backoff_millis(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.
        """
        return pulumi.get(self, "rollup_search_backoff_millis")

    @rollup_search_backoff_millis.setter
    def rollup_search_backoff_millis(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rollup_search_backoff_millis", value)

    @property
    @pulumi.getter(name="rollupSearchSearchAllJobs")
    def rollup_search_search_all_jobs(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.
        """
        return pulumi.get(self, "rollup_search_search_all_jobs")

    @rollup_search_search_all_jobs.setter
    def rollup_search_search_all_jobs(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rollup_search_search_all_jobs", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesIndexTemplateArgsDict(TypedDict):
        mapping_nested_objects_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
        """
        number_of_replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of replicas each primary shard has.
        """
        number_of_shards: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of primary shards that an index should have.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesIndexTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesIndexTemplateArgs:
    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[pulumi.Input[builtins.int]] = None,
                 number_of_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 number_of_shards: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] mapping_nested_objects_limit: index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
        :param pulumi.Input[builtins.int] number_of_replicas: The number of replicas each primary shard has.
        :param pulumi.Input[builtins.int] number_of_shards: The number of primary shards that an index should have.
        """
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @mapping_nested_objects_limit.setter
    def mapping_nested_objects_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "mapping_nested_objects_limit", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of replicas each primary shard has.
        """
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of primary shards that an index should have.
        """
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "number_of_shards", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesOpenidArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.
        """
        connect_url: NotRequired[pulumi.Input[builtins.str]]
        """
        OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.
        """
        header: NotRequired[pulumi.Input[builtins.str]]
        """
        HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.
        """
        jwt_header: NotRequired[pulumi.Input[builtins.str]]
        """
        The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer <token>. Optional. Default is Authorization.
        """
        jwt_url_parameter: NotRequired[pulumi.Input[builtins.str]]
        """
        URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.
        """
        refresh_rate_limit_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.
        """
        refresh_rate_limit_time_window_ms: NotRequired[pulumi.Input[builtins.int]]
        """
        The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).
        """
        roles_key: NotRequired[pulumi.Input[builtins.str]]
        """
        The key in the JSON payload that stores the users roles. The key in the JSON payload that stores the users roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.
        """
        scope: NotRequired[pulumi.Input[builtins.str]]
        """
        The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.
        """
        subject_key: NotRequired[pulumi.Input[builtins.str]]
        """
        The key in the JSON payload that stores the users name. The key in the JSON payload that stores the users name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesOpenidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesOpenidArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 connect_url: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 header: Optional[pulumi.Input[builtins.str]] = None,
                 jwt_header: Optional[pulumi.Input[builtins.str]] = None,
                 jwt_url_parameter: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_rate_limit_count: Optional[pulumi.Input[builtins.int]] = None,
                 refresh_rate_limit_time_window_ms: Optional[pulumi.Input[builtins.int]] = None,
                 roles_key: Optional[pulumi.Input[builtins.str]] = None,
                 scope: Optional[pulumi.Input[builtins.str]] = None,
                 subject_key: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_id: The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.
        :param pulumi.Input[builtins.str] client_secret: The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.
        :param pulumi.Input[builtins.str] connect_url: OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.
        :param pulumi.Input[builtins.bool] enabled: Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.
        :param pulumi.Input[builtins.str] header: HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.
        :param pulumi.Input[builtins.str] jwt_header: The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer <token>. Optional. Default is Authorization.
        :param pulumi.Input[builtins.str] jwt_url_parameter: URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.
        :param pulumi.Input[builtins.int] refresh_rate_limit_count: The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.
        :param pulumi.Input[builtins.int] refresh_rate_limit_time_window_ms: The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).
        :param pulumi.Input[builtins.str] roles_key: The key in the JSON payload that stores the users roles. The key in the JSON payload that stores the users roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.
        :param pulumi.Input[builtins.str] scope: The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.
        :param pulumi.Input[builtins.str] subject_key: The key in the JSON payload that stores the users name. The key in the JSON payload that stores the users name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_url is not None:
            pulumi.set(__self__, "connect_url", connect_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if jwt_header is not None:
            pulumi.set(__self__, "jwt_header", jwt_header)
        if jwt_url_parameter is not None:
            pulumi.set(__self__, "jwt_url_parameter", jwt_url_parameter)
        if refresh_rate_limit_count is not None:
            pulumi.set(__self__, "refresh_rate_limit_count", refresh_rate_limit_count)
        if refresh_rate_limit_time_window_ms is not None:
            pulumi.set(__self__, "refresh_rate_limit_time_window_ms", refresh_rate_limit_time_window_ms)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectUrl")
    def connect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.
        """
        return pulumi.get(self, "connect_url")

    @connect_url.setter
    def connect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connect_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="jwtHeader")
    def jwt_header(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer <token>. Optional. Default is Authorization.
        """
        return pulumi.get(self, "jwt_header")

    @jwt_header.setter
    def jwt_header(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwt_header", value)

    @property
    @pulumi.getter(name="jwtUrlParameter")
    def jwt_url_parameter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.
        """
        return pulumi.get(self, "jwt_url_parameter")

    @jwt_url_parameter.setter
    def jwt_url_parameter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jwt_url_parameter", value)

    @property
    @pulumi.getter(name="refreshRateLimitCount")
    def refresh_rate_limit_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.
        """
        return pulumi.get(self, "refresh_rate_limit_count")

    @refresh_rate_limit_count.setter
    def refresh_rate_limit_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "refresh_rate_limit_count", value)

    @property
    @pulumi.getter(name="refreshRateLimitTimeWindowMs")
    def refresh_rate_limit_time_window_ms(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).
        """
        return pulumi.get(self, "refresh_rate_limit_time_window_ms")

    @refresh_rate_limit_time_window_ms.setter
    def refresh_rate_limit_time_window_ms(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "refresh_rate_limit_time_window_ms", value)

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The key in the JSON payload that stores the users roles. The key in the JSON payload that stores the users roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.
        """
        return pulumi.get(self, "roles_key")

    @roles_key.setter
    def roles_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "roles_key", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The key in the JSON payload that stores the users name. The key in the JSON payload that stores the users name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.
        """
        return pulumi.get(self, "subject_key")

    @subject_key.setter
    def subject_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subject_key", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable OpenSearch Dashboards.
        """
        max_old_space_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.
        """
        multiple_data_source_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable multiple data sources in OpenSearch Dashboards.
        """
        opensearch_request_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_old_space_size: Optional[pulumi.Input[builtins.int]] = None,
                 multiple_data_source_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 opensearch_request_timeout: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable OpenSearch Dashboards.
        :param pulumi.Input[builtins.int] max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.
        :param pulumi.Input[builtins.bool] multiple_data_source_enabled: Enable or disable multiple data sources in OpenSearch Dashboards.
        :param pulumi.Input[builtins.int] opensearch_request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if multiple_data_source_enabled is not None:
            pulumi.set(__self__, "multiple_data_source_enabled", multiple_data_source_enabled)
        if opensearch_request_timeout is not None:
            pulumi.set(__self__, "opensearch_request_timeout", opensearch_request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable OpenSearch Dashboards.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.
        """
        return pulumi.get(self, "max_old_space_size")

    @max_old_space_size.setter
    def max_old_space_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_old_space_size", value)

    @property
    @pulumi.getter(name="multipleDataSourceEnabled")
    def multiple_data_source_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable multiple data sources in OpenSearch Dashboards.
        """
        return pulumi.get(self, "multiple_data_source_enabled")

    @multiple_data_source_enabled.setter
    def multiple_data_source_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "multiple_data_source_enabled", value)

    @property
    @pulumi.getter(name="opensearchRequestTimeout")
    def opensearch_request_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.
        """
        return pulumi.get(self, "opensearch_request_timeout")

    @opensearch_request_timeout.setter
    def opensearch_request_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "opensearch_request_timeout", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSamlArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.
        """
        idp_entity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.
        """
        idp_metadata_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.
        """
        idp_pemtrustedcas_content: NotRequired[pulumi.Input[builtins.str]]
        """
        PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.
        """
        roles_key: NotRequired[pulumi.Input[builtins.str]]
        """
        SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.
        """
        sp_entity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.
        """
        subject_key: NotRequired[pulumi.Input[builtins.str]]
        """
        SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSamlArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 idp_entity_id: Optional[pulumi.Input[builtins.str]] = None,
                 idp_metadata_url: Optional[pulumi.Input[builtins.str]] = None,
                 idp_pemtrustedcas_content: Optional[pulumi.Input[builtins.str]] = None,
                 roles_key: Optional[pulumi.Input[builtins.str]] = None,
                 sp_entity_id: Optional[pulumi.Input[builtins.str]] = None,
                 subject_key: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.
        :param pulumi.Input[builtins.str] idp_entity_id: Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.
        :param pulumi.Input[builtins.str] idp_metadata_url: Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.
        :param pulumi.Input[builtins.str] idp_pemtrustedcas_content: PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.
        :param pulumi.Input[builtins.str] roles_key: SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.
        :param pulumi.Input[builtins.str] sp_entity_id: Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.
        :param pulumi.Input[builtins.str] subject_key: SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if idp_metadata_url is not None:
            pulumi.set(__self__, "idp_metadata_url", idp_metadata_url)
        if idp_pemtrustedcas_content is not None:
            pulumi.set(__self__, "idp_pemtrustedcas_content", idp_pemtrustedcas_content)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="idpMetadataUrl")
    def idp_metadata_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.
        """
        return pulumi.get(self, "idp_metadata_url")

    @idp_metadata_url.setter
    def idp_metadata_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idp_metadata_url", value)

    @property
    @pulumi.getter(name="idpPemtrustedcasContent")
    def idp_pemtrustedcas_content(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.
        """
        return pulumi.get(self, "idp_pemtrustedcas_content")

    @idp_pemtrustedcas_content.setter
    def idp_pemtrustedcas_content(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "idp_pemtrustedcas_content", value)

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.
        """
        return pulumi.get(self, "roles_key")

    @roles_key.setter
    def roles_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "roles_key", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sp_entity_id", value)

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.
        """
        return pulumi.get(self, "subject_key")

    @subject_key.setter
    def subject_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subject_key", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSearchBackpressureArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The search backpressure mode. The search backpressure mode. Valid values are monitor_only, enforced, or disabled. Default is monitor_only.
        """
        node_duress: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgsDict']]
        """
        Node duress settings.
        """
        search_shard_task: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgsDict']]
        """
        Search shard settings.
        """
        search_task: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgsDict']]
        """
        Search task settings.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSearchBackpressureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSearchBackpressureArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 node_duress: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgs']] = None,
                 search_shard_task: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgs']] = None,
                 search_task: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgs']] = None):
        """
        :param pulumi.Input[builtins.str] mode: The search backpressure mode. The search backpressure mode. Valid values are monitor_only, enforced, or disabled. Default is monitor_only.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgs'] node_duress: Node duress settings.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgs'] search_shard_task: Search shard settings.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgs'] search_task: Search task settings.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if node_duress is not None:
            pulumi.set(__self__, "node_duress", node_duress)
        if search_shard_task is not None:
            pulumi.set(__self__, "search_shard_task", search_shard_task)
        if search_task is not None:
            pulumi.set(__self__, "search_task", search_task)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The search backpressure mode. The search backpressure mode. Valid values are monitor_only, enforced, or disabled. Default is monitor_only.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="nodeDuress")
    def node_duress(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgs']]:
        """
        Node duress settings.
        """
        return pulumi.get(self, "node_duress")

    @node_duress.setter
    def node_duress(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgs']]):
        pulumi.set(self, "node_duress", value)

    @property
    @pulumi.getter(name="searchShardTask")
    def search_shard_task(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgs']]:
        """
        Search shard settings.
        """
        return pulumi.get(self, "search_shard_task")

    @search_shard_task.setter
    def search_shard_task(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgs']]):
        pulumi.set(self, "search_shard_task", value)

    @property
    @pulumi.getter(name="searchTask")
    def search_task(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgs']]:
        """
        Search task settings.
        """
        return pulumi.get(self, "search_task")

    @search_task.setter
    def search_task(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgs']]):
        pulumi.set(self, "search_task", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgsDict(TypedDict):
        cpu_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The CPU usage threshold (as a percentage) required for a node to be considered to be under duress. The CPU usage threshold (as a percentage) required for a node to be considered to be under duress. Default is 0.9.
        """
        heap_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The heap usage threshold (as a percentage) required for a node to be considered to be under duress. The heap usage threshold (as a percentage) required for a node to be considered to be under duress. Default is 0.7.
        """
        num_successive_breaches: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of successive limit breaches after which the node is considered to be under duress. The number of successive limit breaches after which the node is considered to be under duress. Default is 3.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSearchBackpressureNodeDuressArgs:
    def __init__(__self__, *,
                 cpu_threshold: Optional[pulumi.Input[builtins.float]] = None,
                 heap_threshold: Optional[pulumi.Input[builtins.float]] = None,
                 num_successive_breaches: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.float] cpu_threshold: The CPU usage threshold (as a percentage) required for a node to be considered to be under duress. The CPU usage threshold (as a percentage) required for a node to be considered to be under duress. Default is 0.9.
        :param pulumi.Input[builtins.float] heap_threshold: The heap usage threshold (as a percentage) required for a node to be considered to be under duress. The heap usage threshold (as a percentage) required for a node to be considered to be under duress. Default is 0.7.
        :param pulumi.Input[builtins.int] num_successive_breaches: The number of successive limit breaches after which the node is considered to be under duress. The number of successive limit breaches after which the node is considered to be under duress. Default is 3.
        """
        if cpu_threshold is not None:
            pulumi.set(__self__, "cpu_threshold", cpu_threshold)
        if heap_threshold is not None:
            pulumi.set(__self__, "heap_threshold", heap_threshold)
        if num_successive_breaches is not None:
            pulumi.set(__self__, "num_successive_breaches", num_successive_breaches)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The CPU usage threshold (as a percentage) required for a node to be considered to be under duress. The CPU usage threshold (as a percentage) required for a node to be considered to be under duress. Default is 0.9.
        """
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cpu_threshold", value)

    @property
    @pulumi.getter(name="heapThreshold")
    def heap_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The heap usage threshold (as a percentage) required for a node to be considered to be under duress. The heap usage threshold (as a percentage) required for a node to be considered to be under duress. Default is 0.7.
        """
        return pulumi.get(self, "heap_threshold")

    @heap_threshold.setter
    def heap_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "heap_threshold", value)

    @property
    @pulumi.getter(name="numSuccessiveBreaches")
    def num_successive_breaches(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of successive limit breaches after which the node is considered to be under duress. The number of successive limit breaches after which the node is considered to be under duress. Default is 3.
        """
        return pulumi.get(self, "num_successive_breaches")

    @num_successive_breaches.setter
    def num_successive_breaches(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "num_successive_breaches", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgsDict(TypedDict):
        cancellation_burst: NotRequired[pulumi.Input[builtins.float]]
        """
        The maximum number of search tasks to cancel in a single iteration of the observer thread. The maximum number of search tasks to cancel in a single iteration of the observer thread. Default is 10.0.
        """
        cancellation_rate: NotRequired[pulumi.Input[builtins.float]]
        """
        The maximum number of tasks to cancel per millisecond of elapsed time. The maximum number of tasks to cancel per millisecond of elapsed time. Default is 0.003.
        """
        cancellation_ratio: NotRequired[pulumi.Input[builtins.float]]
        """
        The maximum number of tasks to cancel. The maximum number of tasks to cancel, as a percentage of successful task completions. Default is 0.1.
        """
        cpu_time_millis_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        The CPU usage threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. The CPU usage threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. Default is 15000.
        """
        elapsed_time_millis_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        The elapsed time threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. The elapsed time threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. Default is 30000.
        """
        heap_moving_average_window_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of previously completed search shard tasks to consider when calculating the rolling average of heap usage. The number of previously completed search shard tasks to consider when calculating the rolling average of heap usage. Default is 100.
        """
        heap_percent_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The heap usage threshold (as a percentage) required for a single search shard task before it is considered for cancellation. The heap usage threshold (as a percentage) required for a single search shard task before it is considered for cancellation. Default is 0.5.
        """
        heap_variance: NotRequired[pulumi.Input[builtins.float]]
        """
        The minimum variance required for a single search shard tasks heap usage compared to the rolling average of previously completed tasks before it is considered for cancellation. The minimum variance required for a single search shard tasks heap usage compared to the rolling average of previously completed tasks before it is considered for cancellation. Default is 2.0.
        """
        total_heap_percent_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The heap usage threshold (as a percentage) required for the sum of heap usages of all search shard tasks before cancellation is applied. The heap usage threshold (as a percentage) required for the sum of heap usages of all search shard tasks before cancellation is applied. Default is 0.5.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchShardTaskArgs:
    def __init__(__self__, *,
                 cancellation_burst: Optional[pulumi.Input[builtins.float]] = None,
                 cancellation_rate: Optional[pulumi.Input[builtins.float]] = None,
                 cancellation_ratio: Optional[pulumi.Input[builtins.float]] = None,
                 cpu_time_millis_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 elapsed_time_millis_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 heap_moving_average_window_size: Optional[pulumi.Input[builtins.int]] = None,
                 heap_percent_threshold: Optional[pulumi.Input[builtins.float]] = None,
                 heap_variance: Optional[pulumi.Input[builtins.float]] = None,
                 total_heap_percent_threshold: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.float] cancellation_burst: The maximum number of search tasks to cancel in a single iteration of the observer thread. The maximum number of search tasks to cancel in a single iteration of the observer thread. Default is 10.0.
        :param pulumi.Input[builtins.float] cancellation_rate: The maximum number of tasks to cancel per millisecond of elapsed time. The maximum number of tasks to cancel per millisecond of elapsed time. Default is 0.003.
        :param pulumi.Input[builtins.float] cancellation_ratio: The maximum number of tasks to cancel. The maximum number of tasks to cancel, as a percentage of successful task completions. Default is 0.1.
        :param pulumi.Input[builtins.int] cpu_time_millis_threshold: The CPU usage threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. The CPU usage threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. Default is 15000.
        :param pulumi.Input[builtins.int] elapsed_time_millis_threshold: The elapsed time threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. The elapsed time threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. Default is 30000.
        :param pulumi.Input[builtins.int] heap_moving_average_window_size: The number of previously completed search shard tasks to consider when calculating the rolling average of heap usage. The number of previously completed search shard tasks to consider when calculating the rolling average of heap usage. Default is 100.
        :param pulumi.Input[builtins.float] heap_percent_threshold: The heap usage threshold (as a percentage) required for a single search shard task before it is considered for cancellation. The heap usage threshold (as a percentage) required for a single search shard task before it is considered for cancellation. Default is 0.5.
        :param pulumi.Input[builtins.float] heap_variance: The minimum variance required for a single search shard tasks heap usage compared to the rolling average of previously completed tasks before it is considered for cancellation. The minimum variance required for a single search shard tasks heap usage compared to the rolling average of previously completed tasks before it is considered for cancellation. Default is 2.0.
        :param pulumi.Input[builtins.float] total_heap_percent_threshold: The heap usage threshold (as a percentage) required for the sum of heap usages of all search shard tasks before cancellation is applied. The heap usage threshold (as a percentage) required for the sum of heap usages of all search shard tasks before cancellation is applied. Default is 0.5.
        """
        if cancellation_burst is not None:
            pulumi.set(__self__, "cancellation_burst", cancellation_burst)
        if cancellation_rate is not None:
            pulumi.set(__self__, "cancellation_rate", cancellation_rate)
        if cancellation_ratio is not None:
            pulumi.set(__self__, "cancellation_ratio", cancellation_ratio)
        if cpu_time_millis_threshold is not None:
            pulumi.set(__self__, "cpu_time_millis_threshold", cpu_time_millis_threshold)
        if elapsed_time_millis_threshold is not None:
            pulumi.set(__self__, "elapsed_time_millis_threshold", elapsed_time_millis_threshold)
        if heap_moving_average_window_size is not None:
            pulumi.set(__self__, "heap_moving_average_window_size", heap_moving_average_window_size)
        if heap_percent_threshold is not None:
            pulumi.set(__self__, "heap_percent_threshold", heap_percent_threshold)
        if heap_variance is not None:
            pulumi.set(__self__, "heap_variance", heap_variance)
        if total_heap_percent_threshold is not None:
            pulumi.set(__self__, "total_heap_percent_threshold", total_heap_percent_threshold)

    @property
    @pulumi.getter(name="cancellationBurst")
    def cancellation_burst(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The maximum number of search tasks to cancel in a single iteration of the observer thread. The maximum number of search tasks to cancel in a single iteration of the observer thread. Default is 10.0.
        """
        return pulumi.get(self, "cancellation_burst")

    @cancellation_burst.setter
    def cancellation_burst(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cancellation_burst", value)

    @property
    @pulumi.getter(name="cancellationRate")
    def cancellation_rate(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The maximum number of tasks to cancel per millisecond of elapsed time. The maximum number of tasks to cancel per millisecond of elapsed time. Default is 0.003.
        """
        return pulumi.get(self, "cancellation_rate")

    @cancellation_rate.setter
    def cancellation_rate(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cancellation_rate", value)

    @property
    @pulumi.getter(name="cancellationRatio")
    def cancellation_ratio(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The maximum number of tasks to cancel. The maximum number of tasks to cancel, as a percentage of successful task completions. Default is 0.1.
        """
        return pulumi.get(self, "cancellation_ratio")

    @cancellation_ratio.setter
    def cancellation_ratio(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cancellation_ratio", value)

    @property
    @pulumi.getter(name="cpuTimeMillisThreshold")
    def cpu_time_millis_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The CPU usage threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. The CPU usage threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. Default is 15000.
        """
        return pulumi.get(self, "cpu_time_millis_threshold")

    @cpu_time_millis_threshold.setter
    def cpu_time_millis_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cpu_time_millis_threshold", value)

    @property
    @pulumi.getter(name="elapsedTimeMillisThreshold")
    def elapsed_time_millis_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The elapsed time threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. The elapsed time threshold (in milliseconds) required for a single search shard task before it is considered for cancellation. Default is 30000.
        """
        return pulumi.get(self, "elapsed_time_millis_threshold")

    @elapsed_time_millis_threshold.setter
    def elapsed_time_millis_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "elapsed_time_millis_threshold", value)

    @property
    @pulumi.getter(name="heapMovingAverageWindowSize")
    def heap_moving_average_window_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of previously completed search shard tasks to consider when calculating the rolling average of heap usage. The number of previously completed search shard tasks to consider when calculating the rolling average of heap usage. Default is 100.
        """
        return pulumi.get(self, "heap_moving_average_window_size")

    @heap_moving_average_window_size.setter
    def heap_moving_average_window_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "heap_moving_average_window_size", value)

    @property
    @pulumi.getter(name="heapPercentThreshold")
    def heap_percent_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The heap usage threshold (as a percentage) required for a single search shard task before it is considered for cancellation. The heap usage threshold (as a percentage) required for a single search shard task before it is considered for cancellation. Default is 0.5.
        """
        return pulumi.get(self, "heap_percent_threshold")

    @heap_percent_threshold.setter
    def heap_percent_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "heap_percent_threshold", value)

    @property
    @pulumi.getter(name="heapVariance")
    def heap_variance(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The minimum variance required for a single search shard tasks heap usage compared to the rolling average of previously completed tasks before it is considered for cancellation. The minimum variance required for a single search shard tasks heap usage compared to the rolling average of previously completed tasks before it is considered for cancellation. Default is 2.0.
        """
        return pulumi.get(self, "heap_variance")

    @heap_variance.setter
    def heap_variance(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "heap_variance", value)

    @property
    @pulumi.getter(name="totalHeapPercentThreshold")
    def total_heap_percent_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The heap usage threshold (as a percentage) required for the sum of heap usages of all search shard tasks before cancellation is applied. The heap usage threshold (as a percentage) required for the sum of heap usages of all search shard tasks before cancellation is applied. Default is 0.5.
        """
        return pulumi.get(self, "total_heap_percent_threshold")

    @total_heap_percent_threshold.setter
    def total_heap_percent_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "total_heap_percent_threshold", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgsDict(TypedDict):
        cancellation_burst: NotRequired[pulumi.Input[builtins.float]]
        """
        The maximum number of search tasks to cancel in a single iteration of the observer thread. The maximum number of search tasks to cancel in a single iteration of the observer thread. Default is 5.0.
        """
        cancellation_rate: NotRequired[pulumi.Input[builtins.float]]
        """
        The maximum number of search tasks to cancel per millisecond of elapsed time. The maximum number of search tasks to cancel per millisecond of elapsed time. Default is 0.003.
        """
        cancellation_ratio: NotRequired[pulumi.Input[builtins.float]]
        """
        The maximum number of search tasks to cancel, as a percentage of successful search task completions. The maximum number of search tasks to cancel, as a percentage of successful search task completions. Default is 0.1.
        """
        cpu_time_millis_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        The CPU usage threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. The CPU usage threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. Default is 30000.
        """
        elapsed_time_millis_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        The elapsed time threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. The elapsed time threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. Default is 45000.
        """
        heap_moving_average_window_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The window size used to calculate the rolling average of the heap usage for the completed parent tasks. The window size used to calculate the rolling average of the heap usage for the completed parent tasks. Default is 10.
        """
        heap_percent_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The heap usage threshold (as a percentage) required for an individual parent task before it is considered for cancellation. The heap usage threshold (as a percentage) required for an individual parent task before it is considered for cancellation. Default is 0.2.
        """
        heap_variance: NotRequired[pulumi.Input[builtins.float]]
        """
        The heap usage variance required for an individual parent task before it is considered for cancellation. The heap usage variance required for an individual parent task before it is considered for cancellation. A task is considered for cancellation when taskHeapUsage is greater than or equal to heapUsageMovingAverage * variance. Default is 2.0.
        """
        total_heap_percent_threshold: NotRequired[pulumi.Input[builtins.float]]
        """
        The heap usage threshold (as a percentage) required for the sum of heap usages of all search tasks before cancellation is applied. The heap usage threshold (as a percentage) required for the sum of heap usages of all search tasks before cancellation is applied. Default is 0.5.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSearchBackpressureSearchTaskArgs:
    def __init__(__self__, *,
                 cancellation_burst: Optional[pulumi.Input[builtins.float]] = None,
                 cancellation_rate: Optional[pulumi.Input[builtins.float]] = None,
                 cancellation_ratio: Optional[pulumi.Input[builtins.float]] = None,
                 cpu_time_millis_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 elapsed_time_millis_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 heap_moving_average_window_size: Optional[pulumi.Input[builtins.int]] = None,
                 heap_percent_threshold: Optional[pulumi.Input[builtins.float]] = None,
                 heap_variance: Optional[pulumi.Input[builtins.float]] = None,
                 total_heap_percent_threshold: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.float] cancellation_burst: The maximum number of search tasks to cancel in a single iteration of the observer thread. The maximum number of search tasks to cancel in a single iteration of the observer thread. Default is 5.0.
        :param pulumi.Input[builtins.float] cancellation_rate: The maximum number of search tasks to cancel per millisecond of elapsed time. The maximum number of search tasks to cancel per millisecond of elapsed time. Default is 0.003.
        :param pulumi.Input[builtins.float] cancellation_ratio: The maximum number of search tasks to cancel, as a percentage of successful search task completions. The maximum number of search tasks to cancel, as a percentage of successful search task completions. Default is 0.1.
        :param pulumi.Input[builtins.int] cpu_time_millis_threshold: The CPU usage threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. The CPU usage threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. Default is 30000.
        :param pulumi.Input[builtins.int] elapsed_time_millis_threshold: The elapsed time threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. The elapsed time threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. Default is 45000.
        :param pulumi.Input[builtins.int] heap_moving_average_window_size: The window size used to calculate the rolling average of the heap usage for the completed parent tasks. The window size used to calculate the rolling average of the heap usage for the completed parent tasks. Default is 10.
        :param pulumi.Input[builtins.float] heap_percent_threshold: The heap usage threshold (as a percentage) required for an individual parent task before it is considered for cancellation. The heap usage threshold (as a percentage) required for an individual parent task before it is considered for cancellation. Default is 0.2.
        :param pulumi.Input[builtins.float] heap_variance: The heap usage variance required for an individual parent task before it is considered for cancellation. The heap usage variance required for an individual parent task before it is considered for cancellation. A task is considered for cancellation when taskHeapUsage is greater than or equal to heapUsageMovingAverage * variance. Default is 2.0.
        :param pulumi.Input[builtins.float] total_heap_percent_threshold: The heap usage threshold (as a percentage) required for the sum of heap usages of all search tasks before cancellation is applied. The heap usage threshold (as a percentage) required for the sum of heap usages of all search tasks before cancellation is applied. Default is 0.5.
        """
        if cancellation_burst is not None:
            pulumi.set(__self__, "cancellation_burst", cancellation_burst)
        if cancellation_rate is not None:
            pulumi.set(__self__, "cancellation_rate", cancellation_rate)
        if cancellation_ratio is not None:
            pulumi.set(__self__, "cancellation_ratio", cancellation_ratio)
        if cpu_time_millis_threshold is not None:
            pulumi.set(__self__, "cpu_time_millis_threshold", cpu_time_millis_threshold)
        if elapsed_time_millis_threshold is not None:
            pulumi.set(__self__, "elapsed_time_millis_threshold", elapsed_time_millis_threshold)
        if heap_moving_average_window_size is not None:
            pulumi.set(__self__, "heap_moving_average_window_size", heap_moving_average_window_size)
        if heap_percent_threshold is not None:
            pulumi.set(__self__, "heap_percent_threshold", heap_percent_threshold)
        if heap_variance is not None:
            pulumi.set(__self__, "heap_variance", heap_variance)
        if total_heap_percent_threshold is not None:
            pulumi.set(__self__, "total_heap_percent_threshold", total_heap_percent_threshold)

    @property
    @pulumi.getter(name="cancellationBurst")
    def cancellation_burst(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The maximum number of search tasks to cancel in a single iteration of the observer thread. The maximum number of search tasks to cancel in a single iteration of the observer thread. Default is 5.0.
        """
        return pulumi.get(self, "cancellation_burst")

    @cancellation_burst.setter
    def cancellation_burst(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cancellation_burst", value)

    @property
    @pulumi.getter(name="cancellationRate")
    def cancellation_rate(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The maximum number of search tasks to cancel per millisecond of elapsed time. The maximum number of search tasks to cancel per millisecond of elapsed time. Default is 0.003.
        """
        return pulumi.get(self, "cancellation_rate")

    @cancellation_rate.setter
    def cancellation_rate(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cancellation_rate", value)

    @property
    @pulumi.getter(name="cancellationRatio")
    def cancellation_ratio(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The maximum number of search tasks to cancel, as a percentage of successful search task completions. The maximum number of search tasks to cancel, as a percentage of successful search task completions. Default is 0.1.
        """
        return pulumi.get(self, "cancellation_ratio")

    @cancellation_ratio.setter
    def cancellation_ratio(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cancellation_ratio", value)

    @property
    @pulumi.getter(name="cpuTimeMillisThreshold")
    def cpu_time_millis_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The CPU usage threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. The CPU usage threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. Default is 30000.
        """
        return pulumi.get(self, "cpu_time_millis_threshold")

    @cpu_time_millis_threshold.setter
    def cpu_time_millis_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cpu_time_millis_threshold", value)

    @property
    @pulumi.getter(name="elapsedTimeMillisThreshold")
    def elapsed_time_millis_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The elapsed time threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. The elapsed time threshold (in milliseconds) required for an individual parent task before it is considered for cancellation. Default is 45000.
        """
        return pulumi.get(self, "elapsed_time_millis_threshold")

    @elapsed_time_millis_threshold.setter
    def elapsed_time_millis_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "elapsed_time_millis_threshold", value)

    @property
    @pulumi.getter(name="heapMovingAverageWindowSize")
    def heap_moving_average_window_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The window size used to calculate the rolling average of the heap usage for the completed parent tasks. The window size used to calculate the rolling average of the heap usage for the completed parent tasks. Default is 10.
        """
        return pulumi.get(self, "heap_moving_average_window_size")

    @heap_moving_average_window_size.setter
    def heap_moving_average_window_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "heap_moving_average_window_size", value)

    @property
    @pulumi.getter(name="heapPercentThreshold")
    def heap_percent_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The heap usage threshold (as a percentage) required for an individual parent task before it is considered for cancellation. The heap usage threshold (as a percentage) required for an individual parent task before it is considered for cancellation. Default is 0.2.
        """
        return pulumi.get(self, "heap_percent_threshold")

    @heap_percent_threshold.setter
    def heap_percent_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "heap_percent_threshold", value)

    @property
    @pulumi.getter(name="heapVariance")
    def heap_variance(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The heap usage variance required for an individual parent task before it is considered for cancellation. The heap usage variance required for an individual parent task before it is considered for cancellation. A task is considered for cancellation when taskHeapUsage is greater than or equal to heapUsageMovingAverage * variance. Default is 2.0.
        """
        return pulumi.get(self, "heap_variance")

    @heap_variance.setter
    def heap_variance(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "heap_variance", value)

    @property
    @pulumi.getter(name="totalHeapPercentThreshold")
    def total_heap_percent_threshold(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The heap usage threshold (as a percentage) required for the sum of heap usages of all search tasks before cancellation is applied. The heap usage threshold (as a percentage) required for the sum of heap usages of all search tasks before cancellation is applied. Default is 0.5.
        """
        return pulumi.get(self, "total_heap_percent_threshold")

    @total_heap_percent_threshold.setter
    def total_heap_percent_threshold(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "total_heap_percent_threshold", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgsDict']]
        """
        Top N queries monitoring by CPU.
        """
        latency: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgsDict']]
        """
        Top N queries monitoring by latency.
        """
        memory: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgsDict']]
        """
        Top N queries monitoring by memory.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgs']] = None,
                 latency: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgs']] = None,
                 memory: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgs']] = None):
        """
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgs'] cpu: Top N queries monitoring by CPU.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgs'] latency: Top N queries monitoring by latency.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgs'] memory: Top N queries monitoring by memory.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgs']]:
        """
        Top N queries monitoring by CPU.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgs']]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def latency(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgs']]:
        """
        Top N queries monitoring by latency.
        """
        return pulumi.get(self, "latency")

    @latency.setter
    def latency(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgs']]):
        pulumi.set(self, "latency", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgs']]:
        """
        Top N queries monitoring by memory.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgs']]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        """
        top_n_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Specify the value of N for the top N queries by the metric.
        """
        window_size: NotRequired[pulumi.Input[builtins.str]]
        """
        The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesCpuArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 top_n_size: Optional[pulumi.Input[builtins.int]] = None,
                 window_size: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        :param pulumi.Input[builtins.int] top_n_size: Specify the value of N for the top N queries by the metric.
        :param pulumi.Input[builtins.str] window_size: The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if top_n_size is not None:
            pulumi.set(__self__, "top_n_size", top_n_size)
        if window_size is not None:
            pulumi.set(__self__, "window_size", window_size)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="topNSize")
    def top_n_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specify the value of N for the top N queries by the metric.
        """
        return pulumi.get(self, "top_n_size")

    @top_n_size.setter
    def top_n_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "top_n_size", value)

    @property
    @pulumi.getter(name="windowSize")
    def window_size(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
        return pulumi.get(self, "window_size")

    @window_size.setter
    def window_size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "window_size", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        """
        top_n_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Specify the value of N for the top N queries by the metric.
        """
        window_size: NotRequired[pulumi.Input[builtins.str]]
        """
        The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesLatencyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 top_n_size: Optional[pulumi.Input[builtins.int]] = None,
                 window_size: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        :param pulumi.Input[builtins.int] top_n_size: Specify the value of N for the top N queries by the metric.
        :param pulumi.Input[builtins.str] window_size: The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if top_n_size is not None:
            pulumi.set(__self__, "top_n_size", top_n_size)
        if window_size is not None:
            pulumi.set(__self__, "window_size", window_size)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="topNSize")
    def top_n_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specify the value of N for the top N queries by the metric.
        """
        return pulumi.get(self, "top_n_size")

    @top_n_size.setter
    def top_n_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "top_n_size", value)

    @property
    @pulumi.getter(name="windowSize")
    def window_size(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
        return pulumi.get(self, "window_size")

    @window_size.setter
    def window_size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "window_size", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        """
        top_n_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Specify the value of N for the top N queries by the metric.
        """
        window_size: NotRequired[pulumi.Input[builtins.str]]
        """
        The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSearchInsightsTopQueriesMemoryArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 top_n_size: Optional[pulumi.Input[builtins.int]] = None,
                 window_size: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        :param pulumi.Input[builtins.int] top_n_size: Specify the value of N for the top N queries by the metric.
        :param pulumi.Input[builtins.str] window_size: The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if top_n_size is not None:
            pulumi.set(__self__, "top_n_size", top_n_size)
        if window_size is not None:
            pulumi.set(__self__, "window_size", window_size)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable top N query monitoring by the metric. Enable or disable top N query monitoring by the metric.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="topNSize")
    def top_n_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specify the value of N for the top N queries by the metric.
        """
        return pulumi.get(self, "top_n_size")

    @top_n_size.setter
    def top_n_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "top_n_size", value)

    @property
    @pulumi.getter(name="windowSize")
    def window_size(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The window size of the top N queries by the metric. Configure the window size of the top N queries.
        """
        return pulumi.get(self, "window_size")

    @window_size.setter
    def window_size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "window_size", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSegrepArgsDict(TypedDict):
        pressure_checkpoint_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of indexing checkpoints that a replica shard can fall behind when copying from primary. Once `segrep.pressure.checkpoint.limit` is breached along with `segrep.pressure.time.limit`, the segment replication backpressure mechanism is initiated. Default is 4 checkpoints.
        """
        pressure_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables the segment replication backpressure mechanism. Default is false.
        """
        pressure_replica_stale_limit: NotRequired[pulumi.Input[builtins.float]]
        """
        The maximum number of stale replica shards that can exist in a replication group. Once `segrep.pressure.replica.stale.limit` is breached, the segment replication backpressure mechanism is initiated. Default is .5, which is 50% of a replication group.
        """
        pressure_time_limit: NotRequired[pulumi.Input[builtins.str]]
        """
        The maximum amount of time that a replica shard can take to copy from the primary shard. Once segrep.pressure.time.limit is breached along with segrep.pressure.checkpoint.limit, the segment replication backpressure mechanism is initiated. Default is 5 minutes.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSegrepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSegrepArgs:
    def __init__(__self__, *,
                 pressure_checkpoint_limit: Optional[pulumi.Input[builtins.int]] = None,
                 pressure_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 pressure_replica_stale_limit: Optional[pulumi.Input[builtins.float]] = None,
                 pressure_time_limit: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] pressure_checkpoint_limit: The maximum number of indexing checkpoints that a replica shard can fall behind when copying from primary. Once `segrep.pressure.checkpoint.limit` is breached along with `segrep.pressure.time.limit`, the segment replication backpressure mechanism is initiated. Default is 4 checkpoints.
        :param pulumi.Input[builtins.bool] pressure_enabled: Enables the segment replication backpressure mechanism. Default is false.
        :param pulumi.Input[builtins.float] pressure_replica_stale_limit: The maximum number of stale replica shards that can exist in a replication group. Once `segrep.pressure.replica.stale.limit` is breached, the segment replication backpressure mechanism is initiated. Default is .5, which is 50% of a replication group.
        :param pulumi.Input[builtins.str] pressure_time_limit: The maximum amount of time that a replica shard can take to copy from the primary shard. Once segrep.pressure.time.limit is breached along with segrep.pressure.checkpoint.limit, the segment replication backpressure mechanism is initiated. Default is 5 minutes.
        """
        if pressure_checkpoint_limit is not None:
            pulumi.set(__self__, "pressure_checkpoint_limit", pressure_checkpoint_limit)
        if pressure_enabled is not None:
            pulumi.set(__self__, "pressure_enabled", pressure_enabled)
        if pressure_replica_stale_limit is not None:
            pulumi.set(__self__, "pressure_replica_stale_limit", pressure_replica_stale_limit)
        if pressure_time_limit is not None:
            pulumi.set(__self__, "pressure_time_limit", pressure_time_limit)

    @property
    @pulumi.getter(name="pressureCheckpointLimit")
    def pressure_checkpoint_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of indexing checkpoints that a replica shard can fall behind when copying from primary. Once `segrep.pressure.checkpoint.limit` is breached along with `segrep.pressure.time.limit`, the segment replication backpressure mechanism is initiated. Default is 4 checkpoints.
        """
        return pulumi.get(self, "pressure_checkpoint_limit")

    @pressure_checkpoint_limit.setter
    def pressure_checkpoint_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "pressure_checkpoint_limit", value)

    @property
    @pulumi.getter(name="pressureEnabled")
    def pressure_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables the segment replication backpressure mechanism. Default is false.
        """
        return pulumi.get(self, "pressure_enabled")

    @pressure_enabled.setter
    def pressure_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "pressure_enabled", value)

    @property
    @pulumi.getter(name="pressureReplicaStaleLimit")
    def pressure_replica_stale_limit(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The maximum number of stale replica shards that can exist in a replication group. Once `segrep.pressure.replica.stale.limit` is breached, the segment replication backpressure mechanism is initiated. Default is .5, which is 50% of a replication group.
        """
        return pulumi.get(self, "pressure_replica_stale_limit")

    @pressure_replica_stale_limit.setter
    def pressure_replica_stale_limit(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "pressure_replica_stale_limit", value)

    @property
    @pulumi.getter(name="pressureTimeLimit")
    def pressure_time_limit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The maximum amount of time that a replica shard can take to copy from the primary shard. Once segrep.pressure.time.limit is breached along with segrep.pressure.checkpoint.limit, the segment replication backpressure mechanism is initiated. Default is 5 minutes.
        """
        return pulumi.get(self, "pressure_time_limit")

    @pressure_time_limit.setter
    def pressure_time_limit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pressure_time_limit", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable shard indexing backpressure. Enable or disable shard indexing backpressure. Default is false.
        """
        enforced: NotRequired[pulumi.Input[builtins.bool]]
        """
        Run shard indexing backpressure in shadow mode or enforced mode. Run shard indexing backpressure in shadow mode or enforced mode.
                    In shadow mode (value set as false), shard indexing backpressure tracks all granular-level metrics,
                    but it doesnt actually reject any indexing requests.
                    In enforced mode (value set as true),
                    shard indexing backpressure rejects any requests to the cluster that might cause a dip in its performance.
                    Default is false.
        """
        operating_factor: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgsDict']]
        """
        Operating factor.
        """
        primary_parameter: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgsDict']]
        """
        Primary parameter.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesShardIndexingPressureArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 enforced: Optional[pulumi.Input[builtins.bool]] = None,
                 operating_factor: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgs']] = None,
                 primary_parameter: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable shard indexing backpressure. Enable or disable shard indexing backpressure. Default is false.
        :param pulumi.Input[builtins.bool] enforced: Run shard indexing backpressure in shadow mode or enforced mode. Run shard indexing backpressure in shadow mode or enforced mode.
                           In shadow mode (value set as false), shard indexing backpressure tracks all granular-level metrics,
                           but it doesnt actually reject any indexing requests.
                           In enforced mode (value set as true),
                           shard indexing backpressure rejects any requests to the cluster that might cause a dip in its performance.
                           Default is false.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgs'] operating_factor: Operating factor.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgs'] primary_parameter: Primary parameter.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enforced is not None:
            pulumi.set(__self__, "enforced", enforced)
        if operating_factor is not None:
            pulumi.set(__self__, "operating_factor", operating_factor)
        if primary_parameter is not None:
            pulumi.set(__self__, "primary_parameter", primary_parameter)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable shard indexing backpressure. Enable or disable shard indexing backpressure. Default is false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def enforced(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Run shard indexing backpressure in shadow mode or enforced mode. Run shard indexing backpressure in shadow mode or enforced mode.
                    In shadow mode (value set as false), shard indexing backpressure tracks all granular-level metrics,
                    but it doesnt actually reject any indexing requests.
                    In enforced mode (value set as true),
                    shard indexing backpressure rejects any requests to the cluster that might cause a dip in its performance.
                    Default is false.
        """
        return pulumi.get(self, "enforced")

    @enforced.setter
    def enforced(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enforced", value)

    @property
    @pulumi.getter(name="operatingFactor")
    def operating_factor(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgs']]:
        """
        Operating factor.
        """
        return pulumi.get(self, "operating_factor")

    @operating_factor.setter
    def operating_factor(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgs']]):
        pulumi.set(self, "operating_factor", value)

    @property
    @pulumi.getter(name="primaryParameter")
    def primary_parameter(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgs']]:
        """
        Primary parameter.
        """
        return pulumi.get(self, "primary_parameter")

    @primary_parameter.setter
    def primary_parameter(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgs']]):
        pulumi.set(self, "primary_parameter", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgsDict(TypedDict):
        lower: NotRequired[pulumi.Input[builtins.float]]
        """
        Lower occupancy limit of the allocated quota of memory for the shard. Specify the lower occupancy limit of the allocated quota of memory for the shard.
                            If the total memory usage of a shard is below this limit,
                            shard indexing backpressure decreases the current allocated memory for that shard.
                            Default is 0.75.
        """
        optimal: NotRequired[pulumi.Input[builtins.float]]
        """
        Optimal occupancy of the allocated quota of memory for the shard. Specify the optimal occupancy of the allocated quota of memory for the shard.
                            If the total memory usage of a shard is at this level,
                            shard indexing backpressure doesnt change the current allocated memory for that shard.
                            Default is 0.85.
        """
        upper: NotRequired[pulumi.Input[builtins.float]]
        """
        Upper occupancy limit of the allocated quota of memory for the shard. Specify the upper occupancy limit of the allocated quota of memory for the shard.
                            If the total memory usage of a shard is above this limit,
                            shard indexing backpressure increases the current allocated memory for that shard.
                            Default is 0.95.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesShardIndexingPressureOperatingFactorArgs:
    def __init__(__self__, *,
                 lower: Optional[pulumi.Input[builtins.float]] = None,
                 optimal: Optional[pulumi.Input[builtins.float]] = None,
                 upper: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.float] lower: Lower occupancy limit of the allocated quota of memory for the shard. Specify the lower occupancy limit of the allocated quota of memory for the shard.
                                   If the total memory usage of a shard is below this limit,
                                   shard indexing backpressure decreases the current allocated memory for that shard.
                                   Default is 0.75.
        :param pulumi.Input[builtins.float] optimal: Optimal occupancy of the allocated quota of memory for the shard. Specify the optimal occupancy of the allocated quota of memory for the shard.
                                   If the total memory usage of a shard is at this level,
                                   shard indexing backpressure doesnt change the current allocated memory for that shard.
                                   Default is 0.85.
        :param pulumi.Input[builtins.float] upper: Upper occupancy limit of the allocated quota of memory for the shard. Specify the upper occupancy limit of the allocated quota of memory for the shard.
                                   If the total memory usage of a shard is above this limit,
                                   shard indexing backpressure increases the current allocated memory for that shard.
                                   Default is 0.95.
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if optimal is not None:
            pulumi.set(__self__, "optimal", optimal)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Lower occupancy limit of the allocated quota of memory for the shard. Specify the lower occupancy limit of the allocated quota of memory for the shard.
                            If the total memory usage of a shard is below this limit,
                            shard indexing backpressure decreases the current allocated memory for that shard.
                            Default is 0.75.
        """
        return pulumi.get(self, "lower")

    @lower.setter
    def lower(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "lower", value)

    @property
    @pulumi.getter
    def optimal(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Optimal occupancy of the allocated quota of memory for the shard. Specify the optimal occupancy of the allocated quota of memory for the shard.
                            If the total memory usage of a shard is at this level,
                            shard indexing backpressure doesnt change the current allocated memory for that shard.
                            Default is 0.85.
        """
        return pulumi.get(self, "optimal")

    @optimal.setter
    def optimal(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "optimal", value)

    @property
    @pulumi.getter
    def upper(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Upper occupancy limit of the allocated quota of memory for the shard. Specify the upper occupancy limit of the allocated quota of memory for the shard.
                            If the total memory usage of a shard is above this limit,
                            shard indexing backpressure increases the current allocated memory for that shard.
                            Default is 0.95.
        """
        return pulumi.get(self, "upper")

    @upper.setter
    def upper(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "upper", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgsDict(TypedDict):
        node: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgsDict']]
        shard: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgsDict']]
elif False:
    ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterArgs:
    def __init__(__self__, *,
                 node: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgs']] = None,
                 shard: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgs']] = None):
        if node is not None:
            pulumi.set(__self__, "node", node)
        if shard is not None:
            pulumi.set(__self__, "shard", shard)

    @property
    @pulumi.getter
    def node(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgs']]:
        return pulumi.get(self, "node")

    @node.setter
    def node(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgs']]):
        pulumi.set(self, "node", value)

    @property
    @pulumi.getter
    def shard(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgs']]:
        return pulumi.get(self, "shard")

    @shard.setter
    def shard(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgs']]):
        pulumi.set(self, "shard", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgsDict(TypedDict):
        soft_limit: NotRequired[pulumi.Input[builtins.float]]
        """
        Node soft limit. Define the percentage of the node-level memory
                                    threshold that acts as a soft indicator for strain on a node.
                                    Default is 0.7.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterNodeArgs:
    def __init__(__self__, *,
                 soft_limit: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.float] soft_limit: Node soft limit. Define the percentage of the node-level memory
                                           threshold that acts as a soft indicator for strain on a node.
                                           Default is 0.7.
        """
        if soft_limit is not None:
            pulumi.set(__self__, "soft_limit", soft_limit)

    @property
    @pulumi.getter(name="softLimit")
    def soft_limit(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Node soft limit. Define the percentage of the node-level memory
                                    threshold that acts as a soft indicator for strain on a node.
                                    Default is 0.7.
        """
        return pulumi.get(self, "soft_limit")

    @soft_limit.setter
    def soft_limit(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "soft_limit", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgsDict(TypedDict):
        min_limit: NotRequired[pulumi.Input[builtins.float]]
        """
        Shard min limit. Specify the minimum assigned quota for a new shard in any role (coordinator, primary, or replica).
                                    Shard indexing backpressure increases or decreases this allocated quota based on the inflow of traffic for the shard.
                                    Default is 0.001.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesShardIndexingPressurePrimaryParameterShardArgs:
    def __init__(__self__, *,
                 min_limit: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.float] min_limit: Shard min limit. Specify the minimum assigned quota for a new shard in any role (coordinator, primary, or replica).
                                           Shard indexing backpressure increases or decreases this allocated quota based on the inflow of traffic for the shard.
                                           Default is 0.001.
        """
        if min_limit is not None:
            pulumi.set(__self__, "min_limit", min_limit)

    @property
    @pulumi.getter(name="minLimit")
    def min_limit(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Shard min limit. Specify the minimum assigned quota for a new shard in any role (coordinator, primary, or replica).
                                    Shard indexing backpressure increases or decreases this allocated quota based on the inflow of traffic for the shard.
                                    Default is 0.001.
        """
        return pulumi.get(self, "min_limit")

    @min_limit.setter
    def min_limit(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "min_limit", value)


if not MYPY:
    class ManagedDatabasePostgresqlComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[builtins.str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[builtins.str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabasePostgresqlComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 route: Optional[pulumi.Input[builtins.str]] = None,
                 usage: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] component: Type of the component
        :param pulumi.Input[builtins.str] host: Hostname of the component
        :param pulumi.Input[builtins.int] port: Port number of the component
        :param pulumi.Input[builtins.str] route: Component network route type
        :param pulumi.Input[builtins.str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabasePostgresqlNetworkArgsDict(TypedDict):
        family: pulumi.Input[builtins.str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[builtins.str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabasePostgresqlNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 uuid: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[builtins.str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[builtins.str] type: The type of the network. Must be private.
        :param pulumi.Input[builtins.str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[builtins.str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabasePostgresqlNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the node
        """
elif False:
    ManagedDatabasePostgresqlNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name plus a node iteration
        :param pulumi.Input[builtins.str] role: Role of the node
        :param pulumi.Input[builtins.str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        admin_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[builtins.bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        autovacuum_analyze_scale_factor: NotRequired[pulumi.Input[builtins.float]]
        """
        Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        """
        autovacuum_analyze_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        """
        autovacuum_freeze_max_age: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        """
        autovacuum_max_workers: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        """
        autovacuum_naptime: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.
        """
        autovacuum_vacuum_cost_delay: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.
        """
        autovacuum_vacuum_cost_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        """
        autovacuum_vacuum_scale_factor: NotRequired[pulumi.Input[builtins.float]]
        """
        Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        """
        autovacuum_vacuum_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        """
        backup_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        backup_minute: NotRequired[pulumi.Input[builtins.int]]
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        bgwriter_delay: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
        """
        bgwriter_flush_after: NotRequired[pulumi.Input[builtins.int]]
        """
        Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
        """
        bgwriter_lru_maxpages: NotRequired[pulumi.Input[builtins.int]]
        """
        In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
        """
        bgwriter_lru_multiplier: NotRequired[pulumi.Input[builtins.float]]
        """
        The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a just in time policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        """
        deadlock_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        """
        default_toast_compression: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        """
        idle_in_transaction_session_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Time out sessions with open transactions after this number of milliseconds.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        jit: NotRequired[pulumi.Input[builtins.bool]]
        """
        Controls system-wide use of Just-in-Time Compilation (JIT).
        """
        log_autovacuum_min_duration: NotRequired[pulumi.Input[builtins.int]]
        """
        Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        """
        log_error_verbosity: NotRequired[pulumi.Input[builtins.str]]
        """
        Controls the amount of detail written in the server log for each message that is logged.
        """
        log_line_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        Choose from one of the available log formats.
        """
        log_min_duration_statement: NotRequired[pulumi.Input[builtins.int]]
        """
        Log statements that take more than this number of milliseconds to run, -1 disables.
        """
        log_temp_files: NotRequired[pulumi.Input[builtins.int]]
        """
        Log statements for each temporary file created larger than this number of kilobytes, -1 disables.
        """
        max_files_per_process: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL maximum number of files that can be open per process.
        """
        max_locks_per_transaction: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL maximum locks per transaction.
        """
        max_logical_replication_workers: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        """
        max_parallel_workers: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets the maximum number of workers that the system can support for parallel queries.
        """
        max_parallel_workers_per_gather: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        """
        max_pred_locks_per_transaction: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL maximum predicate locks per transaction.
        """
        max_prepared_transactions: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL maximum prepared transactions.
        """
        max_replication_slots: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL maximum replication slots.
        """
        max_slot_wal_keep_size: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
        """
        max_stack_depth: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum depth of the stack in bytes.
        """
        max_standby_archive_delay: NotRequired[pulumi.Input[builtins.int]]
        """
        Max standby archive delay in milliseconds.
        """
        max_standby_streaming_delay: NotRequired[pulumi.Input[builtins.int]]
        """
        Max standby streaming delay in milliseconds.
        """
        max_wal_senders: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL maximum WAL senders.
        """
        max_worker_processes: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets the maximum number of background processes that the system can support.
        """
        migration: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgsDict']]
        """
        Migrate data from existing server.
        """
        password_encryption: NotRequired[pulumi.Input[builtins.str]]
        """
        Chooses the algorithm for encrypting passwords.
        """
        pg_partman_bgw_interval: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets the time interval to run pg_partman's scheduled tasks.
        """
        pg_partman_bgw_role: NotRequired[pulumi.Input[builtins.str]]
        """
        Controls which role to use for pg_partman's scheduled background tasks.
        """
        pg_stat_monitor_enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        """
        pg_stat_monitor_pgsm_enable_query_plan: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables or disables query plan monitoring.
        """
        pg_stat_monitor_pgsm_max_buckets: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets the maximum number of buckets.
        """
        pg_stat_statements_track: NotRequired[pulumi.Input[builtins.str]]
        """
        Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
        """
        pgaudit: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgauditArgsDict']]
        """
        PGAudit settings. System-wide settings for the pgaudit extension.
        """
        pgbouncer: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgsDict']]
        """
        PGBouncer connection pooling settings. System-wide settings for pgbouncer.
        """
        pglookout: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgsDict']]
        """
        PGLookout settings. System-wide settings for pglookout.
        """
        public_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        service_log: NotRequired[pulumi.Input[builtins.bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        shared_buffers_percentage: NotRequired[pulumi.Input[builtins.float]]
        """
        Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
        """
        synchronous_replication: NotRequired[pulumi.Input[builtins.str]]
        """
        Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        """
        temp_file_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        PostgreSQL temporary file limit in KiB, -1 for unlimited.
        """
        timescaledb: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgsDict']]
        """
        TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.
        """
        timezone: NotRequired[pulumi.Input[builtins.str]]
        """
        PostgreSQL service timezone.
        """
        track_activity_query_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the number of bytes reserved to track the currently executing command for each active session.
        """
        track_commit_timestamp: NotRequired[pulumi.Input[builtins.str]]
        """
        Record commit time of transactions.
        """
        track_functions: NotRequired[pulumi.Input[builtins.str]]
        """
        Enables tracking of function call counts and time used.
        """
        track_io_timing: NotRequired[pulumi.Input[builtins.str]]
        """
        Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        """
        variant: NotRequired[pulumi.Input[builtins.str]]
        """
        Variant of the PostgreSQL service, may affect the features that are exposed by default.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        PostgreSQL major version.
        """
        wal_sender_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
        """
        wal_writer_delay: NotRequired[pulumi.Input[builtins.int]]
        """
        WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
        """
        work_mem: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
elif False:
    ManagedDatabasePostgresqlPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 admin_username: Optional[pulumi.Input[builtins.str]] = None,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 autovacuum_analyze_scale_factor: Optional[pulumi.Input[builtins.float]] = None,
                 autovacuum_analyze_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 autovacuum_freeze_max_age: Optional[pulumi.Input[builtins.int]] = None,
                 autovacuum_max_workers: Optional[pulumi.Input[builtins.int]] = None,
                 autovacuum_naptime: Optional[pulumi.Input[builtins.int]] = None,
                 autovacuum_vacuum_cost_delay: Optional[pulumi.Input[builtins.int]] = None,
                 autovacuum_vacuum_cost_limit: Optional[pulumi.Input[builtins.int]] = None,
                 autovacuum_vacuum_scale_factor: Optional[pulumi.Input[builtins.float]] = None,
                 autovacuum_vacuum_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 backup_hour: Optional[pulumi.Input[builtins.int]] = None,
                 backup_minute: Optional[pulumi.Input[builtins.int]] = None,
                 bgwriter_delay: Optional[pulumi.Input[builtins.int]] = None,
                 bgwriter_flush_after: Optional[pulumi.Input[builtins.int]] = None,
                 bgwriter_lru_maxpages: Optional[pulumi.Input[builtins.int]] = None,
                 bgwriter_lru_multiplier: Optional[pulumi.Input[builtins.float]] = None,
                 deadlock_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 default_toast_compression: Optional[pulumi.Input[builtins.str]] = None,
                 idle_in_transaction_session_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 jit: Optional[pulumi.Input[builtins.bool]] = None,
                 log_autovacuum_min_duration: Optional[pulumi.Input[builtins.int]] = None,
                 log_error_verbosity: Optional[pulumi.Input[builtins.str]] = None,
                 log_line_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 log_min_duration_statement: Optional[pulumi.Input[builtins.int]] = None,
                 log_temp_files: Optional[pulumi.Input[builtins.int]] = None,
                 max_files_per_process: Optional[pulumi.Input[builtins.int]] = None,
                 max_locks_per_transaction: Optional[pulumi.Input[builtins.int]] = None,
                 max_logical_replication_workers: Optional[pulumi.Input[builtins.int]] = None,
                 max_parallel_workers: Optional[pulumi.Input[builtins.int]] = None,
                 max_parallel_workers_per_gather: Optional[pulumi.Input[builtins.int]] = None,
                 max_pred_locks_per_transaction: Optional[pulumi.Input[builtins.int]] = None,
                 max_prepared_transactions: Optional[pulumi.Input[builtins.int]] = None,
                 max_replication_slots: Optional[pulumi.Input[builtins.int]] = None,
                 max_slot_wal_keep_size: Optional[pulumi.Input[builtins.int]] = None,
                 max_stack_depth: Optional[pulumi.Input[builtins.int]] = None,
                 max_standby_archive_delay: Optional[pulumi.Input[builtins.int]] = None,
                 max_standby_streaming_delay: Optional[pulumi.Input[builtins.int]] = None,
                 max_wal_senders: Optional[pulumi.Input[builtins.int]] = None,
                 max_worker_processes: Optional[pulumi.Input[builtins.int]] = None,
                 migration: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgs']] = None,
                 password_encryption: Optional[pulumi.Input[builtins.str]] = None,
                 pg_partman_bgw_interval: Optional[pulumi.Input[builtins.int]] = None,
                 pg_partman_bgw_role: Optional[pulumi.Input[builtins.str]] = None,
                 pg_stat_monitor_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 pg_stat_monitor_pgsm_enable_query_plan: Optional[pulumi.Input[builtins.bool]] = None,
                 pg_stat_monitor_pgsm_max_buckets: Optional[pulumi.Input[builtins.int]] = None,
                 pg_stat_statements_track: Optional[pulumi.Input[builtins.str]] = None,
                 pgaudit: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgauditArgs']] = None,
                 pgbouncer: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgs']] = None,
                 pglookout: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgs']] = None,
                 public_access: Optional[pulumi.Input[builtins.bool]] = None,
                 service_log: Optional[pulumi.Input[builtins.bool]] = None,
                 shared_buffers_percentage: Optional[pulumi.Input[builtins.float]] = None,
                 synchronous_replication: Optional[pulumi.Input[builtins.str]] = None,
                 temp_file_limit: Optional[pulumi.Input[builtins.int]] = None,
                 timescaledb: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgs']] = None,
                 timezone: Optional[pulumi.Input[builtins.str]] = None,
                 track_activity_query_size: Optional[pulumi.Input[builtins.int]] = None,
                 track_commit_timestamp: Optional[pulumi.Input[builtins.str]] = None,
                 track_functions: Optional[pulumi.Input[builtins.str]] = None,
                 track_io_timing: Optional[pulumi.Input[builtins.str]] = None,
                 variant: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None,
                 wal_sender_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 wal_writer_delay: Optional[pulumi.Input[builtins.int]] = None,
                 work_mem: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] admin_password: Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        :param pulumi.Input[builtins.str] admin_username: Custom username for admin user. This must be set only when a new service is being created.
        :param pulumi.Input[builtins.bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[builtins.float] autovacuum_analyze_scale_factor: Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        :param pulumi.Input[builtins.int] autovacuum_analyze_threshold: Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        :param pulumi.Input[builtins.int] autovacuum_freeze_max_age: Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        :param pulumi.Input[builtins.int] autovacuum_max_workers: Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        :param pulumi.Input[builtins.int] autovacuum_naptime: Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.
        :param pulumi.Input[builtins.int] autovacuum_vacuum_cost_delay: Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.
        :param pulumi.Input[builtins.int] autovacuum_vacuum_cost_limit: Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        :param pulumi.Input[builtins.float] autovacuum_vacuum_scale_factor: Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        :param pulumi.Input[builtins.int] autovacuum_vacuum_threshold: Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        :param pulumi.Input[builtins.int] backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[builtins.int] backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[builtins.int] bgwriter_delay: Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
        :param pulumi.Input[builtins.int] bgwriter_flush_after: Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
        :param pulumi.Input[builtins.int] bgwriter_lru_maxpages: In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
        :param pulumi.Input[builtins.float] bgwriter_lru_multiplier: The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a just in time policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        :param pulumi.Input[builtins.int] deadlock_timeout: This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        :param pulumi.Input[builtins.str] default_toast_compression: Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        :param pulumi.Input[builtins.int] idle_in_transaction_session_timeout: Time out sessions with open transactions after this number of milliseconds.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input[builtins.bool] jit: Controls system-wide use of Just-in-Time Compilation (JIT).
        :param pulumi.Input[builtins.int] log_autovacuum_min_duration: Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        :param pulumi.Input[builtins.str] log_error_verbosity: Controls the amount of detail written in the server log for each message that is logged.
        :param pulumi.Input[builtins.str] log_line_prefix: Choose from one of the available log formats.
        :param pulumi.Input[builtins.int] log_min_duration_statement: Log statements that take more than this number of milliseconds to run, -1 disables.
        :param pulumi.Input[builtins.int] log_temp_files: Log statements for each temporary file created larger than this number of kilobytes, -1 disables.
        :param pulumi.Input[builtins.int] max_files_per_process: PostgreSQL maximum number of files that can be open per process.
        :param pulumi.Input[builtins.int] max_locks_per_transaction: PostgreSQL maximum locks per transaction.
        :param pulumi.Input[builtins.int] max_logical_replication_workers: PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        :param pulumi.Input[builtins.int] max_parallel_workers: Sets the maximum number of workers that the system can support for parallel queries.
        :param pulumi.Input[builtins.int] max_parallel_workers_per_gather: Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        :param pulumi.Input[builtins.int] max_pred_locks_per_transaction: PostgreSQL maximum predicate locks per transaction.
        :param pulumi.Input[builtins.int] max_prepared_transactions: PostgreSQL maximum prepared transactions.
        :param pulumi.Input[builtins.int] max_replication_slots: PostgreSQL maximum replication slots.
        :param pulumi.Input[builtins.int] max_slot_wal_keep_size: PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
        :param pulumi.Input[builtins.int] max_stack_depth: Maximum depth of the stack in bytes.
        :param pulumi.Input[builtins.int] max_standby_archive_delay: Max standby archive delay in milliseconds.
        :param pulumi.Input[builtins.int] max_standby_streaming_delay: Max standby streaming delay in milliseconds.
        :param pulumi.Input[builtins.int] max_wal_senders: PostgreSQL maximum WAL senders.
        :param pulumi.Input[builtins.int] max_worker_processes: Sets the maximum number of background processes that the system can support.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgs'] migration: Migrate data from existing server.
        :param pulumi.Input[builtins.str] password_encryption: Chooses the algorithm for encrypting passwords.
        :param pulumi.Input[builtins.int] pg_partman_bgw_interval: Sets the time interval to run pg_partman's scheduled tasks.
        :param pulumi.Input[builtins.str] pg_partman_bgw_role: Controls which role to use for pg_partman's scheduled background tasks.
        :param pulumi.Input[builtins.bool] pg_stat_monitor_enable: Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        :param pulumi.Input[builtins.bool] pg_stat_monitor_pgsm_enable_query_plan: Enables or disables query plan monitoring.
        :param pulumi.Input[builtins.int] pg_stat_monitor_pgsm_max_buckets: Sets the maximum number of buckets.
        :param pulumi.Input[builtins.str] pg_stat_statements_track: Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesPgauditArgs'] pgaudit: PGAudit settings. System-wide settings for the pgaudit extension.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgs'] pgbouncer: PGBouncer connection pooling settings. System-wide settings for pgbouncer.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgs'] pglookout: PGLookout settings. System-wide settings for pglookout.
        :param pulumi.Input[builtins.bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[builtins.bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param pulumi.Input[builtins.float] shared_buffers_percentage: Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
        :param pulumi.Input[builtins.str] synchronous_replication: Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        :param pulumi.Input[builtins.int] temp_file_limit: PostgreSQL temporary file limit in KiB, -1 for unlimited.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgs'] timescaledb: TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.
        :param pulumi.Input[builtins.str] timezone: PostgreSQL service timezone.
        :param pulumi.Input[builtins.int] track_activity_query_size: Specifies the number of bytes reserved to track the currently executing command for each active session.
        :param pulumi.Input[builtins.str] track_commit_timestamp: Record commit time of transactions.
        :param pulumi.Input[builtins.str] track_functions: Enables tracking of function call counts and time used.
        :param pulumi.Input[builtins.str] track_io_timing: Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        :param pulumi.Input[builtins.str] variant: Variant of the PostgreSQL service, may affect the features that are exposed by default.
        :param pulumi.Input[builtins.str] version: PostgreSQL major version.
        :param pulumi.Input[builtins.int] wal_sender_timeout: Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
        :param pulumi.Input[builtins.int] wal_writer_delay: WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
        :param pulumi.Input[builtins.int] work_mem: Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_analyze_threshold is not None:
            pulumi.set(__self__, "autovacuum_analyze_threshold", autovacuum_analyze_threshold)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if bgwriter_delay is not None:
            pulumi.set(__self__, "bgwriter_delay", bgwriter_delay)
        if bgwriter_flush_after is not None:
            pulumi.set(__self__, "bgwriter_flush_after", bgwriter_flush_after)
        if bgwriter_lru_maxpages is not None:
            pulumi.set(__self__, "bgwriter_lru_maxpages", bgwriter_lru_maxpages)
        if bgwriter_lru_multiplier is not None:
            pulumi.set(__self__, "bgwriter_lru_multiplier", bgwriter_lru_multiplier)
        if deadlock_timeout is not None:
            pulumi.set(__self__, "deadlock_timeout", deadlock_timeout)
        if default_toast_compression is not None:
            pulumi.set(__self__, "default_toast_compression", default_toast_compression)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if jit is not None:
            pulumi.set(__self__, "jit", jit)
        if log_autovacuum_min_duration is not None:
            pulumi.set(__self__, "log_autovacuum_min_duration", log_autovacuum_min_duration)
        if log_error_verbosity is not None:
            pulumi.set(__self__, "log_error_verbosity", log_error_verbosity)
        if log_line_prefix is not None:
            pulumi.set(__self__, "log_line_prefix", log_line_prefix)
        if log_min_duration_statement is not None:
            pulumi.set(__self__, "log_min_duration_statement", log_min_duration_statement)
        if log_temp_files is not None:
            pulumi.set(__self__, "log_temp_files", log_temp_files)
        if max_files_per_process is not None:
            pulumi.set(__self__, "max_files_per_process", max_files_per_process)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_logical_replication_workers is not None:
            pulumi.set(__self__, "max_logical_replication_workers", max_logical_replication_workers)
        if max_parallel_workers is not None:
            pulumi.set(__self__, "max_parallel_workers", max_parallel_workers)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_pred_locks_per_transaction is not None:
            pulumi.set(__self__, "max_pred_locks_per_transaction", max_pred_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_slot_wal_keep_size is not None:
            pulumi.set(__self__, "max_slot_wal_keep_size", max_slot_wal_keep_size)
        if max_stack_depth is not None:
            pulumi.set(__self__, "max_stack_depth", max_stack_depth)
        if max_standby_archive_delay is not None:
            pulumi.set(__self__, "max_standby_archive_delay", max_standby_archive_delay)
        if max_standby_streaming_delay is not None:
            pulumi.set(__self__, "max_standby_streaming_delay", max_standby_streaming_delay)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if password_encryption is not None:
            pulumi.set(__self__, "password_encryption", password_encryption)
        if pg_partman_bgw_interval is not None:
            pulumi.set(__self__, "pg_partman_bgw_interval", pg_partman_bgw_interval)
        if pg_partman_bgw_role is not None:
            pulumi.set(__self__, "pg_partman_bgw_role", pg_partman_bgw_role)
        if pg_stat_monitor_enable is not None:
            pulumi.set(__self__, "pg_stat_monitor_enable", pg_stat_monitor_enable)
        if pg_stat_monitor_pgsm_enable_query_plan is not None:
            pulumi.set(__self__, "pg_stat_monitor_pgsm_enable_query_plan", pg_stat_monitor_pgsm_enable_query_plan)
        if pg_stat_monitor_pgsm_max_buckets is not None:
            pulumi.set(__self__, "pg_stat_monitor_pgsm_max_buckets", pg_stat_monitor_pgsm_max_buckets)
        if pg_stat_statements_track is not None:
            pulumi.set(__self__, "pg_stat_statements_track", pg_stat_statements_track)
        if pgaudit is not None:
            pulumi.set(__self__, "pgaudit", pgaudit)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if pglookout is not None:
            pulumi.set(__self__, "pglookout", pglookout)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if shared_buffers_percentage is not None:
            pulumi.set(__self__, "shared_buffers_percentage", shared_buffers_percentage)
        if synchronous_replication is not None:
            pulumi.set(__self__, "synchronous_replication", synchronous_replication)
        if temp_file_limit is not None:
            pulumi.set(__self__, "temp_file_limit", temp_file_limit)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if track_activity_query_size is not None:
            pulumi.set(__self__, "track_activity_query_size", track_activity_query_size)
        if track_commit_timestamp is not None:
            pulumi.set(__self__, "track_commit_timestamp", track_commit_timestamp)
        if track_functions is not None:
            pulumi.set(__self__, "track_functions", track_functions)
        if track_io_timing is not None:
            pulumi.set(__self__, "track_io_timing", track_io_timing)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if wal_sender_timeout is not None:
            pulumi.set(__self__, "wal_sender_timeout", wal_sender_timeout)
        if wal_writer_delay is not None:
            pulumi.set(__self__, "wal_writer_delay", wal_writer_delay)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        """
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @autovacuum_analyze_scale_factor.setter
    def autovacuum_analyze_scale_factor(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "autovacuum_analyze_scale_factor", value)

    @property
    @pulumi.getter(name="autovacuumAnalyzeThreshold")
    def autovacuum_analyze_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        """
        return pulumi.get(self, "autovacuum_analyze_threshold")

    @autovacuum_analyze_threshold.setter
    def autovacuum_analyze_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autovacuum_analyze_threshold", value)

    @property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        """
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @autovacuum_freeze_max_age.setter
    def autovacuum_freeze_max_age(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autovacuum_freeze_max_age", value)

    @property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        """
        return pulumi.get(self, "autovacuum_max_workers")

    @autovacuum_max_workers.setter
    def autovacuum_max_workers(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autovacuum_max_workers", value)

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.
        """
        return pulumi.get(self, "autovacuum_naptime")

    @autovacuum_naptime.setter
    def autovacuum_naptime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autovacuum_naptime", value)

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @autovacuum_vacuum_cost_delay.setter
    def autovacuum_vacuum_cost_delay(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autovacuum_vacuum_cost_delay", value)

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @autovacuum_vacuum_cost_limit.setter
    def autovacuum_vacuum_cost_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autovacuum_vacuum_cost_limit", value)

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        """
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @autovacuum_vacuum_scale_factor.setter
    def autovacuum_vacuum_scale_factor(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "autovacuum_vacuum_scale_factor", value)

    @property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        """
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @autovacuum_vacuum_threshold.setter
    def autovacuum_vacuum_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autovacuum_vacuum_threshold", value)

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @backup_hour.setter
    def backup_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_hour", value)

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @backup_minute.setter
    def backup_minute(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_minute", value)

    @property
    @pulumi.getter(name="bgwriterDelay")
    def bgwriter_delay(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
        """
        return pulumi.get(self, "bgwriter_delay")

    @bgwriter_delay.setter
    def bgwriter_delay(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bgwriter_delay", value)

    @property
    @pulumi.getter(name="bgwriterFlushAfter")
    def bgwriter_flush_after(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
        """
        return pulumi.get(self, "bgwriter_flush_after")

    @bgwriter_flush_after.setter
    def bgwriter_flush_after(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bgwriter_flush_after", value)

    @property
    @pulumi.getter(name="bgwriterLruMaxpages")
    def bgwriter_lru_maxpages(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
        """
        return pulumi.get(self, "bgwriter_lru_maxpages")

    @bgwriter_lru_maxpages.setter
    def bgwriter_lru_maxpages(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bgwriter_lru_maxpages", value)

    @property
    @pulumi.getter(name="bgwriterLruMultiplier")
    def bgwriter_lru_multiplier(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a just in time policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        """
        return pulumi.get(self, "bgwriter_lru_multiplier")

    @bgwriter_lru_multiplier.setter
    def bgwriter_lru_multiplier(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "bgwriter_lru_multiplier", value)

    @property
    @pulumi.getter(name="deadlockTimeout")
    def deadlock_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        """
        return pulumi.get(self, "deadlock_timeout")

    @deadlock_timeout.setter
    def deadlock_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "deadlock_timeout", value)

    @property
    @pulumi.getter(name="defaultToastCompression")
    def default_toast_compression(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        """
        return pulumi.get(self, "default_toast_compression")

    @default_toast_compression.setter
    def default_toast_compression(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_toast_compression", value)

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time out sessions with open transactions after this number of milliseconds.
        """
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @idle_in_transaction_session_timeout.setter
    def idle_in_transaction_session_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "idle_in_transaction_session_timeout", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter
    def jit(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Controls system-wide use of Just-in-Time Compilation (JIT).
        """
        return pulumi.get(self, "jit")

    @jit.setter
    def jit(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "jit", value)

    @property
    @pulumi.getter(name="logAutovacuumMinDuration")
    def log_autovacuum_min_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        """
        return pulumi.get(self, "log_autovacuum_min_duration")

    @log_autovacuum_min_duration.setter
    def log_autovacuum_min_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "log_autovacuum_min_duration", value)

    @property
    @pulumi.getter(name="logErrorVerbosity")
    def log_error_verbosity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Controls the amount of detail written in the server log for each message that is logged.
        """
        return pulumi.get(self, "log_error_verbosity")

    @log_error_verbosity.setter
    def log_error_verbosity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "log_error_verbosity", value)

    @property
    @pulumi.getter(name="logLinePrefix")
    def log_line_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Choose from one of the available log formats.
        """
        return pulumi.get(self, "log_line_prefix")

    @log_line_prefix.setter
    def log_line_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "log_line_prefix", value)

    @property
    @pulumi.getter(name="logMinDurationStatement")
    def log_min_duration_statement(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Log statements that take more than this number of milliseconds to run, -1 disables.
        """
        return pulumi.get(self, "log_min_duration_statement")

    @log_min_duration_statement.setter
    def log_min_duration_statement(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "log_min_duration_statement", value)

    @property
    @pulumi.getter(name="logTempFiles")
    def log_temp_files(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Log statements for each temporary file created larger than this number of kilobytes, -1 disables.
        """
        return pulumi.get(self, "log_temp_files")

    @log_temp_files.setter
    def log_temp_files(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "log_temp_files", value)

    @property
    @pulumi.getter(name="maxFilesPerProcess")
    def max_files_per_process(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL maximum number of files that can be open per process.
        """
        return pulumi.get(self, "max_files_per_process")

    @max_files_per_process.setter
    def max_files_per_process(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_files_per_process", value)

    @property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL maximum locks per transaction.
        """
        return pulumi.get(self, "max_locks_per_transaction")

    @max_locks_per_transaction.setter
    def max_locks_per_transaction(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_locks_per_transaction", value)

    @property
    @pulumi.getter(name="maxLogicalReplicationWorkers")
    def max_logical_replication_workers(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        """
        return pulumi.get(self, "max_logical_replication_workers")

    @max_logical_replication_workers.setter
    def max_logical_replication_workers(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_logical_replication_workers", value)

    @property
    @pulumi.getter(name="maxParallelWorkers")
    def max_parallel_workers(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets the maximum number of workers that the system can support for parallel queries.
        """
        return pulumi.get(self, "max_parallel_workers")

    @max_parallel_workers.setter
    def max_parallel_workers(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_parallel_workers", value)

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        """
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @max_parallel_workers_per_gather.setter
    def max_parallel_workers_per_gather(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_parallel_workers_per_gather", value)

    @property
    @pulumi.getter(name="maxPredLocksPerTransaction")
    def max_pred_locks_per_transaction(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL maximum predicate locks per transaction.
        """
        return pulumi.get(self, "max_pred_locks_per_transaction")

    @max_pred_locks_per_transaction.setter
    def max_pred_locks_per_transaction(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_pred_locks_per_transaction", value)

    @property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL maximum prepared transactions.
        """
        return pulumi.get(self, "max_prepared_transactions")

    @max_prepared_transactions.setter
    def max_prepared_transactions(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_prepared_transactions", value)

    @property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL maximum replication slots.
        """
        return pulumi.get(self, "max_replication_slots")

    @max_replication_slots.setter
    def max_replication_slots(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_replication_slots", value)

    @property
    @pulumi.getter(name="maxSlotWalKeepSize")
    def max_slot_wal_keep_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
        """
        return pulumi.get(self, "max_slot_wal_keep_size")

    @max_slot_wal_keep_size.setter
    def max_slot_wal_keep_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_slot_wal_keep_size", value)

    @property
    @pulumi.getter(name="maxStackDepth")
    def max_stack_depth(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum depth of the stack in bytes.
        """
        return pulumi.get(self, "max_stack_depth")

    @max_stack_depth.setter
    def max_stack_depth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_stack_depth", value)

    @property
    @pulumi.getter(name="maxStandbyArchiveDelay")
    def max_standby_archive_delay(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max standby archive delay in milliseconds.
        """
        return pulumi.get(self, "max_standby_archive_delay")

    @max_standby_archive_delay.setter
    def max_standby_archive_delay(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_standby_archive_delay", value)

    @property
    @pulumi.getter(name="maxStandbyStreamingDelay")
    def max_standby_streaming_delay(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max standby streaming delay in milliseconds.
        """
        return pulumi.get(self, "max_standby_streaming_delay")

    @max_standby_streaming_delay.setter
    def max_standby_streaming_delay(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_standby_streaming_delay", value)

    @property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL maximum WAL senders.
        """
        return pulumi.get(self, "max_wal_senders")

    @max_wal_senders.setter
    def max_wal_senders(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_wal_senders", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets the maximum number of background processes that the system can support.
        """
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter
    def migration(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgs']]:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @migration.setter
    def migration(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgs']]):
        pulumi.set(self, "migration", value)

    @property
    @pulumi.getter(name="passwordEncryption")
    def password_encryption(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Chooses the algorithm for encrypting passwords.
        """
        return pulumi.get(self, "password_encryption")

    @password_encryption.setter
    def password_encryption(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password_encryption", value)

    @property
    @pulumi.getter(name="pgPartmanBgwInterval")
    def pg_partman_bgw_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets the time interval to run pg_partman's scheduled tasks.
        """
        return pulumi.get(self, "pg_partman_bgw_interval")

    @pg_partman_bgw_interval.setter
    def pg_partman_bgw_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "pg_partman_bgw_interval", value)

    @property
    @pulumi.getter(name="pgPartmanBgwRole")
    def pg_partman_bgw_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Controls which role to use for pg_partman's scheduled background tasks.
        """
        return pulumi.get(self, "pg_partman_bgw_role")

    @pg_partman_bgw_role.setter
    def pg_partman_bgw_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pg_partman_bgw_role", value)

    @property
    @pulumi.getter(name="pgStatMonitorEnable")
    def pg_stat_monitor_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        """
        return pulumi.get(self, "pg_stat_monitor_enable")

    @pg_stat_monitor_enable.setter
    def pg_stat_monitor_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "pg_stat_monitor_enable", value)

    @property
    @pulumi.getter(name="pgStatMonitorPgsmEnableQueryPlan")
    def pg_stat_monitor_pgsm_enable_query_plan(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables or disables query plan monitoring.
        """
        return pulumi.get(self, "pg_stat_monitor_pgsm_enable_query_plan")

    @pg_stat_monitor_pgsm_enable_query_plan.setter
    def pg_stat_monitor_pgsm_enable_query_plan(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "pg_stat_monitor_pgsm_enable_query_plan", value)

    @property
    @pulumi.getter(name="pgStatMonitorPgsmMaxBuckets")
    def pg_stat_monitor_pgsm_max_buckets(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets the maximum number of buckets.
        """
        return pulumi.get(self, "pg_stat_monitor_pgsm_max_buckets")

    @pg_stat_monitor_pgsm_max_buckets.setter
    def pg_stat_monitor_pgsm_max_buckets(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "pg_stat_monitor_pgsm_max_buckets", value)

    @property
    @pulumi.getter(name="pgStatStatementsTrack")
    def pg_stat_statements_track(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
        """
        return pulumi.get(self, "pg_stat_statements_track")

    @pg_stat_statements_track.setter
    def pg_stat_statements_track(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pg_stat_statements_track", value)

    @property
    @pulumi.getter
    def pgaudit(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgauditArgs']]:
        """
        PGAudit settings. System-wide settings for the pgaudit extension.
        """
        return pulumi.get(self, "pgaudit")

    @pgaudit.setter
    def pgaudit(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgauditArgs']]):
        pulumi.set(self, "pgaudit", value)

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgs']]:
        """
        PGBouncer connection pooling settings. System-wide settings for pgbouncer.
        """
        return pulumi.get(self, "pgbouncer")

    @pgbouncer.setter
    def pgbouncer(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgs']]):
        pulumi.set(self, "pgbouncer", value)

    @property
    @pulumi.getter
    def pglookout(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgs']]:
        """
        PGLookout settings. System-wide settings for pglookout.
        """
        return pulumi.get(self, "pglookout")

    @pglookout.setter
    def pglookout(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgs']]):
        pulumi.set(self, "pglookout", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "service_log", value)

    @property
    @pulumi.getter(name="sharedBuffersPercentage")
    def shared_buffers_percentage(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
        """
        return pulumi.get(self, "shared_buffers_percentage")

    @shared_buffers_percentage.setter
    def shared_buffers_percentage(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "shared_buffers_percentage", value)

    @property
    @pulumi.getter(name="synchronousReplication")
    def synchronous_replication(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        """
        return pulumi.get(self, "synchronous_replication")

    @synchronous_replication.setter
    def synchronous_replication(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "synchronous_replication", value)

    @property
    @pulumi.getter(name="tempFileLimit")
    def temp_file_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PostgreSQL temporary file limit in KiB, -1 for unlimited.
        """
        return pulumi.get(self, "temp_file_limit")

    @temp_file_limit.setter
    def temp_file_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "temp_file_limit", value)

    @property
    @pulumi.getter
    def timescaledb(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgs']]:
        """
        TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.
        """
        return pulumi.get(self, "timescaledb")

    @timescaledb.setter
    def timescaledb(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgs']]):
        pulumi.set(self, "timescaledb", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PostgreSQL service timezone.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="trackActivityQuerySize")
    def track_activity_query_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the number of bytes reserved to track the currently executing command for each active session.
        """
        return pulumi.get(self, "track_activity_query_size")

    @track_activity_query_size.setter
    def track_activity_query_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "track_activity_query_size", value)

    @property
    @pulumi.getter(name="trackCommitTimestamp")
    def track_commit_timestamp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Record commit time of transactions.
        """
        return pulumi.get(self, "track_commit_timestamp")

    @track_commit_timestamp.setter
    def track_commit_timestamp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "track_commit_timestamp", value)

    @property
    @pulumi.getter(name="trackFunctions")
    def track_functions(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enables tracking of function call counts and time used.
        """
        return pulumi.get(self, "track_functions")

    @track_functions.setter
    def track_functions(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "track_functions", value)

    @property
    @pulumi.getter(name="trackIoTiming")
    def track_io_timing(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        """
        return pulumi.get(self, "track_io_timing")

    @track_io_timing.setter
    def track_io_timing(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "track_io_timing", value)

    @property
    @pulumi.getter
    def variant(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Variant of the PostgreSQL service, may affect the features that are exposed by default.
        """
        return pulumi.get(self, "variant")

    @variant.setter
    def variant(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "variant", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PostgreSQL major version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="walSenderTimeout")
    def wal_sender_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
        """
        return pulumi.get(self, "wal_sender_timeout")

    @wal_sender_timeout.setter
    def wal_sender_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "wal_sender_timeout", value)

    @property
    @pulumi.getter(name="walWriterDelay")
    def wal_writer_delay(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
        """
        return pulumi.get(self, "wal_writer_delay")

    @wal_writer_delay.setter
    def wal_writer_delay(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "wal_writer_delay", value)

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
        return pulumi.get(self, "work_mem")

    @work_mem.setter
    def work_mem(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "work_mem", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesMigrationArgsDict(TypedDict):
        dbname: NotRequired[pulumi.Input[builtins.str]]
        """
        Database name for bootstrapping the initial connection.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname or IP address of the server where to migrate data from.
        """
        ignore_dbs: NotRequired[pulumi.Input[builtins.str]]
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        ignore_roles: NotRequired[pulumi.Input[builtins.str]]
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        method: NotRequired[pulumi.Input[builtins.str]]
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password for authentication with the server where to migrate data from.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the server where to migrate data from.
        """
        ssl: NotRequired[pulumi.Input[builtins.bool]]
        """
        The server where to migrate data from is secured with SSL.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        User name for authentication with the server where to migrate data from.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesMigrationArgs:
    def __init__(__self__, *,
                 dbname: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_dbs: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_roles: Optional[pulumi.Input[builtins.str]] = None,
                 method: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 ssl: Optional[pulumi.Input[builtins.bool]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] dbname: Database name for bootstrapping the initial connection.
        :param pulumi.Input[builtins.str] host: Hostname or IP address of the server where to migrate data from.
        :param pulumi.Input[builtins.str] ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param pulumi.Input[builtins.str] ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param pulumi.Input[builtins.str] method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param pulumi.Input[builtins.str] password: Password for authentication with the server where to migrate data from.
        :param pulumi.Input[builtins.int] port: Port number of the server where to migrate data from.
        :param pulumi.Input[builtins.bool] ssl: The server where to migrate data from is secured with SSL.
        :param pulumi.Input[builtins.str] username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @ignore_dbs.setter
    def ignore_dbs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ignore_dbs", value)

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @ignore_roles.setter
    def ignore_roles(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ignore_roles", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesPgauditArgsDict(TypedDict):
        feature_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable pgaudit extension. Enable pgaudit extension. When enabled, pgaudit extension will be automatically installed.Otherwise, extension will be uninstalled but auditing configurations will be preserved.
        """
        log_catalog: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies that session logging should be enabled in the casewhere all relations in a statement are in pg_catalog.
        """
        log_client: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether log messages will be visible to a client process such as psql.
        """
        log_level: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the log level that will be used for log entries.
        """
        log_max_string_length: NotRequired[pulumi.Input[builtins.int]]
        """
        Crop parameters representation and whole statements if they exceed this threshold. A (default) value of -1 disable the truncation.
        """
        log_nested_statements: NotRequired[pulumi.Input[builtins.bool]]
        """
        This GUC allows to turn off logging nested statements, that is, statements that are executed as part of another ExecutorRun.
        """
        log_parameter: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies that audit logging should include the parameters that were passed with the statement.
        """
        log_parameter_max_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies that parameter values longer than this setting (in bytes) should not be logged, but replaced with <long param suppressed>.
        """
        log_relation: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether session audit logging should create a separate log entry for each relation (TABLE, VIEW, etc.) referenced in a SELECT or DML statement.
        """
        log_rows: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies that audit logging should include the rows retrieved or affected by a statement. When enabled the rows field will be included after the parameter field.
        """
        log_statement: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether logging will include the statement text and parameters (if enabled).
        """
        log_statement_once: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether logging will include the statement text and parameters with the first log entry for a statement/substatement combination or with every entry.
        """
        logs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies which classes of statements will be logged by session audit logging.
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the master role to use for object audit logging.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesPgauditArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesPgauditArgs:
    def __init__(__self__, *,
                 feature_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 log_catalog: Optional[pulumi.Input[builtins.bool]] = None,
                 log_client: Optional[pulumi.Input[builtins.bool]] = None,
                 log_level: Optional[pulumi.Input[builtins.str]] = None,
                 log_max_string_length: Optional[pulumi.Input[builtins.int]] = None,
                 log_nested_statements: Optional[pulumi.Input[builtins.bool]] = None,
                 log_parameter: Optional[pulumi.Input[builtins.bool]] = None,
                 log_parameter_max_size: Optional[pulumi.Input[builtins.int]] = None,
                 log_relation: Optional[pulumi.Input[builtins.bool]] = None,
                 log_rows: Optional[pulumi.Input[builtins.bool]] = None,
                 log_statement: Optional[pulumi.Input[builtins.bool]] = None,
                 log_statement_once: Optional[pulumi.Input[builtins.bool]] = None,
                 logs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] feature_enabled: Enable pgaudit extension. Enable pgaudit extension. When enabled, pgaudit extension will be automatically installed.Otherwise, extension will be uninstalled but auditing configurations will be preserved.
        :param pulumi.Input[builtins.bool] log_catalog: Specifies that session logging should be enabled in the casewhere all relations in a statement are in pg_catalog.
        :param pulumi.Input[builtins.bool] log_client: Specifies whether log messages will be visible to a client process such as psql.
        :param pulumi.Input[builtins.str] log_level: Specifies the log level that will be used for log entries.
        :param pulumi.Input[builtins.int] log_max_string_length: Crop parameters representation and whole statements if they exceed this threshold. A (default) value of -1 disable the truncation.
        :param pulumi.Input[builtins.bool] log_nested_statements: This GUC allows to turn off logging nested statements, that is, statements that are executed as part of another ExecutorRun.
        :param pulumi.Input[builtins.bool] log_parameter: Specifies that audit logging should include the parameters that were passed with the statement.
        :param pulumi.Input[builtins.int] log_parameter_max_size: Specifies that parameter values longer than this setting (in bytes) should not be logged, but replaced with <long param suppressed>.
        :param pulumi.Input[builtins.bool] log_relation: Specifies whether session audit logging should create a separate log entry for each relation (TABLE, VIEW, etc.) referenced in a SELECT or DML statement.
        :param pulumi.Input[builtins.bool] log_rows: Specifies that audit logging should include the rows retrieved or affected by a statement. When enabled the rows field will be included after the parameter field.
        :param pulumi.Input[builtins.bool] log_statement: Specifies whether logging will include the statement text and parameters (if enabled).
        :param pulumi.Input[builtins.bool] log_statement_once: Specifies whether logging will include the statement text and parameters with the first log entry for a statement/substatement combination or with every entry.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] logs: Specifies which classes of statements will be logged by session audit logging.
        :param pulumi.Input[builtins.str] role: Specifies the master role to use for object audit logging.
        """
        if feature_enabled is not None:
            pulumi.set(__self__, "feature_enabled", feature_enabled)
        if log_catalog is not None:
            pulumi.set(__self__, "log_catalog", log_catalog)
        if log_client is not None:
            pulumi.set(__self__, "log_client", log_client)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if log_max_string_length is not None:
            pulumi.set(__self__, "log_max_string_length", log_max_string_length)
        if log_nested_statements is not None:
            pulumi.set(__self__, "log_nested_statements", log_nested_statements)
        if log_parameter is not None:
            pulumi.set(__self__, "log_parameter", log_parameter)
        if log_parameter_max_size is not None:
            pulumi.set(__self__, "log_parameter_max_size", log_parameter_max_size)
        if log_relation is not None:
            pulumi.set(__self__, "log_relation", log_relation)
        if log_rows is not None:
            pulumi.set(__self__, "log_rows", log_rows)
        if log_statement is not None:
            pulumi.set(__self__, "log_statement", log_statement)
        if log_statement_once is not None:
            pulumi.set(__self__, "log_statement_once", log_statement_once)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="featureEnabled")
    def feature_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable pgaudit extension. Enable pgaudit extension. When enabled, pgaudit extension will be automatically installed.Otherwise, extension will be uninstalled but auditing configurations will be preserved.
        """
        return pulumi.get(self, "feature_enabled")

    @feature_enabled.setter
    def feature_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "feature_enabled", value)

    @property
    @pulumi.getter(name="logCatalog")
    def log_catalog(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies that session logging should be enabled in the casewhere all relations in a statement are in pg_catalog.
        """
        return pulumi.get(self, "log_catalog")

    @log_catalog.setter
    def log_catalog(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_catalog", value)

    @property
    @pulumi.getter(name="logClient")
    def log_client(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether log messages will be visible to a client process such as psql.
        """
        return pulumi.get(self, "log_client")

    @log_client.setter
    def log_client(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_client", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the log level that will be used for log entries.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="logMaxStringLength")
    def log_max_string_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Crop parameters representation and whole statements if they exceed this threshold. A (default) value of -1 disable the truncation.
        """
        return pulumi.get(self, "log_max_string_length")

    @log_max_string_length.setter
    def log_max_string_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "log_max_string_length", value)

    @property
    @pulumi.getter(name="logNestedStatements")
    def log_nested_statements(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This GUC allows to turn off logging nested statements, that is, statements that are executed as part of another ExecutorRun.
        """
        return pulumi.get(self, "log_nested_statements")

    @log_nested_statements.setter
    def log_nested_statements(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_nested_statements", value)

    @property
    @pulumi.getter(name="logParameter")
    def log_parameter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies that audit logging should include the parameters that were passed with the statement.
        """
        return pulumi.get(self, "log_parameter")

    @log_parameter.setter
    def log_parameter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_parameter", value)

    @property
    @pulumi.getter(name="logParameterMaxSize")
    def log_parameter_max_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies that parameter values longer than this setting (in bytes) should not be logged, but replaced with <long param suppressed>.
        """
        return pulumi.get(self, "log_parameter_max_size")

    @log_parameter_max_size.setter
    def log_parameter_max_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "log_parameter_max_size", value)

    @property
    @pulumi.getter(name="logRelation")
    def log_relation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether session audit logging should create a separate log entry for each relation (TABLE, VIEW, etc.) referenced in a SELECT or DML statement.
        """
        return pulumi.get(self, "log_relation")

    @log_relation.setter
    def log_relation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_relation", value)

    @property
    @pulumi.getter(name="logRows")
    def log_rows(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies that audit logging should include the rows retrieved or affected by a statement. When enabled the rows field will be included after the parameter field.
        """
        return pulumi.get(self, "log_rows")

    @log_rows.setter
    def log_rows(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_rows", value)

    @property
    @pulumi.getter(name="logStatement")
    def log_statement(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether logging will include the statement text and parameters (if enabled).
        """
        return pulumi.get(self, "log_statement")

    @log_statement.setter
    def log_statement(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_statement", value)

    @property
    @pulumi.getter(name="logStatementOnce")
    def log_statement_once(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether logging will include the statement text and parameters with the first log entry for a statement/substatement combination or with every entry.
        """
        return pulumi.get(self, "log_statement_once")

    @log_statement_once.setter
    def log_statement_once(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "log_statement_once", value)

    @property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies which classes of statements will be logged by session audit logging.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "logs", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the master role to use for object audit logging.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesPgbouncerArgsDict(TypedDict):
        autodb_idle_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].
        """
        autodb_max_db_connections: NotRequired[pulumi.Input[builtins.int]]
        """
        Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
        """
        autodb_pool_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        PGBouncer pool mode.
        """
        autodb_pool_size: NotRequired[pulumi.Input[builtins.int]]
        """
        If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
        """
        ignore_startup_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of parameters to ignore when given in startup packet.
        """
        max_prepared_statements: NotRequired[pulumi.Input[builtins.int]]
        """
        PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.
        """
        min_pool_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        """
        server_idle_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].
        """
        server_lifetime: NotRequired[pulumi.Input[builtins.int]]
        """
        The pooler will close an unused server connection that has been connected longer than this. [seconds].
        """
        server_reset_query_always: NotRequired[pulumi.Input[builtins.bool]]
        """
        Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesPgbouncerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesPgbouncerArgs:
    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 autodb_max_db_connections: Optional[pulumi.Input[builtins.int]] = None,
                 autodb_pool_mode: Optional[pulumi.Input[builtins.str]] = None,
                 autodb_pool_size: Optional[pulumi.Input[builtins.int]] = None,
                 ignore_startup_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 max_prepared_statements: Optional[pulumi.Input[builtins.int]] = None,
                 min_pool_size: Optional[pulumi.Input[builtins.int]] = None,
                 server_idle_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 server_lifetime: Optional[pulumi.Input[builtins.int]] = None,
                 server_reset_query_always: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] autodb_idle_timeout: If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].
        :param pulumi.Input[builtins.int] autodb_max_db_connections: Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
        :param pulumi.Input[builtins.str] autodb_pool_mode: PGBouncer pool mode.
        :param pulumi.Input[builtins.int] autodb_pool_size: If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ignore_startup_parameters: List of parameters to ignore when given in startup packet.
        :param pulumi.Input[builtins.int] max_prepared_statements: PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.
        :param pulumi.Input[builtins.int] min_pool_size: Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        :param pulumi.Input[builtins.int] server_idle_timeout: If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].
        :param pulumi.Input[builtins.int] server_lifetime: The pooler will close an unused server connection that has been connected longer than this. [seconds].
        :param pulumi.Input[builtins.bool] server_reset_query_always: Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if max_prepared_statements is not None:
            pulumi.set(__self__, "max_prepared_statements", max_prepared_statements)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].
        """
        return pulumi.get(self, "autodb_idle_timeout")

    @autodb_idle_timeout.setter
    def autodb_idle_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autodb_idle_timeout", value)

    @property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
        """
        return pulumi.get(self, "autodb_max_db_connections")

    @autodb_max_db_connections.setter
    def autodb_max_db_connections(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autodb_max_db_connections", value)

    @property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PGBouncer pool mode.
        """
        return pulumi.get(self, "autodb_pool_mode")

    @autodb_pool_mode.setter
    def autodb_pool_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "autodb_pool_mode", value)

    @property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
        """
        return pulumi.get(self, "autodb_pool_size")

    @autodb_pool_size.setter
    def autodb_pool_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autodb_pool_size", value)

    @property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of parameters to ignore when given in startup packet.
        """
        return pulumi.get(self, "ignore_startup_parameters")

    @ignore_startup_parameters.setter
    def ignore_startup_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ignore_startup_parameters", value)

    @property
    @pulumi.getter(name="maxPreparedStatements")
    def max_prepared_statements(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.
        """
        return pulumi.get(self, "max_prepared_statements")

    @max_prepared_statements.setter
    def max_prepared_statements(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_prepared_statements", value)

    @property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        """
        return pulumi.get(self, "min_pool_size")

    @min_pool_size.setter
    def min_pool_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_pool_size", value)

    @property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].
        """
        return pulumi.get(self, "server_idle_timeout")

    @server_idle_timeout.setter
    def server_idle_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "server_idle_timeout", value)

    @property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The pooler will close an unused server connection that has been connected longer than this. [seconds].
        """
        return pulumi.get(self, "server_lifetime")

    @server_lifetime.setter
    def server_lifetime(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "server_lifetime", value)

    @property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
        return pulumi.get(self, "server_reset_query_always")

    @server_reset_query_always.setter
    def server_reset_query_always(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "server_reset_query_always", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesPglookoutArgsDict(TypedDict):
        max_failover_replication_time_lag: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of seconds of master unavailability before triggering database failover to standby.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesPglookoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesPglookoutArgs:
    def __init__(__self__, *,
                 max_failover_replication_time_lag: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] max_failover_replication_time_lag: Number of seconds of master unavailability before triggering database failover to standby.
        """
        if max_failover_replication_time_lag is not None:
            pulumi.set(__self__, "max_failover_replication_time_lag", max_failover_replication_time_lag)

    @property
    @pulumi.getter(name="maxFailoverReplicationTimeLag")
    def max_failover_replication_time_lag(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of seconds of master unavailability before triggering database failover to standby.
        """
        return pulumi.get(self, "max_failover_replication_time_lag")

    @max_failover_replication_time_lag.setter
    def max_failover_replication_time_lag(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_failover_replication_time_lag", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesTimescaledbArgsDict(TypedDict):
        max_background_workers: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesTimescaledbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesTimescaledbArgs:
    def __init__(__self__, *,
                 max_background_workers: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] max_background_workers: The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
        return pulumi.get(self, "max_background_workers")

    @max_background_workers.setter
    def max_background_workers(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_background_workers", value)


if not MYPY:
    class ManagedDatabaseRedisComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[builtins.str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[builtins.str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabaseRedisComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 route: Optional[pulumi.Input[builtins.str]] = None,
                 usage: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] component: Type of the component
        :param pulumi.Input[builtins.str] host: Hostname of the component
        :param pulumi.Input[builtins.int] port: Port number of the component
        :param pulumi.Input[builtins.str] route: Component network route type
        :param pulumi.Input[builtins.str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabaseRedisNetworkArgsDict(TypedDict):
        family: pulumi.Input[builtins.str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[builtins.str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabaseRedisNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 uuid: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[builtins.str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[builtins.str] type: The type of the network. Must be private.
        :param pulumi.Input[builtins.str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[builtins.str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabaseRedisNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the node
        """
elif False:
    ManagedDatabaseRedisNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name plus a node iteration
        :param pulumi.Input[builtins.str] role: Role of the node
        :param pulumi.Input[builtins.str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabaseRedisPropertiesArgsDict(TypedDict):
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[builtins.bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        backup_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        backup_minute: NotRequired[pulumi.Input[builtins.int]]
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        migration: NotRequired[pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgsDict']]
        """
        Migrate data from existing server.
        """
        public_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        redis_acl_channels_default: NotRequired[pulumi.Input[builtins.str]]
        """
        Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        """
        redis_io_threads: NotRequired[pulumi.Input[builtins.int]]
        """
        Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.
        """
        redis_lfu_decay_time: NotRequired[pulumi.Input[builtins.int]]
        """
        LFU maxmemory-policy counter decay time in minutes.
        """
        redis_lfu_log_factor: NotRequired[pulumi.Input[builtins.int]]
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        """
        redis_maxmemory_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Redis maxmemory-policy.
        """
        redis_notify_keyspace_events: NotRequired[pulumi.Input[builtins.str]]
        """
        Set notify-keyspace-events option.
        """
        redis_number_of_databases: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.
        """
        redis_persistence: NotRequired[pulumi.Input[builtins.str]]
        """
        Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.
        """
        redis_pubsub_client_output_buffer_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        """
        redis_ssl: NotRequired[pulumi.Input[builtins.bool]]
        """
        Require SSL to access Redis.
        """
        redis_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Redis idle connection timeout in seconds.
        """
        redis_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Redis major version.
        """
        service_log: NotRequired[pulumi.Input[builtins.bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
elif False:
    ManagedDatabaseRedisPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisPropertiesArgs:
    def __init__(__self__, *,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 backup_hour: Optional[pulumi.Input[builtins.int]] = None,
                 backup_minute: Optional[pulumi.Input[builtins.int]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 migration: Optional[pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgs']] = None,
                 public_access: Optional[pulumi.Input[builtins.bool]] = None,
                 redis_acl_channels_default: Optional[pulumi.Input[builtins.str]] = None,
                 redis_io_threads: Optional[pulumi.Input[builtins.int]] = None,
                 redis_lfu_decay_time: Optional[pulumi.Input[builtins.int]] = None,
                 redis_lfu_log_factor: Optional[pulumi.Input[builtins.int]] = None,
                 redis_maxmemory_policy: Optional[pulumi.Input[builtins.str]] = None,
                 redis_notify_keyspace_events: Optional[pulumi.Input[builtins.str]] = None,
                 redis_number_of_databases: Optional[pulumi.Input[builtins.int]] = None,
                 redis_persistence: Optional[pulumi.Input[builtins.str]] = None,
                 redis_pubsub_client_output_buffer_limit: Optional[pulumi.Input[builtins.int]] = None,
                 redis_ssl: Optional[pulumi.Input[builtins.bool]] = None,
                 redis_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 redis_version: Optional[pulumi.Input[builtins.str]] = None,
                 service_log: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[builtins.int] backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[builtins.int] backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgs'] migration: Migrate data from existing server.
        :param pulumi.Input[builtins.bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[builtins.str] redis_acl_channels_default: Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        :param pulumi.Input[builtins.int] redis_io_threads: Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.
        :param pulumi.Input[builtins.int] redis_lfu_decay_time: LFU maxmemory-policy counter decay time in minutes.
        :param pulumi.Input[builtins.int] redis_lfu_log_factor: Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        :param pulumi.Input[builtins.str] redis_maxmemory_policy: Redis maxmemory-policy.
        :param pulumi.Input[builtins.str] redis_notify_keyspace_events: Set notify-keyspace-events option.
        :param pulumi.Input[builtins.int] redis_number_of_databases: Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.
        :param pulumi.Input[builtins.str] redis_persistence: Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.
        :param pulumi.Input[builtins.int] redis_pubsub_client_output_buffer_limit: Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        :param pulumi.Input[builtins.bool] redis_ssl: Require SSL to access Redis.
        :param pulumi.Input[builtins.int] redis_timeout: Redis idle connection timeout in seconds.
        :param pulumi.Input[builtins.str] redis_version: Redis major version.
        :param pulumi.Input[builtins.bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if redis_acl_channels_default is not None:
            pulumi.set(__self__, "redis_acl_channels_default", redis_acl_channels_default)
        if redis_io_threads is not None:
            pulumi.set(__self__, "redis_io_threads", redis_io_threads)
        if redis_lfu_decay_time is not None:
            pulumi.set(__self__, "redis_lfu_decay_time", redis_lfu_decay_time)
        if redis_lfu_log_factor is not None:
            pulumi.set(__self__, "redis_lfu_log_factor", redis_lfu_log_factor)
        if redis_maxmemory_policy is not None:
            pulumi.set(__self__, "redis_maxmemory_policy", redis_maxmemory_policy)
        if redis_notify_keyspace_events is not None:
            pulumi.set(__self__, "redis_notify_keyspace_events", redis_notify_keyspace_events)
        if redis_number_of_databases is not None:
            pulumi.set(__self__, "redis_number_of_databases", redis_number_of_databases)
        if redis_persistence is not None:
            pulumi.set(__self__, "redis_persistence", redis_persistence)
        if redis_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "redis_pubsub_client_output_buffer_limit", redis_pubsub_client_output_buffer_limit)
        if redis_ssl is not None:
            pulumi.set(__self__, "redis_ssl", redis_ssl)
        if redis_timeout is not None:
            pulumi.set(__self__, "redis_timeout", redis_timeout)
        if redis_version is not None:
            pulumi.set(__self__, "redis_version", redis_version)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @backup_hour.setter
    def backup_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_hour", value)

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @backup_minute.setter
    def backup_minute(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_minute", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter
    def migration(self) -> Optional[pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgs']]:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @migration.setter
    def migration(self, value: Optional[pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgs']]):
        pulumi.set(self, "migration", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="redisAclChannelsDefault")
    def redis_acl_channels_default(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        """
        return pulumi.get(self, "redis_acl_channels_default")

    @redis_acl_channels_default.setter
    def redis_acl_channels_default(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redis_acl_channels_default", value)

    @property
    @pulumi.getter(name="redisIoThreads")
    def redis_io_threads(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.
        """
        return pulumi.get(self, "redis_io_threads")

    @redis_io_threads.setter
    def redis_io_threads(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "redis_io_threads", value)

    @property
    @pulumi.getter(name="redisLfuDecayTime")
    def redis_lfu_decay_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        LFU maxmemory-policy counter decay time in minutes.
        """
        return pulumi.get(self, "redis_lfu_decay_time")

    @redis_lfu_decay_time.setter
    def redis_lfu_decay_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "redis_lfu_decay_time", value)

    @property
    @pulumi.getter(name="redisLfuLogFactor")
    def redis_lfu_log_factor(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        """
        return pulumi.get(self, "redis_lfu_log_factor")

    @redis_lfu_log_factor.setter
    def redis_lfu_log_factor(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "redis_lfu_log_factor", value)

    @property
    @pulumi.getter(name="redisMaxmemoryPolicy")
    def redis_maxmemory_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Redis maxmemory-policy.
        """
        return pulumi.get(self, "redis_maxmemory_policy")

    @redis_maxmemory_policy.setter
    def redis_maxmemory_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redis_maxmemory_policy", value)

    @property
    @pulumi.getter(name="redisNotifyKeyspaceEvents")
    def redis_notify_keyspace_events(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set notify-keyspace-events option.
        """
        return pulumi.get(self, "redis_notify_keyspace_events")

    @redis_notify_keyspace_events.setter
    def redis_notify_keyspace_events(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redis_notify_keyspace_events", value)

    @property
    @pulumi.getter(name="redisNumberOfDatabases")
    def redis_number_of_databases(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.
        """
        return pulumi.get(self, "redis_number_of_databases")

    @redis_number_of_databases.setter
    def redis_number_of_databases(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "redis_number_of_databases", value)

    @property
    @pulumi.getter(name="redisPersistence")
    def redis_persistence(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.
        """
        return pulumi.get(self, "redis_persistence")

    @redis_persistence.setter
    def redis_persistence(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redis_persistence", value)

    @property
    @pulumi.getter(name="redisPubsubClientOutputBufferLimit")
    def redis_pubsub_client_output_buffer_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        """
        return pulumi.get(self, "redis_pubsub_client_output_buffer_limit")

    @redis_pubsub_client_output_buffer_limit.setter
    def redis_pubsub_client_output_buffer_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "redis_pubsub_client_output_buffer_limit", value)

    @property
    @pulumi.getter(name="redisSsl")
    def redis_ssl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Require SSL to access Redis.
        """
        return pulumi.get(self, "redis_ssl")

    @redis_ssl.setter
    def redis_ssl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "redis_ssl", value)

    @property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Redis idle connection timeout in seconds.
        """
        return pulumi.get(self, "redis_timeout")

    @redis_timeout.setter
    def redis_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "redis_timeout", value)

    @property
    @pulumi.getter(name="redisVersion")
    def redis_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Redis major version.
        """
        return pulumi.get(self, "redis_version")

    @redis_version.setter
    def redis_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redis_version", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "service_log", value)


if not MYPY:
    class ManagedDatabaseRedisPropertiesMigrationArgsDict(TypedDict):
        dbname: NotRequired[pulumi.Input[builtins.str]]
        """
        Database name for bootstrapping the initial connection.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname or IP address of the server where to migrate data from.
        """
        ignore_dbs: NotRequired[pulumi.Input[builtins.str]]
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        ignore_roles: NotRequired[pulumi.Input[builtins.str]]
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        method: NotRequired[pulumi.Input[builtins.str]]
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password for authentication with the server where to migrate data from.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the server where to migrate data from.
        """
        ssl: NotRequired[pulumi.Input[builtins.bool]]
        """
        The server where to migrate data from is secured with SSL.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        User name for authentication with the server where to migrate data from.
        """
elif False:
    ManagedDatabaseRedisPropertiesMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisPropertiesMigrationArgs:
    def __init__(__self__, *,
                 dbname: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_dbs: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_roles: Optional[pulumi.Input[builtins.str]] = None,
                 method: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 ssl: Optional[pulumi.Input[builtins.bool]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] dbname: Database name for bootstrapping the initial connection.
        :param pulumi.Input[builtins.str] host: Hostname or IP address of the server where to migrate data from.
        :param pulumi.Input[builtins.str] ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param pulumi.Input[builtins.str] ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param pulumi.Input[builtins.str] method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param pulumi.Input[builtins.str] password: Password for authentication with the server where to migrate data from.
        :param pulumi.Input[builtins.int] port: Port number of the server where to migrate data from.
        :param pulumi.Input[builtins.bool] ssl: The server where to migrate data from is secured with SSL.
        :param pulumi.Input[builtins.str] username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @ignore_dbs.setter
    def ignore_dbs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ignore_dbs", value)

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @ignore_roles.setter
    def ignore_roles(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ignore_roles", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ManagedDatabaseUserOpensearchAccessControlArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgsDict']]]
        """
        Set user access control rules.
        """
elif False:
    ManagedDatabaseUserOpensearchAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserOpensearchAccessControlArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgs']]] rules: Set user access control rules.
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgs']]]:
        """
        Set user access control rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class ManagedDatabaseUserOpensearchAccessControlRuleArgsDict(TypedDict):
        index: pulumi.Input[builtins.str]
        """
        Set index name, pattern or top level API.
        """
        permission: pulumi.Input[builtins.str]
        """
        Set permission access.
        """
elif False:
    ManagedDatabaseUserOpensearchAccessControlRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserOpensearchAccessControlRuleArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[builtins.str],
                 permission: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] index: Set index name, pattern or top level API.
        :param pulumi.Input[builtins.str] permission: Set permission access.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[builtins.str]:
        """
        Set index name, pattern or top level API.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[builtins.str]:
        """
        Set permission access.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class ManagedDatabaseUserPgAccessControlArgsDict(TypedDict):
        allow_replication: NotRequired[pulumi.Input[builtins.bool]]
        """
        Grant replication privilege
        """
elif False:
    ManagedDatabaseUserPgAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserPgAccessControlArgs:
    def __init__(__self__, *,
                 allow_replication: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] allow_replication: Grant replication privilege
        """
        if allow_replication is not None:
            pulumi.set(__self__, "allow_replication", allow_replication)

    @property
    @pulumi.getter(name="allowReplication")
    def allow_replication(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Grant replication privilege
        """
        return pulumi.get(self, "allow_replication")

    @allow_replication.setter
    def allow_replication(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_replication", value)


if not MYPY:
    class ManagedDatabaseUserRedisAccessControlArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input[builtins.str]]
        """
        Set access control to all commands in specified categories.
        """
        channels: NotRequired[pulumi.Input[builtins.str]]
        """
        Set access control to Pub/Sub channels.
        """
        commands: NotRequired[pulumi.Input[builtins.str]]
        """
        Set access control to commands.
        """
        keys: NotRequired[pulumi.Input[builtins.str]]
        """
        Set access control to keys.
        """
elif False:
    ManagedDatabaseUserRedisAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserRedisAccessControlArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[builtins.str]] = None,
                 channels: Optional[pulumi.Input[builtins.str]] = None,
                 commands: Optional[pulumi.Input[builtins.str]] = None,
                 keys: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] categories: Set access control to all commands in specified categories.
        :param pulumi.Input[builtins.str] channels: Set access control to Pub/Sub channels.
        :param pulumi.Input[builtins.str] commands: Set access control to commands.
        :param pulumi.Input[builtins.str] keys: Set access control to keys.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set access control to all commands in specified categories.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set access control to Pub/Sub channels.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set access control to commands.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set access control to keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keys", value)


if not MYPY:
    class ManagedDatabaseUserValkeyAccessControlArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input[builtins.str]]
        """
        Set access control to all commands in specified categories.
        """
        channels: NotRequired[pulumi.Input[builtins.str]]
        """
        Set access control to Pub/Sub channels.
        """
        commands: NotRequired[pulumi.Input[builtins.str]]
        """
        Set access control to commands.
        """
        keys: NotRequired[pulumi.Input[builtins.str]]
        """
        Set access control to keys.
        """
elif False:
    ManagedDatabaseUserValkeyAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserValkeyAccessControlArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[builtins.str]] = None,
                 channels: Optional[pulumi.Input[builtins.str]] = None,
                 commands: Optional[pulumi.Input[builtins.str]] = None,
                 keys: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] categories: Set access control to all commands in specified categories.
        :param pulumi.Input[builtins.str] channels: Set access control to Pub/Sub channels.
        :param pulumi.Input[builtins.str] commands: Set access control to commands.
        :param pulumi.Input[builtins.str] keys: Set access control to keys.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set access control to all commands in specified categories.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set access control to Pub/Sub channels.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set access control to commands.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set access control to keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keys", value)


if not MYPY:
    class ManagedDatabaseValkeyComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[builtins.str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[builtins.str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabaseValkeyComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseValkeyComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 route: Optional[pulumi.Input[builtins.str]] = None,
                 usage: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] component: Type of the component
        :param pulumi.Input[builtins.str] host: Hostname of the component
        :param pulumi.Input[builtins.int] port: Port number of the component
        :param pulumi.Input[builtins.str] route: Component network route type
        :param pulumi.Input[builtins.str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabaseValkeyNetworkArgsDict(TypedDict):
        family: pulumi.Input[builtins.str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[builtins.str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabaseValkeyNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseValkeyNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 uuid: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[builtins.str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[builtins.str] type: The type of the network. Must be private.
        :param pulumi.Input[builtins.str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[builtins.str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabaseValkeyNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the node
        """
elif False:
    ManagedDatabaseValkeyNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseValkeyNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name plus a node iteration
        :param pulumi.Input[builtins.str] role: Role of the node
        :param pulumi.Input[builtins.str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabaseValkeyPropertiesArgsDict(TypedDict):
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[builtins.bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        backup_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        backup_minute: NotRequired[pulumi.Input[builtins.int]]
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        frequent_snapshots: NotRequired[pulumi.Input[builtins.bool]]
        """
        Frequent RDB snapshots. When enabled, Valkey will create frequent local RDB snapshots. When disabled, Valkey will only take RDB snapshots when a backup is created, based on the backup schedule. This setting is ignored when `valkey_persistence` is set to `off`.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        migration: NotRequired[pulumi.Input['ManagedDatabaseValkeyPropertiesMigrationArgsDict']]
        """
        Migrate data from existing server.
        """
        public_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        service_log: NotRequired[pulumi.Input[builtins.bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        valkey_acl_channels_default: NotRequired[pulumi.Input[builtins.str]]
        """
        Default ACL for pub/sub channels used when a Valkey user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Valkey configuration acl-pubsub-default.
        """
        valkey_active_expire_effort: NotRequired[pulumi.Input[builtins.int]]
        """
        Active expire effort. Valkey reclaims expired keys both when accessed and in the background. The background process scans for expired keys to free memory. Increasing the active-expire-effort setting (default 1, max 10) uses more CPU to reclaim expired keys faster, reducing memory usage but potentially increasing latency.
        """
        valkey_io_threads: NotRequired[pulumi.Input[builtins.int]]
        """
        Valkey IO thread count. Set Valkey IO thread count. Changing this will cause a restart of the Valkey service.
        """
        valkey_lfu_decay_time: NotRequired[pulumi.Input[builtins.int]]
        """
        LFU maxmemory-policy counter decay time in minutes.
        """
        valkey_lfu_log_factor: NotRequired[pulumi.Input[builtins.int]]
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        """
        valkey_maxmemory_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Valkey maxmemory-policy.
        """
        valkey_notify_keyspace_events: NotRequired[pulumi.Input[builtins.str]]
        """
        Set notify-keyspace-events option.
        """
        valkey_number_of_databases: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of Valkey databases. Set number of Valkey databases. Changing this will cause a restart of the Valkey service.
        """
        valkey_persistence: NotRequired[pulumi.Input[builtins.str]]
        """
        Valkey persistence. When persistence is 'rdb', Valkey does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
        """
        valkey_pubsub_client_output_buffer_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        """
        valkey_ssl: NotRequired[pulumi.Input[builtins.bool]]
        """
        Require SSL to access Valkey.
        """
        valkey_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Valkey idle connection timeout in seconds.
        """
elif False:
    ManagedDatabaseValkeyPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseValkeyPropertiesArgs:
    def __init__(__self__, *,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[builtins.bool]] = None,
                 backup_hour: Optional[pulumi.Input[builtins.int]] = None,
                 backup_minute: Optional[pulumi.Input[builtins.int]] = None,
                 frequent_snapshots: Optional[pulumi.Input[builtins.bool]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 migration: Optional[pulumi.Input['ManagedDatabaseValkeyPropertiesMigrationArgs']] = None,
                 public_access: Optional[pulumi.Input[builtins.bool]] = None,
                 service_log: Optional[pulumi.Input[builtins.bool]] = None,
                 valkey_acl_channels_default: Optional[pulumi.Input[builtins.str]] = None,
                 valkey_active_expire_effort: Optional[pulumi.Input[builtins.int]] = None,
                 valkey_io_threads: Optional[pulumi.Input[builtins.int]] = None,
                 valkey_lfu_decay_time: Optional[pulumi.Input[builtins.int]] = None,
                 valkey_lfu_log_factor: Optional[pulumi.Input[builtins.int]] = None,
                 valkey_maxmemory_policy: Optional[pulumi.Input[builtins.str]] = None,
                 valkey_notify_keyspace_events: Optional[pulumi.Input[builtins.str]] = None,
                 valkey_number_of_databases: Optional[pulumi.Input[builtins.int]] = None,
                 valkey_persistence: Optional[pulumi.Input[builtins.str]] = None,
                 valkey_pubsub_client_output_buffer_limit: Optional[pulumi.Input[builtins.int]] = None,
                 valkey_ssl: Optional[pulumi.Input[builtins.bool]] = None,
                 valkey_timeout: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[builtins.int] backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[builtins.int] backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[builtins.bool] frequent_snapshots: Frequent RDB snapshots. When enabled, Valkey will create frequent local RDB snapshots. When disabled, Valkey will only take RDB snapshots when a backup is created, based on the backup schedule. This setting is ignored when `valkey_persistence` is set to `off`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input['ManagedDatabaseValkeyPropertiesMigrationArgs'] migration: Migrate data from existing server.
        :param pulumi.Input[builtins.bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[builtins.bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param pulumi.Input[builtins.str] valkey_acl_channels_default: Default ACL for pub/sub channels used when a Valkey user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Valkey configuration acl-pubsub-default.
        :param pulumi.Input[builtins.int] valkey_active_expire_effort: Active expire effort. Valkey reclaims expired keys both when accessed and in the background. The background process scans for expired keys to free memory. Increasing the active-expire-effort setting (default 1, max 10) uses more CPU to reclaim expired keys faster, reducing memory usage but potentially increasing latency.
        :param pulumi.Input[builtins.int] valkey_io_threads: Valkey IO thread count. Set Valkey IO thread count. Changing this will cause a restart of the Valkey service.
        :param pulumi.Input[builtins.int] valkey_lfu_decay_time: LFU maxmemory-policy counter decay time in minutes.
        :param pulumi.Input[builtins.int] valkey_lfu_log_factor: Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        :param pulumi.Input[builtins.str] valkey_maxmemory_policy: Valkey maxmemory-policy.
        :param pulumi.Input[builtins.str] valkey_notify_keyspace_events: Set notify-keyspace-events option.
        :param pulumi.Input[builtins.int] valkey_number_of_databases: Number of Valkey databases. Set number of Valkey databases. Changing this will cause a restart of the Valkey service.
        :param pulumi.Input[builtins.str] valkey_persistence: Valkey persistence. When persistence is 'rdb', Valkey does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
        :param pulumi.Input[builtins.int] valkey_pubsub_client_output_buffer_limit: Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        :param pulumi.Input[builtins.bool] valkey_ssl: Require SSL to access Valkey.
        :param pulumi.Input[builtins.int] valkey_timeout: Valkey idle connection timeout in seconds.
        """
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if frequent_snapshots is not None:
            pulumi.set(__self__, "frequent_snapshots", frequent_snapshots)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if valkey_acl_channels_default is not None:
            pulumi.set(__self__, "valkey_acl_channels_default", valkey_acl_channels_default)
        if valkey_active_expire_effort is not None:
            pulumi.set(__self__, "valkey_active_expire_effort", valkey_active_expire_effort)
        if valkey_io_threads is not None:
            pulumi.set(__self__, "valkey_io_threads", valkey_io_threads)
        if valkey_lfu_decay_time is not None:
            pulumi.set(__self__, "valkey_lfu_decay_time", valkey_lfu_decay_time)
        if valkey_lfu_log_factor is not None:
            pulumi.set(__self__, "valkey_lfu_log_factor", valkey_lfu_log_factor)
        if valkey_maxmemory_policy is not None:
            pulumi.set(__self__, "valkey_maxmemory_policy", valkey_maxmemory_policy)
        if valkey_notify_keyspace_events is not None:
            pulumi.set(__self__, "valkey_notify_keyspace_events", valkey_notify_keyspace_events)
        if valkey_number_of_databases is not None:
            pulumi.set(__self__, "valkey_number_of_databases", valkey_number_of_databases)
        if valkey_persistence is not None:
            pulumi.set(__self__, "valkey_persistence", valkey_persistence)
        if valkey_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "valkey_pubsub_client_output_buffer_limit", valkey_pubsub_client_output_buffer_limit)
        if valkey_ssl is not None:
            pulumi.set(__self__, "valkey_ssl", valkey_ssl)
        if valkey_timeout is not None:
            pulumi.set(__self__, "valkey_timeout", valkey_timeout)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @backup_hour.setter
    def backup_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_hour", value)

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @backup_minute.setter
    def backup_minute(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_minute", value)

    @property
    @pulumi.getter(name="frequentSnapshots")
    def frequent_snapshots(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Frequent RDB snapshots. When enabled, Valkey will create frequent local RDB snapshots. When disabled, Valkey will only take RDB snapshots when a backup is created, based on the backup schedule. This setting is ignored when `valkey_persistence` is set to `off`.
        """
        return pulumi.get(self, "frequent_snapshots")

    @frequent_snapshots.setter
    def frequent_snapshots(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "frequent_snapshots", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter
    def migration(self) -> Optional[pulumi.Input['ManagedDatabaseValkeyPropertiesMigrationArgs']]:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @migration.setter
    def migration(self, value: Optional[pulumi.Input['ManagedDatabaseValkeyPropertiesMigrationArgs']]):
        pulumi.set(self, "migration", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "service_log", value)

    @property
    @pulumi.getter(name="valkeyAclChannelsDefault")
    def valkey_acl_channels_default(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default ACL for pub/sub channels used when a Valkey user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Valkey configuration acl-pubsub-default.
        """
        return pulumi.get(self, "valkey_acl_channels_default")

    @valkey_acl_channels_default.setter
    def valkey_acl_channels_default(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "valkey_acl_channels_default", value)

    @property
    @pulumi.getter(name="valkeyActiveExpireEffort")
    def valkey_active_expire_effort(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Active expire effort. Valkey reclaims expired keys both when accessed and in the background. The background process scans for expired keys to free memory. Increasing the active-expire-effort setting (default 1, max 10) uses more CPU to reclaim expired keys faster, reducing memory usage but potentially increasing latency.
        """
        return pulumi.get(self, "valkey_active_expire_effort")

    @valkey_active_expire_effort.setter
    def valkey_active_expire_effort(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valkey_active_expire_effort", value)

    @property
    @pulumi.getter(name="valkeyIoThreads")
    def valkey_io_threads(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Valkey IO thread count. Set Valkey IO thread count. Changing this will cause a restart of the Valkey service.
        """
        return pulumi.get(self, "valkey_io_threads")

    @valkey_io_threads.setter
    def valkey_io_threads(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valkey_io_threads", value)

    @property
    @pulumi.getter(name="valkeyLfuDecayTime")
    def valkey_lfu_decay_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        LFU maxmemory-policy counter decay time in minutes.
        """
        return pulumi.get(self, "valkey_lfu_decay_time")

    @valkey_lfu_decay_time.setter
    def valkey_lfu_decay_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valkey_lfu_decay_time", value)

    @property
    @pulumi.getter(name="valkeyLfuLogFactor")
    def valkey_lfu_log_factor(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        """
        return pulumi.get(self, "valkey_lfu_log_factor")

    @valkey_lfu_log_factor.setter
    def valkey_lfu_log_factor(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valkey_lfu_log_factor", value)

    @property
    @pulumi.getter(name="valkeyMaxmemoryPolicy")
    def valkey_maxmemory_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Valkey maxmemory-policy.
        """
        return pulumi.get(self, "valkey_maxmemory_policy")

    @valkey_maxmemory_policy.setter
    def valkey_maxmemory_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "valkey_maxmemory_policy", value)

    @property
    @pulumi.getter(name="valkeyNotifyKeyspaceEvents")
    def valkey_notify_keyspace_events(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Set notify-keyspace-events option.
        """
        return pulumi.get(self, "valkey_notify_keyspace_events")

    @valkey_notify_keyspace_events.setter
    def valkey_notify_keyspace_events(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "valkey_notify_keyspace_events", value)

    @property
    @pulumi.getter(name="valkeyNumberOfDatabases")
    def valkey_number_of_databases(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of Valkey databases. Set number of Valkey databases. Changing this will cause a restart of the Valkey service.
        """
        return pulumi.get(self, "valkey_number_of_databases")

    @valkey_number_of_databases.setter
    def valkey_number_of_databases(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valkey_number_of_databases", value)

    @property
    @pulumi.getter(name="valkeyPersistence")
    def valkey_persistence(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Valkey persistence. When persistence is 'rdb', Valkey does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
        """
        return pulumi.get(self, "valkey_persistence")

    @valkey_persistence.setter
    def valkey_persistence(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "valkey_persistence", value)

    @property
    @pulumi.getter(name="valkeyPubsubClientOutputBufferLimit")
    def valkey_pubsub_client_output_buffer_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        """
        return pulumi.get(self, "valkey_pubsub_client_output_buffer_limit")

    @valkey_pubsub_client_output_buffer_limit.setter
    def valkey_pubsub_client_output_buffer_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valkey_pubsub_client_output_buffer_limit", value)

    @property
    @pulumi.getter(name="valkeySsl")
    def valkey_ssl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Require SSL to access Valkey.
        """
        return pulumi.get(self, "valkey_ssl")

    @valkey_ssl.setter
    def valkey_ssl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "valkey_ssl", value)

    @property
    @pulumi.getter(name="valkeyTimeout")
    def valkey_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Valkey idle connection timeout in seconds.
        """
        return pulumi.get(self, "valkey_timeout")

    @valkey_timeout.setter
    def valkey_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valkey_timeout", value)


if not MYPY:
    class ManagedDatabaseValkeyPropertiesMigrationArgsDict(TypedDict):
        dbname: NotRequired[pulumi.Input[builtins.str]]
        """
        Database name for bootstrapping the initial connection.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname or IP address of the server where to migrate data from.
        """
        ignore_dbs: NotRequired[pulumi.Input[builtins.str]]
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        ignore_roles: NotRequired[pulumi.Input[builtins.str]]
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        method: NotRequired[pulumi.Input[builtins.str]]
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password for authentication with the server where to migrate data from.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port number of the server where to migrate data from.
        """
        ssl: NotRequired[pulumi.Input[builtins.bool]]
        """
        The server where to migrate data from is secured with SSL.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        User name for authentication with the server where to migrate data from.
        """
elif False:
    ManagedDatabaseValkeyPropertiesMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseValkeyPropertiesMigrationArgs:
    def __init__(__self__, *,
                 dbname: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_dbs: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_roles: Optional[pulumi.Input[builtins.str]] = None,
                 method: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 ssl: Optional[pulumi.Input[builtins.bool]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] dbname: Database name for bootstrapping the initial connection.
        :param pulumi.Input[builtins.str] host: Hostname or IP address of the server where to migrate data from.
        :param pulumi.Input[builtins.str] ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param pulumi.Input[builtins.str] ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param pulumi.Input[builtins.str] method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param pulumi.Input[builtins.str] password: Password for authentication with the server where to migrate data from.
        :param pulumi.Input[builtins.int] port: Port number of the server where to migrate data from.
        :param pulumi.Input[builtins.bool] ssl: The server where to migrate data from is secured with SSL.
        :param pulumi.Input[builtins.str] username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @ignore_dbs.setter
    def ignore_dbs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ignore_dbs", value)

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @ignore_roles.setter
    def ignore_roles(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ignore_roles", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ManagedObjectStorageEndpointArgsDict(TypedDict):
        domain_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Domain name of the endpoint.
        """
        iam_url: NotRequired[pulumi.Input[builtins.str]]
        """
        URL for IAM.
        """
        sts_url: NotRequired[pulumi.Input[builtins.str]]
        """
        URL for STS.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the endpoint (`private` / `public`).
        """
elif False:
    ManagedObjectStorageEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedObjectStorageEndpointArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 iam_url: Optional[pulumi.Input[builtins.str]] = None,
                 sts_url: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] domain_name: Domain name of the endpoint.
        :param pulumi.Input[builtins.str] iam_url: URL for IAM.
        :param pulumi.Input[builtins.str] sts_url: URL for STS.
        :param pulumi.Input[builtins.str] type: Type of the endpoint (`private` / `public`).
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if iam_url is not None:
            pulumi.set(__self__, "iam_url", iam_url)
        if sts_url is not None:
            pulumi.set(__self__, "sts_url", sts_url)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Domain name of the endpoint.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="iamUrl")
    def iam_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL for IAM.
        """
        return pulumi.get(self, "iam_url")

    @iam_url.setter
    def iam_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "iam_url", value)

    @property
    @pulumi.getter(name="stsUrl")
    def sts_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL for STS.
        """
        return pulumi.get(self, "sts_url")

    @sts_url.setter
    def sts_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sts_url", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the endpoint (`private` / `public`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManagedObjectStorageNetworkArgsDict(TypedDict):
        family: pulumi.Input[builtins.str]
        """
        Network family. IPv6 currently not supported.
        """
        name: pulumi.Input[builtins.str]
        """
        Network name. Must be unique within the service.
        """
        type: pulumi.Input[builtins.str]
        """
        Network type.
        """
        uuid: NotRequired[pulumi.Input[builtins.str]]
        """
        Private network uuid. For public networks the field should be omitted.
        """
elif False:
    ManagedObjectStorageNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedObjectStorageNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 uuid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] family: Network family. IPv6 currently not supported.
        :param pulumi.Input[builtins.str] name: Network name. Must be unique within the service.
        :param pulumi.Input[builtins.str] type: Network type.
        :param pulumi.Input[builtins.str] uuid: Private network uuid. For public networks the field should be omitted.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        Network family. IPv6 currently not supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Network name. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Network type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Private network uuid. For public networks the field should be omitted.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkIpNetworkArgsDict(TypedDict):
        address: pulumi.Input[builtins.str]
        """
        The CIDR range of the subnet
        """
        dhcp: pulumi.Input[builtins.bool]
        """
        Is DHCP enabled?
        """
        family: pulumi.Input[builtins.str]
        """
        IP address family
        """
        dhcp_default_route: NotRequired[pulumi.Input[builtins.bool]]
        """
        Is the gateway the DHCP default route?
        """
        dhcp_dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The DNS servers given by DHCP
        """
        dhcp_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The additional DHCP classless static routes given by DHCP
        """
        gateway: NotRequired[pulumi.Input[builtins.str]]
        """
        Gateway address given by DHCP
        """
elif False:
    NetworkIpNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIpNetworkArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 dhcp: pulumi.Input[builtins.bool],
                 family: pulumi.Input[builtins.str],
                 dhcp_default_route: Optional[pulumi.Input[builtins.bool]] = None,
                 dhcp_dns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 dhcp_routes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 gateway: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] address: The CIDR range of the subnet
        :param pulumi.Input[builtins.bool] dhcp: Is DHCP enabled?
        :param pulumi.Input[builtins.str] family: IP address family
        :param pulumi.Input[builtins.bool] dhcp_default_route: Is the gateway the DHCP default route?
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dhcp_dns: The DNS servers given by DHCP
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dhcp_routes: The additional DHCP classless static routes given by DHCP
        :param pulumi.Input[builtins.str] gateway: Gateway address given by DHCP
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "family", family)
        if dhcp_default_route is not None:
            pulumi.set(__self__, "dhcp_default_route", dhcp_default_route)
        if dhcp_dns is not None:
            pulumi.set(__self__, "dhcp_dns", dhcp_dns)
        if dhcp_routes is not None:
            pulumi.set(__self__, "dhcp_routes", dhcp_routes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        """
        The CIDR range of the subnet
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def dhcp(self) -> pulumi.Input[builtins.bool]:
        """
        Is DHCP enabled?
        """
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        IP address family
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter(name="dhcpDefaultRoute")
    def dhcp_default_route(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is the gateway the DHCP default route?
        """
        return pulumi.get(self, "dhcp_default_route")

    @dhcp_default_route.setter
    def dhcp_default_route(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "dhcp_default_route", value)

    @property
    @pulumi.getter(name="dhcpDns")
    def dhcp_dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The DNS servers given by DHCP
        """
        return pulumi.get(self, "dhcp_dns")

    @dhcp_dns.setter
    def dhcp_dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dhcp_dns", value)

    @property
    @pulumi.getter(name="dhcpRoutes")
    def dhcp_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The additional DHCP classless static routes given by DHCP
        """
        return pulumi.get(self, "dhcp_routes")

    @dhcp_routes.setter
    def dhcp_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dhcp_routes", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Gateway address given by DHCP
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gateway", value)


if not MYPY:
    class NetworkPeeringNetworkArgsDict(TypedDict):
        uuid: pulumi.Input[builtins.str]
        """
        The UUID of the network.
        """
elif False:
    NetworkPeeringNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPeeringNetworkArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] uuid: The UUID of the network.
        """
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[builtins.str]:
        """
        The UUID of the network.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkPeeringPeerNetworkArgsDict(TypedDict):
        uuid: pulumi.Input[builtins.str]
        """
        The UUID of the network.
        """
elif False:
    NetworkPeeringPeerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPeeringPeerNetworkArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] uuid: The UUID of the network.
        """
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[builtins.str]:
        """
        The UUID of the network.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ObjectStorageBucketArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the bucket
        """
elif False:
    ObjectStorageBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectStorageBucketArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: The name of the bucket
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the bucket
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RouterStaticRouteArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        nexthop: pulumi.Input[builtins.str]
        route: pulumi.Input[builtins.str]
        type: pulumi.Input[builtins.str]
elif False:
    RouterStaticRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterStaticRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 nexthop: pulumi.Input[builtins.str],
                 route: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nexthop", nexthop)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nexthop(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "nexthop", value)

    @property
    @pulumi.getter
    def route(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerFirewallRulesFirewallRuleArgsDict(TypedDict):
        action: pulumi.Input[builtins.str]
        """
        Action to take if the rule conditions are met. Valid values `accept | drop`
        """
        direction: pulumi.Input[builtins.str]
        """
        The direction of network traffic this rule will be applied to
        """
        comment: NotRequired[pulumi.Input[builtins.str]]
        """
        Freeform comment string for the rule
        """
        destination_address_end: NotRequired[pulumi.Input[builtins.str]]
        """
        The destination address range ends from this address
        """
        destination_address_start: NotRequired[pulumi.Input[builtins.str]]
        """
        The destination address range starts from this address
        """
        destination_port_end: NotRequired[pulumi.Input[builtins.str]]
        """
        The destination port range ends from this port number
        """
        destination_port_start: NotRequired[pulumi.Input[builtins.str]]
        """
        The destination port range starts from this port number
        """
        family: NotRequired[pulumi.Input[builtins.str]]
        """
        The address family of new firewall rule
        """
        icmp_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The ICMP type
        """
        protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The protocol this rule will be applied to
        """
        source_address_end: NotRequired[pulumi.Input[builtins.str]]
        """
        The source address range ends from this address
        """
        source_address_start: NotRequired[pulumi.Input[builtins.str]]
        """
        The source address range starts from this address
        """
        source_port_end: NotRequired[pulumi.Input[builtins.str]]
        """
        The source port range ends from this port number
        """
        source_port_start: NotRequired[pulumi.Input[builtins.str]]
        """
        The source port range starts from this port number
        """
elif False:
    ServerFirewallRulesFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerFirewallRulesFirewallRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[builtins.str],
                 direction: pulumi.Input[builtins.str],
                 comment: Optional[pulumi.Input[builtins.str]] = None,
                 destination_address_end: Optional[pulumi.Input[builtins.str]] = None,
                 destination_address_start: Optional[pulumi.Input[builtins.str]] = None,
                 destination_port_end: Optional[pulumi.Input[builtins.str]] = None,
                 destination_port_start: Optional[pulumi.Input[builtins.str]] = None,
                 family: Optional[pulumi.Input[builtins.str]] = None,
                 icmp_type: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 source_address_end: Optional[pulumi.Input[builtins.str]] = None,
                 source_address_start: Optional[pulumi.Input[builtins.str]] = None,
                 source_port_end: Optional[pulumi.Input[builtins.str]] = None,
                 source_port_start: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] action: Action to take if the rule conditions are met. Valid values `accept | drop`
        :param pulumi.Input[builtins.str] direction: The direction of network traffic this rule will be applied to
        :param pulumi.Input[builtins.str] comment: Freeform comment string for the rule
        :param pulumi.Input[builtins.str] destination_address_end: The destination address range ends from this address
        :param pulumi.Input[builtins.str] destination_address_start: The destination address range starts from this address
        :param pulumi.Input[builtins.str] destination_port_end: The destination port range ends from this port number
        :param pulumi.Input[builtins.str] destination_port_start: The destination port range starts from this port number
        :param pulumi.Input[builtins.str] family: The address family of new firewall rule
        :param pulumi.Input[builtins.str] icmp_type: The ICMP type
        :param pulumi.Input[builtins.str] protocol: The protocol this rule will be applied to
        :param pulumi.Input[builtins.str] source_address_end: The source address range ends from this address
        :param pulumi.Input[builtins.str] source_address_start: The source address range starts from this address
        :param pulumi.Input[builtins.str] source_port_end: The source port range ends from this port number
        :param pulumi.Input[builtins.str] source_port_start: The source port range starts from this port number
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "direction", direction)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if destination_address_end is not None:
            pulumi.set(__self__, "destination_address_end", destination_address_end)
        if destination_address_start is not None:
            pulumi.set(__self__, "destination_address_start", destination_address_start)
        if destination_port_end is not None:
            pulumi.set(__self__, "destination_port_end", destination_port_end)
        if destination_port_start is not None:
            pulumi.set(__self__, "destination_port_start", destination_port_start)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_address_end is not None:
            pulumi.set(__self__, "source_address_end", source_address_end)
        if source_address_start is not None:
            pulumi.set(__self__, "source_address_start", source_address_start)
        if source_port_end is not None:
            pulumi.set(__self__, "source_port_end", source_port_end)
        if source_port_start is not None:
            pulumi.set(__self__, "source_port_start", source_port_start)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[builtins.str]:
        """
        Action to take if the rule conditions are met. Valid values `accept | drop`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[builtins.str]:
        """
        The direction of network traffic this rule will be applied to
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Freeform comment string for the rule
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="destinationAddressEnd")
    def destination_address_end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The destination address range ends from this address
        """
        return pulumi.get(self, "destination_address_end")

    @destination_address_end.setter
    def destination_address_end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_address_end", value)

    @property
    @pulumi.getter(name="destinationAddressStart")
    def destination_address_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The destination address range starts from this address
        """
        return pulumi.get(self, "destination_address_start")

    @destination_address_start.setter
    def destination_address_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_address_start", value)

    @property
    @pulumi.getter(name="destinationPortEnd")
    def destination_port_end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The destination port range ends from this port number
        """
        return pulumi.get(self, "destination_port_end")

    @destination_port_end.setter
    def destination_port_end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_port_end", value)

    @property
    @pulumi.getter(name="destinationPortStart")
    def destination_port_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The destination port range starts from this port number
        """
        return pulumi.get(self, "destination_port_start")

    @destination_port_start.setter
    def destination_port_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_port_start", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The address family of new firewall rule
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ICMP type
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The protocol this rule will be applied to
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sourceAddressEnd")
    def source_address_end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The source address range ends from this address
        """
        return pulumi.get(self, "source_address_end")

    @source_address_end.setter
    def source_address_end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_address_end", value)

    @property
    @pulumi.getter(name="sourceAddressStart")
    def source_address_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The source address range starts from this address
        """
        return pulumi.get(self, "source_address_start")

    @source_address_start.setter
    def source_address_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_address_start", value)

    @property
    @pulumi.getter(name="sourcePortEnd")
    def source_port_end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The source port range ends from this port number
        """
        return pulumi.get(self, "source_port_end")

    @source_port_end.setter
    def source_port_end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_port_end", value)

    @property
    @pulumi.getter(name="sourcePortStart")
    def source_port_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The source port range starts from this port number
        """
        return pulumi.get(self, "source_port_start")

    @source_port_start.setter
    def source_port_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_port_start", value)


if not MYPY:
    class ServerLoginArgsDict(TypedDict):
        create_password: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates a password should be create to allow access
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of ssh keys to access the server
        """
        password_delivery: NotRequired[pulumi.Input[builtins.str]]
        """
        The delivery method for the server's root password (one of `none`, `email` or `sms`)
        """
        user: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to be create to access the server
        """
elif False:
    ServerLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerLoginArgs:
    def __init__(__self__, *,
                 create_password: Optional[pulumi.Input[builtins.bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 password_delivery: Optional[pulumi.Input[builtins.str]] = None,
                 user: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] create_password: Indicates a password should be create to allow access
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] keys: A list of ssh keys to access the server
        :param pulumi.Input[builtins.str] password_delivery: The delivery method for the server's root password (one of `none`, `email` or `sms`)
        :param pulumi.Input[builtins.str] user: Username to be create to access the server
        """
        if create_password is not None:
            pulumi.set(__self__, "create_password", create_password)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if password_delivery is not None:
            pulumi.set(__self__, "password_delivery", password_delivery)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="createPassword")
    def create_password(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates a password should be create to allow access
        """
        return pulumi.get(self, "create_password")

    @create_password.setter
    def create_password(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "create_password", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of ssh keys to access the server
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="passwordDelivery")
    def password_delivery(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The delivery method for the server's root password (one of `none`, `email` or `sms`)
        """
        return pulumi.get(self, "password_delivery")

    @password_delivery.setter
    def password_delivery(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password_delivery", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to be create to access the server
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServerNetworkInterfaceArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Network interface type. For private network interfaces, a network must be specified with an existing network id.
        """
        additional_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgsDict']]]]
        """
        0-31 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`
        """
        bootable: NotRequired[pulumi.Input[builtins.bool]]
        """
        `true` if this interface should be used for network booting.
        """
        index: NotRequired[pulumi.Input[builtins.int]]
        """
        The interface index.
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The primary IP address of this interface.
        """
        ip_address_family: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).
        """
        ip_address_floating: NotRequired[pulumi.Input[builtins.bool]]
        """
        `true` indicates that the primary IP address is a floating IP address.
        """
        mac_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The MAC address of the interface.
        """
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        The UUID of the network to attach this interface to. Required for private network interfaces.
        """
        source_ip_filtering: NotRequired[pulumi.Input[builtins.bool]]
        """
        `true` if source IP should be filtered.
        """
elif False:
    ServerNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerNetworkInterfaceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 additional_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgs']]]] = None,
                 bootable: Optional[pulumi.Input[builtins.bool]] = None,
                 index: Optional[pulumi.Input[builtins.int]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address_family: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address_floating: Optional[pulumi.Input[builtins.bool]] = None,
                 mac_address: Optional[pulumi.Input[builtins.str]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 source_ip_filtering: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] type: Network interface type. For private network interfaces, a network must be specified with an existing network id.
        :param pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgs']]] additional_ip_addresses: 0-31 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`
        :param pulumi.Input[builtins.bool] bootable: `true` if this interface should be used for network booting.
        :param pulumi.Input[builtins.int] index: The interface index.
        :param pulumi.Input[builtins.str] ip_address: The primary IP address of this interface.
        :param pulumi.Input[builtins.str] ip_address_family: The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).
        :param pulumi.Input[builtins.bool] ip_address_floating: `true` indicates that the primary IP address is a floating IP address.
        :param pulumi.Input[builtins.str] mac_address: The MAC address of the interface.
        :param pulumi.Input[builtins.str] network: The UUID of the network to attach this interface to. Required for private network interfaces.
        :param pulumi.Input[builtins.bool] source_ip_filtering: `true` if source IP should be filtered.
        """
        pulumi.set(__self__, "type", type)
        if additional_ip_addresses is not None:
            pulumi.set(__self__, "additional_ip_addresses", additional_ip_addresses)
        if bootable is not None:
            pulumi.set(__self__, "bootable", bootable)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_address_family is not None:
            pulumi.set(__self__, "ip_address_family", ip_address_family)
        if ip_address_floating is not None:
            pulumi.set(__self__, "ip_address_floating", ip_address_floating)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip_filtering is not None:
            pulumi.set(__self__, "source_ip_filtering", source_ip_filtering)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Network interface type. For private network interfaces, a network must be specified with an existing network id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalIpAddresses")
    def additional_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgs']]]]:
        """
        0-31 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`
        """
        return pulumi.get(self, "additional_ip_addresses")

    @additional_ip_addresses.setter
    def additional_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgs']]]]):
        pulumi.set(self, "additional_ip_addresses", value)

    @property
    @pulumi.getter
    def bootable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        `true` if this interface should be used for network booting.
        """
        return pulumi.get(self, "bootable")

    @bootable.setter
    def bootable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "bootable", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The interface index.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The primary IP address of this interface.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipAddressFamily")
    def ip_address_family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).
        """
        return pulumi.get(self, "ip_address_family")

    @ip_address_family.setter
    def ip_address_family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address_family", value)

    @property
    @pulumi.getter(name="ipAddressFloating")
    def ip_address_floating(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        `true` indicates that the primary IP address is a floating IP address.
        """
        return pulumi.get(self, "ip_address_floating")

    @ip_address_floating.setter
    def ip_address_floating(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ip_address_floating", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The MAC address of the interface.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The UUID of the network to attach this interface to. Required for private network interfaces.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="sourceIpFiltering")
    def source_ip_filtering(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        `true` if source IP should be filtered.
        """
        return pulumi.get(self, "source_ip_filtering")

    @source_ip_filtering.setter
    def source_ip_filtering(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "source_ip_filtering", value)


if not MYPY:
    class ServerNetworkInterfaceAdditionalIpAddressArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        An additional IP address for this interface.
        """
        ip_address_family: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the additional IP address of this interface (one of `IPv4` or `IPv6`).
        """
        ip_address_floating: NotRequired[pulumi.Input[builtins.bool]]
        """
        `true` indicates that the additional IP address is a floating IP address.
        """
elif False:
    ServerNetworkInterfaceAdditionalIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerNetworkInterfaceAdditionalIpAddressArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address_family: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address_floating: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] ip_address: An additional IP address for this interface.
        :param pulumi.Input[builtins.str] ip_address_family: The type of the additional IP address of this interface (one of `IPv4` or `IPv6`).
        :param pulumi.Input[builtins.bool] ip_address_floating: `true` indicates that the additional IP address is a floating IP address.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_address_family is not None:
            pulumi.set(__self__, "ip_address_family", ip_address_family)
        if ip_address_floating is not None:
            pulumi.set(__self__, "ip_address_floating", ip_address_floating)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An additional IP address for this interface.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipAddressFamily")
    def ip_address_family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the additional IP address of this interface (one of `IPv4` or `IPv6`).
        """
        return pulumi.get(self, "ip_address_family")

    @ip_address_family.setter
    def ip_address_family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address_family", value)

    @property
    @pulumi.getter(name="ipAddressFloating")
    def ip_address_floating(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        `true` indicates that the additional IP address is a floating IP address.
        """
        return pulumi.get(self, "ip_address_floating")

    @ip_address_floating.setter
    def ip_address_floating(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ip_address_floating", value)


if not MYPY:
    class ServerSimpleBackupArgsDict(TypedDict):
        plan: NotRequired[pulumi.Input[builtins.str]]
        """
        Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.
        """
        time: NotRequired[pulumi.Input[builtins.str]]
        """
        Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).
        """
elif False:
    ServerSimpleBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerSimpleBackupArgs:
    def __init__(__self__, *,
                 plan: Optional[pulumi.Input[builtins.str]] = None,
                 time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] plan: Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.
        :param pulumi.Input[builtins.str] time: Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).
        """
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def plan(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class ServerStorageDeviceArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[builtins.str]]
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        address_position: NotRequired[pulumi.Input[builtins.str]]
        """
        The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.
        """
        storage: NotRequired[pulumi.Input[builtins.str]]
        """
        The UUID of the storage to attach to the server.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The device type the storage will be attached as
        """
elif False:
    ServerStorageDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerStorageDeviceArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[builtins.str]] = None,
                 address_position: Optional[pulumi.Input[builtins.str]] = None,
                 storage: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] address: The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        :param pulumi.Input[builtins.str] address_position: The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.
        :param pulumi.Input[builtins.str] storage: The UUID of the storage to attach to the server.
        :param pulumi.Input[builtins.str] type: The device type the storage will be attached as
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_position is not None:
            pulumi.set(__self__, "address_position", address_position)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="addressPosition")
    def address_position(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.
        """
        return pulumi.get(self, "address_position")

    @address_position.setter
    def address_position(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address_position", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The UUID of the storage to attach to the server.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The device type the storage will be attached as
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerTemplateArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[builtins.str]]
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        address_position: NotRequired[pulumi.Input[builtins.str]]
        """
        The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.
        """
        backup_rule: NotRequired[pulumi.Input['ServerTemplateBackupRuleArgsDict']]
        delete_autoresize_backup: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
        """
        encrypt: NotRequired[pulumi.Input[builtins.bool]]
        """
        Sets if the storage is encrypted at rest
        """
        filesystem_autoresize: NotRequired[pulumi.Input[builtins.bool]]
        """
        If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.
        							Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used
        							to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).
        							Taking and keeping backups incure costs.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The unique identifier for the storage
        """
        size: NotRequired[pulumi.Input[builtins.int]]
        """
        The size of the storage in gigabytes
        """
        storage: NotRequired[pulumi.Input[builtins.str]]
        """
        A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.
        """
        tier: NotRequired[pulumi.Input[builtins.str]]
        """
        The storage tier to use.
        """
        title: NotRequired[pulumi.Input[builtins.str]]
        """
        A short, informative description
        """
elif False:
    ServerTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTemplateArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[builtins.str]] = None,
                 address_position: Optional[pulumi.Input[builtins.str]] = None,
                 backup_rule: Optional[pulumi.Input['ServerTemplateBackupRuleArgs']] = None,
                 delete_autoresize_backup: Optional[pulumi.Input[builtins.bool]] = None,
                 encrypt: Optional[pulumi.Input[builtins.bool]] = None,
                 filesystem_autoresize: Optional[pulumi.Input[builtins.bool]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None,
                 storage: Optional[pulumi.Input[builtins.str]] = None,
                 tier: Optional[pulumi.Input[builtins.str]] = None,
                 title: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] address: The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        :param pulumi.Input[builtins.str] address_position: The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.
        :param pulumi.Input[builtins.bool] delete_autoresize_backup: If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
        :param pulumi.Input[builtins.bool] encrypt: Sets if the storage is encrypted at rest
        :param pulumi.Input[builtins.bool] filesystem_autoresize: If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.
               							Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used
               							to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).
               							Taking and keeping backups incure costs.
        :param pulumi.Input[builtins.str] id: The unique identifier for the storage
        :param pulumi.Input[builtins.int] size: The size of the storage in gigabytes
        :param pulumi.Input[builtins.str] storage: A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.
        :param pulumi.Input[builtins.str] tier: The storage tier to use.
        :param pulumi.Input[builtins.str] title: A short, informative description
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_position is not None:
            pulumi.set(__self__, "address_position", address_position)
        if backup_rule is not None:
            pulumi.set(__self__, "backup_rule", backup_rule)
        if delete_autoresize_backup is not None:
            pulumi.set(__self__, "delete_autoresize_backup", delete_autoresize_backup)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if filesystem_autoresize is not None:
            pulumi.set(__self__, "filesystem_autoresize", filesystem_autoresize)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="addressPosition")
    def address_position(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.
        """
        return pulumi.get(self, "address_position")

    @address_position.setter
    def address_position(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address_position", value)

    @property
    @pulumi.getter(name="backupRule")
    def backup_rule(self) -> Optional[pulumi.Input['ServerTemplateBackupRuleArgs']]:
        return pulumi.get(self, "backup_rule")

    @backup_rule.setter
    def backup_rule(self, value: Optional[pulumi.Input['ServerTemplateBackupRuleArgs']]):
        pulumi.set(self, "backup_rule", value)

    @property
    @pulumi.getter(name="deleteAutoresizeBackup")
    def delete_autoresize_backup(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
        """
        return pulumi.get(self, "delete_autoresize_backup")

    @delete_autoresize_backup.setter
    def delete_autoresize_backup(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "delete_autoresize_backup", value)

    @property
    @pulumi.getter
    def encrypt(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Sets if the storage is encrypted at rest
        """
        return pulumi.get(self, "encrypt")

    @encrypt.setter
    def encrypt(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "encrypt", value)

    @property
    @pulumi.getter(name="filesystemAutoresize")
    def filesystem_autoresize(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.
        							Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used
        							to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).
        							Taking and keeping backups incure costs.
        """
        return pulumi.get(self, "filesystem_autoresize")

    @filesystem_autoresize.setter
    def filesystem_autoresize(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "filesystem_autoresize", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The unique identifier for the storage
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The size of the storage in gigabytes
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The storage tier to use.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A short, informative description
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ServerTemplateBackupRuleArgsDict(TypedDict):
        interval: pulumi.Input[builtins.str]
        """
        The weekday when the backup is created
        """
        retention: pulumi.Input[builtins.int]
        """
        The number of days before a backup is automatically deleted
        """
        time: pulumi.Input[builtins.str]
        """
        The time of day when the backup is created
        """
elif False:
    ServerTemplateBackupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTemplateBackupRuleArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[builtins.str],
                 retention: pulumi.Input[builtins.int],
                 time: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] interval: The weekday when the backup is created
        :param pulumi.Input[builtins.int] retention: The number of days before a backup is automatically deleted
        :param pulumi.Input[builtins.str] time: The time of day when the backup is created
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "retention", retention)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[builtins.str]:
        """
        The weekday when the backup is created
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def retention(self) -> pulumi.Input[builtins.int]:
        """
        The number of days before a backup is automatically deleted
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[builtins.str]:
        """
        The time of day when the backup is created
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class StorageBackupRuleArgsDict(TypedDict):
        interval: pulumi.Input[builtins.str]
        """
        The weekday when the backup is created
        """
        retention: pulumi.Input[builtins.int]
        """
        The number of days before a backup is automatically deleted
        """
        time: pulumi.Input[builtins.str]
        """
        The time of day when the backup is created
        """
elif False:
    StorageBackupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBackupRuleArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[builtins.str],
                 retention: pulumi.Input[builtins.int],
                 time: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] interval: The weekday when the backup is created
        :param pulumi.Input[builtins.int] retention: The number of days before a backup is automatically deleted
        :param pulumi.Input[builtins.str] time: The time of day when the backup is created
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "retention", retention)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[builtins.str]:
        """
        The weekday when the backup is created
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def retention(self) -> pulumi.Input[builtins.int]:
        """
        The number of days before a backup is automatically deleted
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[builtins.str]:
        """
        The time of day when the backup is created
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class StorageCloneArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The unique identifier of the storage/template to clone.
        """
elif False:
    StorageCloneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageCloneArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] id: The unique identifier of the storage/template to clone.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The unique identifier of the storage/template to clone.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class StorageImportArgsDict(TypedDict):
        source: pulumi.Input[builtins.str]
        """
        The mode of the import task. One of `http_import` or `direct_upload`.
        """
        source_location: pulumi.Input[builtins.str]
        """
        The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).
        """
        sha256sum: NotRequired[pulumi.Input[builtins.str]]
        """
        sha256 sum of the imported data
        """
        source_hash: NotRequired[pulumi.Input[builtins.str]]
        """
        SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.
        """
        written_bytes: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of bytes imported
        """
elif False:
    StorageImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageImportArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[builtins.str],
                 source_location: pulumi.Input[builtins.str],
                 sha256sum: Optional[pulumi.Input[builtins.str]] = None,
                 source_hash: Optional[pulumi.Input[builtins.str]] = None,
                 written_bytes: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] source: The mode of the import task. One of `http_import` or `direct_upload`.
        :param pulumi.Input[builtins.str] source_location: The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).
        :param pulumi.Input[builtins.str] sha256sum: sha256 sum of the imported data
        :param pulumi.Input[builtins.str] source_hash: SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.
        :param pulumi.Input[builtins.int] written_bytes: Number of bytes imported
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_location", source_location)
        if sha256sum is not None:
            pulumi.set(__self__, "sha256sum", sha256sum)
        if source_hash is not None:
            pulumi.set(__self__, "source_hash", source_hash)
        if written_bytes is not None:
            pulumi.set(__self__, "written_bytes", written_bytes)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[builtins.str]:
        """
        The mode of the import task. One of `http_import` or `direct_upload`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourceLocation")
    def source_location(self) -> pulumi.Input[builtins.str]:
        """
        The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).
        """
        return pulumi.get(self, "source_location")

    @source_location.setter
    def source_location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_location", value)

    @property
    @pulumi.getter
    def sha256sum(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        sha256 sum of the imported data
        """
        return pulumi.get(self, "sha256sum")

    @sha256sum.setter
    def sha256sum(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sha256sum", value)

    @property
    @pulumi.getter(name="sourceHash")
    def source_hash(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.
        """
        return pulumi.get(self, "source_hash")

    @source_hash.setter
    def source_hash(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_hash", value)

    @property
    @pulumi.getter(name="writtenBytes")
    def written_bytes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of bytes imported
        """
        return pulumi.get(self, "written_bytes")

    @written_bytes.setter
    def written_bytes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "written_bytes", value)


if not MYPY:
    class GetHostsHostArgsDict(TypedDict):
        description: builtins.str
        """
        Free form text describing the host
        """
        host_id: builtins.int
        """
        The unique id of the host
        """
        windows_enabled: builtins.bool
        """
        If true, this node can be used as a host for Windows servers.
        """
        zone: builtins.str
        """
        The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        statistics: NotRequired[Sequence['GetHostsHostStatisticArgsDict']]
elif False:
    GetHostsHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHostsHostArgs:
    def __init__(__self__, *,
                 description: builtins.str,
                 host_id: builtins.int,
                 windows_enabled: builtins.bool,
                 zone: builtins.str,
                 statistics: Optional[Sequence['GetHostsHostStatisticArgs']] = None):
        """
        :param builtins.str description: Free form text describing the host
        :param builtins.int host_id: The unique id of the host
        :param builtins.bool windows_enabled: If true, this node can be used as a host for Windows servers.
        :param builtins.str zone: The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host_id", host_id)
        pulumi.set(__self__, "windows_enabled", windows_enabled)
        pulumi.set(__self__, "zone", zone)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Free form text describing the host
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: builtins.str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> builtins.int:
        """
        The unique id of the host
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: builtins.int):
        pulumi.set(self, "host_id", value)

    @property
    @pulumi.getter(name="windowsEnabled")
    def windows_enabled(self) -> builtins.bool:
        """
        If true, this node can be used as a host for Windows servers.
        """
        return pulumi.get(self, "windows_enabled")

    @windows_enabled.setter
    def windows_enabled(self, value: builtins.bool):
        pulumi.set(self, "windows_enabled", value)

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        """
        The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: builtins.str):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter
    def statistics(self) -> Optional[Sequence['GetHostsHostStatisticArgs']]:
        return pulumi.get(self, "statistics")

    @statistics.setter
    def statistics(self, value: Optional[Sequence['GetHostsHostStatisticArgs']]):
        pulumi.set(self, "statistics", value)


if not MYPY:
    class GetHostsHostStatisticArgsDict(TypedDict):
        name: builtins.str
        """
        The name of the statistic
        """
        timestamp: builtins.str
        """
        The timestamp of the statistic
        """
        value: builtins.float
        """
        The value of the statistic
        """
elif False:
    GetHostsHostStatisticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHostsHostStatisticArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 timestamp: builtins.str,
                 value: builtins.float):
        """
        :param builtins.str name: The name of the statistic
        :param builtins.str timestamp: The timestamp of the statistic
        :param builtins.float value: The value of the statistic
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the statistic
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def timestamp(self) -> builtins.str:
        """
        The timestamp of the statistic
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: builtins.str):
        pulumi.set(self, "timestamp", value)

    @property
    @pulumi.getter
    def value(self) -> builtins.float:
        """
        The value of the statistic
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: builtins.float):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetIpAddressesAddressArgsDict(TypedDict):
        access: builtins.str
        """
        Is address for utility or public network
        """
        address: builtins.str
        """
        An UpCloud assigned IP Address
        """
        family: builtins.str
        """
        IP address family
        """
        floating: builtins.bool
        """
        Does the IP Address represents a floating IP Address
        """
        mac: builtins.str
        """
        MAC address of server interface to assign address to
        """
        part_of_plan: builtins.bool
        """
        Is the address a part of a plan
        """
        ptr_record: builtins.str
        """
        A reverse DNS record entry
        """
        server: builtins.str
        """
        The unique identifier for a server
        """
        zone: builtins.str
        """
        Zone of address, required when assigning a detached floating IP address, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
elif False:
    GetIpAddressesAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIpAddressesAddressArgs:
    def __init__(__self__, *,
                 access: builtins.str,
                 address: builtins.str,
                 family: builtins.str,
                 floating: builtins.bool,
                 mac: builtins.str,
                 part_of_plan: builtins.bool,
                 ptr_record: builtins.str,
                 server: builtins.str,
                 zone: builtins.str):
        """
        :param builtins.str access: Is address for utility or public network
        :param builtins.str address: An UpCloud assigned IP Address
        :param builtins.str family: IP address family
        :param builtins.bool floating: Does the IP Address represents a floating IP Address
        :param builtins.str mac: MAC address of server interface to assign address to
        :param builtins.bool part_of_plan: Is the address a part of a plan
        :param builtins.str ptr_record: A reverse DNS record entry
        :param builtins.str server: The unique identifier for a server
        :param builtins.str zone: Zone of address, required when assigning a detached floating IP address, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "floating", floating)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "part_of_plan", part_of_plan)
        pulumi.set(__self__, "ptr_record", ptr_record)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def access(self) -> builtins.str:
        """
        Is address for utility or public network
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: builtins.str):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        An UpCloud assigned IP Address
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: builtins.str):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def family(self) -> builtins.str:
        """
        IP address family
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: builtins.str):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def floating(self) -> builtins.bool:
        """
        Does the IP Address represents a floating IP Address
        """
        return pulumi.get(self, "floating")

    @floating.setter
    def floating(self, value: builtins.bool):
        pulumi.set(self, "floating", value)

    @property
    @pulumi.getter
    def mac(self) -> builtins.str:
        """
        MAC address of server interface to assign address to
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: builtins.str):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter(name="partOfPlan")
    def part_of_plan(self) -> builtins.bool:
        """
        Is the address a part of a plan
        """
        return pulumi.get(self, "part_of_plan")

    @part_of_plan.setter
    def part_of_plan(self, value: builtins.bool):
        pulumi.set(self, "part_of_plan", value)

    @property
    @pulumi.getter(name="ptrRecord")
    def ptr_record(self) -> builtins.str:
        """
        A reverse DNS record entry
        """
        return pulumi.get(self, "ptr_record")

    @ptr_record.setter
    def ptr_record(self, value: builtins.str):
        pulumi.set(self, "ptr_record", value)

    @property
    @pulumi.getter
    def server(self) -> builtins.str:
        """
        The unique identifier for a server
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: builtins.str):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        """
        Zone of address, required when assigning a detached floating IP address, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: builtins.str):
        pulumi.set(self, "zone", value)


if not MYPY:
    class GetManagedDatabaseMysqlSessionsSessionArgsDict(TypedDict):
        application_name: builtins.str
        """
        Name of the application that is connected to this service.
        """
        client_addr: builtins.str
        """
        IP address of the client connected to this service.
        """
        datname: builtins.str
        """
        Name of the database this service is connected to.
        """
        id: builtins.str
        """
        Process ID of this service.
        """
        query: builtins.str
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.
        """
        query_duration: builtins.str
        """
        The active query current duration.
        """
        state: builtins.str
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        usename: builtins.str
        """
        Name of the user logged into this service.
        """
elif False:
    GetManagedDatabaseMysqlSessionsSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabaseMysqlSessionsSessionArgs:
    def __init__(__self__, *,
                 application_name: builtins.str,
                 client_addr: builtins.str,
                 datname: builtins.str,
                 id: builtins.str,
                 query: builtins.str,
                 query_duration: builtins.str,
                 state: builtins.str,
                 usename: builtins.str):
        """
        :param builtins.str application_name: Name of the application that is connected to this service.
        :param builtins.str client_addr: IP address of the client connected to this service.
        :param builtins.str datname: Name of the database this service is connected to.
        :param builtins.str id: Process ID of this service.
        :param builtins.str query: Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.
        :param builtins.str query_duration: The active query current duration.
        :param builtins.str state: Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        :param builtins.str usename: Name of the user logged into this service.
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "datname", datname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_duration", query_duration)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "usename", usename)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> builtins.str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: builtins.str):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> builtins.str:
        """
        IP address of the client connected to this service.
        """
        return pulumi.get(self, "client_addr")

    @client_addr.setter
    def client_addr(self, value: builtins.str):
        pulumi.set(self, "client_addr", value)

    @property
    @pulumi.getter
    def datname(self) -> builtins.str:
        """
        Name of the database this service is connected to.
        """
        return pulumi.get(self, "datname")

    @datname.setter
    def datname(self, value: builtins.str):
        pulumi.set(self, "datname", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Process ID of this service.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: builtins.str):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryDuration")
    def query_duration(self) -> builtins.str:
        """
        The active query current duration.
        """
        return pulumi.get(self, "query_duration")

    @query_duration.setter
    def query_duration(self, value: builtins.str):
        pulumi.set(self, "query_duration", value)

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: builtins.str):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def usename(self) -> builtins.str:
        """
        Name of the user logged into this service.
        """
        return pulumi.get(self, "usename")

    @usename.setter
    def usename(self, value: builtins.str):
        pulumi.set(self, "usename", value)


if not MYPY:
    class GetManagedDatabaseOpensearchIndicesIndexArgsDict(TypedDict):
        create_time: builtins.str
        """
        Timestamp indicating the creation time of the index.
        """
        docs: builtins.int
        """
        Number of documents stored in the index.
        """
        health: builtins.str
        """
        Health status of the index e.g. `green`, `yellow`, or `red`.
        """
        index_name: builtins.str
        """
        Name of the index.
        """
        number_of_replicas: builtins.int
        """
        Number of replicas configured for the index.
        """
        number_of_shards: builtins.int
        """
        Number of shards configured & used by the index.
        """
        read_only_allow_delete: builtins.bool
        """
        Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.
        """
        size: builtins.int
        """
        Size of the index in bytes.
        """
        status: builtins.str
        """
        Status of the index e.g. `open` or `closed`.
        """
elif False:
    GetManagedDatabaseOpensearchIndicesIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabaseOpensearchIndicesIndexArgs:
    def __init__(__self__, *,
                 create_time: builtins.str,
                 docs: builtins.int,
                 health: builtins.str,
                 index_name: builtins.str,
                 number_of_replicas: builtins.int,
                 number_of_shards: builtins.int,
                 read_only_allow_delete: builtins.bool,
                 size: builtins.int,
                 status: builtins.str):
        """
        :param builtins.str create_time: Timestamp indicating the creation time of the index.
        :param builtins.int docs: Number of documents stored in the index.
        :param builtins.str health: Health status of the index e.g. `green`, `yellow`, or `red`.
        :param builtins.str index_name: Name of the index.
        :param builtins.int number_of_replicas: Number of replicas configured for the index.
        :param builtins.int number_of_shards: Number of shards configured & used by the index.
        :param builtins.bool read_only_allow_delete: Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.
        :param builtins.int size: Size of the index in bytes.
        :param builtins.str status: Status of the index e.g. `open` or `closed`.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "docs", docs)
        pulumi.set(__self__, "health", health)
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        pulumi.set(__self__, "number_of_shards", number_of_shards)
        pulumi.set(__self__, "read_only_allow_delete", read_only_allow_delete)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> builtins.str:
        """
        Timestamp indicating the creation time of the index.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: builtins.str):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter
    def docs(self) -> builtins.int:
        """
        Number of documents stored in the index.
        """
        return pulumi.get(self, "docs")

    @docs.setter
    def docs(self, value: builtins.int):
        pulumi.set(self, "docs", value)

    @property
    @pulumi.getter
    def health(self) -> builtins.str:
        """
        Health status of the index e.g. `green`, `yellow`, or `red`.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: builtins.str):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> builtins.str:
        """
        Name of the index.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: builtins.str):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> builtins.int:
        """
        Number of replicas configured for the index.
        """
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: builtins.int):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> builtins.int:
        """
        Number of shards configured & used by the index.
        """
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: builtins.int):
        pulumi.set(self, "number_of_shards", value)

    @property
    @pulumi.getter(name="readOnlyAllowDelete")
    def read_only_allow_delete(self) -> builtins.bool:
        """
        Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.
        """
        return pulumi.get(self, "read_only_allow_delete")

    @read_only_allow_delete.setter
    def read_only_allow_delete(self, value: builtins.bool):
        pulumi.set(self, "read_only_allow_delete", value)

    @property
    @pulumi.getter
    def size(self) -> builtins.int:
        """
        Size of the index in bytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: builtins.int):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the index e.g. `open` or `closed`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: builtins.str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetManagedDatabasePostgresqlSessionsSessionArgsDict(TypedDict):
        application_name: builtins.str
        """
        Name of the application that is connected to this service.
        """
        backend_start: builtins.str
        """
        Time when this process was started, i.e., when the client connected to the server.
        """
        backend_type: builtins.str
        """
        Type of current service.
        """
        backend_xid: builtins.int
        """
        Top-level transaction identifier of this service, if any.
        """
        backend_xmin: builtins.int
        """
        The current service's xmin horizon.
        """
        client_addr: builtins.str
        """
        IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
        """
        client_hostname: builtins.str
        """
        Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.
        """
        client_port: builtins.int
        """
        TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.
        """
        datid: builtins.int
        """
        OID of the database this service is connected to.
        """
        datname: builtins.str
        """
        Name of the database this service is connected to.
        """
        id: builtins.str
        """
        Process ID of this service.
        """
        query: builtins.str
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
        """
        query_duration: builtins.str
        """
        The active query current duration.
        """
        query_start: builtins.str
        """
        Time when the currently active query was started, or if state is not active, when the last query was started.
        """
        state: builtins.str
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        state_change: builtins.str
        """
        Time when the state was last changed.
        """
        usename: builtins.str
        """
        Name of the user logged into this service.
        """
        usesysid: builtins.int
        """
        OID of the user logged into this service.
        """
        wait_event: builtins.str
        """
        Wait event name if service is currently waiting.
        """
        wait_event_type: builtins.str
        """
        The type of event for which the service is waiting, if any; otherwise NULL.
        """
        xact_start: builtins.str
        """
        Time when this process' current transaction was started, or null if no transaction is active.
        """
elif False:
    GetManagedDatabasePostgresqlSessionsSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabasePostgresqlSessionsSessionArgs:
    def __init__(__self__, *,
                 application_name: builtins.str,
                 backend_start: builtins.str,
                 backend_type: builtins.str,
                 backend_xid: builtins.int,
                 backend_xmin: builtins.int,
                 client_addr: builtins.str,
                 client_hostname: builtins.str,
                 client_port: builtins.int,
                 datid: builtins.int,
                 datname: builtins.str,
                 id: builtins.str,
                 query: builtins.str,
                 query_duration: builtins.str,
                 query_start: builtins.str,
                 state: builtins.str,
                 state_change: builtins.str,
                 usename: builtins.str,
                 usesysid: builtins.int,
                 wait_event: builtins.str,
                 wait_event_type: builtins.str,
                 xact_start: builtins.str):
        """
        :param builtins.str application_name: Name of the application that is connected to this service.
        :param builtins.str backend_start: Time when this process was started, i.e., when the client connected to the server.
        :param builtins.str backend_type: Type of current service.
        :param builtins.int backend_xid: Top-level transaction identifier of this service, if any.
        :param builtins.int backend_xmin: The current service's xmin horizon.
        :param builtins.str client_addr: IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
        :param builtins.str client_hostname: Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.
        :param builtins.int client_port: TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.
        :param builtins.int datid: OID of the database this service is connected to.
        :param builtins.str datname: Name of the database this service is connected to.
        :param builtins.str id: Process ID of this service.
        :param builtins.str query: Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
        :param builtins.str query_duration: The active query current duration.
        :param builtins.str query_start: Time when the currently active query was started, or if state is not active, when the last query was started.
        :param builtins.str state: Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        :param builtins.str state_change: Time when the state was last changed.
        :param builtins.str usename: Name of the user logged into this service.
        :param builtins.int usesysid: OID of the user logged into this service.
        :param builtins.str wait_event: Wait event name if service is currently waiting.
        :param builtins.str wait_event_type: The type of event for which the service is waiting, if any; otherwise NULL.
        :param builtins.str xact_start: Time when this process' current transaction was started, or null if no transaction is active.
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "backend_start", backend_start)
        pulumi.set(__self__, "backend_type", backend_type)
        pulumi.set(__self__, "backend_xid", backend_xid)
        pulumi.set(__self__, "backend_xmin", backend_xmin)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "client_hostname", client_hostname)
        pulumi.set(__self__, "client_port", client_port)
        pulumi.set(__self__, "datid", datid)
        pulumi.set(__self__, "datname", datname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_duration", query_duration)
        pulumi.set(__self__, "query_start", query_start)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_change", state_change)
        pulumi.set(__self__, "usename", usename)
        pulumi.set(__self__, "usesysid", usesysid)
        pulumi.set(__self__, "wait_event", wait_event)
        pulumi.set(__self__, "wait_event_type", wait_event_type)
        pulumi.set(__self__, "xact_start", xact_start)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> builtins.str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: builtins.str):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="backendStart")
    def backend_start(self) -> builtins.str:
        """
        Time when this process was started, i.e., when the client connected to the server.
        """
        return pulumi.get(self, "backend_start")

    @backend_start.setter
    def backend_start(self, value: builtins.str):
        pulumi.set(self, "backend_start", value)

    @property
    @pulumi.getter(name="backendType")
    def backend_type(self) -> builtins.str:
        """
        Type of current service.
        """
        return pulumi.get(self, "backend_type")

    @backend_type.setter
    def backend_type(self, value: builtins.str):
        pulumi.set(self, "backend_type", value)

    @property
    @pulumi.getter(name="backendXid")
    def backend_xid(self) -> builtins.int:
        """
        Top-level transaction identifier of this service, if any.
        """
        return pulumi.get(self, "backend_xid")

    @backend_xid.setter
    def backend_xid(self, value: builtins.int):
        pulumi.set(self, "backend_xid", value)

    @property
    @pulumi.getter(name="backendXmin")
    def backend_xmin(self) -> builtins.int:
        """
        The current service's xmin horizon.
        """
        return pulumi.get(self, "backend_xmin")

    @backend_xmin.setter
    def backend_xmin(self, value: builtins.int):
        pulumi.set(self, "backend_xmin", value)

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> builtins.str:
        """
        IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
        """
        return pulumi.get(self, "client_addr")

    @client_addr.setter
    def client_addr(self, value: builtins.str):
        pulumi.set(self, "client_addr", value)

    @property
    @pulumi.getter(name="clientHostname")
    def client_hostname(self) -> builtins.str:
        """
        Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.
        """
        return pulumi.get(self, "client_hostname")

    @client_hostname.setter
    def client_hostname(self, value: builtins.str):
        pulumi.set(self, "client_hostname", value)

    @property
    @pulumi.getter(name="clientPort")
    def client_port(self) -> builtins.int:
        """
        TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.
        """
        return pulumi.get(self, "client_port")

    @client_port.setter
    def client_port(self, value: builtins.int):
        pulumi.set(self, "client_port", value)

    @property
    @pulumi.getter
    def datid(self) -> builtins.int:
        """
        OID of the database this service is connected to.
        """
        return pulumi.get(self, "datid")

    @datid.setter
    def datid(self, value: builtins.int):
        pulumi.set(self, "datid", value)

    @property
    @pulumi.getter
    def datname(self) -> builtins.str:
        """
        Name of the database this service is connected to.
        """
        return pulumi.get(self, "datname")

    @datname.setter
    def datname(self, value: builtins.str):
        pulumi.set(self, "datname", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Process ID of this service.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: builtins.str):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryDuration")
    def query_duration(self) -> builtins.str:
        """
        The active query current duration.
        """
        return pulumi.get(self, "query_duration")

    @query_duration.setter
    def query_duration(self, value: builtins.str):
        pulumi.set(self, "query_duration", value)

    @property
    @pulumi.getter(name="queryStart")
    def query_start(self) -> builtins.str:
        """
        Time when the currently active query was started, or if state is not active, when the last query was started.
        """
        return pulumi.get(self, "query_start")

    @query_start.setter
    def query_start(self, value: builtins.str):
        pulumi.set(self, "query_start", value)

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: builtins.str):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="stateChange")
    def state_change(self) -> builtins.str:
        """
        Time when the state was last changed.
        """
        return pulumi.get(self, "state_change")

    @state_change.setter
    def state_change(self, value: builtins.str):
        pulumi.set(self, "state_change", value)

    @property
    @pulumi.getter
    def usename(self) -> builtins.str:
        """
        Name of the user logged into this service.
        """
        return pulumi.get(self, "usename")

    @usename.setter
    def usename(self, value: builtins.str):
        pulumi.set(self, "usename", value)

    @property
    @pulumi.getter
    def usesysid(self) -> builtins.int:
        """
        OID of the user logged into this service.
        """
        return pulumi.get(self, "usesysid")

    @usesysid.setter
    def usesysid(self, value: builtins.int):
        pulumi.set(self, "usesysid", value)

    @property
    @pulumi.getter(name="waitEvent")
    def wait_event(self) -> builtins.str:
        """
        Wait event name if service is currently waiting.
        """
        return pulumi.get(self, "wait_event")

    @wait_event.setter
    def wait_event(self, value: builtins.str):
        pulumi.set(self, "wait_event", value)

    @property
    @pulumi.getter(name="waitEventType")
    def wait_event_type(self) -> builtins.str:
        """
        The type of event for which the service is waiting, if any; otherwise NULL.
        """
        return pulumi.get(self, "wait_event_type")

    @wait_event_type.setter
    def wait_event_type(self, value: builtins.str):
        pulumi.set(self, "wait_event_type", value)

    @property
    @pulumi.getter(name="xactStart")
    def xact_start(self) -> builtins.str:
        """
        Time when this process' current transaction was started, or null if no transaction is active.
        """
        return pulumi.get(self, "xact_start")

    @xact_start.setter
    def xact_start(self, value: builtins.str):
        pulumi.set(self, "xact_start", value)


if not MYPY:
    class GetManagedDatabaseRedisSessionsSessionArgsDict(TypedDict):
        active_channel_subscriptions: builtins.int
        """
        Number of active channel subscriptions
        """
        active_database: builtins.str
        """
        Current database ID
        """
        active_pattern_matching_channel_subscriptions: builtins.int
        """
        Number of pattern matching subscriptions.
        """
        application_name: builtins.str
        """
        Name of the application that is connected to this service.
        """
        client_addr: builtins.str
        """
        Number of pattern matching subscriptions.
        """
        connection_age: builtins.int
        """
        Total duration of the connection in nanoseconds.
        """
        connection_idle: builtins.int
        """
        Idle time of the connection in nanoseconds.
        """
        flags: Sequence[builtins.str]
        """
        A set containing flags' descriptions.
        """
        flags_raw: builtins.str
        """
        Client connection flags in raw string format.
        """
        id: builtins.str
        """
        Process ID of this session.
        """
        multi_exec_commands: builtins.int
        """
        Number of commands in a MULTI/EXEC context.
        """
        output_buffer: builtins.int
        """
        Output buffer length.
        """
        output_buffer_memory: builtins.int
        """
        Output buffer memory usage.
        """
        output_list_length: builtins.int
        """
        Output list length (replies are queued in this list when the buffer is full).
        """
        query: builtins.str
        """
        The last executed command.
        """
        query_buffer: builtins.int
        """
        Query buffer length (0 means no query pending).
        """
        query_buffer_free: builtins.int
        """
        Free space of the query buffer (0 means the buffer is full).
        """
elif False:
    GetManagedDatabaseRedisSessionsSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabaseRedisSessionsSessionArgs:
    def __init__(__self__, *,
                 active_channel_subscriptions: builtins.int,
                 active_database: builtins.str,
                 active_pattern_matching_channel_subscriptions: builtins.int,
                 application_name: builtins.str,
                 client_addr: builtins.str,
                 connection_age: builtins.int,
                 connection_idle: builtins.int,
                 flags: Sequence[builtins.str],
                 flags_raw: builtins.str,
                 id: builtins.str,
                 multi_exec_commands: builtins.int,
                 output_buffer: builtins.int,
                 output_buffer_memory: builtins.int,
                 output_list_length: builtins.int,
                 query: builtins.str,
                 query_buffer: builtins.int,
                 query_buffer_free: builtins.int):
        """
        :param builtins.int active_channel_subscriptions: Number of active channel subscriptions
        :param builtins.str active_database: Current database ID
        :param builtins.int active_pattern_matching_channel_subscriptions: Number of pattern matching subscriptions.
        :param builtins.str application_name: Name of the application that is connected to this service.
        :param builtins.str client_addr: Number of pattern matching subscriptions.
        :param builtins.int connection_age: Total duration of the connection in nanoseconds.
        :param builtins.int connection_idle: Idle time of the connection in nanoseconds.
        :param Sequence[builtins.str] flags: A set containing flags' descriptions.
        :param builtins.str flags_raw: Client connection flags in raw string format.
        :param builtins.str id: Process ID of this session.
        :param builtins.int multi_exec_commands: Number of commands in a MULTI/EXEC context.
        :param builtins.int output_buffer: Output buffer length.
        :param builtins.int output_buffer_memory: Output buffer memory usage.
        :param builtins.int output_list_length: Output list length (replies are queued in this list when the buffer is full).
        :param builtins.str query: The last executed command.
        :param builtins.int query_buffer: Query buffer length (0 means no query pending).
        :param builtins.int query_buffer_free: Free space of the query buffer (0 means the buffer is full).
        """
        pulumi.set(__self__, "active_channel_subscriptions", active_channel_subscriptions)
        pulumi.set(__self__, "active_database", active_database)
        pulumi.set(__self__, "active_pattern_matching_channel_subscriptions", active_pattern_matching_channel_subscriptions)
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "connection_age", connection_age)
        pulumi.set(__self__, "connection_idle", connection_idle)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "flags_raw", flags_raw)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "multi_exec_commands", multi_exec_commands)
        pulumi.set(__self__, "output_buffer", output_buffer)
        pulumi.set(__self__, "output_buffer_memory", output_buffer_memory)
        pulumi.set(__self__, "output_list_length", output_list_length)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_buffer", query_buffer)
        pulumi.set(__self__, "query_buffer_free", query_buffer_free)

    @property
    @pulumi.getter(name="activeChannelSubscriptions")
    def active_channel_subscriptions(self) -> builtins.int:
        """
        Number of active channel subscriptions
        """
        return pulumi.get(self, "active_channel_subscriptions")

    @active_channel_subscriptions.setter
    def active_channel_subscriptions(self, value: builtins.int):
        pulumi.set(self, "active_channel_subscriptions", value)

    @property
    @pulumi.getter(name="activeDatabase")
    def active_database(self) -> builtins.str:
        """
        Current database ID
        """
        return pulumi.get(self, "active_database")

    @active_database.setter
    def active_database(self, value: builtins.str):
        pulumi.set(self, "active_database", value)

    @property
    @pulumi.getter(name="activePatternMatchingChannelSubscriptions")
    def active_pattern_matching_channel_subscriptions(self) -> builtins.int:
        """
        Number of pattern matching subscriptions.
        """
        return pulumi.get(self, "active_pattern_matching_channel_subscriptions")

    @active_pattern_matching_channel_subscriptions.setter
    def active_pattern_matching_channel_subscriptions(self, value: builtins.int):
        pulumi.set(self, "active_pattern_matching_channel_subscriptions", value)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> builtins.str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: builtins.str):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> builtins.str:
        """
        Number of pattern matching subscriptions.
        """
        return pulumi.get(self, "client_addr")

    @client_addr.setter
    def client_addr(self, value: builtins.str):
        pulumi.set(self, "client_addr", value)

    @property
    @pulumi.getter(name="connectionAge")
    def connection_age(self) -> builtins.int:
        """
        Total duration of the connection in nanoseconds.
        """
        return pulumi.get(self, "connection_age")

    @connection_age.setter
    def connection_age(self, value: builtins.int):
        pulumi.set(self, "connection_age", value)

    @property
    @pulumi.getter(name="connectionIdle")
    def connection_idle(self) -> builtins.int:
        """
        Idle time of the connection in nanoseconds.
        """
        return pulumi.get(self, "connection_idle")

    @connection_idle.setter
    def connection_idle(self, value: builtins.int):
        pulumi.set(self, "connection_idle", value)

    @property
    @pulumi.getter
    def flags(self) -> Sequence[builtins.str]:
        """
        A set containing flags' descriptions.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Sequence[builtins.str]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter(name="flagsRaw")
    def flags_raw(self) -> builtins.str:
        """
        Client connection flags in raw string format.
        """
        return pulumi.get(self, "flags_raw")

    @flags_raw.setter
    def flags_raw(self, value: builtins.str):
        pulumi.set(self, "flags_raw", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Process ID of this session.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="multiExecCommands")
    def multi_exec_commands(self) -> builtins.int:
        """
        Number of commands in a MULTI/EXEC context.
        """
        return pulumi.get(self, "multi_exec_commands")

    @multi_exec_commands.setter
    def multi_exec_commands(self, value: builtins.int):
        pulumi.set(self, "multi_exec_commands", value)

    @property
    @pulumi.getter(name="outputBuffer")
    def output_buffer(self) -> builtins.int:
        """
        Output buffer length.
        """
        return pulumi.get(self, "output_buffer")

    @output_buffer.setter
    def output_buffer(self, value: builtins.int):
        pulumi.set(self, "output_buffer", value)

    @property
    @pulumi.getter(name="outputBufferMemory")
    def output_buffer_memory(self) -> builtins.int:
        """
        Output buffer memory usage.
        """
        return pulumi.get(self, "output_buffer_memory")

    @output_buffer_memory.setter
    def output_buffer_memory(self, value: builtins.int):
        pulumi.set(self, "output_buffer_memory", value)

    @property
    @pulumi.getter(name="outputListLength")
    def output_list_length(self) -> builtins.int:
        """
        Output list length (replies are queued in this list when the buffer is full).
        """
        return pulumi.get(self, "output_list_length")

    @output_list_length.setter
    def output_list_length(self, value: builtins.int):
        pulumi.set(self, "output_list_length", value)

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        """
        The last executed command.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: builtins.str):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryBuffer")
    def query_buffer(self) -> builtins.int:
        """
        Query buffer length (0 means no query pending).
        """
        return pulumi.get(self, "query_buffer")

    @query_buffer.setter
    def query_buffer(self, value: builtins.int):
        pulumi.set(self, "query_buffer", value)

    @property
    @pulumi.getter(name="queryBufferFree")
    def query_buffer_free(self) -> builtins.int:
        """
        Free space of the query buffer (0 means the buffer is full).
        """
        return pulumi.get(self, "query_buffer_free")

    @query_buffer_free.setter
    def query_buffer_free(self, value: builtins.int):
        pulumi.set(self, "query_buffer_free", value)


if not MYPY:
    class GetManagedDatabaseValkeySessionsSessionArgsDict(TypedDict):
        active_channel_subscriptions: builtins.int
        """
        Number of active channel subscriptions
        """
        active_database: builtins.str
        """
        Current database ID
        """
        active_pattern_matching_channel_subscriptions: builtins.int
        """
        Number of pattern matching subscriptions.
        """
        application_name: builtins.str
        """
        Name of the application that is connected to this service.
        """
        client_addr: builtins.str
        """
        Number of pattern matching subscriptions.
        """
        connection_age: builtins.int
        """
        Total duration of the connection in nanoseconds.
        """
        connection_idle: builtins.int
        """
        Idle time of the connection in nanoseconds.
        """
        flags: Sequence[builtins.str]
        """
        A set containing flags' descriptions.
        """
        flags_raw: builtins.str
        """
        Client connection flags in raw string format.
        """
        id: builtins.str
        """
        Process ID of this session.
        """
        multi_exec_commands: builtins.int
        """
        Number of commands in a MULTI/EXEC context.
        """
        output_buffer: builtins.int
        """
        Output buffer length.
        """
        output_buffer_memory: builtins.int
        """
        Output buffer memory usage.
        """
        output_list_length: builtins.int
        """
        Output list length (replies are queued in this list when the buffer is full).
        """
        query: builtins.str
        """
        The last executed command.
        """
        query_buffer: builtins.int
        """
        Query buffer length (0 means no query pending).
        """
        query_buffer_free: builtins.int
        """
        Free space of the query buffer (0 means the buffer is full).
        """
elif False:
    GetManagedDatabaseValkeySessionsSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabaseValkeySessionsSessionArgs:
    def __init__(__self__, *,
                 active_channel_subscriptions: builtins.int,
                 active_database: builtins.str,
                 active_pattern_matching_channel_subscriptions: builtins.int,
                 application_name: builtins.str,
                 client_addr: builtins.str,
                 connection_age: builtins.int,
                 connection_idle: builtins.int,
                 flags: Sequence[builtins.str],
                 flags_raw: builtins.str,
                 id: builtins.str,
                 multi_exec_commands: builtins.int,
                 output_buffer: builtins.int,
                 output_buffer_memory: builtins.int,
                 output_list_length: builtins.int,
                 query: builtins.str,
                 query_buffer: builtins.int,
                 query_buffer_free: builtins.int):
        """
        :param builtins.int active_channel_subscriptions: Number of active channel subscriptions
        :param builtins.str active_database: Current database ID
        :param builtins.int active_pattern_matching_channel_subscriptions: Number of pattern matching subscriptions.
        :param builtins.str application_name: Name of the application that is connected to this service.
        :param builtins.str client_addr: Number of pattern matching subscriptions.
        :param builtins.int connection_age: Total duration of the connection in nanoseconds.
        :param builtins.int connection_idle: Idle time of the connection in nanoseconds.
        :param Sequence[builtins.str] flags: A set containing flags' descriptions.
        :param builtins.str flags_raw: Client connection flags in raw string format.
        :param builtins.str id: Process ID of this session.
        :param builtins.int multi_exec_commands: Number of commands in a MULTI/EXEC context.
        :param builtins.int output_buffer: Output buffer length.
        :param builtins.int output_buffer_memory: Output buffer memory usage.
        :param builtins.int output_list_length: Output list length (replies are queued in this list when the buffer is full).
        :param builtins.str query: The last executed command.
        :param builtins.int query_buffer: Query buffer length (0 means no query pending).
        :param builtins.int query_buffer_free: Free space of the query buffer (0 means the buffer is full).
        """
        pulumi.set(__self__, "active_channel_subscriptions", active_channel_subscriptions)
        pulumi.set(__self__, "active_database", active_database)
        pulumi.set(__self__, "active_pattern_matching_channel_subscriptions", active_pattern_matching_channel_subscriptions)
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "connection_age", connection_age)
        pulumi.set(__self__, "connection_idle", connection_idle)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "flags_raw", flags_raw)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "multi_exec_commands", multi_exec_commands)
        pulumi.set(__self__, "output_buffer", output_buffer)
        pulumi.set(__self__, "output_buffer_memory", output_buffer_memory)
        pulumi.set(__self__, "output_list_length", output_list_length)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_buffer", query_buffer)
        pulumi.set(__self__, "query_buffer_free", query_buffer_free)

    @property
    @pulumi.getter(name="activeChannelSubscriptions")
    def active_channel_subscriptions(self) -> builtins.int:
        """
        Number of active channel subscriptions
        """
        return pulumi.get(self, "active_channel_subscriptions")

    @active_channel_subscriptions.setter
    def active_channel_subscriptions(self, value: builtins.int):
        pulumi.set(self, "active_channel_subscriptions", value)

    @property
    @pulumi.getter(name="activeDatabase")
    def active_database(self) -> builtins.str:
        """
        Current database ID
        """
        return pulumi.get(self, "active_database")

    @active_database.setter
    def active_database(self, value: builtins.str):
        pulumi.set(self, "active_database", value)

    @property
    @pulumi.getter(name="activePatternMatchingChannelSubscriptions")
    def active_pattern_matching_channel_subscriptions(self) -> builtins.int:
        """
        Number of pattern matching subscriptions.
        """
        return pulumi.get(self, "active_pattern_matching_channel_subscriptions")

    @active_pattern_matching_channel_subscriptions.setter
    def active_pattern_matching_channel_subscriptions(self, value: builtins.int):
        pulumi.set(self, "active_pattern_matching_channel_subscriptions", value)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> builtins.str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: builtins.str):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> builtins.str:
        """
        Number of pattern matching subscriptions.
        """
        return pulumi.get(self, "client_addr")

    @client_addr.setter
    def client_addr(self, value: builtins.str):
        pulumi.set(self, "client_addr", value)

    @property
    @pulumi.getter(name="connectionAge")
    def connection_age(self) -> builtins.int:
        """
        Total duration of the connection in nanoseconds.
        """
        return pulumi.get(self, "connection_age")

    @connection_age.setter
    def connection_age(self, value: builtins.int):
        pulumi.set(self, "connection_age", value)

    @property
    @pulumi.getter(name="connectionIdle")
    def connection_idle(self) -> builtins.int:
        """
        Idle time of the connection in nanoseconds.
        """
        return pulumi.get(self, "connection_idle")

    @connection_idle.setter
    def connection_idle(self, value: builtins.int):
        pulumi.set(self, "connection_idle", value)

    @property
    @pulumi.getter
    def flags(self) -> Sequence[builtins.str]:
        """
        A set containing flags' descriptions.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Sequence[builtins.str]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter(name="flagsRaw")
    def flags_raw(self) -> builtins.str:
        """
        Client connection flags in raw string format.
        """
        return pulumi.get(self, "flags_raw")

    @flags_raw.setter
    def flags_raw(self, value: builtins.str):
        pulumi.set(self, "flags_raw", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Process ID of this session.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: builtins.str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="multiExecCommands")
    def multi_exec_commands(self) -> builtins.int:
        """
        Number of commands in a MULTI/EXEC context.
        """
        return pulumi.get(self, "multi_exec_commands")

    @multi_exec_commands.setter
    def multi_exec_commands(self, value: builtins.int):
        pulumi.set(self, "multi_exec_commands", value)

    @property
    @pulumi.getter(name="outputBuffer")
    def output_buffer(self) -> builtins.int:
        """
        Output buffer length.
        """
        return pulumi.get(self, "output_buffer")

    @output_buffer.setter
    def output_buffer(self, value: builtins.int):
        pulumi.set(self, "output_buffer", value)

    @property
    @pulumi.getter(name="outputBufferMemory")
    def output_buffer_memory(self) -> builtins.int:
        """
        Output buffer memory usage.
        """
        return pulumi.get(self, "output_buffer_memory")

    @output_buffer_memory.setter
    def output_buffer_memory(self, value: builtins.int):
        pulumi.set(self, "output_buffer_memory", value)

    @property
    @pulumi.getter(name="outputListLength")
    def output_list_length(self) -> builtins.int:
        """
        Output list length (replies are queued in this list when the buffer is full).
        """
        return pulumi.get(self, "output_list_length")

    @output_list_length.setter
    def output_list_length(self, value: builtins.int):
        pulumi.set(self, "output_list_length", value)

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        """
        The last executed command.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: builtins.str):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryBuffer")
    def query_buffer(self) -> builtins.int:
        """
        Query buffer length (0 means no query pending).
        """
        return pulumi.get(self, "query_buffer")

    @query_buffer.setter
    def query_buffer(self, value: builtins.int):
        pulumi.set(self, "query_buffer", value)

    @property
    @pulumi.getter(name="queryBufferFree")
    def query_buffer_free(self) -> builtins.int:
        """
        Free space of the query buffer (0 means the buffer is full).
        """
        return pulumi.get(self, "query_buffer_free")

    @query_buffer_free.setter
    def query_buffer_free(self, value: builtins.int):
        pulumi.set(self, "query_buffer_free", value)


if not MYPY:
    class GetManagedObjectStorageRegionsRegionArgsDict(TypedDict):
        name: builtins.str
        """
        Name of the region.
        """
        primary_zone: builtins.str
        """
        Primary zone of the region.
        """
        zones: Sequence[builtins.str]
        """
        List of zones in the region.
        """
elif False:
    GetManagedObjectStorageRegionsRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedObjectStorageRegionsRegionArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 primary_zone: builtins.str,
                 zones: Sequence[builtins.str]):
        """
        :param builtins.str name: Name of the region.
        :param builtins.str primary_zone: Primary zone of the region.
        :param Sequence[builtins.str] zones: List of zones in the region.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_zone", primary_zone)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the region.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryZone")
    def primary_zone(self) -> builtins.str:
        """
        Primary zone of the region.
        """
        return pulumi.get(self, "primary_zone")

    @primary_zone.setter
    def primary_zone(self, value: builtins.str):
        pulumi.set(self, "primary_zone", value)

    @property
    @pulumi.getter
    def zones(self) -> Sequence[builtins.str]:
        """
        List of zones in the region.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Sequence[builtins.str]):
        pulumi.set(self, "zones", value)


