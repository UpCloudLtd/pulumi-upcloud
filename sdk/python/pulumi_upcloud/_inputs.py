# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'GatewayAddressArgs',
    'GatewayAddressArgsDict',
    'GatewayConnectionLocalRouteArgs',
    'GatewayConnectionLocalRouteArgsDict',
    'GatewayConnectionRemoteRouteArgs',
    'GatewayConnectionRemoteRouteArgsDict',
    'GatewayConnectionTunnelIpsecAuthPskArgs',
    'GatewayConnectionTunnelIpsecAuthPskArgsDict',
    'GatewayConnectionTunnelIpsecPropertiesArgs',
    'GatewayConnectionTunnelIpsecPropertiesArgsDict',
    'GatewayRouterArgs',
    'GatewayRouterArgsDict',
    'KubernetesNodeGroupCustomPlanArgs',
    'KubernetesNodeGroupCustomPlanArgsDict',
    'KubernetesNodeGroupKubeletArgArgs',
    'KubernetesNodeGroupKubeletArgArgsDict',
    'KubernetesNodeGroupTaintArgs',
    'KubernetesNodeGroupTaintArgsDict',
    'LoadbalancerBackendPropertiesArgs',
    'LoadbalancerBackendPropertiesArgsDict',
    'LoadbalancerFrontendNetworkArgs',
    'LoadbalancerFrontendNetworkArgsDict',
    'LoadbalancerFrontendPropertiesArgs',
    'LoadbalancerFrontendPropertiesArgsDict',
    'LoadbalancerFrontendRuleActionsArgs',
    'LoadbalancerFrontendRuleActionsArgsDict',
    'LoadbalancerFrontendRuleActionsHttpRedirectArgs',
    'LoadbalancerFrontendRuleActionsHttpRedirectArgsDict',
    'LoadbalancerFrontendRuleActionsHttpReturnArgs',
    'LoadbalancerFrontendRuleActionsHttpReturnArgsDict',
    'LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs',
    'LoadbalancerFrontendRuleActionsSetForwardedHeaderArgsDict',
    'LoadbalancerFrontendRuleActionsTcpRejectArgs',
    'LoadbalancerFrontendRuleActionsTcpRejectArgsDict',
    'LoadbalancerFrontendRuleActionsUseBackendArgs',
    'LoadbalancerFrontendRuleActionsUseBackendArgsDict',
    'LoadbalancerFrontendRuleMatchersArgs',
    'LoadbalancerFrontendRuleMatchersArgsDict',
    'LoadbalancerFrontendRuleMatchersBodySizeArgs',
    'LoadbalancerFrontendRuleMatchersBodySizeArgsDict',
    'LoadbalancerFrontendRuleMatchersBodySizeRangeArgs',
    'LoadbalancerFrontendRuleMatchersBodySizeRangeArgsDict',
    'LoadbalancerFrontendRuleMatchersCookieArgs',
    'LoadbalancerFrontendRuleMatchersCookieArgsDict',
    'LoadbalancerFrontendRuleMatchersHeaderArgs',
    'LoadbalancerFrontendRuleMatchersHeaderArgsDict',
    'LoadbalancerFrontendRuleMatchersHostArgs',
    'LoadbalancerFrontendRuleMatchersHostArgsDict',
    'LoadbalancerFrontendRuleMatchersHttpMethodArgs',
    'LoadbalancerFrontendRuleMatchersHttpMethodArgsDict',
    'LoadbalancerFrontendRuleMatchersNumMembersUpArgs',
    'LoadbalancerFrontendRuleMatchersNumMembersUpArgsDict',
    'LoadbalancerFrontendRuleMatchersPathArgs',
    'LoadbalancerFrontendRuleMatchersPathArgsDict',
    'LoadbalancerFrontendRuleMatchersSrcIpArgs',
    'LoadbalancerFrontendRuleMatchersSrcIpArgsDict',
    'LoadbalancerFrontendRuleMatchersSrcPortArgs',
    'LoadbalancerFrontendRuleMatchersSrcPortArgsDict',
    'LoadbalancerFrontendRuleMatchersSrcPortRangeArgs',
    'LoadbalancerFrontendRuleMatchersSrcPortRangeArgsDict',
    'LoadbalancerFrontendRuleMatchersUrlArgs',
    'LoadbalancerFrontendRuleMatchersUrlArgsDict',
    'LoadbalancerFrontendRuleMatchersUrlParamArgs',
    'LoadbalancerFrontendRuleMatchersUrlParamArgsDict',
    'LoadbalancerFrontendRuleMatchersUrlQueryArgs',
    'LoadbalancerFrontendRuleMatchersUrlQueryArgsDict',
    'LoadbalancerNetworkArgs',
    'LoadbalancerNetworkArgsDict',
    'LoadbalancerNodeArgs',
    'LoadbalancerNodeArgsDict',
    'LoadbalancerNodeNetworkArgs',
    'LoadbalancerNodeNetworkArgsDict',
    'LoadbalancerNodeNetworkIpAddressArgs',
    'LoadbalancerNodeNetworkIpAddressArgsDict',
    'ManagedDatabaseMysqlComponentArgs',
    'ManagedDatabaseMysqlComponentArgsDict',
    'ManagedDatabaseMysqlNetworkArgs',
    'ManagedDatabaseMysqlNetworkArgsDict',
    'ManagedDatabaseMysqlNodeStateArgs',
    'ManagedDatabaseMysqlNodeStateArgsDict',
    'ManagedDatabaseMysqlPropertiesArgs',
    'ManagedDatabaseMysqlPropertiesArgsDict',
    'ManagedDatabaseMysqlPropertiesMigrationArgs',
    'ManagedDatabaseMysqlPropertiesMigrationArgsDict',
    'ManagedDatabaseOpensearchComponentArgs',
    'ManagedDatabaseOpensearchComponentArgsDict',
    'ManagedDatabaseOpensearchNetworkArgs',
    'ManagedDatabaseOpensearchNetworkArgsDict',
    'ManagedDatabaseOpensearchNodeStateArgs',
    'ManagedDatabaseOpensearchNodeStateArgsDict',
    'ManagedDatabaseOpensearchPropertiesArgs',
    'ManagedDatabaseOpensearchPropertiesArgsDict',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgsDict',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgsDict',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgs',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgsDict',
    'ManagedDatabaseOpensearchPropertiesAzureMigrationArgs',
    'ManagedDatabaseOpensearchPropertiesAzureMigrationArgsDict',
    'ManagedDatabaseOpensearchPropertiesGcsMigrationArgs',
    'ManagedDatabaseOpensearchPropertiesGcsMigrationArgsDict',
    'ManagedDatabaseOpensearchPropertiesIndexRollupArgs',
    'ManagedDatabaseOpensearchPropertiesIndexRollupArgsDict',
    'ManagedDatabaseOpensearchPropertiesIndexTemplateArgs',
    'ManagedDatabaseOpensearchPropertiesIndexTemplateArgsDict',
    'ManagedDatabaseOpensearchPropertiesOpenidArgs',
    'ManagedDatabaseOpensearchPropertiesOpenidArgsDict',
    'ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs',
    'ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgsDict',
    'ManagedDatabaseOpensearchPropertiesS3MigrationArgs',
    'ManagedDatabaseOpensearchPropertiesS3MigrationArgsDict',
    'ManagedDatabaseOpensearchPropertiesSamlArgs',
    'ManagedDatabaseOpensearchPropertiesSamlArgsDict',
    'ManagedDatabasePostgresqlComponentArgs',
    'ManagedDatabasePostgresqlComponentArgsDict',
    'ManagedDatabasePostgresqlNetworkArgs',
    'ManagedDatabasePostgresqlNetworkArgsDict',
    'ManagedDatabasePostgresqlNodeStateArgs',
    'ManagedDatabasePostgresqlNodeStateArgsDict',
    'ManagedDatabasePostgresqlPropertiesArgs',
    'ManagedDatabasePostgresqlPropertiesArgsDict',
    'ManagedDatabasePostgresqlPropertiesMigrationArgs',
    'ManagedDatabasePostgresqlPropertiesMigrationArgsDict',
    'ManagedDatabasePostgresqlPropertiesPgbouncerArgs',
    'ManagedDatabasePostgresqlPropertiesPgbouncerArgsDict',
    'ManagedDatabasePostgresqlPropertiesPglookoutArgs',
    'ManagedDatabasePostgresqlPropertiesPglookoutArgsDict',
    'ManagedDatabasePostgresqlPropertiesTimescaledbArgs',
    'ManagedDatabasePostgresqlPropertiesTimescaledbArgsDict',
    'ManagedDatabaseRedisComponentArgs',
    'ManagedDatabaseRedisComponentArgsDict',
    'ManagedDatabaseRedisNetworkArgs',
    'ManagedDatabaseRedisNetworkArgsDict',
    'ManagedDatabaseRedisNodeStateArgs',
    'ManagedDatabaseRedisNodeStateArgsDict',
    'ManagedDatabaseRedisPropertiesArgs',
    'ManagedDatabaseRedisPropertiesArgsDict',
    'ManagedDatabaseRedisPropertiesMigrationArgs',
    'ManagedDatabaseRedisPropertiesMigrationArgsDict',
    'ManagedDatabaseUserOpensearchAccessControlArgs',
    'ManagedDatabaseUserOpensearchAccessControlArgsDict',
    'ManagedDatabaseUserOpensearchAccessControlRuleArgs',
    'ManagedDatabaseUserOpensearchAccessControlRuleArgsDict',
    'ManagedDatabaseUserPgAccessControlArgs',
    'ManagedDatabaseUserPgAccessControlArgsDict',
    'ManagedDatabaseUserRedisAccessControlArgs',
    'ManagedDatabaseUserRedisAccessControlArgsDict',
    'ManagedObjectStorageEndpointArgs',
    'ManagedObjectStorageEndpointArgsDict',
    'ManagedObjectStorageNetworkArgs',
    'ManagedObjectStorageNetworkArgsDict',
    'NetworkIpNetworkArgs',
    'NetworkIpNetworkArgsDict',
    'NetworkPeeringNetworkArgs',
    'NetworkPeeringNetworkArgsDict',
    'NetworkPeeringPeerNetworkArgs',
    'NetworkPeeringPeerNetworkArgsDict',
    'ObjectStorageBucketArgs',
    'ObjectStorageBucketArgsDict',
    'RouterStaticRouteArgs',
    'RouterStaticRouteArgsDict',
    'ServerFirewallRulesFirewallRuleArgs',
    'ServerFirewallRulesFirewallRuleArgsDict',
    'ServerLoginArgs',
    'ServerLoginArgsDict',
    'ServerNetworkInterfaceArgs',
    'ServerNetworkInterfaceArgsDict',
    'ServerNetworkInterfaceAdditionalIpAddressArgs',
    'ServerNetworkInterfaceAdditionalIpAddressArgsDict',
    'ServerSimpleBackupArgs',
    'ServerSimpleBackupArgsDict',
    'ServerStorageDeviceArgs',
    'ServerStorageDeviceArgsDict',
    'ServerTemplateArgs',
    'ServerTemplateArgsDict',
    'ServerTemplateBackupRuleArgs',
    'ServerTemplateBackupRuleArgsDict',
    'StorageBackupRuleArgs',
    'StorageBackupRuleArgsDict',
    'StorageCloneArgs',
    'StorageCloneArgsDict',
    'StorageImportArgs',
    'StorageImportArgsDict',
    'GetHostsHostArgs',
    'GetHostsHostArgsDict',
    'GetManagedDatabaseMysqlSessionsSessionArgs',
    'GetManagedDatabaseMysqlSessionsSessionArgsDict',
    'GetManagedDatabaseOpensearchIndicesIndexArgs',
    'GetManagedDatabaseOpensearchIndicesIndexArgsDict',
    'GetManagedDatabasePostgresqlSessionsSessionArgs',
    'GetManagedDatabasePostgresqlSessionsSessionArgsDict',
    'GetManagedDatabaseRedisSessionsSessionArgs',
    'GetManagedDatabaseRedisSessionsSessionArgsDict',
    'GetManagedObjectStorageRegionsRegionArgs',
    'GetManagedObjectStorageRegionsRegionArgsDict',
]

MYPY = False

if not MYPY:
    class GatewayAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        IP addresss
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the IP address
        """
elif False:
    GatewayAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: IP addresss
        :param pulumi.Input[str] name: Name of the IP address
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        IP addresss
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the IP address
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GatewayConnectionLocalRouteArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the route
        """
        static_network: pulumi.Input[str]
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of route; currently the only supported type is 'static'
        """
elif False:
    GatewayConnectionLocalRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayConnectionLocalRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 static_network: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the route
        :param pulumi.Input[str] static_network: Destination prefix of the route; needs to be a valid IPv4 prefix
        :param pulumi.Input[str] type: Type of route; currently the only supported type is 'static'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "static_network", static_network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the route
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="staticNetwork")
    def static_network(self) -> pulumi.Input[str]:
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        return pulumi.get(self, "static_network")

    @static_network.setter
    def static_network(self, value: pulumi.Input[str]):
        pulumi.set(self, "static_network", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of route; currently the only supported type is 'static'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayConnectionRemoteRouteArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the route
        """
        static_network: pulumi.Input[str]
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of route; currently the only supported type is 'static'
        """
elif False:
    GatewayConnectionRemoteRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayConnectionRemoteRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 static_network: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the route
        :param pulumi.Input[str] static_network: Destination prefix of the route; needs to be a valid IPv4 prefix
        :param pulumi.Input[str] type: Type of route; currently the only supported type is 'static'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "static_network", static_network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the route
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="staticNetwork")
    def static_network(self) -> pulumi.Input[str]:
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        return pulumi.get(self, "static_network")

    @static_network.setter
    def static_network(self, value: pulumi.Input[str]):
        pulumi.set(self, "static_network", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of route; currently the only supported type is 'static'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayConnectionTunnelIpsecAuthPskArgsDict(TypedDict):
        psk: pulumi.Input[str]
        """
        The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.
        """
elif False:
    GatewayConnectionTunnelIpsecAuthPskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayConnectionTunnelIpsecAuthPskArgs:
    def __init__(__self__, *,
                 psk: pulumi.Input[str]):
        """
        :param pulumi.Input[str] psk: The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.
        """
        pulumi.set(__self__, "psk", psk)

    @property
    @pulumi.getter
    def psk(self) -> pulumi.Input[str]:
        """
        The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.
        """
        return pulumi.get(self, "psk")

    @psk.setter
    def psk(self, value: pulumi.Input[str]):
        pulumi.set(self, "psk", value)


if not MYPY:
    class GatewayConnectionTunnelIpsecPropertiesArgsDict(TypedDict):
        child_rekey_time: NotRequired[pulumi.Input[int]]
        """
        IKE child SA rekey time in seconds.
        """
        dpd_delay: NotRequired[pulumi.Input[int]]
        """
        Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.
        """
        dpd_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout period for DPD reply before considering the peer to be dead, in seconds.
        """
        ike_lifetime: NotRequired[pulumi.Input[int]]
        """
        Maximum IKE SA lifetime in seconds.
        """
        phase1_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Phase 1: Proposal algorithms.
        """
        phase1_dh_group_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        List of Phase 1 Diffie-Hellman group numbers.
        """
        phase1_integrity_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Phase 1 integrity algorithms.
        """
        phase2_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Phase 2: Security Association algorithms.
        """
        phase2_dh_group_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        List of Phase 2 Diffie-Hellman group numbers.
        """
        phase2_integrity_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Phase 2 integrity algorithms.
        """
        rekey_time: NotRequired[pulumi.Input[int]]
        """
        IKE SA rekey time in seconds.
        """
elif False:
    GatewayConnectionTunnelIpsecPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayConnectionTunnelIpsecPropertiesArgs:
    def __init__(__self__, *,
                 child_rekey_time: Optional[pulumi.Input[int]] = None,
                 dpd_delay: Optional[pulumi.Input[int]] = None,
                 dpd_timeout: Optional[pulumi.Input[int]] = None,
                 ike_lifetime: Optional[pulumi.Input[int]] = None,
                 phase1_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 phase1_dh_group_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 phase1_integrity_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 phase2_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 phase2_dh_group_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 phase2_integrity_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 rekey_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] child_rekey_time: IKE child SA rekey time in seconds.
        :param pulumi.Input[int] dpd_delay: Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.
        :param pulumi.Input[int] dpd_timeout: Timeout period for DPD reply before considering the peer to be dead, in seconds.
        :param pulumi.Input[int] ike_lifetime: Maximum IKE SA lifetime in seconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] phase1_algorithms: List of Phase 1: Proposal algorithms.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] phase1_dh_group_numbers: List of Phase 1 Diffie-Hellman group numbers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] phase1_integrity_algorithms: List of Phase 1 integrity algorithms.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] phase2_algorithms: List of Phase 2: Security Association algorithms.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] phase2_dh_group_numbers: List of Phase 2 Diffie-Hellman group numbers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] phase2_integrity_algorithms: List of Phase 2 integrity algorithms.
        :param pulumi.Input[int] rekey_time: IKE SA rekey time in seconds.
        """
        if child_rekey_time is not None:
            pulumi.set(__self__, "child_rekey_time", child_rekey_time)
        if dpd_delay is not None:
            pulumi.set(__self__, "dpd_delay", dpd_delay)
        if dpd_timeout is not None:
            pulumi.set(__self__, "dpd_timeout", dpd_timeout)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if phase1_algorithms is not None:
            pulumi.set(__self__, "phase1_algorithms", phase1_algorithms)
        if phase1_dh_group_numbers is not None:
            pulumi.set(__self__, "phase1_dh_group_numbers", phase1_dh_group_numbers)
        if phase1_integrity_algorithms is not None:
            pulumi.set(__self__, "phase1_integrity_algorithms", phase1_integrity_algorithms)
        if phase2_algorithms is not None:
            pulumi.set(__self__, "phase2_algorithms", phase2_algorithms)
        if phase2_dh_group_numbers is not None:
            pulumi.set(__self__, "phase2_dh_group_numbers", phase2_dh_group_numbers)
        if phase2_integrity_algorithms is not None:
            pulumi.set(__self__, "phase2_integrity_algorithms", phase2_integrity_algorithms)
        if rekey_time is not None:
            pulumi.set(__self__, "rekey_time", rekey_time)

    @property
    @pulumi.getter(name="childRekeyTime")
    def child_rekey_time(self) -> Optional[pulumi.Input[int]]:
        """
        IKE child SA rekey time in seconds.
        """
        return pulumi.get(self, "child_rekey_time")

    @child_rekey_time.setter
    def child_rekey_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "child_rekey_time", value)

    @property
    @pulumi.getter(name="dpdDelay")
    def dpd_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.
        """
        return pulumi.get(self, "dpd_delay")

    @dpd_delay.setter
    def dpd_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dpd_delay", value)

    @property
    @pulumi.getter(name="dpdTimeout")
    def dpd_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout period for DPD reply before considering the peer to be dead, in seconds.
        """
        return pulumi.get(self, "dpd_timeout")

    @dpd_timeout.setter
    def dpd_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dpd_timeout", value)

    @property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum IKE SA lifetime in seconds.
        """
        return pulumi.get(self, "ike_lifetime")

    @ike_lifetime.setter
    def ike_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ike_lifetime", value)

    @property
    @pulumi.getter(name="phase1Algorithms")
    def phase1_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Phase 1: Proposal algorithms.
        """
        return pulumi.get(self, "phase1_algorithms")

    @phase1_algorithms.setter
    def phase1_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "phase1_algorithms", value)

    @property
    @pulumi.getter(name="phase1DhGroupNumbers")
    def phase1_dh_group_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of Phase 1 Diffie-Hellman group numbers.
        """
        return pulumi.get(self, "phase1_dh_group_numbers")

    @phase1_dh_group_numbers.setter
    def phase1_dh_group_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "phase1_dh_group_numbers", value)

    @property
    @pulumi.getter(name="phase1IntegrityAlgorithms")
    def phase1_integrity_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Phase 1 integrity algorithms.
        """
        return pulumi.get(self, "phase1_integrity_algorithms")

    @phase1_integrity_algorithms.setter
    def phase1_integrity_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "phase1_integrity_algorithms", value)

    @property
    @pulumi.getter(name="phase2Algorithms")
    def phase2_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Phase 2: Security Association algorithms.
        """
        return pulumi.get(self, "phase2_algorithms")

    @phase2_algorithms.setter
    def phase2_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "phase2_algorithms", value)

    @property
    @pulumi.getter(name="phase2DhGroupNumbers")
    def phase2_dh_group_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of Phase 2 Diffie-Hellman group numbers.
        """
        return pulumi.get(self, "phase2_dh_group_numbers")

    @phase2_dh_group_numbers.setter
    def phase2_dh_group_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "phase2_dh_group_numbers", value)

    @property
    @pulumi.getter(name="phase2IntegrityAlgorithms")
    def phase2_integrity_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Phase 2 integrity algorithms.
        """
        return pulumi.get(self, "phase2_integrity_algorithms")

    @phase2_integrity_algorithms.setter
    def phase2_integrity_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "phase2_integrity_algorithms", value)

    @property
    @pulumi.getter(name="rekeyTime")
    def rekey_time(self) -> Optional[pulumi.Input[int]]:
        """
        IKE SA rekey time in seconds.
        """
        return pulumi.get(self, "rekey_time")

    @rekey_time.setter
    def rekey_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rekey_time", value)


if not MYPY:
    class GatewayRouterArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the router attached to the gateway.
        """
elif False:
    GatewayRouterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayRouterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the router attached to the gateway.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the router attached to the gateway.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class KubernetesNodeGroupCustomPlanArgsDict(TypedDict):
        cores: pulumi.Input[int]
        """
        The number of CPU cores dedicated to individual node group nodes when using custom plan
        """
        memory: pulumi.Input[int]
        """
        The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
        """
        storage_size: pulumi.Input[int]
        """
        The size of the storage device in gigabytes.
        """
        storage_tier: NotRequired[pulumi.Input[str]]
        """
        The storage tier to use. Defaults to maxiops
        """
elif False:
    KubernetesNodeGroupCustomPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupCustomPlanArgs:
    def __init__(__self__, *,
                 cores: pulumi.Input[int],
                 memory: pulumi.Input[int],
                 storage_size: pulumi.Input[int],
                 storage_tier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] cores: The number of CPU cores dedicated to individual node group nodes when using custom plan
        :param pulumi.Input[int] memory: The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
        :param pulumi.Input[int] storage_size: The size of the storage device in gigabytes.
        :param pulumi.Input[str] storage_tier: The storage tier to use. Defaults to maxiops
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "storage_size", storage_size)
        if storage_tier is not None:
            pulumi.set(__self__, "storage_tier", storage_tier)

    @property
    @pulumi.getter
    def cores(self) -> pulumi.Input[int]:
        """
        The number of CPU cores dedicated to individual node group nodes when using custom plan
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: pulumi.Input[int]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[int]:
        """
        The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[int]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> pulumi.Input[int]:
        """
        The size of the storage device in gigabytes.
        """
        return pulumi.get(self, "storage_size")

    @storage_size.setter
    def storage_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "storage_size", value)

    @property
    @pulumi.getter(name="storageTier")
    def storage_tier(self) -> Optional[pulumi.Input[str]]:
        """
        The storage tier to use. Defaults to maxiops
        """
        return pulumi.get(self, "storage_tier")

    @storage_tier.setter
    def storage_tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_tier", value)


if not MYPY:
    class KubernetesNodeGroupKubeletArgArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Kubelet argument key.
        """
        value: pulumi.Input[str]
        """
        Kubelet argument value.
        """
elif False:
    KubernetesNodeGroupKubeletArgArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupKubeletArgArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Kubelet argument key.
        :param pulumi.Input[str] value: Kubelet argument value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Kubelet argument key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Kubelet argument value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class KubernetesNodeGroupTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        Taint effect.
        """
        key: pulumi.Input[str]
        """
        Taint key.
        """
        value: pulumi.Input[str]
        """
        Taint value.
        """
elif False:
    KubernetesNodeGroupTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodeGroupTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: Taint effect.
        :param pulumi.Input[str] key: Taint key.
        :param pulumi.Input[str] value: Taint value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        Taint effect.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Taint key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerBackendPropertiesArgsDict(TypedDict):
        health_check_expected_status: NotRequired[pulumi.Input[int]]
        """
        Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.
        """
        health_check_fall: NotRequired[pulumi.Input[int]]
        """
        Sets how many failed health checks are allowed until the backend member is taken off from the rotation.
        """
        health_check_interval: NotRequired[pulumi.Input[int]]
        """
        Interval between health checks in seconds.
        """
        health_check_rise: NotRequired[pulumi.Input[int]]
        """
        Sets how many successful health checks are required to put the backend member back into rotation.
        """
        health_check_tls_verify: NotRequired[pulumi.Input[bool]]
        """
        Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.
        """
        health_check_type: NotRequired[pulumi.Input[str]]
        """
        Health check type.
        """
        health_check_url: NotRequired[pulumi.Input[str]]
        """
        Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.
        """
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.
        """
        outbound_proxy_protocol: NotRequired[pulumi.Input[str]]
        """
        Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.
        """
        sticky_session_cookie_name: NotRequired[pulumi.Input[str]]
        """
        Sets sticky session cookie name. Empty string disables sticky session.
        """
        timeout_server: NotRequired[pulumi.Input[int]]
        """
        Backend server timeout in seconds.
        """
        timeout_tunnel: NotRequired[pulumi.Input[int]]
        """
        Maximum inactivity time on the client and server side for tunnels in seconds.
        """
        tls_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enables TLS connection from the load balancer to backend servers.
        """
        tls_use_system_ca: NotRequired[pulumi.Input[bool]]
        """
        If enabled, then the system CA certificate bundle will be used for the certificate verification.
        """
        tls_verify: NotRequired[pulumi.Input[bool]]
        """
        Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.
        """
elif False:
    LoadbalancerBackendPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerBackendPropertiesArgs:
    def __init__(__self__, *,
                 health_check_expected_status: Optional[pulumi.Input[int]] = None,
                 health_check_fall: Optional[pulumi.Input[int]] = None,
                 health_check_interval: Optional[pulumi.Input[int]] = None,
                 health_check_rise: Optional[pulumi.Input[int]] = None,
                 health_check_tls_verify: Optional[pulumi.Input[bool]] = None,
                 health_check_type: Optional[pulumi.Input[str]] = None,
                 health_check_url: Optional[pulumi.Input[str]] = None,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 outbound_proxy_protocol: Optional[pulumi.Input[str]] = None,
                 sticky_session_cookie_name: Optional[pulumi.Input[str]] = None,
                 timeout_server: Optional[pulumi.Input[int]] = None,
                 timeout_tunnel: Optional[pulumi.Input[int]] = None,
                 tls_enabled: Optional[pulumi.Input[bool]] = None,
                 tls_use_system_ca: Optional[pulumi.Input[bool]] = None,
                 tls_verify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] health_check_expected_status: Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.
        :param pulumi.Input[int] health_check_fall: Sets how many failed health checks are allowed until the backend member is taken off from the rotation.
        :param pulumi.Input[int] health_check_interval: Interval between health checks in seconds.
        :param pulumi.Input[int] health_check_rise: Sets how many successful health checks are required to put the backend member back into rotation.
        :param pulumi.Input[bool] health_check_tls_verify: Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.
        :param pulumi.Input[str] health_check_type: Health check type.
        :param pulumi.Input[str] health_check_url: Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.
        :param pulumi.Input[bool] http2_enabled: Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.
        :param pulumi.Input[str] outbound_proxy_protocol: Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.
        :param pulumi.Input[str] sticky_session_cookie_name: Sets sticky session cookie name. Empty string disables sticky session.
        :param pulumi.Input[int] timeout_server: Backend server timeout in seconds.
        :param pulumi.Input[int] timeout_tunnel: Maximum inactivity time on the client and server side for tunnels in seconds.
        :param pulumi.Input[bool] tls_enabled: Enables TLS connection from the load balancer to backend servers.
        :param pulumi.Input[bool] tls_use_system_ca: If enabled, then the system CA certificate bundle will be used for the certificate verification.
        :param pulumi.Input[bool] tls_verify: Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.
        """
        if health_check_expected_status is not None:
            pulumi.set(__self__, "health_check_expected_status", health_check_expected_status)
        if health_check_fall is not None:
            pulumi.set(__self__, "health_check_fall", health_check_fall)
        if health_check_interval is not None:
            pulumi.set(__self__, "health_check_interval", health_check_interval)
        if health_check_rise is not None:
            pulumi.set(__self__, "health_check_rise", health_check_rise)
        if health_check_tls_verify is not None:
            pulumi.set(__self__, "health_check_tls_verify", health_check_tls_verify)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)
        if health_check_url is not None:
            pulumi.set(__self__, "health_check_url", health_check_url)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if outbound_proxy_protocol is not None:
            pulumi.set(__self__, "outbound_proxy_protocol", outbound_proxy_protocol)
        if sticky_session_cookie_name is not None:
            pulumi.set(__self__, "sticky_session_cookie_name", sticky_session_cookie_name)
        if timeout_server is not None:
            pulumi.set(__self__, "timeout_server", timeout_server)
        if timeout_tunnel is not None:
            pulumi.set(__self__, "timeout_tunnel", timeout_tunnel)
        if tls_enabled is not None:
            pulumi.set(__self__, "tls_enabled", tls_enabled)
        if tls_use_system_ca is not None:
            pulumi.set(__self__, "tls_use_system_ca", tls_use_system_ca)
        if tls_verify is not None:
            pulumi.set(__self__, "tls_verify", tls_verify)

    @property
    @pulumi.getter(name="healthCheckExpectedStatus")
    def health_check_expected_status(self) -> Optional[pulumi.Input[int]]:
        """
        Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.
        """
        return pulumi.get(self, "health_check_expected_status")

    @health_check_expected_status.setter
    def health_check_expected_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_expected_status", value)

    @property
    @pulumi.getter(name="healthCheckFall")
    def health_check_fall(self) -> Optional[pulumi.Input[int]]:
        """
        Sets how many failed health checks are allowed until the backend member is taken off from the rotation.
        """
        return pulumi.get(self, "health_check_fall")

    @health_check_fall.setter
    def health_check_fall(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_fall", value)

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between health checks in seconds.
        """
        return pulumi.get(self, "health_check_interval")

    @health_check_interval.setter
    def health_check_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_interval", value)

    @property
    @pulumi.getter(name="healthCheckRise")
    def health_check_rise(self) -> Optional[pulumi.Input[int]]:
        """
        Sets how many successful health checks are required to put the backend member back into rotation.
        """
        return pulumi.get(self, "health_check_rise")

    @health_check_rise.setter
    def health_check_rise(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_rise", value)

    @property
    @pulumi.getter(name="healthCheckTlsVerify")
    def health_check_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.
        """
        return pulumi.get(self, "health_check_tls_verify")

    @health_check_tls_verify.setter
    def health_check_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "health_check_tls_verify", value)

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[pulumi.Input[str]]:
        """
        Health check type.
        """
        return pulumi.get(self, "health_check_type")

    @health_check_type.setter
    def health_check_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_type", value)

    @property
    @pulumi.getter(name="healthCheckUrl")
    def health_check_url(self) -> Optional[pulumi.Input[str]]:
        """
        Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.
        """
        return pulumi.get(self, "health_check_url")

    @health_check_url.setter
    def health_check_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_url", value)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="outboundProxyProtocol")
    def outbound_proxy_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.
        """
        return pulumi.get(self, "outbound_proxy_protocol")

    @outbound_proxy_protocol.setter
    def outbound_proxy_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outbound_proxy_protocol", value)

    @property
    @pulumi.getter(name="stickySessionCookieName")
    def sticky_session_cookie_name(self) -> Optional[pulumi.Input[str]]:
        """
        Sets sticky session cookie name. Empty string disables sticky session.
        """
        return pulumi.get(self, "sticky_session_cookie_name")

    @sticky_session_cookie_name.setter
    def sticky_session_cookie_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sticky_session_cookie_name", value)

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> Optional[pulumi.Input[int]]:
        """
        Backend server timeout in seconds.
        """
        return pulumi.get(self, "timeout_server")

    @timeout_server.setter
    def timeout_server(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_server", value)

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum inactivity time on the client and server side for tunnels in seconds.
        """
        return pulumi.get(self, "timeout_tunnel")

    @timeout_tunnel.setter
    def timeout_tunnel(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_tunnel", value)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables TLS connection from the load balancer to backend servers.
        """
        return pulumi.get(self, "tls_enabled")

    @tls_enabled.setter
    def tls_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_enabled", value)

    @property
    @pulumi.getter(name="tlsUseSystemCa")
    def tls_use_system_ca(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, then the system CA certificate bundle will be used for the certificate verification.
        """
        return pulumi.get(self, "tls_use_system_ca")

    @tls_use_system_ca.setter
    def tls_use_system_ca(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_use_system_ca", value)

    @property
    @pulumi.getter(name="tlsVerify")
    def tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.
        """
        return pulumi.get(self, "tls_verify")

    @tls_verify.setter
    def tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_verify", value)


if not MYPY:
    class LoadbalancerFrontendNetworkArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the load balancer network.
        """
elif False:
    LoadbalancerFrontendNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendNetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the load balancer network.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the load balancer network.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LoadbalancerFrontendPropertiesArgsDict(TypedDict):
        http2_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable HTTP/2 support.
        """
        inbound_proxy_protocol: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable inbound proxy protocol support.
        """
        timeout_client: NotRequired[pulumi.Input[int]]
        """
        Client request timeout in seconds.
        """
elif False:
    LoadbalancerFrontendPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendPropertiesArgs:
    def __init__(__self__, *,
                 http2_enabled: Optional[pulumi.Input[bool]] = None,
                 inbound_proxy_protocol: Optional[pulumi.Input[bool]] = None,
                 timeout_client: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] http2_enabled: Enable or disable HTTP/2 support.
        :param pulumi.Input[bool] inbound_proxy_protocol: Enable or disable inbound proxy protocol support.
        :param pulumi.Input[int] timeout_client: Client request timeout in seconds.
        """
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if inbound_proxy_protocol is not None:
            pulumi.set(__self__, "inbound_proxy_protocol", inbound_proxy_protocol)
        if timeout_client is not None:
            pulumi.set(__self__, "timeout_client", timeout_client)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable HTTP/2 support.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_enabled", value)

    @property
    @pulumi.getter(name="inboundProxyProtocol")
    def inbound_proxy_protocol(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable inbound proxy protocol support.
        """
        return pulumi.get(self, "inbound_proxy_protocol")

    @inbound_proxy_protocol.setter
    def inbound_proxy_protocol(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inbound_proxy_protocol", value)

    @property
    @pulumi.getter(name="timeoutClient")
    def timeout_client(self) -> Optional[pulumi.Input[int]]:
        """
        Client request timeout in seconds.
        """
        return pulumi.get(self, "timeout_client")

    @timeout_client.setter
    def timeout_client(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_client", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsArgsDict(TypedDict):
        http_redirects: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgsDict']]]]
        """
        Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.
        """
        http_returns: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgsDict']]]]
        """
        Returns HTTP response with specified HTTP status.
        """
        set_forwarded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgsDict']]]]
        """
        Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests
        """
        tcp_rejects: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgsDict']]]]
        """
        Terminates a connection.
        """
        use_backends: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgsDict']]]]
        """
        Routes traffic to specified `backend`.
        """
elif False:
    LoadbalancerFrontendRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsArgs:
    def __init__(__self__, *,
                 http_redirects: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgs']]]] = None,
                 http_returns: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgs']]]] = None,
                 set_forwarded_headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs']]]] = None,
                 tcp_rejects: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgs']]]] = None,
                 use_backends: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgs']]] http_redirects: Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgs']]] http_returns: Returns HTTP response with specified HTTP status.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs']]] set_forwarded_headers: Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgs']]] tcp_rejects: Terminates a connection.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgs']]] use_backends: Routes traffic to specified `backend`.
        """
        if http_redirects is not None:
            pulumi.set(__self__, "http_redirects", http_redirects)
        if http_returns is not None:
            pulumi.set(__self__, "http_returns", http_returns)
        if set_forwarded_headers is not None:
            pulumi.set(__self__, "set_forwarded_headers", set_forwarded_headers)
        if tcp_rejects is not None:
            pulumi.set(__self__, "tcp_rejects", tcp_rejects)
        if use_backends is not None:
            pulumi.set(__self__, "use_backends", use_backends)

    @property
    @pulumi.getter(name="httpRedirects")
    def http_redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgs']]]]:
        """
        Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.
        """
        return pulumi.get(self, "http_redirects")

    @http_redirects.setter
    def http_redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpRedirectArgs']]]]):
        pulumi.set(self, "http_redirects", value)

    @property
    @pulumi.getter(name="httpReturns")
    def http_returns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgs']]]]:
        """
        Returns HTTP response with specified HTTP status.
        """
        return pulumi.get(self, "http_returns")

    @http_returns.setter
    def http_returns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsHttpReturnArgs']]]]):
        pulumi.set(self, "http_returns", value)

    @property
    @pulumi.getter(name="setForwardedHeaders")
    def set_forwarded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs']]]]:
        """
        Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests
        """
        return pulumi.get(self, "set_forwarded_headers")

    @set_forwarded_headers.setter
    def set_forwarded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs']]]]):
        pulumi.set(self, "set_forwarded_headers", value)

    @property
    @pulumi.getter(name="tcpRejects")
    def tcp_rejects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgs']]]]:
        """
        Terminates a connection.
        """
        return pulumi.get(self, "tcp_rejects")

    @tcp_rejects.setter
    def tcp_rejects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsTcpRejectArgs']]]]):
        pulumi.set(self, "tcp_rejects", value)

    @property
    @pulumi.getter(name="useBackends")
    def use_backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgs']]]]:
        """
        Routes traffic to specified `backend`.
        """
        return pulumi.get(self, "use_backends")

    @use_backends.setter
    def use_backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleActionsUseBackendArgs']]]]):
        pulumi.set(self, "use_backends", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsHttpRedirectArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[str]]
        """
        Target location.
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
        Target scheme.
        """
elif False:
    LoadbalancerFrontendRuleActionsHttpRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsHttpRedirectArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[str]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location: Target location.
        :param pulumi.Input[str] scheme: Target scheme.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Target location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Target scheme.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsHttpReturnArgsDict(TypedDict):
        content_type: pulumi.Input[str]
        """
        Content type.
        """
        payload: pulumi.Input[str]
        """
        The payload.
        """
        status: pulumi.Input[int]
        """
        HTTP status code.
        """
elif False:
    LoadbalancerFrontendRuleActionsHttpReturnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsHttpReturnArgs:
    def __init__(__self__, *,
                 content_type: pulumi.Input[str],
                 payload: pulumi.Input[str],
                 status: pulumi.Input[int]):
        """
        :param pulumi.Input[str] content_type: Content type.
        :param pulumi.Input[str] payload: The payload.
        :param pulumi.Input[int] status: HTTP status code.
        """
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        Content type.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def payload(self) -> pulumi.Input[str]:
        """
        The payload.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[str]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[int]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[int]):
        pulumi.set(self, "status", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsSetForwardedHeaderArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
elif False:
    LoadbalancerFrontendRuleActionsSetForwardedHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None):
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsTcpRejectArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
        """
        Indicates if the rule is active.
        """
elif False:
    LoadbalancerFrontendRuleActionsTcpRejectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsTcpRejectArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] active: Indicates if the rule is active.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the rule is active.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class LoadbalancerFrontendRuleActionsUseBackendArgsDict(TypedDict):
        backend_name: pulumi.Input[str]
        """
        The name of the backend where traffic will be routed.
        """
elif False:
    LoadbalancerFrontendRuleActionsUseBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleActionsUseBackendArgs:
    def __init__(__self__, *,
                 backend_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] backend_name: The name of the backend where traffic will be routed.
        """
        pulumi.set(__self__, "backend_name", backend_name)

    @property
    @pulumi.getter(name="backendName")
    def backend_name(self) -> pulumi.Input[str]:
        """
        The name of the backend where traffic will be routed.
        """
        return pulumi.get(self, "backend_name")

    @backend_name.setter
    def backend_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_name", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersArgsDict(TypedDict):
        body_size_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgsDict']]]]
        """
        Matches by range of HTTP request body sizes.
        """
        body_sizes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgsDict']]]]
        """
        Matches by HTTP request body size.
        """
        cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgsDict']]]]
        """
        Matches by HTTP cookie value. Cookie name must be provided.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgsDict']]]]
        """
        Matches by HTTP header value. Header name must be provided.
        """
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgsDict']]]]
        """
        Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.
        """
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgsDict']]]]
        """
        Matches by HTTP method.
        """
        num_members_ups: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgsDict']]]]
        """
        Matches by number of healthy backend members.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgsDict']]]]
        """
        Matches by URL path.
        """
        src_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgsDict']]]]
        """
        Matches by source IP address.
        """
        src_port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgsDict']]]]
        """
        Matches by range of source port numbers.
        """
        src_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgsDict']]]]
        """
        Matches by source port number.
        """
        url_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgsDict']]]]
        """
        Matches by URL query parameter value. Query parameter name must be provided
        """
        url_queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgsDict']]]]
        """
        Matches by URL query string.
        """
        urls: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgsDict']]]]
        """
        Matches by URL without schema, e.g. `example.com/dashboard`.
        """
elif False:
    LoadbalancerFrontendRuleMatchersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersArgs:
    def __init__(__self__, *,
                 body_size_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs']]]] = None,
                 body_sizes: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgs']]]] = None,
                 cookies: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgs']]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgs']]]] = None,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgs']]]] = None,
                 num_members_ups: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgs']]]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgs']]]] = None,
                 src_ips: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgs']]]] = None,
                 src_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs']]]] = None,
                 src_ports: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgs']]]] = None,
                 url_params: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgs']]]] = None,
                 url_queries: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgs']]]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs']]] body_size_ranges: Matches by range of HTTP request body sizes.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgs']]] body_sizes: Matches by HTTP request body size.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgs']]] cookies: Matches by HTTP cookie value. Cookie name must be provided.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgs']]] headers: Matches by HTTP header value. Header name must be provided.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgs']]] hosts: Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgs']]] http_methods: Matches by HTTP method.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgs']]] num_members_ups: Matches by number of healthy backend members.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgs']]] paths: Matches by URL path.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgs']]] src_ips: Matches by source IP address.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs']]] src_port_ranges: Matches by range of source port numbers.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgs']]] src_ports: Matches by source port number.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgs']]] url_params: Matches by URL query parameter value. Query parameter name must be provided
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgs']]] url_queries: Matches by URL query string.
        :param pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgs']]] urls: Matches by URL without schema, e.g. `example.com/dashboard`.
        """
        if body_size_ranges is not None:
            pulumi.set(__self__, "body_size_ranges", body_size_ranges)
        if body_sizes is not None:
            pulumi.set(__self__, "body_sizes", body_sizes)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if num_members_ups is not None:
            pulumi.set(__self__, "num_members_ups", num_members_ups)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if src_ips is not None:
            pulumi.set(__self__, "src_ips", src_ips)
        if src_port_ranges is not None:
            pulumi.set(__self__, "src_port_ranges", src_port_ranges)
        if src_ports is not None:
            pulumi.set(__self__, "src_ports", src_ports)
        if url_params is not None:
            pulumi.set(__self__, "url_params", url_params)
        if url_queries is not None:
            pulumi.set(__self__, "url_queries", url_queries)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="bodySizeRanges")
    def body_size_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs']]]]:
        """
        Matches by range of HTTP request body sizes.
        """
        return pulumi.get(self, "body_size_ranges")

    @body_size_ranges.setter
    def body_size_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs']]]]):
        pulumi.set(self, "body_size_ranges", value)

    @property
    @pulumi.getter(name="bodySizes")
    def body_sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgs']]]]:
        """
        Matches by HTTP request body size.
        """
        return pulumi.get(self, "body_sizes")

    @body_sizes.setter
    def body_sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersBodySizeArgs']]]]):
        pulumi.set(self, "body_sizes", value)

    @property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgs']]]]:
        """
        Matches by HTTP cookie value. Cookie name must be provided.
        """
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersCookieArgs']]]]):
        pulumi.set(self, "cookies", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgs']]]]:
        """
        Matches by HTTP header value. Header name must be provided.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgs']]]]:
        """
        Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHostArgs']]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgs']]]]:
        """
        Matches by HTTP method.
        """
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersHttpMethodArgs']]]]):
        pulumi.set(self, "http_methods", value)

    @property
    @pulumi.getter(name="numMembersUps")
    def num_members_ups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgs']]]]:
        """
        Matches by number of healthy backend members.
        """
        return pulumi.get(self, "num_members_ups")

    @num_members_ups.setter
    def num_members_ups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersNumMembersUpArgs']]]]):
        pulumi.set(self, "num_members_ups", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgs']]]]:
        """
        Matches by URL path.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersPathArgs']]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgs']]]]:
        """
        Matches by source IP address.
        """
        return pulumi.get(self, "src_ips")

    @src_ips.setter
    def src_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcIpArgs']]]]):
        pulumi.set(self, "src_ips", value)

    @property
    @pulumi.getter(name="srcPortRanges")
    def src_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs']]]]:
        """
        Matches by range of source port numbers.
        """
        return pulumi.get(self, "src_port_ranges")

    @src_port_ranges.setter
    def src_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs']]]]):
        pulumi.set(self, "src_port_ranges", value)

    @property
    @pulumi.getter(name="srcPorts")
    def src_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgs']]]]:
        """
        Matches by source port number.
        """
        return pulumi.get(self, "src_ports")

    @src_ports.setter
    def src_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersSrcPortArgs']]]]):
        pulumi.set(self, "src_ports", value)

    @property
    @pulumi.getter(name="urlParams")
    def url_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgs']]]]:
        """
        Matches by URL query parameter value. Query parameter name must be provided
        """
        return pulumi.get(self, "url_params")

    @url_params.setter
    def url_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlParamArgs']]]]):
        pulumi.set(self, "url_params", value)

    @property
    @pulumi.getter(name="urlQueries")
    def url_queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgs']]]]:
        """
        Matches by URL query string.
        """
        return pulumi.get(self, "url_queries")

    @url_queries.setter
    def url_queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlQueryArgs']]]]):
        pulumi.set(self, "url_queries", value)

    @property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgs']]]]:
        """
        Matches by URL without schema, e.g. `example.com/dashboard`.
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerFrontendRuleMatchersUrlArgs']]]]):
        pulumi.set(self, "urls", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersBodySizeArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        value: pulumi.Input[int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersBodySizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersBodySizeArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 value: pulumi.Input[int],
                 inverse: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param pulumi.Input[int] value: Integer value.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersBodySizeRangeArgsDict(TypedDict):
        range_end: pulumi.Input[int]
        """
        Integer value.
        """
        range_start: pulumi.Input[int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersBodySizeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersBodySizeRangeArgs:
    def __init__(__self__, *,
                 range_end: pulumi.Input[int],
                 range_start: pulumi.Input[int],
                 inverse: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] range_end: Integer value.
        :param pulumi.Input[int] range_start: Integer value.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> pulumi.Input[int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_end")

    @range_end.setter
    def range_end(self, value: pulumi.Input[int]):
        pulumi.set(self, "range_end", value)

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> pulumi.Input[int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_start")

    @range_start.setter
    def range_start(self, value: pulumi.Input[int]):
        pulumi.set(self, "range_start", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersCookieArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        name: pulumi.Input[str]
        """
        Name of the argument.
        """
        ignore_case: NotRequired[pulumi.Input[bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersCookieArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 name: pulumi.Input[str],
                 ignore_case: Optional[pulumi.Input[bool]] = None,
                 inverse: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[str] name: Name of the argument.
        :param pulumi.Input[bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersHeaderArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        name: pulumi.Input[str]
        """
        Name of the argument.
        """
        ignore_case: NotRequired[pulumi.Input[bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersHeaderArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 name: pulumi.Input[str],
                 ignore_case: Optional[pulumi.Input[bool]] = None,
                 inverse: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[str] name: Name of the argument.
        :param pulumi.Input[bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersHostArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        String value.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersHostArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 inverse: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] value: String value.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersHttpMethodArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersHttpMethodArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 inverse: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] value: String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersNumMembersUpArgsDict(TypedDict):
        backend_name: pulumi.Input[str]
        """
        The name of the `backend`.
        """
        method: pulumi.Input[str]
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        value: pulumi.Input[int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersNumMembersUpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersNumMembersUpArgs:
    def __init__(__self__, *,
                 backend_name: pulumi.Input[str],
                 method: pulumi.Input[str],
                 value: pulumi.Input[int],
                 inverse: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] backend_name: The name of the `backend`.
        :param pulumi.Input[str] method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param pulumi.Input[int] value: Integer value.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "backend_name", backend_name)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="backendName")
    def backend_name(self) -> pulumi.Input[str]:
        """
        The name of the `backend`.
        """
        return pulumi.get(self, "backend_name")

    @backend_name.setter
    def backend_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_name", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersPathArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        ignore_case: NotRequired[pulumi.Input[bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersPathArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 ignore_case: Optional[pulumi.Input[bool]] = None,
                 inverse: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersSrcIpArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersSrcIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersSrcIpArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 inverse: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] value: IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersSrcPortArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        value: pulumi.Input[int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersSrcPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersSrcPortArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 value: pulumi.Input[int],
                 inverse: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param pulumi.Input[int] value: Integer value.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersSrcPortRangeArgsDict(TypedDict):
        range_end: pulumi.Input[int]
        """
        Integer value.
        """
        range_start: pulumi.Input[int]
        """
        Integer value.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
elif False:
    LoadbalancerFrontendRuleMatchersSrcPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersSrcPortRangeArgs:
    def __init__(__self__, *,
                 range_end: pulumi.Input[int],
                 range_start: pulumi.Input[int],
                 inverse: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] range_end: Integer value.
        :param pulumi.Input[int] range_start: Integer value.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> pulumi.Input[int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_end")

    @range_end.setter
    def range_end(self, value: pulumi.Input[int]):
        pulumi.set(self, "range_end", value)

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> pulumi.Input[int]:
        """
        Integer value.
        """
        return pulumi.get(self, "range_start")

    @range_start.setter
    def range_start(self, value: pulumi.Input[int]):
        pulumi.set(self, "range_start", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersUrlArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        ignore_case: NotRequired[pulumi.Input[bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersUrlArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 ignore_case: Optional[pulumi.Input[bool]] = None,
                 inverse: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersUrlParamArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        name: pulumi.Input[str]
        """
        Name of the argument.
        """
        ignore_case: NotRequired[pulumi.Input[bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersUrlParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersUrlParamArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 name: pulumi.Input[str],
                 ignore_case: Optional[pulumi.Input[bool]] = None,
                 inverse: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[str] name: Name of the argument.
        :param pulumi.Input[bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerFrontendRuleMatchersUrlQueryArgsDict(TypedDict):
        method: pulumi.Input[str]
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        ignore_case: NotRequired[pulumi.Input[bool]]
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        inverse: NotRequired[pulumi.Input[bool]]
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        String value.
        """
elif False:
    LoadbalancerFrontendRuleMatchersUrlQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerFrontendRuleMatchersUrlQueryArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 ignore_case: Optional[pulumi.Input[bool]] = None,
                 inverse: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param pulumi.Input[bool] ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param pulumi.Input[bool] inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param pulumi.Input[str] value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_case", value)

    @property
    @pulumi.getter
    def inverse(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @inverse.setter
    def inverse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inverse", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadbalancerNetworkArgsDict(TypedDict):
        family: pulumi.Input[str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[str]
        """
        The name of the network must be unique within the service.
        """
        type: pulumi.Input[str]
        """
        The type of the network. Only one public network can be attached and at least one private network must be attached.
        """
        dns_name: NotRequired[pulumi.Input[str]]
        """
        DNS name of the load balancer network
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Network identifier.
        """
        network: NotRequired[pulumi.Input[str]]
        """
        Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.
        """
elif False:
    LoadbalancerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 dns_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[str] name: The name of the network must be unique within the service.
        :param pulumi.Input[str] type: The type of the network. Only one public network can be attached and at least one private network must be attached.
        :param pulumi.Input[str] dns_name: DNS name of the load balancer network
        :param pulumi.Input[str] id: Network identifier.
        :param pulumi.Input[str] network: Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the network must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the network. Only one public network can be attached and at least one private network must be attached.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name of the load balancer network
        """
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Network identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)


if not MYPY:
    class LoadbalancerNodeArgsDict(TypedDict):
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgsDict']]]]
        operational_state: NotRequired[pulumi.Input[str]]
        """
        Node's operational state. Managed by the system.
        """
elif False:
    LoadbalancerNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerNodeArgs:
    def __init__(__self__, *,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgs']]]] = None,
                 operational_state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operational_state: Node's operational state. Managed by the system.
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgs']]]]:
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkArgs']]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[pulumi.Input[str]]:
        """
        Node's operational state. Managed by the system.
        """
        return pulumi.get(self, "operational_state")

    @operational_state.setter
    def operational_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operational_state", value)


if not MYPY:
    class LoadbalancerNodeNetworkArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the network.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the network.
        """
elif False:
    LoadbalancerNodeNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerNodeNetworkArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the network.
        :param pulumi.Input[str] type: The type of the network.
        """
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadbalancerNodeNetworkIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the network.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the network.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LoadbalancerNodeNetworkIpAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        Node's IP address.
        """
        listen: NotRequired[pulumi.Input[bool]]
        """
        Does IP address listen network connections.
        """
elif False:
    LoadbalancerNodeNetworkIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadbalancerNodeNetworkIpAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 listen: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] address: Node's IP address.
        :param pulumi.Input[bool] listen: Does IP address listen network connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if listen is not None:
            pulumi.set(__self__, "listen", listen)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Node's IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def listen(self) -> Optional[pulumi.Input[bool]]:
        """
        Does IP address listen network connections.
        """
        return pulumi.get(self, "listen")

    @listen.setter
    def listen(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "listen", value)


if not MYPY:
    class ManagedDatabaseMysqlComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabaseMysqlComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 route: Optional[pulumi.Input[str]] = None,
                 usage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] component: Type of the component
        :param pulumi.Input[str] host: Hostname of the component
        :param pulumi.Input[int] port: Port number of the component
        :param pulumi.Input[str] route: Component network route type
        :param pulumi.Input[str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabaseMysqlNetworkArgsDict(TypedDict):
        family: pulumi.Input[str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabaseMysqlNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uuid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[str] type: The type of the network. Must be private.
        :param pulumi.Input[str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabaseMysqlNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[str]]
        """
        State of the node
        """
elif False:
    ManagedDatabaseMysqlNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name plus a node iteration
        :param pulumi.Input[str] role: Role of the node
        :param pulumi.Input[str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabaseMysqlPropertiesArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[str]]
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        admin_username: NotRequired[pulumi.Input[str]]
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        backup_hour: NotRequired[pulumi.Input[int]]
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        backup_minute: NotRequired[pulumi.Input[int]]
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        binlog_retention_period: NotRequired[pulumi.Input[int]]
        """
        The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        """
        connect_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
        """
        default_time_zone: NotRequired[pulumi.Input[str]]
        """
        Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
        """
        group_concat_max_len: NotRequired[pulumi.Input[int]]
        """
        The maximum permitted result length in bytes for the GROUP_CONCAT() function.
        """
        information_schema_stats_expiry: NotRequired[pulumi.Input[int]]
        """
        The time, in seconds, before cached statistics expire.
        """
        innodb_change_buffer_max_size: NotRequired[pulumi.Input[int]]
        """
        Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
        """
        innodb_flush_neighbors: NotRequired[pulumi.Input[int]]
        """
        Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
        """
        innodb_ft_min_token_size: NotRequired[pulumi.Input[int]]
        """
        Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
        """
        innodb_ft_server_stopword_table: NotRequired[pulumi.Input[str]]
        """
        This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
        """
        innodb_lock_wait_timeout: NotRequired[pulumi.Input[int]]
        """
        The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
        """
        innodb_log_buffer_size: NotRequired[pulumi.Input[int]]
        """
        The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
        """
        innodb_online_alter_log_max_size: NotRequired[pulumi.Input[int]]
        """
        The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
        """
        innodb_print_all_deadlocks: NotRequired[pulumi.Input[bool]]
        """
        When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
        """
        innodb_read_io_threads: NotRequired[pulumi.Input[int]]
        """
        The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        innodb_rollback_on_timeout: NotRequired[pulumi.Input[bool]]
        """
        When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
        """
        innodb_thread_concurrency: NotRequired[pulumi.Input[int]]
        """
        Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
        """
        innodb_write_io_threads: NotRequired[pulumi.Input[int]]
        """
        The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        interactive_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds the server waits for activity on an interactive connection before closing it.
        """
        internal_tmp_mem_storage_engine: NotRequired[pulumi.Input[str]]
        """
        The storage engine for in-memory internal temporary tables.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        long_query_time: NotRequired[pulumi.Input[float]]
        """
        The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute. Default is 10s.
        """
        max_allowed_packet: NotRequired[pulumi.Input[int]]
        """
        Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
        """
        max_heap_table_size: NotRequired[pulumi.Input[int]]
        """
        Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
        """
        migration: NotRequired[pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgsDict']]
        """
        Migrate data from existing server.
        """
        net_buffer_length: NotRequired[pulumi.Input[int]]
        """
        Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
        """
        net_read_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait for more data from a connection before aborting the read.
        """
        net_write_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait for a block to be written to a connection before aborting the write.
        """
        public_access: NotRequired[pulumi.Input[bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        service_log: NotRequired[pulumi.Input[bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        slow_query_log: NotRequired[pulumi.Input[bool]]
        """
        Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table. Default is off.
        """
        sort_buffer_size: NotRequired[pulumi.Input[int]]
        """
        Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
        """
        sql_mode: NotRequired[pulumi.Input[str]]
        """
        Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
        """
        sql_require_primary_key: NotRequired[pulumi.Input[bool]]
        """
        Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        """
        tmp_table_size: NotRequired[pulumi.Input[int]]
        """
        Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        """
        version: NotRequired[pulumi.Input[str]]
        """
        MySQL major version.
        """
        wait_timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
elif False:
    ManagedDatabaseMysqlPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlPropertiesArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[bool]] = None,
                 backup_hour: Optional[pulumi.Input[int]] = None,
                 backup_minute: Optional[pulumi.Input[int]] = None,
                 binlog_retention_period: Optional[pulumi.Input[int]] = None,
                 connect_timeout: Optional[pulumi.Input[int]] = None,
                 default_time_zone: Optional[pulumi.Input[str]] = None,
                 group_concat_max_len: Optional[pulumi.Input[int]] = None,
                 information_schema_stats_expiry: Optional[pulumi.Input[int]] = None,
                 innodb_change_buffer_max_size: Optional[pulumi.Input[int]] = None,
                 innodb_flush_neighbors: Optional[pulumi.Input[int]] = None,
                 innodb_ft_min_token_size: Optional[pulumi.Input[int]] = None,
                 innodb_ft_server_stopword_table: Optional[pulumi.Input[str]] = None,
                 innodb_lock_wait_timeout: Optional[pulumi.Input[int]] = None,
                 innodb_log_buffer_size: Optional[pulumi.Input[int]] = None,
                 innodb_online_alter_log_max_size: Optional[pulumi.Input[int]] = None,
                 innodb_print_all_deadlocks: Optional[pulumi.Input[bool]] = None,
                 innodb_read_io_threads: Optional[pulumi.Input[int]] = None,
                 innodb_rollback_on_timeout: Optional[pulumi.Input[bool]] = None,
                 innodb_thread_concurrency: Optional[pulumi.Input[int]] = None,
                 innodb_write_io_threads: Optional[pulumi.Input[int]] = None,
                 interactive_timeout: Optional[pulumi.Input[int]] = None,
                 internal_tmp_mem_storage_engine: Optional[pulumi.Input[str]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 long_query_time: Optional[pulumi.Input[float]] = None,
                 max_allowed_packet: Optional[pulumi.Input[int]] = None,
                 max_heap_table_size: Optional[pulumi.Input[int]] = None,
                 migration: Optional[pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgs']] = None,
                 net_buffer_length: Optional[pulumi.Input[int]] = None,
                 net_read_timeout: Optional[pulumi.Input[int]] = None,
                 net_write_timeout: Optional[pulumi.Input[int]] = None,
                 public_access: Optional[pulumi.Input[bool]] = None,
                 service_log: Optional[pulumi.Input[bool]] = None,
                 slow_query_log: Optional[pulumi.Input[bool]] = None,
                 sort_buffer_size: Optional[pulumi.Input[int]] = None,
                 sql_mode: Optional[pulumi.Input[str]] = None,
                 sql_require_primary_key: Optional[pulumi.Input[bool]] = None,
                 tmp_table_size: Optional[pulumi.Input[int]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 wait_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] admin_password: Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        :param pulumi.Input[str] admin_username: Custom username for admin user. This must be set only when a new service is being created.
        :param pulumi.Input[bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[int] backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[int] backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[int] binlog_retention_period: The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        :param pulumi.Input[int] connect_timeout: The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
        :param pulumi.Input[str] default_time_zone: Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
        :param pulumi.Input[int] group_concat_max_len: The maximum permitted result length in bytes for the GROUP_CONCAT() function.
        :param pulumi.Input[int] information_schema_stats_expiry: The time, in seconds, before cached statistics expire.
        :param pulumi.Input[int] innodb_change_buffer_max_size: Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
        :param pulumi.Input[int] innodb_flush_neighbors: Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
        :param pulumi.Input[int] innodb_ft_min_token_size: Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[str] innodb_ft_server_stopword_table: This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
        :param pulumi.Input[int] innodb_lock_wait_timeout: The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
        :param pulumi.Input[int] innodb_log_buffer_size: The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
        :param pulumi.Input[int] innodb_online_alter_log_max_size: The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
        :param pulumi.Input[bool] innodb_print_all_deadlocks: When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
        :param pulumi.Input[int] innodb_read_io_threads: The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[bool] innodb_rollback_on_timeout: When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[int] innodb_thread_concurrency: Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
        :param pulumi.Input[int] innodb_write_io_threads: The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[int] interactive_timeout: The number of seconds the server waits for activity on an interactive connection before closing it.
        :param pulumi.Input[str] internal_tmp_mem_storage_engine: The storage engine for in-memory internal temporary tables.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input[float] long_query_time: The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute. Default is 10s.
        :param pulumi.Input[int] max_allowed_packet: Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
        :param pulumi.Input[int] max_heap_table_size: Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
        :param pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgs'] migration: Migrate data from existing server.
        :param pulumi.Input[int] net_buffer_length: Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
        :param pulumi.Input[int] net_read_timeout: The number of seconds to wait for more data from a connection before aborting the read.
        :param pulumi.Input[int] net_write_timeout: The number of seconds to wait for a block to be written to a connection before aborting the write.
        :param pulumi.Input[bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param pulumi.Input[bool] slow_query_log: Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table. Default is off.
        :param pulumi.Input[int] sort_buffer_size: Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
        :param pulumi.Input[str] sql_mode: Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
        :param pulumi.Input[bool] sql_require_primary_key: Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        :param pulumi.Input[int] tmp_table_size: Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        :param pulumi.Input[str] version: MySQL major version.
        :param pulumi.Input[int] wait_timeout: The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if binlog_retention_period is not None:
            pulumi.set(__self__, "binlog_retention_period", binlog_retention_period)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if default_time_zone is not None:
            pulumi.set(__self__, "default_time_zone", default_time_zone)
        if group_concat_max_len is not None:
            pulumi.set(__self__, "group_concat_max_len", group_concat_max_len)
        if information_schema_stats_expiry is not None:
            pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        if innodb_change_buffer_max_size is not None:
            pulumi.set(__self__, "innodb_change_buffer_max_size", innodb_change_buffer_max_size)
        if innodb_flush_neighbors is not None:
            pulumi.set(__self__, "innodb_flush_neighbors", innodb_flush_neighbors)
        if innodb_ft_min_token_size is not None:
            pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        if innodb_ft_server_stopword_table is not None:
            pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        if innodb_lock_wait_timeout is not None:
            pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        if innodb_log_buffer_size is not None:
            pulumi.set(__self__, "innodb_log_buffer_size", innodb_log_buffer_size)
        if innodb_online_alter_log_max_size is not None:
            pulumi.set(__self__, "innodb_online_alter_log_max_size", innodb_online_alter_log_max_size)
        if innodb_print_all_deadlocks is not None:
            pulumi.set(__self__, "innodb_print_all_deadlocks", innodb_print_all_deadlocks)
        if innodb_read_io_threads is not None:
            pulumi.set(__self__, "innodb_read_io_threads", innodb_read_io_threads)
        if innodb_rollback_on_timeout is not None:
            pulumi.set(__self__, "innodb_rollback_on_timeout", innodb_rollback_on_timeout)
        if innodb_thread_concurrency is not None:
            pulumi.set(__self__, "innodb_thread_concurrency", innodb_thread_concurrency)
        if innodb_write_io_threads is not None:
            pulumi.set(__self__, "innodb_write_io_threads", innodb_write_io_threads)
        if interactive_timeout is not None:
            pulumi.set(__self__, "interactive_timeout", interactive_timeout)
        if internal_tmp_mem_storage_engine is not None:
            pulumi.set(__self__, "internal_tmp_mem_storage_engine", internal_tmp_mem_storage_engine)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if long_query_time is not None:
            pulumi.set(__self__, "long_query_time", long_query_time)
        if max_allowed_packet is not None:
            pulumi.set(__self__, "max_allowed_packet", max_allowed_packet)
        if max_heap_table_size is not None:
            pulumi.set(__self__, "max_heap_table_size", max_heap_table_size)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if net_buffer_length is not None:
            pulumi.set(__self__, "net_buffer_length", net_buffer_length)
        if net_read_timeout is not None:
            pulumi.set(__self__, "net_read_timeout", net_read_timeout)
        if net_write_timeout is not None:
            pulumi.set(__self__, "net_write_timeout", net_write_timeout)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if slow_query_log is not None:
            pulumi.set(__self__, "slow_query_log", slow_query_log)
        if sort_buffer_size is not None:
            pulumi.set(__self__, "sort_buffer_size", sort_buffer_size)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if sql_require_primary_key is not None:
            pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        if tmp_table_size is not None:
            pulumi.set(__self__, "tmp_table_size", tmp_table_size)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if wait_timeout is not None:
            pulumi.set(__self__, "wait_timeout", wait_timeout)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[pulumi.Input[int]]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @backup_hour.setter
    def backup_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_hour", value)

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[pulumi.Input[int]]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @backup_minute.setter
    def backup_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_minute", value)

    @property
    @pulumi.getter(name="binlogRetentionPeriod")
    def binlog_retention_period(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        """
        return pulumi.get(self, "binlog_retention_period")

    @binlog_retention_period.setter
    def binlog_retention_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "binlog_retention_period", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="defaultTimeZone")
    def default_time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
        """
        return pulumi.get(self, "default_time_zone")

    @default_time_zone.setter
    def default_time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_time_zone", value)

    @property
    @pulumi.getter(name="groupConcatMaxLen")
    def group_concat_max_len(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum permitted result length in bytes for the GROUP_CONCAT() function.
        """
        return pulumi.get(self, "group_concat_max_len")

    @group_concat_max_len.setter
    def group_concat_max_len(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_concat_max_len", value)

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> Optional[pulumi.Input[int]]:
        """
        The time, in seconds, before cached statistics expire.
        """
        return pulumi.get(self, "information_schema_stats_expiry")

    @information_schema_stats_expiry.setter
    def information_schema_stats_expiry(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "information_schema_stats_expiry", value)

    @property
    @pulumi.getter(name="innodbChangeBufferMaxSize")
    def innodb_change_buffer_max_size(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
        """
        return pulumi.get(self, "innodb_change_buffer_max_size")

    @innodb_change_buffer_max_size.setter
    def innodb_change_buffer_max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_change_buffer_max_size", value)

    @property
    @pulumi.getter(name="innodbFlushNeighbors")
    def innodb_flush_neighbors(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
        """
        return pulumi.get(self, "innodb_flush_neighbors")

    @innodb_flush_neighbors.setter
    def innodb_flush_neighbors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_flush_neighbors", value)

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_ft_min_token_size")

    @innodb_ft_min_token_size.setter
    def innodb_ft_min_token_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_ft_min_token_size", value)

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> Optional[pulumi.Input[str]]:
        """
        This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
        """
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @innodb_ft_server_stopword_table.setter
    def innodb_ft_server_stopword_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "innodb_ft_server_stopword_table", value)

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
        """
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @innodb_lock_wait_timeout.setter
    def innodb_lock_wait_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_lock_wait_timeout", value)

    @property
    @pulumi.getter(name="innodbLogBufferSize")
    def innodb_log_buffer_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
        """
        return pulumi.get(self, "innodb_log_buffer_size")

    @innodb_log_buffer_size.setter
    def innodb_log_buffer_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_log_buffer_size", value)

    @property
    @pulumi.getter(name="innodbOnlineAlterLogMaxSize")
    def innodb_online_alter_log_max_size(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
        """
        return pulumi.get(self, "innodb_online_alter_log_max_size")

    @innodb_online_alter_log_max_size.setter
    def innodb_online_alter_log_max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_online_alter_log_max_size", value)

    @property
    @pulumi.getter(name="innodbPrintAllDeadlocks")
    def innodb_print_all_deadlocks(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
        """
        return pulumi.get(self, "innodb_print_all_deadlocks")

    @innodb_print_all_deadlocks.setter
    def innodb_print_all_deadlocks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "innodb_print_all_deadlocks", value)

    @property
    @pulumi.getter(name="innodbReadIoThreads")
    def innodb_read_io_threads(self) -> Optional[pulumi.Input[int]]:
        """
        The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_read_io_threads")

    @innodb_read_io_threads.setter
    def innodb_read_io_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_read_io_threads", value)

    @property
    @pulumi.getter(name="innodbRollbackOnTimeout")
    def innodb_rollback_on_timeout(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_rollback_on_timeout")

    @innodb_rollback_on_timeout.setter
    def innodb_rollback_on_timeout(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "innodb_rollback_on_timeout", value)

    @property
    @pulumi.getter(name="innodbThreadConcurrency")
    def innodb_thread_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
        """
        return pulumi.get(self, "innodb_thread_concurrency")

    @innodb_thread_concurrency.setter
    def innodb_thread_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_thread_concurrency", value)

    @property
    @pulumi.getter(name="innodbWriteIoThreads")
    def innodb_write_io_threads(self) -> Optional[pulumi.Input[int]]:
        """
        The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_write_io_threads")

    @innodb_write_io_threads.setter
    def innodb_write_io_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "innodb_write_io_threads", value)

    @property
    @pulumi.getter(name="interactiveTimeout")
    def interactive_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds the server waits for activity on an interactive connection before closing it.
        """
        return pulumi.get(self, "interactive_timeout")

    @interactive_timeout.setter
    def interactive_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interactive_timeout", value)

    @property
    @pulumi.getter(name="internalTmpMemStorageEngine")
    def internal_tmp_mem_storage_engine(self) -> Optional[pulumi.Input[str]]:
        """
        The storage engine for in-memory internal temporary tables.
        """
        return pulumi.get(self, "internal_tmp_mem_storage_engine")

    @internal_tmp_mem_storage_engine.setter
    def internal_tmp_mem_storage_engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_tmp_mem_storage_engine", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="longQueryTime")
    def long_query_time(self) -> Optional[pulumi.Input[float]]:
        """
        The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute. Default is 10s.
        """
        return pulumi.get(self, "long_query_time")

    @long_query_time.setter
    def long_query_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_query_time", value)

    @property
    @pulumi.getter(name="maxAllowedPacket")
    def max_allowed_packet(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
        """
        return pulumi.get(self, "max_allowed_packet")

    @max_allowed_packet.setter
    def max_allowed_packet(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_allowed_packet", value)

    @property
    @pulumi.getter(name="maxHeapTableSize")
    def max_heap_table_size(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
        """
        return pulumi.get(self, "max_heap_table_size")

    @max_heap_table_size.setter
    def max_heap_table_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_heap_table_size", value)

    @property
    @pulumi.getter
    def migration(self) -> Optional[pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgs']]:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @migration.setter
    def migration(self, value: Optional[pulumi.Input['ManagedDatabaseMysqlPropertiesMigrationArgs']]):
        pulumi.set(self, "migration", value)

    @property
    @pulumi.getter(name="netBufferLength")
    def net_buffer_length(self) -> Optional[pulumi.Input[int]]:
        """
        Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "net_buffer_length")

    @net_buffer_length.setter
    def net_buffer_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_buffer_length", value)

    @property
    @pulumi.getter(name="netReadTimeout")
    def net_read_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait for more data from a connection before aborting the read.
        """
        return pulumi.get(self, "net_read_timeout")

    @net_read_timeout.setter
    def net_read_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_read_timeout", value)

    @property
    @pulumi.getter(name="netWriteTimeout")
    def net_write_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait for a block to be written to a connection before aborting the write.
        """
        return pulumi.get(self, "net_write_timeout")

    @net_write_timeout.setter
    def net_write_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "net_write_timeout", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "service_log", value)

    @property
    @pulumi.getter(name="slowQueryLog")
    def slow_query_log(self) -> Optional[pulumi.Input[bool]]:
        """
        Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table. Default is off.
        """
        return pulumi.get(self, "slow_query_log")

    @slow_query_log.setter
    def slow_query_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "slow_query_log", value)

    @property
    @pulumi.getter(name="sortBufferSize")
    def sort_buffer_size(self) -> Optional[pulumi.Input[int]]:
        """
        Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
        """
        return pulumi.get(self, "sort_buffer_size")

    @sort_buffer_size.setter
    def sort_buffer_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sort_buffer_size", value)

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
        """
        return pulumi.get(self, "sql_mode")

    @sql_mode.setter
    def sql_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_mode", value)

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        """
        return pulumi.get(self, "sql_require_primary_key")

    @sql_require_primary_key.setter
    def sql_require_primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sql_require_primary_key", value)

    @property
    @pulumi.getter(name="tmpTableSize")
    def tmp_table_size(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        """
        return pulumi.get(self, "tmp_table_size")

    @tmp_table_size.setter
    def tmp_table_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tmp_table_size", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        MySQL major version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="waitTimeout")
    def wait_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
        return pulumi.get(self, "wait_timeout")

    @wait_timeout.setter
    def wait_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_timeout", value)


if not MYPY:
    class ManagedDatabaseMysqlPropertiesMigrationArgsDict(TypedDict):
        dbname: NotRequired[pulumi.Input[str]]
        """
        Database name for bootstrapping the initial connection.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Hostname or IP address of the server where to migrate data from.
        """
        ignore_dbs: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        ignore_roles: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password for authentication with the server where to migrate data from.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number of the server where to migrate data from.
        """
        ssl: NotRequired[pulumi.Input[bool]]
        """
        The server where to migrate data from is secured with SSL.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        User name for authentication with the server where to migrate data from.
        """
elif False:
    ManagedDatabaseMysqlPropertiesMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseMysqlPropertiesMigrationArgs:
    def __init__(__self__, *,
                 dbname: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 ignore_dbs: Optional[pulumi.Input[str]] = None,
                 ignore_roles: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 ssl: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbname: Database name for bootstrapping the initial connection.
        :param pulumi.Input[str] host: Hostname or IP address of the server where to migrate data from.
        :param pulumi.Input[str] ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param pulumi.Input[str] ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param pulumi.Input[str] method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param pulumi.Input[str] password: Password for authentication with the server where to migrate data from.
        :param pulumi.Input[int] port: Port number of the server where to migrate data from.
        :param pulumi.Input[bool] ssl: The server where to migrate data from is secured with SSL.
        :param pulumi.Input[str] username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[pulumi.Input[str]]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @ignore_dbs.setter
    def ignore_dbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ignore_dbs", value)

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @ignore_roles.setter
    def ignore_roles(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ignore_roles", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ManagedDatabaseOpensearchComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabaseOpensearchComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 route: Optional[pulumi.Input[str]] = None,
                 usage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] component: Type of the component
        :param pulumi.Input[str] host: Hostname of the component
        :param pulumi.Input[int] port: Port number of the component
        :param pulumi.Input[str] route: Component network route type
        :param pulumi.Input[str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabaseOpensearchNetworkArgsDict(TypedDict):
        family: pulumi.Input[str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabaseOpensearchNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uuid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[str] type: The type of the network. Must be private.
        :param pulumi.Input[str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabaseOpensearchNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[str]]
        """
        State of the node
        """
elif False:
    ManagedDatabaseOpensearchNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name plus a node iteration
        :param pulumi.Input[str] role: Role of the node
        :param pulumi.Input[str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesArgsDict(TypedDict):
        action_auto_create_index_enabled: NotRequired[pulumi.Input[bool]]
        """
        action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.
        """
        action_destructive_requires_name: NotRequired[pulumi.Input[bool]]
        """
        Require explicit index names when deleting.
        """
        auth_failure_listeners: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgsDict']]
        """
        Opensearch Security Plugin Settings.
        """
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        azure_migration: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesAzureMigrationArgsDict']]
        cluster_max_shards_per_node: NotRequired[pulumi.Input[int]]
        """
        Controls the number of shards allowed in the cluster per data node.
        """
        cluster_routing_allocation_node_concurrent_recoveries: NotRequired[pulumi.Input[int]]
        """
        Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
        """
        custom_domain: NotRequired[pulumi.Input[str]]
        """
        Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
        """
        email_sender_name: NotRequired[pulumi.Input[str]]
        """
        Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.
        """
        email_sender_password: NotRequired[pulumi.Input[str]]
        """
        Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.
        """
        email_sender_username: NotRequired[pulumi.Input[str]]
        """
        Sender username for Opensearch alerts.
        """
        enable_security_audit: NotRequired[pulumi.Input[bool]]
        """
        Enable/Disable security audit.
        """
        gcs_migration: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesGcsMigrationArgsDict']]
        http_max_content_length: NotRequired[pulumi.Input[int]]
        """
        Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
        """
        http_max_header_size: NotRequired[pulumi.Input[int]]
        """
        The max size of allowed headers, in bytes.
        """
        http_max_initial_line_length: NotRequired[pulumi.Input[int]]
        """
        The max length of an HTTP URL, in bytes.
        """
        index_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Index patterns.
        """
        index_rollup: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgsDict']]
        """
        Index rollup settings.
        """
        index_template: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgsDict']]
        """
        Template settings for all new indexes.
        """
        indices_fielddata_cache_size: NotRequired[pulumi.Input[int]]
        """
        Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
        """
        indices_memory_index_buffer_size: NotRequired[pulumi.Input[int]]
        """
        Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
        """
        indices_memory_max_index_buffer_size: NotRequired[pulumi.Input[int]]
        """
        Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.
        """
        indices_memory_min_index_buffer_size: NotRequired[pulumi.Input[int]]
        """
        Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.
        """
        indices_queries_cache_size: NotRequired[pulumi.Input[int]]
        """
        Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
        """
        indices_query_bool_max_clause_count: NotRequired[pulumi.Input[int]]
        """
        Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
        """
        indices_recovery_max_bytes_per_sec: NotRequired[pulumi.Input[int]]
        """
        Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.
        """
        indices_recovery_max_concurrent_file_chunks: NotRequired[pulumi.Input[int]]
        """
        Number of file chunks sent in parallel for each recovery. Defaults to 2.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        ism_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether ISM is enabled or not.
        """
        ism_history_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.
        """
        ism_history_max_age: NotRequired[pulumi.Input[int]]
        """
        The maximum age before rolling over the audit history index in hours.
        """
        ism_history_max_docs: NotRequired[pulumi.Input[int]]
        """
        The maximum number of documents before rolling over the audit history index.
        """
        ism_history_rollover_check_period: NotRequired[pulumi.Input[int]]
        """
        The time between rollover checks for the audit history index in hours.
        """
        ism_history_rollover_retention_period: NotRequired[pulumi.Input[int]]
        """
        How long audit history indices are kept in days.
        """
        keep_index_refresh_interval: NotRequired[pulumi.Input[bool]]
        """
        Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        knn_memory_circuit_breaker_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable KNN memory circuit breaker. Defaults to true.
        """
        knn_memory_circuit_breaker_limit: NotRequired[pulumi.Input[int]]
        """
        Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.
        """
        openid: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgsDict']]
        """
        OpenSearch OpenID Connect Configuration.
        """
        opensearch_dashboards: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgsDict']]
        """
        OpenSearch Dashboards settings.
        """
        override_main_response_version: NotRequired[pulumi.Input[bool]]
        """
        Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.
        """
        plugins_alerting_filter_by_backend_roles: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.
        """
        public_access: NotRequired[pulumi.Input[bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        reindex_remote_whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
        """
        s3_migration: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesS3MigrationArgsDict']]
        saml: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgsDict']]
        """
        OpenSearch SAML configuration.
        """
        script_max_compilations_rate: NotRequired[pulumi.Input[str]]
        """
        Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.
        """
        search_max_buckets: NotRequired[pulumi.Input[int]]
        """
        Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
        """
        service_log: NotRequired[pulumi.Input[bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        thread_pool_analyze_queue_size: NotRequired[pulumi.Input[int]]
        """
        analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_analyze_size: NotRequired[pulumi.Input[int]]
        """
        analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_force_merge_size: NotRequired[pulumi.Input[int]]
        """
        force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_get_queue_size: NotRequired[pulumi.Input[int]]
        """
        get thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_get_size: NotRequired[pulumi.Input[int]]
        """
        get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_search_queue_size: NotRequired[pulumi.Input[int]]
        """
        search thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_search_size: NotRequired[pulumi.Input[int]]
        """
        search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_search_throttled_queue_size: NotRequired[pulumi.Input[int]]
        """
        search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_search_throttled_size: NotRequired[pulumi.Input[int]]
        """
        search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        thread_pool_write_queue_size: NotRequired[pulumi.Input[int]]
        """
        write thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        thread_pool_write_size: NotRequired[pulumi.Input[int]]
        """
        write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        OpenSearch major version.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesArgs:
    def __init__(__self__, *,
                 action_auto_create_index_enabled: Optional[pulumi.Input[bool]] = None,
                 action_destructive_requires_name: Optional[pulumi.Input[bool]] = None,
                 auth_failure_listeners: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs']] = None,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[bool]] = None,
                 azure_migration: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAzureMigrationArgs']] = None,
                 cluster_max_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[pulumi.Input[int]] = None,
                 custom_domain: Optional[pulumi.Input[str]] = None,
                 email_sender_name: Optional[pulumi.Input[str]] = None,
                 email_sender_password: Optional[pulumi.Input[str]] = None,
                 email_sender_username: Optional[pulumi.Input[str]] = None,
                 enable_security_audit: Optional[pulumi.Input[bool]] = None,
                 gcs_migration: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesGcsMigrationArgs']] = None,
                 http_max_content_length: Optional[pulumi.Input[int]] = None,
                 http_max_header_size: Optional[pulumi.Input[int]] = None,
                 http_max_initial_line_length: Optional[pulumi.Input[int]] = None,
                 index_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 index_rollup: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgs']] = None,
                 index_template: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgs']] = None,
                 indices_fielddata_cache_size: Optional[pulumi.Input[int]] = None,
                 indices_memory_index_buffer_size: Optional[pulumi.Input[int]] = None,
                 indices_memory_max_index_buffer_size: Optional[pulumi.Input[int]] = None,
                 indices_memory_min_index_buffer_size: Optional[pulumi.Input[int]] = None,
                 indices_queries_cache_size: Optional[pulumi.Input[int]] = None,
                 indices_query_bool_max_clause_count: Optional[pulumi.Input[int]] = None,
                 indices_recovery_max_bytes_per_sec: Optional[pulumi.Input[int]] = None,
                 indices_recovery_max_concurrent_file_chunks: Optional[pulumi.Input[int]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ism_enabled: Optional[pulumi.Input[bool]] = None,
                 ism_history_enabled: Optional[pulumi.Input[bool]] = None,
                 ism_history_max_age: Optional[pulumi.Input[int]] = None,
                 ism_history_max_docs: Optional[pulumi.Input[int]] = None,
                 ism_history_rollover_check_period: Optional[pulumi.Input[int]] = None,
                 ism_history_rollover_retention_period: Optional[pulumi.Input[int]] = None,
                 keep_index_refresh_interval: Optional[pulumi.Input[bool]] = None,
                 knn_memory_circuit_breaker_enabled: Optional[pulumi.Input[bool]] = None,
                 knn_memory_circuit_breaker_limit: Optional[pulumi.Input[int]] = None,
                 openid: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgs']] = None,
                 opensearch_dashboards: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs']] = None,
                 override_main_response_version: Optional[pulumi.Input[bool]] = None,
                 plugins_alerting_filter_by_backend_roles: Optional[pulumi.Input[bool]] = None,
                 public_access: Optional[pulumi.Input[bool]] = None,
                 reindex_remote_whitelists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 s3_migration: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesS3MigrationArgs']] = None,
                 saml: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgs']] = None,
                 script_max_compilations_rate: Optional[pulumi.Input[str]] = None,
                 search_max_buckets: Optional[pulumi.Input[int]] = None,
                 service_log: Optional[pulumi.Input[bool]] = None,
                 thread_pool_analyze_queue_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_analyze_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_force_merge_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_get_queue_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_get_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_search_queue_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_search_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_search_throttled_queue_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_search_throttled_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_write_queue_size: Optional[pulumi.Input[int]] = None,
                 thread_pool_write_size: Optional[pulumi.Input[int]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] action_auto_create_index_enabled: action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.
        :param pulumi.Input[bool] action_destructive_requires_name: Require explicit index names when deleting.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs'] auth_failure_listeners: Opensearch Security Plugin Settings.
        :param pulumi.Input[bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[int] cluster_max_shards_per_node: Controls the number of shards allowed in the cluster per data node.
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_recoveries: Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
        :param pulumi.Input[str] custom_domain: Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
        :param pulumi.Input[str] email_sender_name: Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.
        :param pulumi.Input[str] email_sender_password: Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.
        :param pulumi.Input[str] email_sender_username: Sender username for Opensearch alerts.
        :param pulumi.Input[bool] enable_security_audit: Enable/Disable security audit.
        :param pulumi.Input[int] http_max_content_length: Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
        :param pulumi.Input[int] http_max_header_size: The max size of allowed headers, in bytes.
        :param pulumi.Input[int] http_max_initial_line_length: The max length of an HTTP URL, in bytes.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] index_patterns: Index patterns.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgs'] index_rollup: Index rollup settings.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgs'] index_template: Template settings for all new indexes.
        :param pulumi.Input[int] indices_fielddata_cache_size: Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
        :param pulumi.Input[int] indices_memory_index_buffer_size: Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
        :param pulumi.Input[int] indices_memory_max_index_buffer_size: Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.
        :param pulumi.Input[int] indices_memory_min_index_buffer_size: Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.
        :param pulumi.Input[int] indices_queries_cache_size: Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
        :param pulumi.Input[int] indices_query_bool_max_clause_count: Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
        :param pulumi.Input[int] indices_recovery_max_bytes_per_sec: Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.
        :param pulumi.Input[int] indices_recovery_max_concurrent_file_chunks: Number of file chunks sent in parallel for each recovery. Defaults to 2.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input[bool] ism_enabled: Specifies whether ISM is enabled or not.
        :param pulumi.Input[bool] ism_history_enabled: Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.
        :param pulumi.Input[int] ism_history_max_age: The maximum age before rolling over the audit history index in hours.
        :param pulumi.Input[int] ism_history_max_docs: The maximum number of documents before rolling over the audit history index.
        :param pulumi.Input[int] ism_history_rollover_check_period: The time between rollover checks for the audit history index in hours.
        :param pulumi.Input[int] ism_history_rollover_retention_period: How long audit history indices are kept in days.
        :param pulumi.Input[bool] keep_index_refresh_interval: Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param pulumi.Input[bool] knn_memory_circuit_breaker_enabled: Enable or disable KNN memory circuit breaker. Defaults to true.
        :param pulumi.Input[int] knn_memory_circuit_breaker_limit: Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgs'] openid: OpenSearch OpenID Connect Configuration.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs'] opensearch_dashboards: OpenSearch Dashboards settings.
        :param pulumi.Input[bool] override_main_response_version: Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.
        :param pulumi.Input[bool] plugins_alerting_filter_by_backend_roles: Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.
        :param pulumi.Input[bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] reindex_remote_whitelists: Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgs'] saml: OpenSearch SAML configuration.
        :param pulumi.Input[str] script_max_compilations_rate: Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.
        :param pulumi.Input[int] search_max_buckets: Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
        :param pulumi.Input[bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param pulumi.Input[int] thread_pool_analyze_queue_size: analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[int] thread_pool_analyze_size: analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[int] thread_pool_force_merge_size: force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[int] thread_pool_get_queue_size: get thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[int] thread_pool_get_size: get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[int] thread_pool_search_queue_size: search thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[int] thread_pool_search_size: search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[int] thread_pool_search_throttled_queue_size: search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[int] thread_pool_search_throttled_size: search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[int] thread_pool_write_queue_size: write thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param pulumi.Input[int] thread_pool_write_size: write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param pulumi.Input[str] version: OpenSearch major version.
        """
        if action_auto_create_index_enabled is not None:
            pulumi.set(__self__, "action_auto_create_index_enabled", action_auto_create_index_enabled)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if auth_failure_listeners is not None:
            pulumi.set(__self__, "auth_failure_listeners", auth_failure_listeners)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if azure_migration is not None:
            pulumi.set(__self__, "azure_migration", azure_migration)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if email_sender_name is not None:
            pulumi.set(__self__, "email_sender_name", email_sender_name)
        if email_sender_password is not None:
            pulumi.set(__self__, "email_sender_password", email_sender_password)
        if email_sender_username is not None:
            pulumi.set(__self__, "email_sender_username", email_sender_username)
        if enable_security_audit is not None:
            pulumi.set(__self__, "enable_security_audit", enable_security_audit)
        if gcs_migration is not None:
            pulumi.set(__self__, "gcs_migration", gcs_migration)
        if http_max_content_length is not None:
            pulumi.set(__self__, "http_max_content_length", http_max_content_length)
        if http_max_header_size is not None:
            pulumi.set(__self__, "http_max_header_size", http_max_header_size)
        if http_max_initial_line_length is not None:
            pulumi.set(__self__, "http_max_initial_line_length", http_max_initial_line_length)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_rollup is not None:
            pulumi.set(__self__, "index_rollup", index_rollup)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if indices_fielddata_cache_size is not None:
            pulumi.set(__self__, "indices_fielddata_cache_size", indices_fielddata_cache_size)
        if indices_memory_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_index_buffer_size", indices_memory_index_buffer_size)
        if indices_memory_max_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_max_index_buffer_size", indices_memory_max_index_buffer_size)
        if indices_memory_min_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_min_index_buffer_size", indices_memory_min_index_buffer_size)
        if indices_queries_cache_size is not None:
            pulumi.set(__self__, "indices_queries_cache_size", indices_queries_cache_size)
        if indices_query_bool_max_clause_count is not None:
            pulumi.set(__self__, "indices_query_bool_max_clause_count", indices_query_bool_max_clause_count)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if indices_recovery_max_concurrent_file_chunks is not None:
            pulumi.set(__self__, "indices_recovery_max_concurrent_file_chunks", indices_recovery_max_concurrent_file_chunks)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if ism_enabled is not None:
            pulumi.set(__self__, "ism_enabled", ism_enabled)
        if ism_history_enabled is not None:
            pulumi.set(__self__, "ism_history_enabled", ism_history_enabled)
        if ism_history_max_age is not None:
            pulumi.set(__self__, "ism_history_max_age", ism_history_max_age)
        if ism_history_max_docs is not None:
            pulumi.set(__self__, "ism_history_max_docs", ism_history_max_docs)
        if ism_history_rollover_check_period is not None:
            pulumi.set(__self__, "ism_history_rollover_check_period", ism_history_rollover_check_period)
        if ism_history_rollover_retention_period is not None:
            pulumi.set(__self__, "ism_history_rollover_retention_period", ism_history_rollover_retention_period)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if knn_memory_circuit_breaker_enabled is not None:
            pulumi.set(__self__, "knn_memory_circuit_breaker_enabled", knn_memory_circuit_breaker_enabled)
        if knn_memory_circuit_breaker_limit is not None:
            pulumi.set(__self__, "knn_memory_circuit_breaker_limit", knn_memory_circuit_breaker_limit)
        if openid is not None:
            pulumi.set(__self__, "openid", openid)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if override_main_response_version is not None:
            pulumi.set(__self__, "override_main_response_version", override_main_response_version)
        if plugins_alerting_filter_by_backend_roles is not None:
            pulumi.set(__self__, "plugins_alerting_filter_by_backend_roles", plugins_alerting_filter_by_backend_roles)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if reindex_remote_whitelists is not None:
            pulumi.set(__self__, "reindex_remote_whitelists", reindex_remote_whitelists)
        if s3_migration is not None:
            pulumi.set(__self__, "s3_migration", s3_migration)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_max_buckets is not None:
            pulumi.set(__self__, "search_max_buckets", search_max_buckets)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if thread_pool_analyze_queue_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_queue_size", thread_pool_analyze_queue_size)
        if thread_pool_analyze_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_size", thread_pool_analyze_size)
        if thread_pool_force_merge_size is not None:
            pulumi.set(__self__, "thread_pool_force_merge_size", thread_pool_force_merge_size)
        if thread_pool_get_queue_size is not None:
            pulumi.set(__self__, "thread_pool_get_queue_size", thread_pool_get_queue_size)
        if thread_pool_get_size is not None:
            pulumi.set(__self__, "thread_pool_get_size", thread_pool_get_size)
        if thread_pool_search_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_queue_size", thread_pool_search_queue_size)
        if thread_pool_search_size is not None:
            pulumi.set(__self__, "thread_pool_search_size", thread_pool_search_size)
        if thread_pool_search_throttled_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_queue_size", thread_pool_search_throttled_queue_size)
        if thread_pool_search_throttled_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_size", thread_pool_search_throttled_size)
        if thread_pool_write_queue_size is not None:
            pulumi.set(__self__, "thread_pool_write_queue_size", thread_pool_write_queue_size)
        if thread_pool_write_size is not None:
            pulumi.set(__self__, "thread_pool_write_size", thread_pool_write_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="actionAutoCreateIndexEnabled")
    def action_auto_create_index_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.
        """
        return pulumi.get(self, "action_auto_create_index_enabled")

    @action_auto_create_index_enabled.setter
    def action_auto_create_index_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action_auto_create_index_enabled", value)

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[pulumi.Input[bool]]:
        """
        Require explicit index names when deleting.
        """
        return pulumi.get(self, "action_destructive_requires_name")

    @action_destructive_requires_name.setter
    def action_destructive_requires_name(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action_destructive_requires_name", value)

    @property
    @pulumi.getter(name="authFailureListeners")
    def auth_failure_listeners(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs']]:
        """
        Opensearch Security Plugin Settings.
        """
        return pulumi.get(self, "auth_failure_listeners")

    @auth_failure_listeners.setter
    def auth_failure_listeners(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs']]):
        pulumi.set(self, "auth_failure_listeners", value)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="azureMigration")
    def azure_migration(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAzureMigrationArgs']]:
        return pulumi.get(self, "azure_migration")

    @azure_migration.setter
    def azure_migration(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAzureMigrationArgs']]):
        pulumi.set(self, "azure_migration", value)

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        Controls the number of shards allowed in the cluster per data node.
        """
        return pulumi.get(self, "cluster_max_shards_per_node")

    @cluster_max_shards_per_node.setter
    def cluster_max_shards_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_max_shards_per_node", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @cluster_routing_allocation_node_concurrent_recoveries.setter
    def cluster_routing_allocation_node_concurrent_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_concurrent_recoveries", value)

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
        """
        return pulumi.get(self, "custom_domain")

    @custom_domain.setter
    def custom_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_domain", value)

    @property
    @pulumi.getter(name="emailSenderName")
    def email_sender_name(self) -> Optional[pulumi.Input[str]]:
        """
        Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.
        """
        return pulumi.get(self, "email_sender_name")

    @email_sender_name.setter
    def email_sender_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_sender_name", value)

    @property
    @pulumi.getter(name="emailSenderPassword")
    def email_sender_password(self) -> Optional[pulumi.Input[str]]:
        """
        Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.
        """
        return pulumi.get(self, "email_sender_password")

    @email_sender_password.setter
    def email_sender_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_sender_password", value)

    @property
    @pulumi.getter(name="emailSenderUsername")
    def email_sender_username(self) -> Optional[pulumi.Input[str]]:
        """
        Sender username for Opensearch alerts.
        """
        return pulumi.get(self, "email_sender_username")

    @email_sender_username.setter
    def email_sender_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_sender_username", value)

    @property
    @pulumi.getter(name="enableSecurityAudit")
    def enable_security_audit(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable/Disable security audit.
        """
        return pulumi.get(self, "enable_security_audit")

    @enable_security_audit.setter
    def enable_security_audit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_security_audit", value)

    @property
    @pulumi.getter(name="gcsMigration")
    def gcs_migration(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesGcsMigrationArgs']]:
        return pulumi.get(self, "gcs_migration")

    @gcs_migration.setter
    def gcs_migration(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesGcsMigrationArgs']]):
        pulumi.set(self, "gcs_migration", value)

    @property
    @pulumi.getter(name="httpMaxContentLength")
    def http_max_content_length(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
        """
        return pulumi.get(self, "http_max_content_length")

    @http_max_content_length.setter
    def http_max_content_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_max_content_length", value)

    @property
    @pulumi.getter(name="httpMaxHeaderSize")
    def http_max_header_size(self) -> Optional[pulumi.Input[int]]:
        """
        The max size of allowed headers, in bytes.
        """
        return pulumi.get(self, "http_max_header_size")

    @http_max_header_size.setter
    def http_max_header_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_max_header_size", value)

    @property
    @pulumi.getter(name="httpMaxInitialLineLength")
    def http_max_initial_line_length(self) -> Optional[pulumi.Input[int]]:
        """
        The max length of an HTTP URL, in bytes.
        """
        return pulumi.get(self, "http_max_initial_line_length")

    @http_max_initial_line_length.setter
    def http_max_initial_line_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_max_initial_line_length", value)

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Index patterns.
        """
        return pulumi.get(self, "index_patterns")

    @index_patterns.setter
    def index_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "index_patterns", value)

    @property
    @pulumi.getter(name="indexRollup")
    def index_rollup(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgs']]:
        """
        Index rollup settings.
        """
        return pulumi.get(self, "index_rollup")

    @index_rollup.setter
    def index_rollup(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexRollupArgs']]):
        pulumi.set(self, "index_rollup", value)

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgs']]:
        """
        Template settings for all new indexes.
        """
        return pulumi.get(self, "index_template")

    @index_template.setter
    def index_template(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesIndexTemplateArgs']]):
        pulumi.set(self, "index_template", value)

    @property
    @pulumi.getter(name="indicesFielddataCacheSize")
    def indices_fielddata_cache_size(self) -> Optional[pulumi.Input[int]]:
        """
        Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
        """
        return pulumi.get(self, "indices_fielddata_cache_size")

    @indices_fielddata_cache_size.setter
    def indices_fielddata_cache_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indices_fielddata_cache_size", value)

    @property
    @pulumi.getter(name="indicesMemoryIndexBufferSize")
    def indices_memory_index_buffer_size(self) -> Optional[pulumi.Input[int]]:
        """
        Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
        """
        return pulumi.get(self, "indices_memory_index_buffer_size")

    @indices_memory_index_buffer_size.setter
    def indices_memory_index_buffer_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indices_memory_index_buffer_size", value)

    @property
    @pulumi.getter(name="indicesMemoryMaxIndexBufferSize")
    def indices_memory_max_index_buffer_size(self) -> Optional[pulumi.Input[int]]:
        """
        Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.
        """
        return pulumi.get(self, "indices_memory_max_index_buffer_size")

    @indices_memory_max_index_buffer_size.setter
    def indices_memory_max_index_buffer_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indices_memory_max_index_buffer_size", value)

    @property
    @pulumi.getter(name="indicesMemoryMinIndexBufferSize")
    def indices_memory_min_index_buffer_size(self) -> Optional[pulumi.Input[int]]:
        """
        Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.
        """
        return pulumi.get(self, "indices_memory_min_index_buffer_size")

    @indices_memory_min_index_buffer_size.setter
    def indices_memory_min_index_buffer_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indices_memory_min_index_buffer_size", value)

    @property
    @pulumi.getter(name="indicesQueriesCacheSize")
    def indices_queries_cache_size(self) -> Optional[pulumi.Input[int]]:
        """
        Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
        """
        return pulumi.get(self, "indices_queries_cache_size")

    @indices_queries_cache_size.setter
    def indices_queries_cache_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indices_queries_cache_size", value)

    @property
    @pulumi.getter(name="indicesQueryBoolMaxClauseCount")
    def indices_query_bool_max_clause_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
        """
        return pulumi.get(self, "indices_query_bool_max_clause_count")

    @indices_query_bool_max_clause_count.setter
    def indices_query_bool_max_clause_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indices_query_bool_max_clause_count", value)

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[pulumi.Input[int]]:
        """
        Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.
        """
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @indices_recovery_max_bytes_per_sec.setter
    def indices_recovery_max_bytes_per_sec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indices_recovery_max_bytes_per_sec", value)

    @property
    @pulumi.getter(name="indicesRecoveryMaxConcurrentFileChunks")
    def indices_recovery_max_concurrent_file_chunks(self) -> Optional[pulumi.Input[int]]:
        """
        Number of file chunks sent in parallel for each recovery. Defaults to 2.
        """
        return pulumi.get(self, "indices_recovery_max_concurrent_file_chunks")

    @indices_recovery_max_concurrent_file_chunks.setter
    def indices_recovery_max_concurrent_file_chunks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indices_recovery_max_concurrent_file_chunks", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter(name="ismEnabled")
    def ism_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether ISM is enabled or not.
        """
        return pulumi.get(self, "ism_enabled")

    @ism_enabled.setter
    def ism_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ism_enabled", value)

    @property
    @pulumi.getter(name="ismHistoryEnabled")
    def ism_history_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.
        """
        return pulumi.get(self, "ism_history_enabled")

    @ism_history_enabled.setter
    def ism_history_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ism_history_enabled", value)

    @property
    @pulumi.getter(name="ismHistoryMaxAge")
    def ism_history_max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum age before rolling over the audit history index in hours.
        """
        return pulumi.get(self, "ism_history_max_age")

    @ism_history_max_age.setter
    def ism_history_max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ism_history_max_age", value)

    @property
    @pulumi.getter(name="ismHistoryMaxDocs")
    def ism_history_max_docs(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of documents before rolling over the audit history index.
        """
        return pulumi.get(self, "ism_history_max_docs")

    @ism_history_max_docs.setter
    def ism_history_max_docs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ism_history_max_docs", value)

    @property
    @pulumi.getter(name="ismHistoryRolloverCheckPeriod")
    def ism_history_rollover_check_period(self) -> Optional[pulumi.Input[int]]:
        """
        The time between rollover checks for the audit history index in hours.
        """
        return pulumi.get(self, "ism_history_rollover_check_period")

    @ism_history_rollover_check_period.setter
    def ism_history_rollover_check_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ism_history_rollover_check_period", value)

    @property
    @pulumi.getter(name="ismHistoryRolloverRetentionPeriod")
    def ism_history_rollover_retention_period(self) -> Optional[pulumi.Input[int]]:
        """
        How long audit history indices are kept in days.
        """
        return pulumi.get(self, "ism_history_rollover_retention_period")

    @ism_history_rollover_retention_period.setter
    def ism_history_rollover_retention_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ism_history_rollover_retention_period", value)

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[pulumi.Input[bool]]:
        """
        Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @keep_index_refresh_interval.setter
    def keep_index_refresh_interval(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_index_refresh_interval", value)

    @property
    @pulumi.getter(name="knnMemoryCircuitBreakerEnabled")
    def knn_memory_circuit_breaker_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable KNN memory circuit breaker. Defaults to true.
        """
        return pulumi.get(self, "knn_memory_circuit_breaker_enabled")

    @knn_memory_circuit_breaker_enabled.setter
    def knn_memory_circuit_breaker_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "knn_memory_circuit_breaker_enabled", value)

    @property
    @pulumi.getter(name="knnMemoryCircuitBreakerLimit")
    def knn_memory_circuit_breaker_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.
        """
        return pulumi.get(self, "knn_memory_circuit_breaker_limit")

    @knn_memory_circuit_breaker_limit.setter
    def knn_memory_circuit_breaker_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "knn_memory_circuit_breaker_limit", value)

    @property
    @pulumi.getter
    def openid(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgs']]:
        """
        OpenSearch OpenID Connect Configuration.
        """
        return pulumi.get(self, "openid")

    @openid.setter
    def openid(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpenidArgs']]):
        pulumi.set(self, "openid", value)

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs']]:
        """
        OpenSearch Dashboards settings.
        """
        return pulumi.get(self, "opensearch_dashboards")

    @opensearch_dashboards.setter
    def opensearch_dashboards(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs']]):
        pulumi.set(self, "opensearch_dashboards", value)

    @property
    @pulumi.getter(name="overrideMainResponseVersion")
    def override_main_response_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.
        """
        return pulumi.get(self, "override_main_response_version")

    @override_main_response_version.setter
    def override_main_response_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_main_response_version", value)

    @property
    @pulumi.getter(name="pluginsAlertingFilterByBackendRoles")
    def plugins_alerting_filter_by_backend_roles(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.
        """
        return pulumi.get(self, "plugins_alerting_filter_by_backend_roles")

    @plugins_alerting_filter_by_backend_roles.setter
    def plugins_alerting_filter_by_backend_roles(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "plugins_alerting_filter_by_backend_roles", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="reindexRemoteWhitelists")
    def reindex_remote_whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
        """
        return pulumi.get(self, "reindex_remote_whitelists")

    @reindex_remote_whitelists.setter
    def reindex_remote_whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "reindex_remote_whitelists", value)

    @property
    @pulumi.getter(name="s3Migration")
    def s3_migration(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesS3MigrationArgs']]:
        return pulumi.get(self, "s3_migration")

    @s3_migration.setter
    def s3_migration(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesS3MigrationArgs']]):
        pulumi.set(self, "s3_migration", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgs']]:
        """
        OpenSearch SAML configuration.
        """
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[pulumi.Input[str]]:
        """
        Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.
        """
        return pulumi.get(self, "script_max_compilations_rate")

    @script_max_compilations_rate.setter
    def script_max_compilations_rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_max_compilations_rate", value)

    @property
    @pulumi.getter(name="searchMaxBuckets")
    def search_max_buckets(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
        """
        return pulumi.get(self, "search_max_buckets")

    @search_max_buckets.setter
    def search_max_buckets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "search_max_buckets", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "service_log", value)

    @property
    @pulumi.getter(name="threadPoolAnalyzeQueueSize")
    def thread_pool_analyze_queue_size(self) -> Optional[pulumi.Input[int]]:
        """
        analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_analyze_queue_size")

    @thread_pool_analyze_queue_size.setter
    def thread_pool_analyze_queue_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_analyze_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolAnalyzeSize")
    def thread_pool_analyze_size(self) -> Optional[pulumi.Input[int]]:
        """
        analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_analyze_size")

    @thread_pool_analyze_size.setter
    def thread_pool_analyze_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_analyze_size", value)

    @property
    @pulumi.getter(name="threadPoolForceMergeSize")
    def thread_pool_force_merge_size(self) -> Optional[pulumi.Input[int]]:
        """
        force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_force_merge_size")

    @thread_pool_force_merge_size.setter
    def thread_pool_force_merge_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_force_merge_size", value)

    @property
    @pulumi.getter(name="threadPoolGetQueueSize")
    def thread_pool_get_queue_size(self) -> Optional[pulumi.Input[int]]:
        """
        get thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_get_queue_size")

    @thread_pool_get_queue_size.setter
    def thread_pool_get_queue_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_get_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolGetSize")
    def thread_pool_get_size(self) -> Optional[pulumi.Input[int]]:
        """
        get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_get_size")

    @thread_pool_get_size.setter
    def thread_pool_get_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_get_size", value)

    @property
    @pulumi.getter(name="threadPoolSearchQueueSize")
    def thread_pool_search_queue_size(self) -> Optional[pulumi.Input[int]]:
        """
        search thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_search_queue_size")

    @thread_pool_search_queue_size.setter
    def thread_pool_search_queue_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_search_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolSearchSize")
    def thread_pool_search_size(self) -> Optional[pulumi.Input[int]]:
        """
        search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_search_size")

    @thread_pool_search_size.setter
    def thread_pool_search_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_search_size", value)

    @property
    @pulumi.getter(name="threadPoolSearchThrottledQueueSize")
    def thread_pool_search_throttled_queue_size(self) -> Optional[pulumi.Input[int]]:
        """
        search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_search_throttled_queue_size")

    @thread_pool_search_throttled_queue_size.setter
    def thread_pool_search_throttled_queue_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_search_throttled_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolSearchThrottledSize")
    def thread_pool_search_throttled_size(self) -> Optional[pulumi.Input[int]]:
        """
        search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_search_throttled_size")

    @thread_pool_search_throttled_size.setter
    def thread_pool_search_throttled_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_search_throttled_size", value)

    @property
    @pulumi.getter(name="threadPoolWriteQueueSize")
    def thread_pool_write_queue_size(self) -> Optional[pulumi.Input[int]]:
        """
        write thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_write_queue_size")

    @thread_pool_write_queue_size.setter
    def thread_pool_write_queue_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_write_queue_size", value)

    @property
    @pulumi.getter(name="threadPoolWriteSize")
    def thread_pool_write_size(self) -> Optional[pulumi.Input[int]]:
        """
        write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_write_size")

    @thread_pool_write_size.setter
    def thread_pool_write_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "thread_pool_write_size", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch major version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgsDict(TypedDict):
        internal_authentication_backend_limiting: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgsDict']]
        ip_rate_limiting: NotRequired[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgsDict']]
        """
        IP address rate limiting settings.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs:
    def __init__(__self__, *,
                 internal_authentication_backend_limiting: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs']] = None,
                 ip_rate_limiting: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgs']] = None):
        """
        :param pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgs'] ip_rate_limiting: IP address rate limiting settings.
        """
        if internal_authentication_backend_limiting is not None:
            pulumi.set(__self__, "internal_authentication_backend_limiting", internal_authentication_backend_limiting)
        if ip_rate_limiting is not None:
            pulumi.set(__self__, "ip_rate_limiting", ip_rate_limiting)

    @property
    @pulumi.getter(name="internalAuthenticationBackendLimiting")
    def internal_authentication_backend_limiting(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs']]:
        return pulumi.get(self, "internal_authentication_backend_limiting")

    @internal_authentication_backend_limiting.setter
    def internal_authentication_backend_limiting(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs']]):
        pulumi.set(self, "internal_authentication_backend_limiting", value)

    @property
    @pulumi.getter(name="ipRateLimiting")
    def ip_rate_limiting(self) -> Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgs']]:
        """
        IP address rate limiting settings.
        """
        return pulumi.get(self, "ip_rate_limiting")

    @ip_rate_limiting.setter
    def ip_rate_limiting(self, value: Optional[pulumi.Input['ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgs']]):
        pulumi.set(self, "ip_rate_limiting", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgsDict(TypedDict):
        allowed_tries: NotRequired[pulumi.Input[int]]
        """
        The number of login attempts allowed before login is blocked.
        """
        authentication_backend: NotRequired[pulumi.Input[str]]
        """
        The internal backend. Enter `internal`.
        """
        block_expiry_seconds: NotRequired[pulumi.Input[int]]
        """
        The duration of time that login remains blocked after a failed login.
        """
        max_blocked_clients: NotRequired[pulumi.Input[int]]
        """
        The maximum number of blocked IP addresses.
        """
        max_tracked_clients: NotRequired[pulumi.Input[int]]
        """
        The maximum number of tracked IP addresses that have failed login.
        """
        time_window_seconds: NotRequired[pulumi.Input[int]]
        """
        The window of time in which the value for `allowed_tries` is enforced.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of rate limiting.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimitingArgs:
    def __init__(__self__, *,
                 allowed_tries: Optional[pulumi.Input[int]] = None,
                 authentication_backend: Optional[pulumi.Input[str]] = None,
                 block_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 max_blocked_clients: Optional[pulumi.Input[int]] = None,
                 max_tracked_clients: Optional[pulumi.Input[int]] = None,
                 time_window_seconds: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] allowed_tries: The number of login attempts allowed before login is blocked.
        :param pulumi.Input[str] authentication_backend: The internal backend. Enter `internal`.
        :param pulumi.Input[int] block_expiry_seconds: The duration of time that login remains blocked after a failed login.
        :param pulumi.Input[int] max_blocked_clients: The maximum number of blocked IP addresses.
        :param pulumi.Input[int] max_tracked_clients: The maximum number of tracked IP addresses that have failed login.
        :param pulumi.Input[int] time_window_seconds: The window of time in which the value for `allowed_tries` is enforced.
        :param pulumi.Input[str] type: The type of rate limiting.
        """
        if allowed_tries is not None:
            pulumi.set(__self__, "allowed_tries", allowed_tries)
        if authentication_backend is not None:
            pulumi.set(__self__, "authentication_backend", authentication_backend)
        if block_expiry_seconds is not None:
            pulumi.set(__self__, "block_expiry_seconds", block_expiry_seconds)
        if max_blocked_clients is not None:
            pulumi.set(__self__, "max_blocked_clients", max_blocked_clients)
        if max_tracked_clients is not None:
            pulumi.set(__self__, "max_tracked_clients", max_tracked_clients)
        if time_window_seconds is not None:
            pulumi.set(__self__, "time_window_seconds", time_window_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedTries")
    def allowed_tries(self) -> Optional[pulumi.Input[int]]:
        """
        The number of login attempts allowed before login is blocked.
        """
        return pulumi.get(self, "allowed_tries")

    @allowed_tries.setter
    def allowed_tries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allowed_tries", value)

    @property
    @pulumi.getter(name="authenticationBackend")
    def authentication_backend(self) -> Optional[pulumi.Input[str]]:
        """
        The internal backend. Enter `internal`.
        """
        return pulumi.get(self, "authentication_backend")

    @authentication_backend.setter
    def authentication_backend(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_backend", value)

    @property
    @pulumi.getter(name="blockExpirySeconds")
    def block_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration of time that login remains blocked after a failed login.
        """
        return pulumi.get(self, "block_expiry_seconds")

    @block_expiry_seconds.setter
    def block_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_expiry_seconds", value)

    @property
    @pulumi.getter(name="maxBlockedClients")
    def max_blocked_clients(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of blocked IP addresses.
        """
        return pulumi.get(self, "max_blocked_clients")

    @max_blocked_clients.setter
    def max_blocked_clients(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_blocked_clients", value)

    @property
    @pulumi.getter(name="maxTrackedClients")
    def max_tracked_clients(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of tracked IP addresses that have failed login.
        """
        return pulumi.get(self, "max_tracked_clients")

    @max_tracked_clients.setter
    def max_tracked_clients(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_tracked_clients", value)

    @property
    @pulumi.getter(name="timeWindowSeconds")
    def time_window_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The window of time in which the value for `allowed_tries` is enforced.
        """
        return pulumi.get(self, "time_window_seconds")

    @time_window_seconds.setter
    def time_window_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_window_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of rate limiting.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgsDict(TypedDict):
        allowed_tries: NotRequired[pulumi.Input[int]]
        """
        The number of login attempts allowed before login is blocked.
        """
        block_expiry_seconds: NotRequired[pulumi.Input[int]]
        """
        The duration of time that login remains blocked after a failed login.
        """
        max_blocked_clients: NotRequired[pulumi.Input[int]]
        """
        The maximum number of blocked IP addresses.
        """
        max_tracked_clients: NotRequired[pulumi.Input[int]]
        """
        The maximum number of tracked IP addresses that have failed login.
        """
        time_window_seconds: NotRequired[pulumi.Input[int]]
        """
        The window of time in which the value for `allowed_tries` is enforced.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of rate limiting.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgs:
    def __init__(__self__, *,
                 allowed_tries: Optional[pulumi.Input[int]] = None,
                 block_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 max_blocked_clients: Optional[pulumi.Input[int]] = None,
                 max_tracked_clients: Optional[pulumi.Input[int]] = None,
                 time_window_seconds: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] allowed_tries: The number of login attempts allowed before login is blocked.
        :param pulumi.Input[int] block_expiry_seconds: The duration of time that login remains blocked after a failed login.
        :param pulumi.Input[int] max_blocked_clients: The maximum number of blocked IP addresses.
        :param pulumi.Input[int] max_tracked_clients: The maximum number of tracked IP addresses that have failed login.
        :param pulumi.Input[int] time_window_seconds: The window of time in which the value for `allowed_tries` is enforced.
        :param pulumi.Input[str] type: The type of rate limiting.
        """
        if allowed_tries is not None:
            pulumi.set(__self__, "allowed_tries", allowed_tries)
        if block_expiry_seconds is not None:
            pulumi.set(__self__, "block_expiry_seconds", block_expiry_seconds)
        if max_blocked_clients is not None:
            pulumi.set(__self__, "max_blocked_clients", max_blocked_clients)
        if max_tracked_clients is not None:
            pulumi.set(__self__, "max_tracked_clients", max_tracked_clients)
        if time_window_seconds is not None:
            pulumi.set(__self__, "time_window_seconds", time_window_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedTries")
    def allowed_tries(self) -> Optional[pulumi.Input[int]]:
        """
        The number of login attempts allowed before login is blocked.
        """
        return pulumi.get(self, "allowed_tries")

    @allowed_tries.setter
    def allowed_tries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allowed_tries", value)

    @property
    @pulumi.getter(name="blockExpirySeconds")
    def block_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The duration of time that login remains blocked after a failed login.
        """
        return pulumi.get(self, "block_expiry_seconds")

    @block_expiry_seconds.setter
    def block_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_expiry_seconds", value)

    @property
    @pulumi.getter(name="maxBlockedClients")
    def max_blocked_clients(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of blocked IP addresses.
        """
        return pulumi.get(self, "max_blocked_clients")

    @max_blocked_clients.setter
    def max_blocked_clients(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_blocked_clients", value)

    @property
    @pulumi.getter(name="maxTrackedClients")
    def max_tracked_clients(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of tracked IP addresses that have failed login.
        """
        return pulumi.get(self, "max_tracked_clients")

    @max_tracked_clients.setter
    def max_tracked_clients(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_tracked_clients", value)

    @property
    @pulumi.getter(name="timeWindowSeconds")
    def time_window_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The window of time in which the value for `allowed_tries` is enforced.
        """
        return pulumi.get(self, "time_window_seconds")

    @time_window_seconds.setter
    def time_window_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_window_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of rate limiting.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesAzureMigrationArgsDict(TypedDict):
        account: NotRequired[pulumi.Input[str]]
        """
        Account name. Azure account name.
        """
        base_path: NotRequired[pulumi.Input[str]]
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        chunk_size: NotRequired[pulumi.Input[str]]
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        compress: NotRequired[pulumi.Input[bool]]
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        container: NotRequired[pulumi.Input[str]]
        """
        Azure container name. Azure container name.
        """
        endpoint_suffix: NotRequired[pulumi.Input[str]]
        """
        Endpoint suffix. Defines the DNS suffix for Azure Storage endpoints.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Account secret key. Azure account secret key. One of key or sas_token should be specified.
        """
        sas_token: NotRequired[pulumi.Input[str]]
        """
        SAS token. A shared access signatures (SAS) token. One of key or sas_token should be specified.
        """
        snapshot_name: NotRequired[pulumi.Input[str]]
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesAzureMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesAzureMigrationArgs:
    def __init__(__self__, *,
                 account: Optional[pulumi.Input[str]] = None,
                 base_path: Optional[pulumi.Input[str]] = None,
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 container: Optional[pulumi.Input[str]] = None,
                 endpoint_suffix: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 sas_token: Optional[pulumi.Input[str]] = None,
                 snapshot_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account: Account name. Azure account name.
        :param pulumi.Input[str] base_path: The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        :param pulumi.Input[str] chunk_size: Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        :param pulumi.Input[bool] compress: Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        :param pulumi.Input[str] container: Azure container name. Azure container name.
        :param pulumi.Input[str] endpoint_suffix: Endpoint suffix. Defines the DNS suffix for Azure Storage endpoints.
        :param pulumi.Input[str] key: Account secret key. Azure account secret key. One of key or sas_token should be specified.
        :param pulumi.Input[str] sas_token: SAS token. A shared access signatures (SAS) token. One of key or sas_token should be specified.
        :param pulumi.Input[str] snapshot_name: The snapshot name to restore from. The snapshot name to restore from.
        """
        if account is not None:
            pulumi.set(__self__, "account", account)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if endpoint_suffix is not None:
            pulumi.set(__self__, "endpoint_suffix", endpoint_suffix)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if snapshot_name is not None:
            pulumi.set(__self__, "snapshot_name", snapshot_name)

    @property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[str]]:
        """
        Account name. Azure account name.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account", value)

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        return pulumi.get(self, "base_path")

    @base_path.setter
    def base_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_path", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[str]]:
        """
        Azure container name. Azure container name.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="endpointSuffix")
    def endpoint_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoint suffix. Defines the DNS suffix for Azure Storage endpoints.
        """
        return pulumi.get(self, "endpoint_suffix")

    @endpoint_suffix.setter
    def endpoint_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_suffix", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Account secret key. Azure account secret key. One of key or sas_token should be specified.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[pulumi.Input[str]]:
        """
        SAS token. A shared access signatures (SAS) token. One of key or sas_token should be specified.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sas_token", value)

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
        return pulumi.get(self, "snapshot_name")

    @snapshot_name.setter
    def snapshot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_name", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesGcsMigrationArgsDict(TypedDict):
        base_path: NotRequired[pulumi.Input[str]]
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        bucket: NotRequired[pulumi.Input[str]]
        """
        The path to the repository data within its container. Google Cloud Storage bucket name.
        """
        chunk_size: NotRequired[pulumi.Input[str]]
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        compress: NotRequired[pulumi.Input[bool]]
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        credentials: NotRequired[pulumi.Input[str]]
        """
        Credentials. Google Cloud Storage credentials file content.
        """
        snapshot_name: NotRequired[pulumi.Input[str]]
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesGcsMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesGcsMigrationArgs:
    def __init__(__self__, *,
                 base_path: Optional[pulumi.Input[str]] = None,
                 bucket: Optional[pulumi.Input[str]] = None,
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 credentials: Optional[pulumi.Input[str]] = None,
                 snapshot_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_path: The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        :param pulumi.Input[str] bucket: The path to the repository data within its container. Google Cloud Storage bucket name.
        :param pulumi.Input[str] chunk_size: Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        :param pulumi.Input[bool] compress: Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        :param pulumi.Input[str] credentials: Credentials. Google Cloud Storage credentials file content.
        :param pulumi.Input[str] snapshot_name: The snapshot name to restore from. The snapshot name to restore from.
        """
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if snapshot_name is not None:
            pulumi.set(__self__, "snapshot_name", snapshot_name)

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        return pulumi.get(self, "base_path")

    @base_path.setter
    def base_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_path", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the repository data within its container. Google Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Credentials. Google Cloud Storage credentials file content.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
        return pulumi.get(self, "snapshot_name")

    @snapshot_name.setter
    def snapshot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_name", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesIndexRollupArgsDict(TypedDict):
        rollup_dashboards_enabled: NotRequired[pulumi.Input[bool]]
        """
        plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.
        """
        rollup_enabled: NotRequired[pulumi.Input[bool]]
        """
        plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.
        """
        rollup_search_backoff_count: NotRequired[pulumi.Input[int]]
        """
        plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.
        """
        rollup_search_backoff_millis: NotRequired[pulumi.Input[int]]
        """
        plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.
        """
        rollup_search_search_all_jobs: NotRequired[pulumi.Input[bool]]
        """
        plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesIndexRollupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesIndexRollupArgs:
    def __init__(__self__, *,
                 rollup_dashboards_enabled: Optional[pulumi.Input[bool]] = None,
                 rollup_enabled: Optional[pulumi.Input[bool]] = None,
                 rollup_search_backoff_count: Optional[pulumi.Input[int]] = None,
                 rollup_search_backoff_millis: Optional[pulumi.Input[int]] = None,
                 rollup_search_search_all_jobs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] rollup_dashboards_enabled: plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.
        :param pulumi.Input[bool] rollup_enabled: plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.
        :param pulumi.Input[int] rollup_search_backoff_count: plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.
        :param pulumi.Input[int] rollup_search_backoff_millis: plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.
        :param pulumi.Input[bool] rollup_search_search_all_jobs: plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.
        """
        if rollup_dashboards_enabled is not None:
            pulumi.set(__self__, "rollup_dashboards_enabled", rollup_dashboards_enabled)
        if rollup_enabled is not None:
            pulumi.set(__self__, "rollup_enabled", rollup_enabled)
        if rollup_search_backoff_count is not None:
            pulumi.set(__self__, "rollup_search_backoff_count", rollup_search_backoff_count)
        if rollup_search_backoff_millis is not None:
            pulumi.set(__self__, "rollup_search_backoff_millis", rollup_search_backoff_millis)
        if rollup_search_search_all_jobs is not None:
            pulumi.set(__self__, "rollup_search_search_all_jobs", rollup_search_search_all_jobs)

    @property
    @pulumi.getter(name="rollupDashboardsEnabled")
    def rollup_dashboards_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.
        """
        return pulumi.get(self, "rollup_dashboards_enabled")

    @rollup_dashboards_enabled.setter
    def rollup_dashboards_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rollup_dashboards_enabled", value)

    @property
    @pulumi.getter(name="rollupEnabled")
    def rollup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.
        """
        return pulumi.get(self, "rollup_enabled")

    @rollup_enabled.setter
    def rollup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rollup_enabled", value)

    @property
    @pulumi.getter(name="rollupSearchBackoffCount")
    def rollup_search_backoff_count(self) -> Optional[pulumi.Input[int]]:
        """
        plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.
        """
        return pulumi.get(self, "rollup_search_backoff_count")

    @rollup_search_backoff_count.setter
    def rollup_search_backoff_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rollup_search_backoff_count", value)

    @property
    @pulumi.getter(name="rollupSearchBackoffMillis")
    def rollup_search_backoff_millis(self) -> Optional[pulumi.Input[int]]:
        """
        plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.
        """
        return pulumi.get(self, "rollup_search_backoff_millis")

    @rollup_search_backoff_millis.setter
    def rollup_search_backoff_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rollup_search_backoff_millis", value)

    @property
    @pulumi.getter(name="rollupSearchSearchAllJobs")
    def rollup_search_search_all_jobs(self) -> Optional[pulumi.Input[bool]]:
        """
        plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.
        """
        return pulumi.get(self, "rollup_search_search_all_jobs")

    @rollup_search_search_all_jobs.setter
    def rollup_search_search_all_jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rollup_search_search_all_jobs", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesIndexTemplateArgsDict(TypedDict):
        mapping_nested_objects_limit: NotRequired[pulumi.Input[int]]
        """
        index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
        """
        number_of_replicas: NotRequired[pulumi.Input[int]]
        """
        The number of replicas each primary shard has.
        """
        number_of_shards: NotRequired[pulumi.Input[int]]
        """
        The number of primary shards that an index should have.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesIndexTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesIndexTemplateArgs:
    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[pulumi.Input[int]] = None,
                 number_of_replicas: Optional[pulumi.Input[int]] = None,
                 number_of_shards: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] mapping_nested_objects_limit: index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
        :param pulumi.Input[int] number_of_replicas: The number of replicas each primary shard has.
        :param pulumi.Input[int] number_of_shards: The number of primary shards that an index should have.
        """
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[pulumi.Input[int]]:
        """
        index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @mapping_nested_objects_limit.setter
    def mapping_nested_objects_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mapping_nested_objects_limit", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of replicas each primary shard has.
        """
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[pulumi.Input[int]]:
        """
        The number of primary shards that an index should have.
        """
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_shards", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesOpenidArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.
        """
        connect_url: NotRequired[pulumi.Input[str]]
        """
        OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.
        """
        header: NotRequired[pulumi.Input[str]]
        """
        HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.
        """
        jwt_header: NotRequired[pulumi.Input[str]]
        """
        The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer <token>. Optional. Default is Authorization.
        """
        jwt_url_parameter: NotRequired[pulumi.Input[str]]
        """
        URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.
        """
        refresh_rate_limit_count: NotRequired[pulumi.Input[int]]
        """
        The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.
        """
        refresh_rate_limit_time_window_ms: NotRequired[pulumi.Input[int]]
        """
        The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).
        """
        roles_key: NotRequired[pulumi.Input[str]]
        """
        The key in the JSON payload that stores the user’s roles. The key in the JSON payload that stores the user’s roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.
        """
        subject_key: NotRequired[pulumi.Input[str]]
        """
        The key in the JSON payload that stores the user’s name. The key in the JSON payload that stores the user’s name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesOpenidArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesOpenidArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 connect_url: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 header: Optional[pulumi.Input[str]] = None,
                 jwt_header: Optional[pulumi.Input[str]] = None,
                 jwt_url_parameter: Optional[pulumi.Input[str]] = None,
                 refresh_rate_limit_count: Optional[pulumi.Input[int]] = None,
                 refresh_rate_limit_time_window_ms: Optional[pulumi.Input[int]] = None,
                 roles_key: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 subject_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.
        :param pulumi.Input[str] client_secret: The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.
        :param pulumi.Input[str] connect_url: OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.
        :param pulumi.Input[bool] enabled: Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.
        :param pulumi.Input[str] header: HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.
        :param pulumi.Input[str] jwt_header: The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer <token>. Optional. Default is Authorization.
        :param pulumi.Input[str] jwt_url_parameter: URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.
        :param pulumi.Input[int] refresh_rate_limit_count: The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.
        :param pulumi.Input[int] refresh_rate_limit_time_window_ms: The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).
        :param pulumi.Input[str] roles_key: The key in the JSON payload that stores the user’s roles. The key in the JSON payload that stores the user’s roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.
        :param pulumi.Input[str] scope: The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.
        :param pulumi.Input[str] subject_key: The key in the JSON payload that stores the user’s name. The key in the JSON payload that stores the user’s name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_url is not None:
            pulumi.set(__self__, "connect_url", connect_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if jwt_header is not None:
            pulumi.set(__self__, "jwt_header", jwt_header)
        if jwt_url_parameter is not None:
            pulumi.set(__self__, "jwt_url_parameter", jwt_url_parameter)
        if refresh_rate_limit_count is not None:
            pulumi.set(__self__, "refresh_rate_limit_count", refresh_rate_limit_count)
        if refresh_rate_limit_time_window_ms is not None:
            pulumi.set(__self__, "refresh_rate_limit_time_window_ms", refresh_rate_limit_time_window_ms)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="connectUrl")
    def connect_url(self) -> Optional[pulumi.Input[str]]:
        """
        OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.
        """
        return pulumi.get(self, "connect_url")

    @connect_url.setter
    def connect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_url", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="jwtHeader")
    def jwt_header(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer <token>. Optional. Default is Authorization.
        """
        return pulumi.get(self, "jwt_header")

    @jwt_header.setter
    def jwt_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jwt_header", value)

    @property
    @pulumi.getter(name="jwtUrlParameter")
    def jwt_url_parameter(self) -> Optional[pulumi.Input[str]]:
        """
        URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.
        """
        return pulumi.get(self, "jwt_url_parameter")

    @jwt_url_parameter.setter
    def jwt_url_parameter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jwt_url_parameter", value)

    @property
    @pulumi.getter(name="refreshRateLimitCount")
    def refresh_rate_limit_count(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.
        """
        return pulumi.get(self, "refresh_rate_limit_count")

    @refresh_rate_limit_count.setter
    def refresh_rate_limit_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_rate_limit_count", value)

    @property
    @pulumi.getter(name="refreshRateLimitTimeWindowMs")
    def refresh_rate_limit_time_window_ms(self) -> Optional[pulumi.Input[int]]:
        """
        The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).
        """
        return pulumi.get(self, "refresh_rate_limit_time_window_ms")

    @refresh_rate_limit_time_window_ms.setter
    def refresh_rate_limit_time_window_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_rate_limit_time_window_ms", value)

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key in the JSON payload that stores the user’s roles. The key in the JSON payload that stores the user’s roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.
        """
        return pulumi.get(self, "roles_key")

    @roles_key.setter
    def roles_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "roles_key", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key in the JSON payload that stores the user’s name. The key in the JSON payload that stores the user’s name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.
        """
        return pulumi.get(self, "subject_key")

    @subject_key.setter
    def subject_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_key", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable OpenSearch Dashboards.
        """
        max_old_space_size: NotRequired[pulumi.Input[int]]
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.
        """
        opensearch_request_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 max_old_space_size: Optional[pulumi.Input[int]] = None,
                 opensearch_request_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable or disable OpenSearch Dashboards.
        :param pulumi.Input[int] max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.
        :param pulumi.Input[int] opensearch_request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if opensearch_request_timeout is not None:
            pulumi.set(__self__, "opensearch_request_timeout", opensearch_request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable OpenSearch Dashboards.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.
        """
        return pulumi.get(self, "max_old_space_size")

    @max_old_space_size.setter
    def max_old_space_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_old_space_size", value)

    @property
    @pulumi.getter(name="opensearchRequestTimeout")
    def opensearch_request_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.
        """
        return pulumi.get(self, "opensearch_request_timeout")

    @opensearch_request_timeout.setter
    def opensearch_request_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "opensearch_request_timeout", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesS3MigrationArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[str]]
        """
        AWS Access key. AWS Access key.
        """
        base_path: NotRequired[pulumi.Input[str]]
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        bucket: NotRequired[pulumi.Input[str]]
        """
        S3 bucket name. S3 bucket name.
        """
        chunk_size: NotRequired[pulumi.Input[str]]
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        compress: NotRequired[pulumi.Input[bool]]
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        The S3 service endpoint to connect. The S3 service endpoint to connect to. If you are using an S3-compatible service then you should set this to the service’s endpoint.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        S3 region. S3 region.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        AWS secret key. AWS secret key.
        """
        server_side_encryption: NotRequired[pulumi.Input[bool]]
        """
        Server side encryption. When set to true files are encrypted on server side.
        """
        snapshot_name: NotRequired[pulumi.Input[str]]
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesS3MigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesS3MigrationArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[str]] = None,
                 base_path: Optional[pulumi.Input[str]] = None,
                 bucket: Optional[pulumi.Input[str]] = None,
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 server_side_encryption: Optional[pulumi.Input[bool]] = None,
                 snapshot_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: AWS Access key. AWS Access key.
        :param pulumi.Input[str] base_path: The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        :param pulumi.Input[str] bucket: S3 bucket name. S3 bucket name.
        :param pulumi.Input[str] chunk_size: Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        :param pulumi.Input[bool] compress: Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        :param pulumi.Input[str] endpoint: The S3 service endpoint to connect. The S3 service endpoint to connect to. If you are using an S3-compatible service then you should set this to the service’s endpoint.
        :param pulumi.Input[str] region: S3 region. S3 region.
        :param pulumi.Input[str] secret_key: AWS secret key. AWS secret key.
        :param pulumi.Input[bool] server_side_encryption: Server side encryption. When set to true files are encrypted on server side.
        :param pulumi.Input[str] snapshot_name: The snapshot name to restore from. The snapshot name to restore from.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if server_side_encryption is not None:
            pulumi.set(__self__, "server_side_encryption", server_side_encryption)
        if snapshot_name is not None:
            pulumi.set(__self__, "snapshot_name", snapshot_name)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Access key. AWS Access key.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        return pulumi.get(self, "base_path")

    @base_path.setter
    def base_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_path", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        S3 bucket name. S3 bucket name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The S3 service endpoint to connect. The S3 service endpoint to connect to. If you are using an S3-compatible service then you should set this to the service’s endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        S3 region. S3 region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS secret key. AWS secret key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Server side encryption. When set to true files are encrypted on server side.
        """
        return pulumi.get(self, "server_side_encryption")

    @server_side_encryption.setter
    def server_side_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_side_encryption", value)

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[pulumi.Input[str]]:
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
        return pulumi.get(self, "snapshot_name")

    @snapshot_name.setter
    def snapshot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_name", value)


if not MYPY:
    class ManagedDatabaseOpensearchPropertiesSamlArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.
        """
        idp_entity_id: NotRequired[pulumi.Input[str]]
        """
        Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.
        """
        idp_metadata_url: NotRequired[pulumi.Input[str]]
        """
        Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.
        """
        idp_pemtrustedcas_content: NotRequired[pulumi.Input[str]]
        """
        PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.
        """
        roles_key: NotRequired[pulumi.Input[str]]
        """
        SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.
        """
        sp_entity_id: NotRequired[pulumi.Input[str]]
        """
        Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.
        """
        subject_key: NotRequired[pulumi.Input[str]]
        """
        SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.
        """
elif False:
    ManagedDatabaseOpensearchPropertiesSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseOpensearchPropertiesSamlArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 idp_entity_id: Optional[pulumi.Input[str]] = None,
                 idp_metadata_url: Optional[pulumi.Input[str]] = None,
                 idp_pemtrustedcas_content: Optional[pulumi.Input[str]] = None,
                 roles_key: Optional[pulumi.Input[str]] = None,
                 sp_entity_id: Optional[pulumi.Input[str]] = None,
                 subject_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.
        :param pulumi.Input[str] idp_entity_id: Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.
        :param pulumi.Input[str] idp_metadata_url: Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.
        :param pulumi.Input[str] idp_pemtrustedcas_content: PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.
        :param pulumi.Input[str] roles_key: SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.
        :param pulumi.Input[str] sp_entity_id: Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.
        :param pulumi.Input[str] subject_key: SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if idp_metadata_url is not None:
            pulumi.set(__self__, "idp_metadata_url", idp_metadata_url)
        if idp_pemtrustedcas_content is not None:
            pulumi.set(__self__, "idp_pemtrustedcas_content", idp_pemtrustedcas_content)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="idpMetadataUrl")
    def idp_metadata_url(self) -> Optional[pulumi.Input[str]]:
        """
        Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.
        """
        return pulumi.get(self, "idp_metadata_url")

    @idp_metadata_url.setter
    def idp_metadata_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_metadata_url", value)

    @property
    @pulumi.getter(name="idpPemtrustedcasContent")
    def idp_pemtrustedcas_content(self) -> Optional[pulumi.Input[str]]:
        """
        PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.
        """
        return pulumi.get(self, "idp_pemtrustedcas_content")

    @idp_pemtrustedcas_content.setter
    def idp_pemtrustedcas_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_pemtrustedcas_content", value)

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[pulumi.Input[str]]:
        """
        SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.
        """
        return pulumi.get(self, "roles_key")

    @roles_key.setter
    def roles_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "roles_key", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sp_entity_id", value)

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[pulumi.Input[str]]:
        """
        SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.
        """
        return pulumi.get(self, "subject_key")

    @subject_key.setter
    def subject_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_key", value)


if not MYPY:
    class ManagedDatabasePostgresqlComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabasePostgresqlComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 route: Optional[pulumi.Input[str]] = None,
                 usage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] component: Type of the component
        :param pulumi.Input[str] host: Hostname of the component
        :param pulumi.Input[int] port: Port number of the component
        :param pulumi.Input[str] route: Component network route type
        :param pulumi.Input[str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabasePostgresqlNetworkArgsDict(TypedDict):
        family: pulumi.Input[str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabasePostgresqlNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uuid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[str] type: The type of the network. Must be private.
        :param pulumi.Input[str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabasePostgresqlNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[str]]
        """
        State of the node
        """
elif False:
    ManagedDatabasePostgresqlNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name plus a node iteration
        :param pulumi.Input[str] role: Role of the node
        :param pulumi.Input[str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[str]]
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        admin_username: NotRequired[pulumi.Input[str]]
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        autovacuum_analyze_scale_factor: NotRequired[pulumi.Input[float]]
        """
        Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        """
        autovacuum_analyze_threshold: NotRequired[pulumi.Input[int]]
        """
        Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        """
        autovacuum_freeze_max_age: NotRequired[pulumi.Input[int]]
        """
        Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        """
        autovacuum_max_workers: NotRequired[pulumi.Input[int]]
        """
        Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        """
        autovacuum_naptime: NotRequired[pulumi.Input[int]]
        """
        Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.
        """
        autovacuum_vacuum_cost_delay: NotRequired[pulumi.Input[int]]
        """
        Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.
        """
        autovacuum_vacuum_cost_limit: NotRequired[pulumi.Input[int]]
        """
        Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        """
        autovacuum_vacuum_scale_factor: NotRequired[pulumi.Input[float]]
        """
        Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        """
        autovacuum_vacuum_threshold: NotRequired[pulumi.Input[int]]
        """
        Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        """
        backup_hour: NotRequired[pulumi.Input[int]]
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        backup_minute: NotRequired[pulumi.Input[int]]
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        bgwriter_delay: NotRequired[pulumi.Input[int]]
        """
        Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
        """
        bgwriter_flush_after: NotRequired[pulumi.Input[int]]
        """
        Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
        """
        bgwriter_lru_maxpages: NotRequired[pulumi.Input[int]]
        """
        In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
        """
        bgwriter_lru_multiplier: NotRequired[pulumi.Input[float]]
        """
        The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        """
        deadlock_timeout: NotRequired[pulumi.Input[int]]
        """
        This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        """
        default_toast_compression: NotRequired[pulumi.Input[str]]
        """
        Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        """
        idle_in_transaction_session_timeout: NotRequired[pulumi.Input[int]]
        """
        Time out sessions with open transactions after this number of milliseconds.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        jit: NotRequired[pulumi.Input[bool]]
        """
        Controls system-wide use of Just-in-Time Compilation (JIT).
        """
        log_autovacuum_min_duration: NotRequired[pulumi.Input[int]]
        """
        Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        """
        log_error_verbosity: NotRequired[pulumi.Input[str]]
        """
        Controls the amount of detail written in the server log for each message that is logged.
        """
        log_line_prefix: NotRequired[pulumi.Input[str]]
        """
        Choose from one of the available log formats.
        """
        log_min_duration_statement: NotRequired[pulumi.Input[int]]
        """
        Log statements that take more than this number of milliseconds to run, -1 disables.
        """
        log_temp_files: NotRequired[pulumi.Input[int]]
        """
        Log statements for each temporary file created larger than this number of kilobytes, -1 disables.
        """
        max_files_per_process: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL maximum number of files that can be open per process.
        """
        max_locks_per_transaction: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL maximum locks per transaction.
        """
        max_logical_replication_workers: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        """
        max_parallel_workers: NotRequired[pulumi.Input[int]]
        """
        Sets the maximum number of workers that the system can support for parallel queries.
        """
        max_parallel_workers_per_gather: NotRequired[pulumi.Input[int]]
        """
        Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        """
        max_pred_locks_per_transaction: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL maximum predicate locks per transaction.
        """
        max_prepared_transactions: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL maximum prepared transactions.
        """
        max_replication_slots: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL maximum replication slots.
        """
        max_slot_wal_keep_size: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
        """
        max_stack_depth: NotRequired[pulumi.Input[int]]
        """
        Maximum depth of the stack in bytes.
        """
        max_standby_archive_delay: NotRequired[pulumi.Input[int]]
        """
        Max standby archive delay in milliseconds.
        """
        max_standby_streaming_delay: NotRequired[pulumi.Input[int]]
        """
        Max standby streaming delay in milliseconds.
        """
        max_wal_senders: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL maximum WAL senders.
        """
        max_worker_processes: NotRequired[pulumi.Input[int]]
        """
        Sets the maximum number of background processes that the system can support.
        """
        migration: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgsDict']]
        """
        Migrate data from existing server.
        """
        pg_partman_bgw_interval: NotRequired[pulumi.Input[int]]
        """
        Sets the time interval to run pg_partman's scheduled tasks.
        """
        pg_partman_bgw_role: NotRequired[pulumi.Input[str]]
        """
        Controls which role to use for pg_partman's scheduled background tasks.
        """
        pg_stat_monitor_enable: NotRequired[pulumi.Input[bool]]
        """
        Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        """
        pg_stat_monitor_pgsm_enable_query_plan: NotRequired[pulumi.Input[bool]]
        """
        Enables or disables query plan monitoring.
        """
        pg_stat_monitor_pgsm_max_buckets: NotRequired[pulumi.Input[int]]
        """
        Sets the maximum number of buckets.
        """
        pg_stat_statements_track: NotRequired[pulumi.Input[str]]
        """
        Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
        """
        pgbouncer: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgsDict']]
        """
        PGBouncer connection pooling settings. System-wide settings for pgbouncer.
        """
        pglookout: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgsDict']]
        """
        PGLookout settings. System-wide settings for pglookout.
        """
        public_access: NotRequired[pulumi.Input[bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        service_log: NotRequired[pulumi.Input[bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        shared_buffers_percentage: NotRequired[pulumi.Input[float]]
        """
        Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
        """
        synchronous_replication: NotRequired[pulumi.Input[str]]
        """
        Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        """
        temp_file_limit: NotRequired[pulumi.Input[int]]
        """
        PostgreSQL temporary file limit in KiB, -1 for unlimited.
        """
        timescaledb: NotRequired[pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgsDict']]
        """
        TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        PostgreSQL service timezone.
        """
        track_activity_query_size: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of bytes reserved to track the currently executing command for each active session.
        """
        track_commit_timestamp: NotRequired[pulumi.Input[str]]
        """
        Record commit time of transactions.
        """
        track_functions: NotRequired[pulumi.Input[str]]
        """
        Enables tracking of function call counts and time used.
        """
        track_io_timing: NotRequired[pulumi.Input[str]]
        """
        Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        """
        variant: NotRequired[pulumi.Input[str]]
        """
        Variant of the PostgreSQL service, may affect the features that are exposed by default.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        PostgreSQL major version.
        """
        wal_sender_timeout: NotRequired[pulumi.Input[int]]
        """
        Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
        """
        wal_writer_delay: NotRequired[pulumi.Input[int]]
        """
        WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
        """
        work_mem: NotRequired[pulumi.Input[int]]
        """
        Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
elif False:
    ManagedDatabasePostgresqlPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[bool]] = None,
                 autovacuum_analyze_scale_factor: Optional[pulumi.Input[float]] = None,
                 autovacuum_analyze_threshold: Optional[pulumi.Input[int]] = None,
                 autovacuum_freeze_max_age: Optional[pulumi.Input[int]] = None,
                 autovacuum_max_workers: Optional[pulumi.Input[int]] = None,
                 autovacuum_naptime: Optional[pulumi.Input[int]] = None,
                 autovacuum_vacuum_cost_delay: Optional[pulumi.Input[int]] = None,
                 autovacuum_vacuum_cost_limit: Optional[pulumi.Input[int]] = None,
                 autovacuum_vacuum_scale_factor: Optional[pulumi.Input[float]] = None,
                 autovacuum_vacuum_threshold: Optional[pulumi.Input[int]] = None,
                 backup_hour: Optional[pulumi.Input[int]] = None,
                 backup_minute: Optional[pulumi.Input[int]] = None,
                 bgwriter_delay: Optional[pulumi.Input[int]] = None,
                 bgwriter_flush_after: Optional[pulumi.Input[int]] = None,
                 bgwriter_lru_maxpages: Optional[pulumi.Input[int]] = None,
                 bgwriter_lru_multiplier: Optional[pulumi.Input[float]] = None,
                 deadlock_timeout: Optional[pulumi.Input[int]] = None,
                 default_toast_compression: Optional[pulumi.Input[str]] = None,
                 idle_in_transaction_session_timeout: Optional[pulumi.Input[int]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jit: Optional[pulumi.Input[bool]] = None,
                 log_autovacuum_min_duration: Optional[pulumi.Input[int]] = None,
                 log_error_verbosity: Optional[pulumi.Input[str]] = None,
                 log_line_prefix: Optional[pulumi.Input[str]] = None,
                 log_min_duration_statement: Optional[pulumi.Input[int]] = None,
                 log_temp_files: Optional[pulumi.Input[int]] = None,
                 max_files_per_process: Optional[pulumi.Input[int]] = None,
                 max_locks_per_transaction: Optional[pulumi.Input[int]] = None,
                 max_logical_replication_workers: Optional[pulumi.Input[int]] = None,
                 max_parallel_workers: Optional[pulumi.Input[int]] = None,
                 max_parallel_workers_per_gather: Optional[pulumi.Input[int]] = None,
                 max_pred_locks_per_transaction: Optional[pulumi.Input[int]] = None,
                 max_prepared_transactions: Optional[pulumi.Input[int]] = None,
                 max_replication_slots: Optional[pulumi.Input[int]] = None,
                 max_slot_wal_keep_size: Optional[pulumi.Input[int]] = None,
                 max_stack_depth: Optional[pulumi.Input[int]] = None,
                 max_standby_archive_delay: Optional[pulumi.Input[int]] = None,
                 max_standby_streaming_delay: Optional[pulumi.Input[int]] = None,
                 max_wal_senders: Optional[pulumi.Input[int]] = None,
                 max_worker_processes: Optional[pulumi.Input[int]] = None,
                 migration: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgs']] = None,
                 pg_partman_bgw_interval: Optional[pulumi.Input[int]] = None,
                 pg_partman_bgw_role: Optional[pulumi.Input[str]] = None,
                 pg_stat_monitor_enable: Optional[pulumi.Input[bool]] = None,
                 pg_stat_monitor_pgsm_enable_query_plan: Optional[pulumi.Input[bool]] = None,
                 pg_stat_monitor_pgsm_max_buckets: Optional[pulumi.Input[int]] = None,
                 pg_stat_statements_track: Optional[pulumi.Input[str]] = None,
                 pgbouncer: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgs']] = None,
                 pglookout: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgs']] = None,
                 public_access: Optional[pulumi.Input[bool]] = None,
                 service_log: Optional[pulumi.Input[bool]] = None,
                 shared_buffers_percentage: Optional[pulumi.Input[float]] = None,
                 synchronous_replication: Optional[pulumi.Input[str]] = None,
                 temp_file_limit: Optional[pulumi.Input[int]] = None,
                 timescaledb: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgs']] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 track_activity_query_size: Optional[pulumi.Input[int]] = None,
                 track_commit_timestamp: Optional[pulumi.Input[str]] = None,
                 track_functions: Optional[pulumi.Input[str]] = None,
                 track_io_timing: Optional[pulumi.Input[str]] = None,
                 variant: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 wal_sender_timeout: Optional[pulumi.Input[int]] = None,
                 wal_writer_delay: Optional[pulumi.Input[int]] = None,
                 work_mem: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] admin_password: Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        :param pulumi.Input[str] admin_username: Custom username for admin user. This must be set only when a new service is being created.
        :param pulumi.Input[bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[float] autovacuum_analyze_scale_factor: Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        :param pulumi.Input[int] autovacuum_analyze_threshold: Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        :param pulumi.Input[int] autovacuum_freeze_max_age: Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        :param pulumi.Input[int] autovacuum_max_workers: Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        :param pulumi.Input[int] autovacuum_naptime: Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.
        :param pulumi.Input[int] autovacuum_vacuum_cost_delay: Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.
        :param pulumi.Input[int] autovacuum_vacuum_cost_limit: Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        :param pulumi.Input[float] autovacuum_vacuum_scale_factor: Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        :param pulumi.Input[int] autovacuum_vacuum_threshold: Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        :param pulumi.Input[int] backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[int] backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param pulumi.Input[int] bgwriter_delay: Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
        :param pulumi.Input[int] bgwriter_flush_after: Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
        :param pulumi.Input[int] bgwriter_lru_maxpages: In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
        :param pulumi.Input[float] bgwriter_lru_multiplier: The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        :param pulumi.Input[int] deadlock_timeout: This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        :param pulumi.Input[str] default_toast_compression: Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        :param pulumi.Input[int] idle_in_transaction_session_timeout: Time out sessions with open transactions after this number of milliseconds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input[bool] jit: Controls system-wide use of Just-in-Time Compilation (JIT).
        :param pulumi.Input[int] log_autovacuum_min_duration: Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        :param pulumi.Input[str] log_error_verbosity: Controls the amount of detail written in the server log for each message that is logged.
        :param pulumi.Input[str] log_line_prefix: Choose from one of the available log formats.
        :param pulumi.Input[int] log_min_duration_statement: Log statements that take more than this number of milliseconds to run, -1 disables.
        :param pulumi.Input[int] log_temp_files: Log statements for each temporary file created larger than this number of kilobytes, -1 disables.
        :param pulumi.Input[int] max_files_per_process: PostgreSQL maximum number of files that can be open per process.
        :param pulumi.Input[int] max_locks_per_transaction: PostgreSQL maximum locks per transaction.
        :param pulumi.Input[int] max_logical_replication_workers: PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        :param pulumi.Input[int] max_parallel_workers: Sets the maximum number of workers that the system can support for parallel queries.
        :param pulumi.Input[int] max_parallel_workers_per_gather: Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        :param pulumi.Input[int] max_pred_locks_per_transaction: PostgreSQL maximum predicate locks per transaction.
        :param pulumi.Input[int] max_prepared_transactions: PostgreSQL maximum prepared transactions.
        :param pulumi.Input[int] max_replication_slots: PostgreSQL maximum replication slots.
        :param pulumi.Input[int] max_slot_wal_keep_size: PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
        :param pulumi.Input[int] max_stack_depth: Maximum depth of the stack in bytes.
        :param pulumi.Input[int] max_standby_archive_delay: Max standby archive delay in milliseconds.
        :param pulumi.Input[int] max_standby_streaming_delay: Max standby streaming delay in milliseconds.
        :param pulumi.Input[int] max_wal_senders: PostgreSQL maximum WAL senders.
        :param pulumi.Input[int] max_worker_processes: Sets the maximum number of background processes that the system can support.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgs'] migration: Migrate data from existing server.
        :param pulumi.Input[int] pg_partman_bgw_interval: Sets the time interval to run pg_partman's scheduled tasks.
        :param pulumi.Input[str] pg_partman_bgw_role: Controls which role to use for pg_partman's scheduled background tasks.
        :param pulumi.Input[bool] pg_stat_monitor_enable: Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        :param pulumi.Input[bool] pg_stat_monitor_pgsm_enable_query_plan: Enables or disables query plan monitoring.
        :param pulumi.Input[int] pg_stat_monitor_pgsm_max_buckets: Sets the maximum number of buckets.
        :param pulumi.Input[str] pg_stat_statements_track: Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgs'] pgbouncer: PGBouncer connection pooling settings. System-wide settings for pgbouncer.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgs'] pglookout: PGLookout settings. System-wide settings for pglookout.
        :param pulumi.Input[bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param pulumi.Input[float] shared_buffers_percentage: Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
        :param pulumi.Input[str] synchronous_replication: Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        :param pulumi.Input[int] temp_file_limit: PostgreSQL temporary file limit in KiB, -1 for unlimited.
        :param pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgs'] timescaledb: TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.
        :param pulumi.Input[str] timezone: PostgreSQL service timezone.
        :param pulumi.Input[int] track_activity_query_size: Specifies the number of bytes reserved to track the currently executing command for each active session.
        :param pulumi.Input[str] track_commit_timestamp: Record commit time of transactions.
        :param pulumi.Input[str] track_functions: Enables tracking of function call counts and time used.
        :param pulumi.Input[str] track_io_timing: Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        :param pulumi.Input[str] variant: Variant of the PostgreSQL service, may affect the features that are exposed by default.
        :param pulumi.Input[str] version: PostgreSQL major version.
        :param pulumi.Input[int] wal_sender_timeout: Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
        :param pulumi.Input[int] wal_writer_delay: WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
        :param pulumi.Input[int] work_mem: Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_analyze_threshold is not None:
            pulumi.set(__self__, "autovacuum_analyze_threshold", autovacuum_analyze_threshold)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if bgwriter_delay is not None:
            pulumi.set(__self__, "bgwriter_delay", bgwriter_delay)
        if bgwriter_flush_after is not None:
            pulumi.set(__self__, "bgwriter_flush_after", bgwriter_flush_after)
        if bgwriter_lru_maxpages is not None:
            pulumi.set(__self__, "bgwriter_lru_maxpages", bgwriter_lru_maxpages)
        if bgwriter_lru_multiplier is not None:
            pulumi.set(__self__, "bgwriter_lru_multiplier", bgwriter_lru_multiplier)
        if deadlock_timeout is not None:
            pulumi.set(__self__, "deadlock_timeout", deadlock_timeout)
        if default_toast_compression is not None:
            pulumi.set(__self__, "default_toast_compression", default_toast_compression)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if jit is not None:
            pulumi.set(__self__, "jit", jit)
        if log_autovacuum_min_duration is not None:
            pulumi.set(__self__, "log_autovacuum_min_duration", log_autovacuum_min_duration)
        if log_error_verbosity is not None:
            pulumi.set(__self__, "log_error_verbosity", log_error_verbosity)
        if log_line_prefix is not None:
            pulumi.set(__self__, "log_line_prefix", log_line_prefix)
        if log_min_duration_statement is not None:
            pulumi.set(__self__, "log_min_duration_statement", log_min_duration_statement)
        if log_temp_files is not None:
            pulumi.set(__self__, "log_temp_files", log_temp_files)
        if max_files_per_process is not None:
            pulumi.set(__self__, "max_files_per_process", max_files_per_process)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_logical_replication_workers is not None:
            pulumi.set(__self__, "max_logical_replication_workers", max_logical_replication_workers)
        if max_parallel_workers is not None:
            pulumi.set(__self__, "max_parallel_workers", max_parallel_workers)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_pred_locks_per_transaction is not None:
            pulumi.set(__self__, "max_pred_locks_per_transaction", max_pred_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_slot_wal_keep_size is not None:
            pulumi.set(__self__, "max_slot_wal_keep_size", max_slot_wal_keep_size)
        if max_stack_depth is not None:
            pulumi.set(__self__, "max_stack_depth", max_stack_depth)
        if max_standby_archive_delay is not None:
            pulumi.set(__self__, "max_standby_archive_delay", max_standby_archive_delay)
        if max_standby_streaming_delay is not None:
            pulumi.set(__self__, "max_standby_streaming_delay", max_standby_streaming_delay)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if pg_partman_bgw_interval is not None:
            pulumi.set(__self__, "pg_partman_bgw_interval", pg_partman_bgw_interval)
        if pg_partman_bgw_role is not None:
            pulumi.set(__self__, "pg_partman_bgw_role", pg_partman_bgw_role)
        if pg_stat_monitor_enable is not None:
            pulumi.set(__self__, "pg_stat_monitor_enable", pg_stat_monitor_enable)
        if pg_stat_monitor_pgsm_enable_query_plan is not None:
            pulumi.set(__self__, "pg_stat_monitor_pgsm_enable_query_plan", pg_stat_monitor_pgsm_enable_query_plan)
        if pg_stat_monitor_pgsm_max_buckets is not None:
            pulumi.set(__self__, "pg_stat_monitor_pgsm_max_buckets", pg_stat_monitor_pgsm_max_buckets)
        if pg_stat_statements_track is not None:
            pulumi.set(__self__, "pg_stat_statements_track", pg_stat_statements_track)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if pglookout is not None:
            pulumi.set(__self__, "pglookout", pglookout)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if shared_buffers_percentage is not None:
            pulumi.set(__self__, "shared_buffers_percentage", shared_buffers_percentage)
        if synchronous_replication is not None:
            pulumi.set(__self__, "synchronous_replication", synchronous_replication)
        if temp_file_limit is not None:
            pulumi.set(__self__, "temp_file_limit", temp_file_limit)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if track_activity_query_size is not None:
            pulumi.set(__self__, "track_activity_query_size", track_activity_query_size)
        if track_commit_timestamp is not None:
            pulumi.set(__self__, "track_commit_timestamp", track_commit_timestamp)
        if track_functions is not None:
            pulumi.set(__self__, "track_functions", track_functions)
        if track_io_timing is not None:
            pulumi.set(__self__, "track_io_timing", track_io_timing)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if wal_sender_timeout is not None:
            pulumi.set(__self__, "wal_sender_timeout", wal_sender_timeout)
        if wal_writer_delay is not None:
            pulumi.set(__self__, "wal_writer_delay", wal_writer_delay)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        """
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @autovacuum_analyze_scale_factor.setter
    def autovacuum_analyze_scale_factor(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "autovacuum_analyze_scale_factor", value)

    @property
    @pulumi.getter(name="autovacuumAnalyzeThreshold")
    def autovacuum_analyze_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        """
        return pulumi.get(self, "autovacuum_analyze_threshold")

    @autovacuum_analyze_threshold.setter
    def autovacuum_analyze_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autovacuum_analyze_threshold", value)

    @property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        """
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @autovacuum_freeze_max_age.setter
    def autovacuum_freeze_max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autovacuum_freeze_max_age", value)

    @property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        """
        return pulumi.get(self, "autovacuum_max_workers")

    @autovacuum_max_workers.setter
    def autovacuum_max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autovacuum_max_workers", value)

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.
        """
        return pulumi.get(self, "autovacuum_naptime")

    @autovacuum_naptime.setter
    def autovacuum_naptime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autovacuum_naptime", value)

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @autovacuum_vacuum_cost_delay.setter
    def autovacuum_vacuum_cost_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autovacuum_vacuum_cost_delay", value)

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @autovacuum_vacuum_cost_limit.setter
    def autovacuum_vacuum_cost_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autovacuum_vacuum_cost_limit", value)

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        """
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @autovacuum_vacuum_scale_factor.setter
    def autovacuum_vacuum_scale_factor(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "autovacuum_vacuum_scale_factor", value)

    @property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        """
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @autovacuum_vacuum_threshold.setter
    def autovacuum_vacuum_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autovacuum_vacuum_threshold", value)

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[pulumi.Input[int]]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @backup_hour.setter
    def backup_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_hour", value)

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[pulumi.Input[int]]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @backup_minute.setter
    def backup_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backup_minute", value)

    @property
    @pulumi.getter(name="bgwriterDelay")
    def bgwriter_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
        """
        return pulumi.get(self, "bgwriter_delay")

    @bgwriter_delay.setter
    def bgwriter_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bgwriter_delay", value)

    @property
    @pulumi.getter(name="bgwriterFlushAfter")
    def bgwriter_flush_after(self) -> Optional[pulumi.Input[int]]:
        """
        Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
        """
        return pulumi.get(self, "bgwriter_flush_after")

    @bgwriter_flush_after.setter
    def bgwriter_flush_after(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bgwriter_flush_after", value)

    @property
    @pulumi.getter(name="bgwriterLruMaxpages")
    def bgwriter_lru_maxpages(self) -> Optional[pulumi.Input[int]]:
        """
        In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
        """
        return pulumi.get(self, "bgwriter_lru_maxpages")

    @bgwriter_lru_maxpages.setter
    def bgwriter_lru_maxpages(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bgwriter_lru_maxpages", value)

    @property
    @pulumi.getter(name="bgwriterLruMultiplier")
    def bgwriter_lru_multiplier(self) -> Optional[pulumi.Input[float]]:
        """
        The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        """
        return pulumi.get(self, "bgwriter_lru_multiplier")

    @bgwriter_lru_multiplier.setter
    def bgwriter_lru_multiplier(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "bgwriter_lru_multiplier", value)

    @property
    @pulumi.getter(name="deadlockTimeout")
    def deadlock_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        """
        return pulumi.get(self, "deadlock_timeout")

    @deadlock_timeout.setter
    def deadlock_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "deadlock_timeout", value)

    @property
    @pulumi.getter(name="defaultToastCompression")
    def default_toast_compression(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        """
        return pulumi.get(self, "default_toast_compression")

    @default_toast_compression.setter
    def default_toast_compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_toast_compression", value)

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Time out sessions with open transactions after this number of milliseconds.
        """
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @idle_in_transaction_session_timeout.setter
    def idle_in_transaction_session_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_in_transaction_session_timeout", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter
    def jit(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls system-wide use of Just-in-Time Compilation (JIT).
        """
        return pulumi.get(self, "jit")

    @jit.setter
    def jit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jit", value)

    @property
    @pulumi.getter(name="logAutovacuumMinDuration")
    def log_autovacuum_min_duration(self) -> Optional[pulumi.Input[int]]:
        """
        Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        """
        return pulumi.get(self, "log_autovacuum_min_duration")

    @log_autovacuum_min_duration.setter
    def log_autovacuum_min_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_autovacuum_min_duration", value)

    @property
    @pulumi.getter(name="logErrorVerbosity")
    def log_error_verbosity(self) -> Optional[pulumi.Input[str]]:
        """
        Controls the amount of detail written in the server log for each message that is logged.
        """
        return pulumi.get(self, "log_error_verbosity")

    @log_error_verbosity.setter
    def log_error_verbosity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_error_verbosity", value)

    @property
    @pulumi.getter(name="logLinePrefix")
    def log_line_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Choose from one of the available log formats.
        """
        return pulumi.get(self, "log_line_prefix")

    @log_line_prefix.setter
    def log_line_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_line_prefix", value)

    @property
    @pulumi.getter(name="logMinDurationStatement")
    def log_min_duration_statement(self) -> Optional[pulumi.Input[int]]:
        """
        Log statements that take more than this number of milliseconds to run, -1 disables.
        """
        return pulumi.get(self, "log_min_duration_statement")

    @log_min_duration_statement.setter
    def log_min_duration_statement(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_min_duration_statement", value)

    @property
    @pulumi.getter(name="logTempFiles")
    def log_temp_files(self) -> Optional[pulumi.Input[int]]:
        """
        Log statements for each temporary file created larger than this number of kilobytes, -1 disables.
        """
        return pulumi.get(self, "log_temp_files")

    @log_temp_files.setter
    def log_temp_files(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_temp_files", value)

    @property
    @pulumi.getter(name="maxFilesPerProcess")
    def max_files_per_process(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL maximum number of files that can be open per process.
        """
        return pulumi.get(self, "max_files_per_process")

    @max_files_per_process.setter
    def max_files_per_process(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_files_per_process", value)

    @property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL maximum locks per transaction.
        """
        return pulumi.get(self, "max_locks_per_transaction")

    @max_locks_per_transaction.setter
    def max_locks_per_transaction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_locks_per_transaction", value)

    @property
    @pulumi.getter(name="maxLogicalReplicationWorkers")
    def max_logical_replication_workers(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        """
        return pulumi.get(self, "max_logical_replication_workers")

    @max_logical_replication_workers.setter
    def max_logical_replication_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_logical_replication_workers", value)

    @property
    @pulumi.getter(name="maxParallelWorkers")
    def max_parallel_workers(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the maximum number of workers that the system can support for parallel queries.
        """
        return pulumi.get(self, "max_parallel_workers")

    @max_parallel_workers.setter
    def max_parallel_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parallel_workers", value)

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        """
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @max_parallel_workers_per_gather.setter
    def max_parallel_workers_per_gather(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parallel_workers_per_gather", value)

    @property
    @pulumi.getter(name="maxPredLocksPerTransaction")
    def max_pred_locks_per_transaction(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL maximum predicate locks per transaction.
        """
        return pulumi.get(self, "max_pred_locks_per_transaction")

    @max_pred_locks_per_transaction.setter
    def max_pred_locks_per_transaction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pred_locks_per_transaction", value)

    @property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL maximum prepared transactions.
        """
        return pulumi.get(self, "max_prepared_transactions")

    @max_prepared_transactions.setter
    def max_prepared_transactions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_prepared_transactions", value)

    @property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL maximum replication slots.
        """
        return pulumi.get(self, "max_replication_slots")

    @max_replication_slots.setter
    def max_replication_slots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replication_slots", value)

    @property
    @pulumi.getter(name="maxSlotWalKeepSize")
    def max_slot_wal_keep_size(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
        """
        return pulumi.get(self, "max_slot_wal_keep_size")

    @max_slot_wal_keep_size.setter
    def max_slot_wal_keep_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_slot_wal_keep_size", value)

    @property
    @pulumi.getter(name="maxStackDepth")
    def max_stack_depth(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum depth of the stack in bytes.
        """
        return pulumi.get(self, "max_stack_depth")

    @max_stack_depth.setter
    def max_stack_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_stack_depth", value)

    @property
    @pulumi.getter(name="maxStandbyArchiveDelay")
    def max_standby_archive_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Max standby archive delay in milliseconds.
        """
        return pulumi.get(self, "max_standby_archive_delay")

    @max_standby_archive_delay.setter
    def max_standby_archive_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_standby_archive_delay", value)

    @property
    @pulumi.getter(name="maxStandbyStreamingDelay")
    def max_standby_streaming_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Max standby streaming delay in milliseconds.
        """
        return pulumi.get(self, "max_standby_streaming_delay")

    @max_standby_streaming_delay.setter
    def max_standby_streaming_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_standby_streaming_delay", value)

    @property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL maximum WAL senders.
        """
        return pulumi.get(self, "max_wal_senders")

    @max_wal_senders.setter
    def max_wal_senders(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_wal_senders", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the maximum number of background processes that the system can support.
        """
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter
    def migration(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgs']]:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @migration.setter
    def migration(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesMigrationArgs']]):
        pulumi.set(self, "migration", value)

    @property
    @pulumi.getter(name="pgPartmanBgwInterval")
    def pg_partman_bgw_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the time interval to run pg_partman's scheduled tasks.
        """
        return pulumi.get(self, "pg_partman_bgw_interval")

    @pg_partman_bgw_interval.setter
    def pg_partman_bgw_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pg_partman_bgw_interval", value)

    @property
    @pulumi.getter(name="pgPartmanBgwRole")
    def pg_partman_bgw_role(self) -> Optional[pulumi.Input[str]]:
        """
        Controls which role to use for pg_partman's scheduled background tasks.
        """
        return pulumi.get(self, "pg_partman_bgw_role")

    @pg_partman_bgw_role.setter
    def pg_partman_bgw_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pg_partman_bgw_role", value)

    @property
    @pulumi.getter(name="pgStatMonitorEnable")
    def pg_stat_monitor_enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        """
        return pulumi.get(self, "pg_stat_monitor_enable")

    @pg_stat_monitor_enable.setter
    def pg_stat_monitor_enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pg_stat_monitor_enable", value)

    @property
    @pulumi.getter(name="pgStatMonitorPgsmEnableQueryPlan")
    def pg_stat_monitor_pgsm_enable_query_plan(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables or disables query plan monitoring.
        """
        return pulumi.get(self, "pg_stat_monitor_pgsm_enable_query_plan")

    @pg_stat_monitor_pgsm_enable_query_plan.setter
    def pg_stat_monitor_pgsm_enable_query_plan(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pg_stat_monitor_pgsm_enable_query_plan", value)

    @property
    @pulumi.getter(name="pgStatMonitorPgsmMaxBuckets")
    def pg_stat_monitor_pgsm_max_buckets(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the maximum number of buckets.
        """
        return pulumi.get(self, "pg_stat_monitor_pgsm_max_buckets")

    @pg_stat_monitor_pgsm_max_buckets.setter
    def pg_stat_monitor_pgsm_max_buckets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pg_stat_monitor_pgsm_max_buckets", value)

    @property
    @pulumi.getter(name="pgStatStatementsTrack")
    def pg_stat_statements_track(self) -> Optional[pulumi.Input[str]]:
        """
        Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
        """
        return pulumi.get(self, "pg_stat_statements_track")

    @pg_stat_statements_track.setter
    def pg_stat_statements_track(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pg_stat_statements_track", value)

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgs']]:
        """
        PGBouncer connection pooling settings. System-wide settings for pgbouncer.
        """
        return pulumi.get(self, "pgbouncer")

    @pgbouncer.setter
    def pgbouncer(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPgbouncerArgs']]):
        pulumi.set(self, "pgbouncer", value)

    @property
    @pulumi.getter
    def pglookout(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgs']]:
        """
        PGLookout settings. System-wide settings for pglookout.
        """
        return pulumi.get(self, "pglookout")

    @pglookout.setter
    def pglookout(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesPglookoutArgs']]):
        pulumi.set(self, "pglookout", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "service_log", value)

    @property
    @pulumi.getter(name="sharedBuffersPercentage")
    def shared_buffers_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
        """
        return pulumi.get(self, "shared_buffers_percentage")

    @shared_buffers_percentage.setter
    def shared_buffers_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "shared_buffers_percentage", value)

    @property
    @pulumi.getter(name="synchronousReplication")
    def synchronous_replication(self) -> Optional[pulumi.Input[str]]:
        """
        Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        """
        return pulumi.get(self, "synchronous_replication")

    @synchronous_replication.setter
    def synchronous_replication(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "synchronous_replication", value)

    @property
    @pulumi.getter(name="tempFileLimit")
    def temp_file_limit(self) -> Optional[pulumi.Input[int]]:
        """
        PostgreSQL temporary file limit in KiB, -1 for unlimited.
        """
        return pulumi.get(self, "temp_file_limit")

    @temp_file_limit.setter
    def temp_file_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "temp_file_limit", value)

    @property
    @pulumi.getter
    def timescaledb(self) -> Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgs']]:
        """
        TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.
        """
        return pulumi.get(self, "timescaledb")

    @timescaledb.setter
    def timescaledb(self, value: Optional[pulumi.Input['ManagedDatabasePostgresqlPropertiesTimescaledbArgs']]):
        pulumi.set(self, "timescaledb", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        PostgreSQL service timezone.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="trackActivityQuerySize")
    def track_activity_query_size(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of bytes reserved to track the currently executing command for each active session.
        """
        return pulumi.get(self, "track_activity_query_size")

    @track_activity_query_size.setter
    def track_activity_query_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "track_activity_query_size", value)

    @property
    @pulumi.getter(name="trackCommitTimestamp")
    def track_commit_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        Record commit time of transactions.
        """
        return pulumi.get(self, "track_commit_timestamp")

    @track_commit_timestamp.setter
    def track_commit_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "track_commit_timestamp", value)

    @property
    @pulumi.getter(name="trackFunctions")
    def track_functions(self) -> Optional[pulumi.Input[str]]:
        """
        Enables tracking of function call counts and time used.
        """
        return pulumi.get(self, "track_functions")

    @track_functions.setter
    def track_functions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "track_functions", value)

    @property
    @pulumi.getter(name="trackIoTiming")
    def track_io_timing(self) -> Optional[pulumi.Input[str]]:
        """
        Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        """
        return pulumi.get(self, "track_io_timing")

    @track_io_timing.setter
    def track_io_timing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "track_io_timing", value)

    @property
    @pulumi.getter
    def variant(self) -> Optional[pulumi.Input[str]]:
        """
        Variant of the PostgreSQL service, may affect the features that are exposed by default.
        """
        return pulumi.get(self, "variant")

    @variant.setter
    def variant(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "variant", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        PostgreSQL major version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="walSenderTimeout")
    def wal_sender_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
        """
        return pulumi.get(self, "wal_sender_timeout")

    @wal_sender_timeout.setter
    def wal_sender_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wal_sender_timeout", value)

    @property
    @pulumi.getter(name="walWriterDelay")
    def wal_writer_delay(self) -> Optional[pulumi.Input[int]]:
        """
        WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
        """
        return pulumi.get(self, "wal_writer_delay")

    @wal_writer_delay.setter
    def wal_writer_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wal_writer_delay", value)

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
        return pulumi.get(self, "work_mem")

    @work_mem.setter
    def work_mem(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "work_mem", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesMigrationArgsDict(TypedDict):
        dbname: NotRequired[pulumi.Input[str]]
        """
        Database name for bootstrapping the initial connection.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Hostname or IP address of the server where to migrate data from.
        """
        ignore_dbs: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        ignore_roles: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password for authentication with the server where to migrate data from.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number of the server where to migrate data from.
        """
        ssl: NotRequired[pulumi.Input[bool]]
        """
        The server where to migrate data from is secured with SSL.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        User name for authentication with the server where to migrate data from.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesMigrationArgs:
    def __init__(__self__, *,
                 dbname: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 ignore_dbs: Optional[pulumi.Input[str]] = None,
                 ignore_roles: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 ssl: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbname: Database name for bootstrapping the initial connection.
        :param pulumi.Input[str] host: Hostname or IP address of the server where to migrate data from.
        :param pulumi.Input[str] ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param pulumi.Input[str] ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param pulumi.Input[str] method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param pulumi.Input[str] password: Password for authentication with the server where to migrate data from.
        :param pulumi.Input[int] port: Port number of the server where to migrate data from.
        :param pulumi.Input[bool] ssl: The server where to migrate data from is secured with SSL.
        :param pulumi.Input[str] username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[pulumi.Input[str]]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @ignore_dbs.setter
    def ignore_dbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ignore_dbs", value)

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @ignore_roles.setter
    def ignore_roles(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ignore_roles", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesPgbouncerArgsDict(TypedDict):
        autodb_idle_timeout: NotRequired[pulumi.Input[int]]
        """
        If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].
        """
        autodb_max_db_connections: NotRequired[pulumi.Input[int]]
        """
        Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
        """
        autodb_pool_mode: NotRequired[pulumi.Input[str]]
        """
        PGBouncer pool mode.
        """
        autodb_pool_size: NotRequired[pulumi.Input[int]]
        """
        If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
        """
        ignore_startup_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of parameters to ignore when given in startup packet.
        """
        max_prepared_statements: NotRequired[pulumi.Input[int]]
        """
        PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.
        """
        min_pool_size: NotRequired[pulumi.Input[int]]
        """
        Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        """
        server_idle_timeout: NotRequired[pulumi.Input[int]]
        """
        If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].
        """
        server_lifetime: NotRequired[pulumi.Input[int]]
        """
        The pooler will close an unused server connection that has been connected longer than this. [seconds].
        """
        server_reset_query_always: NotRequired[pulumi.Input[bool]]
        """
        Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesPgbouncerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesPgbouncerArgs:
    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[pulumi.Input[int]] = None,
                 autodb_max_db_connections: Optional[pulumi.Input[int]] = None,
                 autodb_pool_mode: Optional[pulumi.Input[str]] = None,
                 autodb_pool_size: Optional[pulumi.Input[int]] = None,
                 ignore_startup_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_prepared_statements: Optional[pulumi.Input[int]] = None,
                 min_pool_size: Optional[pulumi.Input[int]] = None,
                 server_idle_timeout: Optional[pulumi.Input[int]] = None,
                 server_lifetime: Optional[pulumi.Input[int]] = None,
                 server_reset_query_always: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] autodb_idle_timeout: If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].
        :param pulumi.Input[int] autodb_max_db_connections: Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
        :param pulumi.Input[str] autodb_pool_mode: PGBouncer pool mode.
        :param pulumi.Input[int] autodb_pool_size: If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ignore_startup_parameters: List of parameters to ignore when given in startup packet.
        :param pulumi.Input[int] max_prepared_statements: PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.
        :param pulumi.Input[int] min_pool_size: Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        :param pulumi.Input[int] server_idle_timeout: If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].
        :param pulumi.Input[int] server_lifetime: The pooler will close an unused server connection that has been connected longer than this. [seconds].
        :param pulumi.Input[bool] server_reset_query_always: Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if max_prepared_statements is not None:
            pulumi.set(__self__, "max_prepared_statements", max_prepared_statements)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].
        """
        return pulumi.get(self, "autodb_idle_timeout")

    @autodb_idle_timeout.setter
    def autodb_idle_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autodb_idle_timeout", value)

    @property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
        """
        return pulumi.get(self, "autodb_max_db_connections")

    @autodb_max_db_connections.setter
    def autodb_max_db_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autodb_max_db_connections", value)

    @property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[pulumi.Input[str]]:
        """
        PGBouncer pool mode.
        """
        return pulumi.get(self, "autodb_pool_mode")

    @autodb_pool_mode.setter
    def autodb_pool_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autodb_pool_mode", value)

    @property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[pulumi.Input[int]]:
        """
        If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
        """
        return pulumi.get(self, "autodb_pool_size")

    @autodb_pool_size.setter
    def autodb_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autodb_pool_size", value)

    @property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of parameters to ignore when given in startup packet.
        """
        return pulumi.get(self, "ignore_startup_parameters")

    @ignore_startup_parameters.setter
    def ignore_startup_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ignore_startup_parameters", value)

    @property
    @pulumi.getter(name="maxPreparedStatements")
    def max_prepared_statements(self) -> Optional[pulumi.Input[int]]:
        """
        PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.
        """
        return pulumi.get(self, "max_prepared_statements")

    @max_prepared_statements.setter
    def max_prepared_statements(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_prepared_statements", value)

    @property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[pulumi.Input[int]]:
        """
        Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        """
        return pulumi.get(self, "min_pool_size")

    @min_pool_size.setter
    def min_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_pool_size", value)

    @property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].
        """
        return pulumi.get(self, "server_idle_timeout")

    @server_idle_timeout.setter
    def server_idle_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "server_idle_timeout", value)

    @property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[pulumi.Input[int]]:
        """
        The pooler will close an unused server connection that has been connected longer than this. [seconds].
        """
        return pulumi.get(self, "server_lifetime")

    @server_lifetime.setter
    def server_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "server_lifetime", value)

    @property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[pulumi.Input[bool]]:
        """
        Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
        return pulumi.get(self, "server_reset_query_always")

    @server_reset_query_always.setter
    def server_reset_query_always(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_reset_query_always", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesPglookoutArgsDict(TypedDict):
        max_failover_replication_time_lag: NotRequired[pulumi.Input[int]]
        """
        Number of seconds of master unavailability before triggering database failover to standby.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesPglookoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesPglookoutArgs:
    def __init__(__self__, *,
                 max_failover_replication_time_lag: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_failover_replication_time_lag: Number of seconds of master unavailability before triggering database failover to standby.
        """
        if max_failover_replication_time_lag is not None:
            pulumi.set(__self__, "max_failover_replication_time_lag", max_failover_replication_time_lag)

    @property
    @pulumi.getter(name="maxFailoverReplicationTimeLag")
    def max_failover_replication_time_lag(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds of master unavailability before triggering database failover to standby.
        """
        return pulumi.get(self, "max_failover_replication_time_lag")

    @max_failover_replication_time_lag.setter
    def max_failover_replication_time_lag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_failover_replication_time_lag", value)


if not MYPY:
    class ManagedDatabasePostgresqlPropertiesTimescaledbArgsDict(TypedDict):
        max_background_workers: NotRequired[pulumi.Input[int]]
        """
        The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
elif False:
    ManagedDatabasePostgresqlPropertiesTimescaledbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabasePostgresqlPropertiesTimescaledbArgs:
    def __init__(__self__, *,
                 max_background_workers: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_background_workers: The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[pulumi.Input[int]]:
        """
        The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
        return pulumi.get(self, "max_background_workers")

    @max_background_workers.setter
    def max_background_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_background_workers", value)


if not MYPY:
    class ManagedDatabaseRedisComponentArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[str]]
        """
        Type of the component
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Hostname of the component
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number of the component
        """
        route: NotRequired[pulumi.Input[str]]
        """
        Component network route type
        """
        usage: NotRequired[pulumi.Input[str]]
        """
        Usage of the component
        """
elif False:
    ManagedDatabaseRedisComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisComponentArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 route: Optional[pulumi.Input[str]] = None,
                 usage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] component: Type of the component
        :param pulumi.Input[str] host: Hostname of the component
        :param pulumi.Input[int] port: Port number of the component
        :param pulumi.Input[str] route: Component network route type
        :param pulumi.Input[str] usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[str]]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[str]]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage", value)


if not MYPY:
    class ManagedDatabaseRedisNetworkArgsDict(TypedDict):
        family: pulumi.Input[str]
        """
        Network family. Currently only `IPv4` is supported.
        """
        name: pulumi.Input[str]
        """
        The name of the network. Must be unique within the service.
        """
        type: pulumi.Input[str]
        """
        The type of the network. Must be private.
        """
        uuid: pulumi.Input[str]
        """
        Private network UUID. Must reside in the same zone as the database.
        """
elif False:
    ManagedDatabaseRedisNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uuid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] family: Network family. Currently only `IPv4` is supported.
        :param pulumi.Input[str] name: The name of the network. Must be unique within the service.
        :param pulumi.Input[str] type: The type of the network. Must be private.
        :param pulumi.Input[str] uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[str]:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ManagedDatabaseRedisNodeStateArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name plus a node iteration
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Role of the node
        """
        state: NotRequired[pulumi.Input[str]]
        """
        State of the node
        """
elif False:
    ManagedDatabaseRedisNodeStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisNodeStateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name plus a node iteration
        :param pulumi.Input[str] role: Role of the node
        :param pulumi.Input[str] state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of the node
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ManagedDatabaseRedisPropertiesArgsDict(TypedDict):
        automatic_utility_network_ip_filter: NotRequired[pulumi.Input[bool]]
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        ip_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        migration: NotRequired[pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgsDict']]
        """
        Migrate data from existing server.
        """
        public_access: NotRequired[pulumi.Input[bool]]
        """
        Public Access. Allow access to the service from the public Internet.
        """
        redis_acl_channels_default: NotRequired[pulumi.Input[str]]
        """
        Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        """
        redis_io_threads: NotRequired[pulumi.Input[int]]
        """
        Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.
        """
        redis_lfu_decay_time: NotRequired[pulumi.Input[int]]
        """
        LFU maxmemory-policy counter decay time in minutes.
        """
        redis_lfu_log_factor: NotRequired[pulumi.Input[int]]
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        """
        redis_maxmemory_policy: NotRequired[pulumi.Input[str]]
        """
        Redis maxmemory-policy.
        """
        redis_notify_keyspace_events: NotRequired[pulumi.Input[str]]
        """
        Set notify-keyspace-events option.
        """
        redis_number_of_databases: NotRequired[pulumi.Input[int]]
        """
        Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.
        """
        redis_persistence: NotRequired[pulumi.Input[str]]
        """
        Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.
        """
        redis_pubsub_client_output_buffer_limit: NotRequired[pulumi.Input[int]]
        """
        Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        """
        redis_ssl: NotRequired[pulumi.Input[bool]]
        """
        Require SSL to access Redis.
        """
        redis_timeout: NotRequired[pulumi.Input[int]]
        """
        Redis idle connection timeout in seconds.
        """
        redis_version: NotRequired[pulumi.Input[str]]
        """
        Redis major version.
        """
        service_log: NotRequired[pulumi.Input[bool]]
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
elif False:
    ManagedDatabaseRedisPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisPropertiesArgs:
    def __init__(__self__, *,
                 automatic_utility_network_ip_filter: Optional[pulumi.Input[bool]] = None,
                 ip_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 migration: Optional[pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgs']] = None,
                 public_access: Optional[pulumi.Input[bool]] = None,
                 redis_acl_channels_default: Optional[pulumi.Input[str]] = None,
                 redis_io_threads: Optional[pulumi.Input[int]] = None,
                 redis_lfu_decay_time: Optional[pulumi.Input[int]] = None,
                 redis_lfu_log_factor: Optional[pulumi.Input[int]] = None,
                 redis_maxmemory_policy: Optional[pulumi.Input[str]] = None,
                 redis_notify_keyspace_events: Optional[pulumi.Input[str]] = None,
                 redis_number_of_databases: Optional[pulumi.Input[int]] = None,
                 redis_persistence: Optional[pulumi.Input[str]] = None,
                 redis_pubsub_client_output_buffer_limit: Optional[pulumi.Input[int]] = None,
                 redis_ssl: Optional[pulumi.Input[bool]] = None,
                 redis_timeout: Optional[pulumi.Input[int]] = None,
                 redis_version: Optional[pulumi.Input[str]] = None,
                 service_log: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgs'] migration: Migrate data from existing server.
        :param pulumi.Input[bool] public_access: Public Access. Allow access to the service from the public Internet.
        :param pulumi.Input[str] redis_acl_channels_default: Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        :param pulumi.Input[int] redis_io_threads: Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.
        :param pulumi.Input[int] redis_lfu_decay_time: LFU maxmemory-policy counter decay time in minutes.
        :param pulumi.Input[int] redis_lfu_log_factor: Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        :param pulumi.Input[str] redis_maxmemory_policy: Redis maxmemory-policy.
        :param pulumi.Input[str] redis_notify_keyspace_events: Set notify-keyspace-events option.
        :param pulumi.Input[int] redis_number_of_databases: Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.
        :param pulumi.Input[str] redis_persistence: Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.
        :param pulumi.Input[int] redis_pubsub_client_output_buffer_limit: Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        :param pulumi.Input[bool] redis_ssl: Require SSL to access Redis.
        :param pulumi.Input[int] redis_timeout: Redis idle connection timeout in seconds.
        :param pulumi.Input[str] redis_version: Redis major version.
        :param pulumi.Input[bool] service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if redis_acl_channels_default is not None:
            pulumi.set(__self__, "redis_acl_channels_default", redis_acl_channels_default)
        if redis_io_threads is not None:
            pulumi.set(__self__, "redis_io_threads", redis_io_threads)
        if redis_lfu_decay_time is not None:
            pulumi.set(__self__, "redis_lfu_decay_time", redis_lfu_decay_time)
        if redis_lfu_log_factor is not None:
            pulumi.set(__self__, "redis_lfu_log_factor", redis_lfu_log_factor)
        if redis_maxmemory_policy is not None:
            pulumi.set(__self__, "redis_maxmemory_policy", redis_maxmemory_policy)
        if redis_notify_keyspace_events is not None:
            pulumi.set(__self__, "redis_notify_keyspace_events", redis_notify_keyspace_events)
        if redis_number_of_databases is not None:
            pulumi.set(__self__, "redis_number_of_databases", redis_number_of_databases)
        if redis_persistence is not None:
            pulumi.set(__self__, "redis_persistence", redis_persistence)
        if redis_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "redis_pubsub_client_output_buffer_limit", redis_pubsub_client_output_buffer_limit)
        if redis_ssl is not None:
            pulumi.set(__self__, "redis_ssl", redis_ssl)
        if redis_timeout is not None:
            pulumi.set(__self__, "redis_timeout", redis_timeout)
        if redis_version is not None:
            pulumi.set(__self__, "redis_version", redis_version)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[pulumi.Input[bool]]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @automatic_utility_network_ip_filter.setter
    def automatic_utility_network_ip_filter(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_utility_network_ip_filter", value)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @ip_filters.setter
    def ip_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_filters", value)

    @property
    @pulumi.getter
    def migration(self) -> Optional[pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgs']]:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @migration.setter
    def migration(self, value: Optional[pulumi.Input['ManagedDatabaseRedisPropertiesMigrationArgs']]):
        pulumi.set(self, "migration", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="redisAclChannelsDefault")
    def redis_acl_channels_default(self) -> Optional[pulumi.Input[str]]:
        """
        Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        """
        return pulumi.get(self, "redis_acl_channels_default")

    @redis_acl_channels_default.setter
    def redis_acl_channels_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redis_acl_channels_default", value)

    @property
    @pulumi.getter(name="redisIoThreads")
    def redis_io_threads(self) -> Optional[pulumi.Input[int]]:
        """
        Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.
        """
        return pulumi.get(self, "redis_io_threads")

    @redis_io_threads.setter
    def redis_io_threads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redis_io_threads", value)

    @property
    @pulumi.getter(name="redisLfuDecayTime")
    def redis_lfu_decay_time(self) -> Optional[pulumi.Input[int]]:
        """
        LFU maxmemory-policy counter decay time in minutes.
        """
        return pulumi.get(self, "redis_lfu_decay_time")

    @redis_lfu_decay_time.setter
    def redis_lfu_decay_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redis_lfu_decay_time", value)

    @property
    @pulumi.getter(name="redisLfuLogFactor")
    def redis_lfu_log_factor(self) -> Optional[pulumi.Input[int]]:
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        """
        return pulumi.get(self, "redis_lfu_log_factor")

    @redis_lfu_log_factor.setter
    def redis_lfu_log_factor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redis_lfu_log_factor", value)

    @property
    @pulumi.getter(name="redisMaxmemoryPolicy")
    def redis_maxmemory_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Redis maxmemory-policy.
        """
        return pulumi.get(self, "redis_maxmemory_policy")

    @redis_maxmemory_policy.setter
    def redis_maxmemory_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redis_maxmemory_policy", value)

    @property
    @pulumi.getter(name="redisNotifyKeyspaceEvents")
    def redis_notify_keyspace_events(self) -> Optional[pulumi.Input[str]]:
        """
        Set notify-keyspace-events option.
        """
        return pulumi.get(self, "redis_notify_keyspace_events")

    @redis_notify_keyspace_events.setter
    def redis_notify_keyspace_events(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redis_notify_keyspace_events", value)

    @property
    @pulumi.getter(name="redisNumberOfDatabases")
    def redis_number_of_databases(self) -> Optional[pulumi.Input[int]]:
        """
        Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.
        """
        return pulumi.get(self, "redis_number_of_databases")

    @redis_number_of_databases.setter
    def redis_number_of_databases(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redis_number_of_databases", value)

    @property
    @pulumi.getter(name="redisPersistence")
    def redis_persistence(self) -> Optional[pulumi.Input[str]]:
        """
        Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.
        """
        return pulumi.get(self, "redis_persistence")

    @redis_persistence.setter
    def redis_persistence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redis_persistence", value)

    @property
    @pulumi.getter(name="redisPubsubClientOutputBufferLimit")
    def redis_pubsub_client_output_buffer_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        """
        return pulumi.get(self, "redis_pubsub_client_output_buffer_limit")

    @redis_pubsub_client_output_buffer_limit.setter
    def redis_pubsub_client_output_buffer_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redis_pubsub_client_output_buffer_limit", value)

    @property
    @pulumi.getter(name="redisSsl")
    def redis_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Require SSL to access Redis.
        """
        return pulumi.get(self, "redis_ssl")

    @redis_ssl.setter
    def redis_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redis_ssl", value)

    @property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Redis idle connection timeout in seconds.
        """
        return pulumi.get(self, "redis_timeout")

    @redis_timeout.setter
    def redis_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redis_timeout", value)

    @property
    @pulumi.getter(name="redisVersion")
    def redis_version(self) -> Optional[pulumi.Input[str]]:
        """
        Redis major version.
        """
        return pulumi.get(self, "redis_version")

    @redis_version.setter
    def redis_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redis_version", value)

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[pulumi.Input[bool]]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @service_log.setter
    def service_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "service_log", value)


if not MYPY:
    class ManagedDatabaseRedisPropertiesMigrationArgsDict(TypedDict):
        dbname: NotRequired[pulumi.Input[str]]
        """
        Database name for bootstrapping the initial connection.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Hostname or IP address of the server where to migrate data from.
        """
        ignore_dbs: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        ignore_roles: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password for authentication with the server where to migrate data from.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number of the server where to migrate data from.
        """
        ssl: NotRequired[pulumi.Input[bool]]
        """
        The server where to migrate data from is secured with SSL.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        User name for authentication with the server where to migrate data from.
        """
elif False:
    ManagedDatabaseRedisPropertiesMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseRedisPropertiesMigrationArgs:
    def __init__(__self__, *,
                 dbname: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 ignore_dbs: Optional[pulumi.Input[str]] = None,
                 ignore_roles: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 ssl: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbname: Database name for bootstrapping the initial connection.
        :param pulumi.Input[str] host: Hostname or IP address of the server where to migrate data from.
        :param pulumi.Input[str] ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param pulumi.Input[str] ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param pulumi.Input[str] method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param pulumi.Input[str] password: Password for authentication with the server where to migrate data from.
        :param pulumi.Input[int] port: Port number of the server where to migrate data from.
        :param pulumi.Input[bool] ssl: The server where to migrate data from is secured with SSL.
        :param pulumi.Input[str] username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[pulumi.Input[str]]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @ignore_dbs.setter
    def ignore_dbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ignore_dbs", value)

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @ignore_roles.setter
    def ignore_roles(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ignore_roles", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ManagedDatabaseUserOpensearchAccessControlArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgsDict']]]
        """
        Set user access control rules.
        """
elif False:
    ManagedDatabaseUserOpensearchAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserOpensearchAccessControlArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgs']]] rules: Set user access control rules.
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgs']]]:
        """
        Set user access control rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['ManagedDatabaseUserOpensearchAccessControlRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class ManagedDatabaseUserOpensearchAccessControlRuleArgsDict(TypedDict):
        index: pulumi.Input[str]
        """
        Set index name, pattern or top level API.
        """
        permission: pulumi.Input[str]
        """
        Set permission access.
        """
elif False:
    ManagedDatabaseUserOpensearchAccessControlRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserOpensearchAccessControlRuleArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 permission: pulumi.Input[str]):
        """
        :param pulumi.Input[str] index: Set index name, pattern or top level API.
        :param pulumi.Input[str] permission: Set permission access.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        Set index name, pattern or top level API.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        Set permission access.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class ManagedDatabaseUserPgAccessControlArgsDict(TypedDict):
        allow_replication: NotRequired[pulumi.Input[bool]]
        """
        Grant replication privilege
        """
elif False:
    ManagedDatabaseUserPgAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserPgAccessControlArgs:
    def __init__(__self__, *,
                 allow_replication: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_replication: Grant replication privilege
        """
        if allow_replication is not None:
            pulumi.set(__self__, "allow_replication", allow_replication)

    @property
    @pulumi.getter(name="allowReplication")
    def allow_replication(self) -> Optional[pulumi.Input[bool]]:
        """
        Grant replication privilege
        """
        return pulumi.get(self, "allow_replication")

    @allow_replication.setter
    def allow_replication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_replication", value)


if not MYPY:
    class ManagedDatabaseUserRedisAccessControlArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input[str]]
        """
        Set access control to all commands in specified categories.
        """
        channels: NotRequired[pulumi.Input[str]]
        """
        Set access control to Pub/Sub channels.
        """
        commands: NotRequired[pulumi.Input[str]]
        """
        Set access control to commands.
        """
        keys: NotRequired[pulumi.Input[str]]
        """
        Set access control to keys.
        """
elif False:
    ManagedDatabaseUserRedisAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedDatabaseUserRedisAccessControlArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[str]] = None,
                 channels: Optional[pulumi.Input[str]] = None,
                 commands: Optional[pulumi.Input[str]] = None,
                 keys: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] categories: Set access control to all commands in specified categories.
        :param pulumi.Input[str] channels: Set access control to Pub/Sub channels.
        :param pulumi.Input[str] commands: Set access control to commands.
        :param pulumi.Input[str] keys: Set access control to keys.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[str]]:
        """
        Set access control to all commands in specified categories.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[str]]:
        """
        Set access control to Pub/Sub channels.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[str]]:
        """
        Set access control to commands.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[str]]:
        """
        Set access control to keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keys", value)


if not MYPY:
    class ManagedObjectStorageEndpointArgsDict(TypedDict):
        domain_name: NotRequired[pulumi.Input[str]]
        """
        Domain name of the endpoint.
        """
        iam_url: NotRequired[pulumi.Input[str]]
        """
        URL for IAM.
        """
        sts_url: NotRequired[pulumi.Input[str]]
        """
        URL for STS.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the endpoint (`private` / `public`).
        """
elif False:
    ManagedObjectStorageEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedObjectStorageEndpointArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 iam_url: Optional[pulumi.Input[str]] = None,
                 sts_url: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain_name: Domain name of the endpoint.
        :param pulumi.Input[str] iam_url: URL for IAM.
        :param pulumi.Input[str] sts_url: URL for STS.
        :param pulumi.Input[str] type: Type of the endpoint (`private` / `public`).
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if iam_url is not None:
            pulumi.set(__self__, "iam_url", iam_url)
        if sts_url is not None:
            pulumi.set(__self__, "sts_url", sts_url)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name of the endpoint.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="iamUrl")
    def iam_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL for IAM.
        """
        return pulumi.get(self, "iam_url")

    @iam_url.setter
    def iam_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_url", value)

    @property
    @pulumi.getter(name="stsUrl")
    def sts_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL for STS.
        """
        return pulumi.get(self, "sts_url")

    @sts_url.setter
    def sts_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sts_url", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the endpoint (`private` / `public`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManagedObjectStorageNetworkArgsDict(TypedDict):
        family: pulumi.Input[str]
        """
        Network family. IPv6 currently not supported.
        """
        name: pulumi.Input[str]
        """
        Network name. Must be unique within the service.
        """
        type: pulumi.Input[str]
        """
        Network type.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        Private network uuid. For public networks the field should be omitted.
        """
elif False:
    ManagedObjectStorageNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedObjectStorageNetworkArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] family: Network family. IPv6 currently not supported.
        :param pulumi.Input[str] name: Network name. Must be unique within the service.
        :param pulumi.Input[str] type: Network type.
        :param pulumi.Input[str] uuid: Private network uuid. For public networks the field should be omitted.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[str]:
        """
        Network family. IPv6 currently not supported.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Network name. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Network type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        Private network uuid. For public networks the field should be omitted.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkIpNetworkArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        The CIDR range of the subnet
        """
        dhcp: pulumi.Input[bool]
        """
        Is DHCP enabled?
        """
        family: pulumi.Input[str]
        """
        IP address family
        """
        dhcp_default_route: NotRequired[pulumi.Input[bool]]
        """
        Is the gateway the DHCP default route?
        """
        dhcp_dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The DNS servers given by DHCP
        """
        dhcp_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The additional DHCP classless static routes given by DHCP
        """
        gateway: NotRequired[pulumi.Input[str]]
        """
        Gateway address given by DHCP
        """
elif False:
    NetworkIpNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIpNetworkArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 dhcp: pulumi.Input[bool],
                 family: pulumi.Input[str],
                 dhcp_default_route: Optional[pulumi.Input[bool]] = None,
                 dhcp_dns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dhcp_routes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gateway: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The CIDR range of the subnet
        :param pulumi.Input[bool] dhcp: Is DHCP enabled?
        :param pulumi.Input[str] family: IP address family
        :param pulumi.Input[bool] dhcp_default_route: Is the gateway the DHCP default route?
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dhcp_dns: The DNS servers given by DHCP
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dhcp_routes: The additional DHCP classless static routes given by DHCP
        :param pulumi.Input[str] gateway: Gateway address given by DHCP
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "family", family)
        if dhcp_default_route is not None:
            pulumi.set(__self__, "dhcp_default_route", dhcp_default_route)
        if dhcp_dns is not None:
            pulumi.set(__self__, "dhcp_dns", dhcp_dns)
        if dhcp_routes is not None:
            pulumi.set(__self__, "dhcp_routes", dhcp_routes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The CIDR range of the subnet
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def dhcp(self) -> pulumi.Input[bool]:
        """
        Is DHCP enabled?
        """
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: pulumi.Input[bool]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[str]:
        """
        IP address family
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter(name="dhcpDefaultRoute")
    def dhcp_default_route(self) -> Optional[pulumi.Input[bool]]:
        """
        Is the gateway the DHCP default route?
        """
        return pulumi.get(self, "dhcp_default_route")

    @dhcp_default_route.setter
    def dhcp_default_route(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp_default_route", value)

    @property
    @pulumi.getter(name="dhcpDns")
    def dhcp_dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The DNS servers given by DHCP
        """
        return pulumi.get(self, "dhcp_dns")

    @dhcp_dns.setter
    def dhcp_dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dhcp_dns", value)

    @property
    @pulumi.getter(name="dhcpRoutes")
    def dhcp_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The additional DHCP classless static routes given by DHCP
        """
        return pulumi.get(self, "dhcp_routes")

    @dhcp_routes.setter
    def dhcp_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dhcp_routes", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        Gateway address given by DHCP
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)


if not MYPY:
    class NetworkPeeringNetworkArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        The UUID of the network.
        """
elif False:
    NetworkPeeringNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPeeringNetworkArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] uuid: The UUID of the network.
        """
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        The UUID of the network.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkPeeringPeerNetworkArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        The UUID of the network.
        """
elif False:
    NetworkPeeringPeerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPeeringPeerNetworkArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] uuid: The UUID of the network.
        """
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        The UUID of the network.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ObjectStorageBucketArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the bucket
        """
elif False:
    ObjectStorageBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectStorageBucketArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the bucket
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the bucket
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RouterStaticRouteArgsDict(TypedDict):
        name: pulumi.Input[str]
        nexthop: pulumi.Input[str]
        route: pulumi.Input[str]
        type: pulumi.Input[str]
elif False:
    RouterStaticRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterStaticRouteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 nexthop: pulumi.Input[str],
                 route: pulumi.Input[str],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nexthop", nexthop)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nexthop(self) -> pulumi.Input[str]:
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: pulumi.Input[str]):
        pulumi.set(self, "nexthop", value)

    @property
    @pulumi.getter
    def route(self) -> pulumi.Input[str]:
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: pulumi.Input[str]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerFirewallRulesFirewallRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action to take if the rule conditions are met
        """
        direction: pulumi.Input[str]
        """
        The direction of network traffic this rule will be applied to
        """
        comment: NotRequired[pulumi.Input[str]]
        """
        Freeform comment string for the rule
        """
        destination_address_end: NotRequired[pulumi.Input[str]]
        """
        The destination address range ends from this address
        """
        destination_address_start: NotRequired[pulumi.Input[str]]
        """
        The destination address range starts from this address
        """
        destination_port_end: NotRequired[pulumi.Input[str]]
        """
        The destination port range ends from this port number
        """
        destination_port_start: NotRequired[pulumi.Input[str]]
        """
        The destination port range starts from this port number
        """
        family: NotRequired[pulumi.Input[str]]
        """
        The address family of new firewall rule
        """
        icmp_type: NotRequired[pulumi.Input[str]]
        """
        The ICMP type
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        The protocol this rule will be applied to
        """
        source_address_end: NotRequired[pulumi.Input[str]]
        """
        The source address range ends from this address
        """
        source_address_start: NotRequired[pulumi.Input[str]]
        """
        The source address range starts from this address
        """
        source_port_end: NotRequired[pulumi.Input[str]]
        """
        The source port range ends from this port number
        """
        source_port_start: NotRequired[pulumi.Input[str]]
        """
        The source port range starts from this port number
        """
elif False:
    ServerFirewallRulesFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerFirewallRulesFirewallRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 comment: Optional[pulumi.Input[str]] = None,
                 destination_address_end: Optional[pulumi.Input[str]] = None,
                 destination_address_start: Optional[pulumi.Input[str]] = None,
                 destination_port_end: Optional[pulumi.Input[str]] = None,
                 destination_port_start: Optional[pulumi.Input[str]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 icmp_type: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 source_address_end: Optional[pulumi.Input[str]] = None,
                 source_address_start: Optional[pulumi.Input[str]] = None,
                 source_port_end: Optional[pulumi.Input[str]] = None,
                 source_port_start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: Action to take if the rule conditions are met
        :param pulumi.Input[str] direction: The direction of network traffic this rule will be applied to
        :param pulumi.Input[str] comment: Freeform comment string for the rule
        :param pulumi.Input[str] destination_address_end: The destination address range ends from this address
        :param pulumi.Input[str] destination_address_start: The destination address range starts from this address
        :param pulumi.Input[str] destination_port_end: The destination port range ends from this port number
        :param pulumi.Input[str] destination_port_start: The destination port range starts from this port number
        :param pulumi.Input[str] family: The address family of new firewall rule
        :param pulumi.Input[str] icmp_type: The ICMP type
        :param pulumi.Input[str] protocol: The protocol this rule will be applied to
        :param pulumi.Input[str] source_address_end: The source address range ends from this address
        :param pulumi.Input[str] source_address_start: The source address range starts from this address
        :param pulumi.Input[str] source_port_end: The source port range ends from this port number
        :param pulumi.Input[str] source_port_start: The source port range starts from this port number
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "direction", direction)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if destination_address_end is not None:
            pulumi.set(__self__, "destination_address_end", destination_address_end)
        if destination_address_start is not None:
            pulumi.set(__self__, "destination_address_start", destination_address_start)
        if destination_port_end is not None:
            pulumi.set(__self__, "destination_port_end", destination_port_end)
        if destination_port_start is not None:
            pulumi.set(__self__, "destination_port_start", destination_port_start)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_address_end is not None:
            pulumi.set(__self__, "source_address_end", source_address_end)
        if source_address_start is not None:
            pulumi.set(__self__, "source_address_start", source_address_start)
        if source_port_end is not None:
            pulumi.set(__self__, "source_port_end", source_port_end)
        if source_port_start is not None:
            pulumi.set(__self__, "source_port_start", source_port_start)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to take if the rule conditions are met
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        The direction of network traffic this rule will be applied to
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Freeform comment string for the rule
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="destinationAddressEnd")
    def destination_address_end(self) -> Optional[pulumi.Input[str]]:
        """
        The destination address range ends from this address
        """
        return pulumi.get(self, "destination_address_end")

    @destination_address_end.setter
    def destination_address_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_address_end", value)

    @property
    @pulumi.getter(name="destinationAddressStart")
    def destination_address_start(self) -> Optional[pulumi.Input[str]]:
        """
        The destination address range starts from this address
        """
        return pulumi.get(self, "destination_address_start")

    @destination_address_start.setter
    def destination_address_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_address_start", value)

    @property
    @pulumi.getter(name="destinationPortEnd")
    def destination_port_end(self) -> Optional[pulumi.Input[str]]:
        """
        The destination port range ends from this port number
        """
        return pulumi.get(self, "destination_port_end")

    @destination_port_end.setter
    def destination_port_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_port_end", value)

    @property
    @pulumi.getter(name="destinationPortStart")
    def destination_port_start(self) -> Optional[pulumi.Input[str]]:
        """
        The destination port range starts from this port number
        """
        return pulumi.get(self, "destination_port_start")

    @destination_port_start.setter
    def destination_port_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_port_start", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        The address family of new firewall rule
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[str]]:
        """
        The ICMP type
        """
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_type", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol this rule will be applied to
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sourceAddressEnd")
    def source_address_end(self) -> Optional[pulumi.Input[str]]:
        """
        The source address range ends from this address
        """
        return pulumi.get(self, "source_address_end")

    @source_address_end.setter
    def source_address_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_address_end", value)

    @property
    @pulumi.getter(name="sourceAddressStart")
    def source_address_start(self) -> Optional[pulumi.Input[str]]:
        """
        The source address range starts from this address
        """
        return pulumi.get(self, "source_address_start")

    @source_address_start.setter
    def source_address_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_address_start", value)

    @property
    @pulumi.getter(name="sourcePortEnd")
    def source_port_end(self) -> Optional[pulumi.Input[str]]:
        """
        The source port range ends from this port number
        """
        return pulumi.get(self, "source_port_end")

    @source_port_end.setter
    def source_port_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_port_end", value)

    @property
    @pulumi.getter(name="sourcePortStart")
    def source_port_start(self) -> Optional[pulumi.Input[str]]:
        """
        The source port range starts from this port number
        """
        return pulumi.get(self, "source_port_start")

    @source_port_start.setter
    def source_port_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_port_start", value)


if not MYPY:
    class ServerLoginArgsDict(TypedDict):
        create_password: NotRequired[pulumi.Input[bool]]
        """
        Indicates a password should be create to allow access
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of ssh keys to access the server
        """
        password_delivery: NotRequired[pulumi.Input[str]]
        """
        The delivery method for the server's root password (one of `none`, `email` or `sms`)
        """
        user: NotRequired[pulumi.Input[str]]
        """
        Username to be create to access the server
        """
elif False:
    ServerLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerLoginArgs:
    def __init__(__self__, *,
                 create_password: Optional[pulumi.Input[bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 password_delivery: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] create_password: Indicates a password should be create to allow access
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: A list of ssh keys to access the server
        :param pulumi.Input[str] password_delivery: The delivery method for the server's root password (one of `none`, `email` or `sms`)
        :param pulumi.Input[str] user: Username to be create to access the server
        """
        if create_password is not None:
            pulumi.set(__self__, "create_password", create_password)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if password_delivery is not None:
            pulumi.set(__self__, "password_delivery", password_delivery)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="createPassword")
    def create_password(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates a password should be create to allow access
        """
        return pulumi.get(self, "create_password")

    @create_password.setter
    def create_password(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_password", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of ssh keys to access the server
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="passwordDelivery")
    def password_delivery(self) -> Optional[pulumi.Input[str]]:
        """
        The delivery method for the server's root password (one of `none`, `email` or `sms`)
        """
        return pulumi.get(self, "password_delivery")

    @password_delivery.setter
    def password_delivery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_delivery", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        Username to be create to access the server
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServerNetworkInterfaceArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Network interface type. For private network interfaces, a network must be specified with an existing network id.
        """
        additional_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgsDict']]]]
        """
        0-4 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`
        """
        bootable: NotRequired[pulumi.Input[bool]]
        """
        `true` if this interface should be used for network booting.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The assigned primary IP address.
        """
        ip_address_family: NotRequired[pulumi.Input[str]]
        """
        The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).
        """
        ip_address_floating: NotRequired[pulumi.Input[bool]]
        """
        `true` indicates that the primary IP address is a floating IP address.
        """
        mac_address: NotRequired[pulumi.Input[str]]
        """
        The assigned MAC address.
        """
        network: NotRequired[pulumi.Input[str]]
        """
        The unique ID of a network to attach this network to.
        """
        source_ip_filtering: NotRequired[pulumi.Input[bool]]
        """
        `true` if source IP should be filtered.
        """
elif False:
    ServerNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerNetworkInterfaceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgs']]]] = None,
                 bootable: Optional[pulumi.Input[bool]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 ip_address_family: Optional[pulumi.Input[str]] = None,
                 ip_address_floating: Optional[pulumi.Input[bool]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 source_ip_filtering: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: Network interface type. For private network interfaces, a network must be specified with an existing network id.
        :param pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgs']]] additional_ip_addresses: 0-4 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`
        :param pulumi.Input[bool] bootable: `true` if this interface should be used for network booting.
        :param pulumi.Input[str] ip_address: The assigned primary IP address.
        :param pulumi.Input[str] ip_address_family: The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).
        :param pulumi.Input[bool] ip_address_floating: `true` indicates that the primary IP address is a floating IP address.
        :param pulumi.Input[str] mac_address: The assigned MAC address.
        :param pulumi.Input[str] network: The unique ID of a network to attach this network to.
        :param pulumi.Input[bool] source_ip_filtering: `true` if source IP should be filtered.
        """
        pulumi.set(__self__, "type", type)
        if additional_ip_addresses is not None:
            pulumi.set(__self__, "additional_ip_addresses", additional_ip_addresses)
        if bootable is not None:
            pulumi.set(__self__, "bootable", bootable)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_address_family is not None:
            pulumi.set(__self__, "ip_address_family", ip_address_family)
        if ip_address_floating is not None:
            pulumi.set(__self__, "ip_address_floating", ip_address_floating)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip_filtering is not None:
            pulumi.set(__self__, "source_ip_filtering", source_ip_filtering)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Network interface type. For private network interfaces, a network must be specified with an existing network id.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalIpAddresses")
    def additional_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgs']]]]:
        """
        0-4 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`
        """
        return pulumi.get(self, "additional_ip_addresses")

    @additional_ip_addresses.setter
    def additional_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServerNetworkInterfaceAdditionalIpAddressArgs']]]]):
        pulumi.set(self, "additional_ip_addresses", value)

    @property
    @pulumi.getter
    def bootable(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` if this interface should be used for network booting.
        """
        return pulumi.get(self, "bootable")

    @bootable.setter
    def bootable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bootable", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The assigned primary IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipAddressFamily")
    def ip_address_family(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).
        """
        return pulumi.get(self, "ip_address_family")

    @ip_address_family.setter
    def ip_address_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address_family", value)

    @property
    @pulumi.getter(name="ipAddressFloating")
    def ip_address_floating(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` indicates that the primary IP address is a floating IP address.
        """
        return pulumi.get(self, "ip_address_floating")

    @ip_address_floating.setter
    def ip_address_floating(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_address_floating", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        The assigned MAC address.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ID of a network to attach this network to.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="sourceIpFiltering")
    def source_ip_filtering(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` if source IP should be filtered.
        """
        return pulumi.get(self, "source_ip_filtering")

    @source_ip_filtering.setter
    def source_ip_filtering(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_ip_filtering", value)


if not MYPY:
    class ServerNetworkInterfaceAdditionalIpAddressArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The assigned additional IP address.
        """
        ip_address_family: NotRequired[pulumi.Input[str]]
        """
        The type of this additional IP address of this interface (one of `IPv4` or `IPv6`).
        """
        ip_address_floating: NotRequired[pulumi.Input[bool]]
        """
        `true` indicates that the additional IP address is a floating IP address.
        """
elif False:
    ServerNetworkInterfaceAdditionalIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerNetworkInterfaceAdditionalIpAddressArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 ip_address_family: Optional[pulumi.Input[str]] = None,
                 ip_address_floating: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] ip_address: The assigned additional IP address.
        :param pulumi.Input[str] ip_address_family: The type of this additional IP address of this interface (one of `IPv4` or `IPv6`).
        :param pulumi.Input[bool] ip_address_floating: `true` indicates that the additional IP address is a floating IP address.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_address_family is not None:
            pulumi.set(__self__, "ip_address_family", ip_address_family)
        if ip_address_floating is not None:
            pulumi.set(__self__, "ip_address_floating", ip_address_floating)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The assigned additional IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipAddressFamily")
    def ip_address_family(self) -> Optional[pulumi.Input[str]]:
        """
        The type of this additional IP address of this interface (one of `IPv4` or `IPv6`).
        """
        return pulumi.get(self, "ip_address_family")

    @ip_address_family.setter
    def ip_address_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address_family", value)

    @property
    @pulumi.getter(name="ipAddressFloating")
    def ip_address_floating(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` indicates that the additional IP address is a floating IP address.
        """
        return pulumi.get(self, "ip_address_floating")

    @ip_address_floating.setter
    def ip_address_floating(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_address_floating", value)


if not MYPY:
    class ServerSimpleBackupArgsDict(TypedDict):
        plan: pulumi.Input[str]
        """
        Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.
        """
        time: pulumi.Input[str]
        """
        Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).
        """
elif False:
    ServerSimpleBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerSimpleBackupArgs:
    def __init__(__self__, *,
                 plan: pulumi.Input[str],
                 time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] plan: Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.
        :param pulumi.Input[str] time: Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).
        """
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def plan(self) -> pulumi.Input[str]:
        """
        Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[str]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class ServerStorageDeviceArgsDict(TypedDict):
        storage: pulumi.Input[str]
        """
        A valid storage UUID
        """
        address: NotRequired[pulumi.Input[str]]
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        address_position: NotRequired[pulumi.Input[str]]
        """
        The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The device type the storage will be attached as
        """
elif False:
    ServerStorageDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerStorageDeviceArgs:
    def __init__(__self__, *,
                 storage: pulumi.Input[str],
                 address: Optional[pulumi.Input[str]] = None,
                 address_position: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage: A valid storage UUID
        :param pulumi.Input[str] address: The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        :param pulumi.Input[str] address_position: The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.
        :param pulumi.Input[str] type: The device type the storage will be attached as
        """
        pulumi.set(__self__, "storage", storage)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_position is not None:
            pulumi.set(__self__, "address_position", address_position)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def storage(self) -> pulumi.Input[str]:
        """
        A valid storage UUID
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="addressPosition")
    def address_position(self) -> Optional[pulumi.Input[str]]:
        """
        The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.
        """
        return pulumi.get(self, "address_position")

    @address_position.setter
    def address_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_position", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The device type the storage will be attached as
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerTemplateArgsDict(TypedDict):
        storage: pulumi.Input[str]
        """
        A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.
        """
        address: NotRequired[pulumi.Input[str]]
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        address_position: NotRequired[pulumi.Input[str]]
        """
        The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.
        """
        backup_rule: NotRequired[pulumi.Input['ServerTemplateBackupRuleArgsDict']]
        delete_autoresize_backup: NotRequired[pulumi.Input[bool]]
        """
        If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
        """
        encrypt: NotRequired[pulumi.Input[bool]]
        """
        Sets if the storage is encrypted at rest
        """
        filesystem_autoresize: NotRequired[pulumi.Input[bool]]
        """
        If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.
        							Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used
        							to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).
        							Taking and keeping backups incure costs.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier for the storage
        """
        size: NotRequired[pulumi.Input[int]]
        """
        The size of the storage in gigabytes
        """
        tier: NotRequired[pulumi.Input[str]]
        """
        The storage tier to use
        """
        title: NotRequired[pulumi.Input[str]]
        """
        A short, informative description
        """
elif False:
    ServerTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTemplateArgs:
    def __init__(__self__, *,
                 storage: pulumi.Input[str],
                 address: Optional[pulumi.Input[str]] = None,
                 address_position: Optional[pulumi.Input[str]] = None,
                 backup_rule: Optional[pulumi.Input['ServerTemplateBackupRuleArgs']] = None,
                 delete_autoresize_backup: Optional[pulumi.Input[bool]] = None,
                 encrypt: Optional[pulumi.Input[bool]] = None,
                 filesystem_autoresize: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 tier: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage: A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.
        :param pulumi.Input[str] address: The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        :param pulumi.Input[str] address_position: The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.
        :param pulumi.Input[bool] delete_autoresize_backup: If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
        :param pulumi.Input[bool] encrypt: Sets if the storage is encrypted at rest
        :param pulumi.Input[bool] filesystem_autoresize: If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.
               							Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used
               							to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).
               							Taking and keeping backups incure costs.
        :param pulumi.Input[str] id: The unique identifier for the storage
        :param pulumi.Input[int] size: The size of the storage in gigabytes
        :param pulumi.Input[str] tier: The storage tier to use
        :param pulumi.Input[str] title: A short, informative description
        """
        pulumi.set(__self__, "storage", storage)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_position is not None:
            pulumi.set(__self__, "address_position", address_position)
        if backup_rule is not None:
            pulumi.set(__self__, "backup_rule", backup_rule)
        if delete_autoresize_backup is not None:
            pulumi.set(__self__, "delete_autoresize_backup", delete_autoresize_backup)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if filesystem_autoresize is not None:
            pulumi.set(__self__, "filesystem_autoresize", filesystem_autoresize)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def storage(self) -> pulumi.Input[str]:
        """
        A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="addressPosition")
    def address_position(self) -> Optional[pulumi.Input[str]]:
        """
        The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.
        """
        return pulumi.get(self, "address_position")

    @address_position.setter
    def address_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_position", value)

    @property
    @pulumi.getter(name="backupRule")
    def backup_rule(self) -> Optional[pulumi.Input['ServerTemplateBackupRuleArgs']]:
        return pulumi.get(self, "backup_rule")

    @backup_rule.setter
    def backup_rule(self, value: Optional[pulumi.Input['ServerTemplateBackupRuleArgs']]):
        pulumi.set(self, "backup_rule", value)

    @property
    @pulumi.getter(name="deleteAutoresizeBackup")
    def delete_autoresize_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
        """
        return pulumi.get(self, "delete_autoresize_backup")

    @delete_autoresize_backup.setter
    def delete_autoresize_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_autoresize_backup", value)

    @property
    @pulumi.getter
    def encrypt(self) -> Optional[pulumi.Input[bool]]:
        """
        Sets if the storage is encrypted at rest
        """
        return pulumi.get(self, "encrypt")

    @encrypt.setter
    def encrypt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypt", value)

    @property
    @pulumi.getter(name="filesystemAutoresize")
    def filesystem_autoresize(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.
        							Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used
        							to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).
        							Taking and keeping backups incure costs.
        """
        return pulumi.get(self, "filesystem_autoresize")

    @filesystem_autoresize.setter
    def filesystem_autoresize(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "filesystem_autoresize", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier for the storage
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the storage in gigabytes
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        The storage tier to use
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        A short, informative description
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ServerTemplateBackupRuleArgsDict(TypedDict):
        interval: pulumi.Input[str]
        """
        The weekday when the backup is created
        """
        retention: pulumi.Input[int]
        """
        The number of days before a backup is automatically deleted
        """
        time: pulumi.Input[str]
        """
        The time of day when the backup is created
        """
elif False:
    ServerTemplateBackupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTemplateBackupRuleArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[str],
                 retention: pulumi.Input[int],
                 time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] interval: The weekday when the backup is created
        :param pulumi.Input[int] retention: The number of days before a backup is automatically deleted
        :param pulumi.Input[str] time: The time of day when the backup is created
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "retention", retention)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The weekday when the backup is created
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def retention(self) -> pulumi.Input[int]:
        """
        The number of days before a backup is automatically deleted
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        The time of day when the backup is created
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class StorageBackupRuleArgsDict(TypedDict):
        interval: pulumi.Input[str]
        """
        The weekday when the backup is created
        """
        retention: pulumi.Input[int]
        """
        The number of days before a backup is automatically deleted
        """
        time: pulumi.Input[str]
        """
        The time of day when the backup is created
        """
elif False:
    StorageBackupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageBackupRuleArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[str],
                 retention: pulumi.Input[int],
                 time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] interval: The weekday when the backup is created
        :param pulumi.Input[int] retention: The number of days before a backup is automatically deleted
        :param pulumi.Input[str] time: The time of day when the backup is created
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "retention", retention)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The weekday when the backup is created
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def retention(self) -> pulumi.Input[int]:
        """
        The number of days before a backup is automatically deleted
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        The time of day when the backup is created
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class StorageCloneArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The unique identifier of the storage/template to clone.
        """
elif False:
    StorageCloneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageCloneArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The unique identifier of the storage/template to clone.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The unique identifier of the storage/template to clone.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class StorageImportArgsDict(TypedDict):
        source: pulumi.Input[str]
        """
        The mode of the import task. One of `http_import` or `direct_upload`.
        """
        source_location: pulumi.Input[str]
        """
        The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).
        """
        sha256sum: NotRequired[pulumi.Input[str]]
        """
        sha256 sum of the imported data
        """
        source_hash: NotRequired[pulumi.Input[str]]
        """
        SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.
        """
        written_bytes: NotRequired[pulumi.Input[int]]
        """
        Number of bytes imported
        """
elif False:
    StorageImportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageImportArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 source_location: pulumi.Input[str],
                 sha256sum: Optional[pulumi.Input[str]] = None,
                 source_hash: Optional[pulumi.Input[str]] = None,
                 written_bytes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] source: The mode of the import task. One of `http_import` or `direct_upload`.
        :param pulumi.Input[str] source_location: The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).
        :param pulumi.Input[str] sha256sum: sha256 sum of the imported data
        :param pulumi.Input[str] source_hash: SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.
        :param pulumi.Input[int] written_bytes: Number of bytes imported
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_location", source_location)
        if sha256sum is not None:
            pulumi.set(__self__, "sha256sum", sha256sum)
        if source_hash is not None:
            pulumi.set(__self__, "source_hash", source_hash)
        if written_bytes is not None:
            pulumi.set(__self__, "written_bytes", written_bytes)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The mode of the import task. One of `http_import` or `direct_upload`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourceLocation")
    def source_location(self) -> pulumi.Input[str]:
        """
        The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).
        """
        return pulumi.get(self, "source_location")

    @source_location.setter
    def source_location(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_location", value)

    @property
    @pulumi.getter
    def sha256sum(self) -> Optional[pulumi.Input[str]]:
        """
        sha256 sum of the imported data
        """
        return pulumi.get(self, "sha256sum")

    @sha256sum.setter
    def sha256sum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256sum", value)

    @property
    @pulumi.getter(name="sourceHash")
    def source_hash(self) -> Optional[pulumi.Input[str]]:
        """
        SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.
        """
        return pulumi.get(self, "source_hash")

    @source_hash.setter
    def source_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_hash", value)

    @property
    @pulumi.getter(name="writtenBytes")
    def written_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Number of bytes imported
        """
        return pulumi.get(self, "written_bytes")

    @written_bytes.setter
    def written_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "written_bytes", value)


if not MYPY:
    class GetHostsHostArgsDict(TypedDict):
        description: str
        """
        Free form text describing the host
        """
        host_id: int
        """
        The unique id of the host
        """
        zone: str
        """
        The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
elif False:
    GetHostsHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHostsHostArgs:
    def __init__(__self__, *,
                 description: str,
                 host_id: int,
                 zone: str):
        """
        :param str description: Free form text describing the host
        :param int host_id: The unique id of the host
        :param str zone: The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host_id", host_id)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Free form text describing the host
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> int:
        """
        The unique id of the host
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: int):
        pulumi.set(self, "host_id", value)

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: str):
        pulumi.set(self, "zone", value)


if not MYPY:
    class GetManagedDatabaseMysqlSessionsSessionArgsDict(TypedDict):
        application_name: str
        """
        Name of the application that is connected to this service.
        """
        client_addr: str
        """
        IP address of the client connected to this service.
        """
        datname: str
        """
        Name of the database this service is connected to.
        """
        id: str
        """
        Process ID of this service.
        """
        query: str
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.
        """
        query_duration: str
        """
        The active query current duration.
        """
        state: str
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        usename: str
        """
        Name of the user logged into this service.
        """
elif False:
    GetManagedDatabaseMysqlSessionsSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabaseMysqlSessionsSessionArgs:
    def __init__(__self__, *,
                 application_name: str,
                 client_addr: str,
                 datname: str,
                 id: str,
                 query: str,
                 query_duration: str,
                 state: str,
                 usename: str):
        """
        :param str application_name: Name of the application that is connected to this service.
        :param str client_addr: IP address of the client connected to this service.
        :param str datname: Name of the database this service is connected to.
        :param str id: Process ID of this service.
        :param str query: Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.
        :param str query_duration: The active query current duration.
        :param str state: Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        :param str usename: Name of the user logged into this service.
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "datname", datname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_duration", query_duration)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "usename", usename)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: str):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> str:
        """
        IP address of the client connected to this service.
        """
        return pulumi.get(self, "client_addr")

    @client_addr.setter
    def client_addr(self, value: str):
        pulumi.set(self, "client_addr", value)

    @property
    @pulumi.getter
    def datname(self) -> str:
        """
        Name of the database this service is connected to.
        """
        return pulumi.get(self, "datname")

    @datname.setter
    def datname(self, value: str):
        pulumi.set(self, "datname", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Process ID of this service.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: str):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryDuration")
    def query_duration(self) -> str:
        """
        The active query current duration.
        """
        return pulumi.get(self, "query_duration")

    @query_duration.setter
    def query_duration(self, value: str):
        pulumi.set(self, "query_duration", value)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: str):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def usename(self) -> str:
        """
        Name of the user logged into this service.
        """
        return pulumi.get(self, "usename")

    @usename.setter
    def usename(self, value: str):
        pulumi.set(self, "usename", value)


if not MYPY:
    class GetManagedDatabaseOpensearchIndicesIndexArgsDict(TypedDict):
        create_time: str
        """
        Timestamp indicating the creation time of the index.
        """
        docs: int
        """
        Number of documents stored in the index.
        """
        health: str
        """
        Health status of the index e.g. `green`, `yellow`, or `red`.
        """
        index_name: str
        """
        Name of the index.
        """
        number_of_replicas: int
        """
        Number of replicas configured for the index.
        """
        number_of_shards: int
        """
        Number of shards configured & used by the index.
        """
        read_only_allow_delete: bool
        """
        Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.
        """
        size: int
        """
        Size of the index in bytes.
        """
        status: str
        """
        Status of the index e.g. `open` or `closed`.
        """
elif False:
    GetManagedDatabaseOpensearchIndicesIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabaseOpensearchIndicesIndexArgs:
    def __init__(__self__, *,
                 create_time: str,
                 docs: int,
                 health: str,
                 index_name: str,
                 number_of_replicas: int,
                 number_of_shards: int,
                 read_only_allow_delete: bool,
                 size: int,
                 status: str):
        """
        :param str create_time: Timestamp indicating the creation time of the index.
        :param int docs: Number of documents stored in the index.
        :param str health: Health status of the index e.g. `green`, `yellow`, or `red`.
        :param str index_name: Name of the index.
        :param int number_of_replicas: Number of replicas configured for the index.
        :param int number_of_shards: Number of shards configured & used by the index.
        :param bool read_only_allow_delete: Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.
        :param int size: Size of the index in bytes.
        :param str status: Status of the index e.g. `open` or `closed`.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "docs", docs)
        pulumi.set(__self__, "health", health)
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        pulumi.set(__self__, "number_of_shards", number_of_shards)
        pulumi.set(__self__, "read_only_allow_delete", read_only_allow_delete)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Timestamp indicating the creation time of the index.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: str):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter
    def docs(self) -> int:
        """
        Number of documents stored in the index.
        """
        return pulumi.get(self, "docs")

    @docs.setter
    def docs(self, value: int):
        pulumi.set(self, "docs", value)

    @property
    @pulumi.getter
    def health(self) -> str:
        """
        Health status of the index e.g. `green`, `yellow`, or `red`.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: str):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: str):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> int:
        """
        Number of replicas configured for the index.
        """
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: int):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> int:
        """
        Number of shards configured & used by the index.
        """
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: int):
        pulumi.set(self, "number_of_shards", value)

    @property
    @pulumi.getter(name="readOnlyAllowDelete")
    def read_only_allow_delete(self) -> bool:
        """
        Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.
        """
        return pulumi.get(self, "read_only_allow_delete")

    @read_only_allow_delete.setter
    def read_only_allow_delete(self, value: bool):
        pulumi.set(self, "read_only_allow_delete", value)

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the index in bytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: int):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the index e.g. `open` or `closed`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetManagedDatabasePostgresqlSessionsSessionArgsDict(TypedDict):
        application_name: str
        """
        Name of the application that is connected to this service.
        """
        backend_start: str
        """
        Time when this process was started, i.e., when the client connected to the server.
        """
        backend_type: str
        """
        Type of current service.
        """
        backend_xid: int
        """
        Top-level transaction identifier of this service, if any.
        """
        backend_xmin: int
        """
        The current service's xmin horizon.
        """
        client_addr: str
        """
        IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
        """
        client_hostname: str
        """
        Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.
        """
        client_port: int
        """
        TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.
        """
        datid: int
        """
        OID of the database this service is connected to.
        """
        datname: str
        """
        Name of the database this service is connected to.
        """
        id: str
        """
        Process ID of this service.
        """
        query: str
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
        """
        query_duration: str
        """
        The active query current duration.
        """
        query_start: str
        """
        Time when the currently active query was started, or if state is not active, when the last query was started.
        """
        state: str
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        state_change: str
        """
        Time when the state was last changed.
        """
        usename: str
        """
        Name of the user logged into this service.
        """
        usesysid: int
        """
        OID of the user logged into this service.
        """
        wait_event: str
        """
        Wait event name if service is currently waiting.
        """
        wait_event_type: str
        """
        The type of event for which the service is waiting, if any; otherwise NULL.
        """
        xact_start: str
        """
        Time when this process' current transaction was started, or null if no transaction is active.
        """
elif False:
    GetManagedDatabasePostgresqlSessionsSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabasePostgresqlSessionsSessionArgs:
    def __init__(__self__, *,
                 application_name: str,
                 backend_start: str,
                 backend_type: str,
                 backend_xid: int,
                 backend_xmin: int,
                 client_addr: str,
                 client_hostname: str,
                 client_port: int,
                 datid: int,
                 datname: str,
                 id: str,
                 query: str,
                 query_duration: str,
                 query_start: str,
                 state: str,
                 state_change: str,
                 usename: str,
                 usesysid: int,
                 wait_event: str,
                 wait_event_type: str,
                 xact_start: str):
        """
        :param str application_name: Name of the application that is connected to this service.
        :param str backend_start: Time when this process was started, i.e., when the client connected to the server.
        :param str backend_type: Type of current service.
        :param int backend_xid: Top-level transaction identifier of this service, if any.
        :param int backend_xmin: The current service's xmin horizon.
        :param str client_addr: IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
        :param str client_hostname: Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.
        :param int client_port: TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.
        :param int datid: OID of the database this service is connected to.
        :param str datname: Name of the database this service is connected to.
        :param str id: Process ID of this service.
        :param str query: Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
        :param str query_duration: The active query current duration.
        :param str query_start: Time when the currently active query was started, or if state is not active, when the last query was started.
        :param str state: Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        :param str state_change: Time when the state was last changed.
        :param str usename: Name of the user logged into this service.
        :param int usesysid: OID of the user logged into this service.
        :param str wait_event: Wait event name if service is currently waiting.
        :param str wait_event_type: The type of event for which the service is waiting, if any; otherwise NULL.
        :param str xact_start: Time when this process' current transaction was started, or null if no transaction is active.
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "backend_start", backend_start)
        pulumi.set(__self__, "backend_type", backend_type)
        pulumi.set(__self__, "backend_xid", backend_xid)
        pulumi.set(__self__, "backend_xmin", backend_xmin)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "client_hostname", client_hostname)
        pulumi.set(__self__, "client_port", client_port)
        pulumi.set(__self__, "datid", datid)
        pulumi.set(__self__, "datname", datname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_duration", query_duration)
        pulumi.set(__self__, "query_start", query_start)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_change", state_change)
        pulumi.set(__self__, "usename", usename)
        pulumi.set(__self__, "usesysid", usesysid)
        pulumi.set(__self__, "wait_event", wait_event)
        pulumi.set(__self__, "wait_event_type", wait_event_type)
        pulumi.set(__self__, "xact_start", xact_start)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: str):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="backendStart")
    def backend_start(self) -> str:
        """
        Time when this process was started, i.e., when the client connected to the server.
        """
        return pulumi.get(self, "backend_start")

    @backend_start.setter
    def backend_start(self, value: str):
        pulumi.set(self, "backend_start", value)

    @property
    @pulumi.getter(name="backendType")
    def backend_type(self) -> str:
        """
        Type of current service.
        """
        return pulumi.get(self, "backend_type")

    @backend_type.setter
    def backend_type(self, value: str):
        pulumi.set(self, "backend_type", value)

    @property
    @pulumi.getter(name="backendXid")
    def backend_xid(self) -> int:
        """
        Top-level transaction identifier of this service, if any.
        """
        return pulumi.get(self, "backend_xid")

    @backend_xid.setter
    def backend_xid(self, value: int):
        pulumi.set(self, "backend_xid", value)

    @property
    @pulumi.getter(name="backendXmin")
    def backend_xmin(self) -> int:
        """
        The current service's xmin horizon.
        """
        return pulumi.get(self, "backend_xmin")

    @backend_xmin.setter
    def backend_xmin(self, value: int):
        pulumi.set(self, "backend_xmin", value)

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> str:
        """
        IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
        """
        return pulumi.get(self, "client_addr")

    @client_addr.setter
    def client_addr(self, value: str):
        pulumi.set(self, "client_addr", value)

    @property
    @pulumi.getter(name="clientHostname")
    def client_hostname(self) -> str:
        """
        Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.
        """
        return pulumi.get(self, "client_hostname")

    @client_hostname.setter
    def client_hostname(self, value: str):
        pulumi.set(self, "client_hostname", value)

    @property
    @pulumi.getter(name="clientPort")
    def client_port(self) -> int:
        """
        TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.
        """
        return pulumi.get(self, "client_port")

    @client_port.setter
    def client_port(self, value: int):
        pulumi.set(self, "client_port", value)

    @property
    @pulumi.getter
    def datid(self) -> int:
        """
        OID of the database this service is connected to.
        """
        return pulumi.get(self, "datid")

    @datid.setter
    def datid(self, value: int):
        pulumi.set(self, "datid", value)

    @property
    @pulumi.getter
    def datname(self) -> str:
        """
        Name of the database this service is connected to.
        """
        return pulumi.get(self, "datname")

    @datname.setter
    def datname(self, value: str):
        pulumi.set(self, "datname", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Process ID of this service.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: str):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryDuration")
    def query_duration(self) -> str:
        """
        The active query current duration.
        """
        return pulumi.get(self, "query_duration")

    @query_duration.setter
    def query_duration(self, value: str):
        pulumi.set(self, "query_duration", value)

    @property
    @pulumi.getter(name="queryStart")
    def query_start(self) -> str:
        """
        Time when the currently active query was started, or if state is not active, when the last query was started.
        """
        return pulumi.get(self, "query_start")

    @query_start.setter
    def query_start(self, value: str):
        pulumi.set(self, "query_start", value)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: str):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="stateChange")
    def state_change(self) -> str:
        """
        Time when the state was last changed.
        """
        return pulumi.get(self, "state_change")

    @state_change.setter
    def state_change(self, value: str):
        pulumi.set(self, "state_change", value)

    @property
    @pulumi.getter
    def usename(self) -> str:
        """
        Name of the user logged into this service.
        """
        return pulumi.get(self, "usename")

    @usename.setter
    def usename(self, value: str):
        pulumi.set(self, "usename", value)

    @property
    @pulumi.getter
    def usesysid(self) -> int:
        """
        OID of the user logged into this service.
        """
        return pulumi.get(self, "usesysid")

    @usesysid.setter
    def usesysid(self, value: int):
        pulumi.set(self, "usesysid", value)

    @property
    @pulumi.getter(name="waitEvent")
    def wait_event(self) -> str:
        """
        Wait event name if service is currently waiting.
        """
        return pulumi.get(self, "wait_event")

    @wait_event.setter
    def wait_event(self, value: str):
        pulumi.set(self, "wait_event", value)

    @property
    @pulumi.getter(name="waitEventType")
    def wait_event_type(self) -> str:
        """
        The type of event for which the service is waiting, if any; otherwise NULL.
        """
        return pulumi.get(self, "wait_event_type")

    @wait_event_type.setter
    def wait_event_type(self, value: str):
        pulumi.set(self, "wait_event_type", value)

    @property
    @pulumi.getter(name="xactStart")
    def xact_start(self) -> str:
        """
        Time when this process' current transaction was started, or null if no transaction is active.
        """
        return pulumi.get(self, "xact_start")

    @xact_start.setter
    def xact_start(self, value: str):
        pulumi.set(self, "xact_start", value)


if not MYPY:
    class GetManagedDatabaseRedisSessionsSessionArgsDict(TypedDict):
        active_channel_subscriptions: int
        """
        Number of active channel subscriptions
        """
        active_database: str
        """
        Current database ID
        """
        active_pattern_matching_channel_subscriptions: int
        """
        Number of pattern matching subscriptions.
        """
        application_name: str
        """
        Name of the application that is connected to this service.
        """
        client_addr: str
        """
        Number of pattern matching subscriptions.
        """
        connection_age: int
        """
        Total duration of the connection in nanoseconds.
        """
        connection_idle: int
        """
        Idle time of the connection in nanoseconds.
        """
        flags: Sequence[str]
        """
        A set containing flags' descriptions.
        """
        flags_raw: str
        """
        Client connection flags in raw string format.
        """
        id: str
        """
        Process ID of this session.
        """
        multi_exec_commands: int
        """
        Number of commands in a MULTI/EXEC context.
        """
        output_buffer: int
        """
        Output buffer length.
        """
        output_buffer_memory: int
        """
        Output buffer memory usage.
        """
        output_list_length: int
        """
        Output list length (replies are queued in this list when the buffer is full).
        """
        query: str
        """
        The last executed command.
        """
        query_buffer: int
        """
        Query buffer length (0 means no query pending).
        """
        query_buffer_free: int
        """
        Free space of the query buffer (0 means the buffer is full).
        """
elif False:
    GetManagedDatabaseRedisSessionsSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedDatabaseRedisSessionsSessionArgs:
    def __init__(__self__, *,
                 active_channel_subscriptions: int,
                 active_database: str,
                 active_pattern_matching_channel_subscriptions: int,
                 application_name: str,
                 client_addr: str,
                 connection_age: int,
                 connection_idle: int,
                 flags: Sequence[str],
                 flags_raw: str,
                 id: str,
                 multi_exec_commands: int,
                 output_buffer: int,
                 output_buffer_memory: int,
                 output_list_length: int,
                 query: str,
                 query_buffer: int,
                 query_buffer_free: int):
        """
        :param int active_channel_subscriptions: Number of active channel subscriptions
        :param str active_database: Current database ID
        :param int active_pattern_matching_channel_subscriptions: Number of pattern matching subscriptions.
        :param str application_name: Name of the application that is connected to this service.
        :param str client_addr: Number of pattern matching subscriptions.
        :param int connection_age: Total duration of the connection in nanoseconds.
        :param int connection_idle: Idle time of the connection in nanoseconds.
        :param Sequence[str] flags: A set containing flags' descriptions.
        :param str flags_raw: Client connection flags in raw string format.
        :param str id: Process ID of this session.
        :param int multi_exec_commands: Number of commands in a MULTI/EXEC context.
        :param int output_buffer: Output buffer length.
        :param int output_buffer_memory: Output buffer memory usage.
        :param int output_list_length: Output list length (replies are queued in this list when the buffer is full).
        :param str query: The last executed command.
        :param int query_buffer: Query buffer length (0 means no query pending).
        :param int query_buffer_free: Free space of the query buffer (0 means the buffer is full).
        """
        pulumi.set(__self__, "active_channel_subscriptions", active_channel_subscriptions)
        pulumi.set(__self__, "active_database", active_database)
        pulumi.set(__self__, "active_pattern_matching_channel_subscriptions", active_pattern_matching_channel_subscriptions)
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "connection_age", connection_age)
        pulumi.set(__self__, "connection_idle", connection_idle)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "flags_raw", flags_raw)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "multi_exec_commands", multi_exec_commands)
        pulumi.set(__self__, "output_buffer", output_buffer)
        pulumi.set(__self__, "output_buffer_memory", output_buffer_memory)
        pulumi.set(__self__, "output_list_length", output_list_length)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_buffer", query_buffer)
        pulumi.set(__self__, "query_buffer_free", query_buffer_free)

    @property
    @pulumi.getter(name="activeChannelSubscriptions")
    def active_channel_subscriptions(self) -> int:
        """
        Number of active channel subscriptions
        """
        return pulumi.get(self, "active_channel_subscriptions")

    @active_channel_subscriptions.setter
    def active_channel_subscriptions(self, value: int):
        pulumi.set(self, "active_channel_subscriptions", value)

    @property
    @pulumi.getter(name="activeDatabase")
    def active_database(self) -> str:
        """
        Current database ID
        """
        return pulumi.get(self, "active_database")

    @active_database.setter
    def active_database(self, value: str):
        pulumi.set(self, "active_database", value)

    @property
    @pulumi.getter(name="activePatternMatchingChannelSubscriptions")
    def active_pattern_matching_channel_subscriptions(self) -> int:
        """
        Number of pattern matching subscriptions.
        """
        return pulumi.get(self, "active_pattern_matching_channel_subscriptions")

    @active_pattern_matching_channel_subscriptions.setter
    def active_pattern_matching_channel_subscriptions(self, value: int):
        pulumi.set(self, "active_pattern_matching_channel_subscriptions", value)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: str):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> str:
        """
        Number of pattern matching subscriptions.
        """
        return pulumi.get(self, "client_addr")

    @client_addr.setter
    def client_addr(self, value: str):
        pulumi.set(self, "client_addr", value)

    @property
    @pulumi.getter(name="connectionAge")
    def connection_age(self) -> int:
        """
        Total duration of the connection in nanoseconds.
        """
        return pulumi.get(self, "connection_age")

    @connection_age.setter
    def connection_age(self, value: int):
        pulumi.set(self, "connection_age", value)

    @property
    @pulumi.getter(name="connectionIdle")
    def connection_idle(self) -> int:
        """
        Idle time of the connection in nanoseconds.
        """
        return pulumi.get(self, "connection_idle")

    @connection_idle.setter
    def connection_idle(self, value: int):
        pulumi.set(self, "connection_idle", value)

    @property
    @pulumi.getter
    def flags(self) -> Sequence[str]:
        """
        A set containing flags' descriptions.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Sequence[str]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter(name="flagsRaw")
    def flags_raw(self) -> str:
        """
        Client connection flags in raw string format.
        """
        return pulumi.get(self, "flags_raw")

    @flags_raw.setter
    def flags_raw(self, value: str):
        pulumi.set(self, "flags_raw", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Process ID of this session.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="multiExecCommands")
    def multi_exec_commands(self) -> int:
        """
        Number of commands in a MULTI/EXEC context.
        """
        return pulumi.get(self, "multi_exec_commands")

    @multi_exec_commands.setter
    def multi_exec_commands(self, value: int):
        pulumi.set(self, "multi_exec_commands", value)

    @property
    @pulumi.getter(name="outputBuffer")
    def output_buffer(self) -> int:
        """
        Output buffer length.
        """
        return pulumi.get(self, "output_buffer")

    @output_buffer.setter
    def output_buffer(self, value: int):
        pulumi.set(self, "output_buffer", value)

    @property
    @pulumi.getter(name="outputBufferMemory")
    def output_buffer_memory(self) -> int:
        """
        Output buffer memory usage.
        """
        return pulumi.get(self, "output_buffer_memory")

    @output_buffer_memory.setter
    def output_buffer_memory(self, value: int):
        pulumi.set(self, "output_buffer_memory", value)

    @property
    @pulumi.getter(name="outputListLength")
    def output_list_length(self) -> int:
        """
        Output list length (replies are queued in this list when the buffer is full).
        """
        return pulumi.get(self, "output_list_length")

    @output_list_length.setter
    def output_list_length(self, value: int):
        pulumi.set(self, "output_list_length", value)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The last executed command.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: str):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryBuffer")
    def query_buffer(self) -> int:
        """
        Query buffer length (0 means no query pending).
        """
        return pulumi.get(self, "query_buffer")

    @query_buffer.setter
    def query_buffer(self, value: int):
        pulumi.set(self, "query_buffer", value)

    @property
    @pulumi.getter(name="queryBufferFree")
    def query_buffer_free(self) -> int:
        """
        Free space of the query buffer (0 means the buffer is full).
        """
        return pulumi.get(self, "query_buffer_free")

    @query_buffer_free.setter
    def query_buffer_free(self, value: int):
        pulumi.set(self, "query_buffer_free", value)


if not MYPY:
    class GetManagedObjectStorageRegionsRegionArgsDict(TypedDict):
        name: str
        """
        Name of the region.
        """
        primary_zone: str
        """
        Primary zone of the region.
        """
        zones: Sequence[str]
        """
        List of zones in the region.
        """
elif False:
    GetManagedObjectStorageRegionsRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedObjectStorageRegionsRegionArgs:
    def __init__(__self__, *,
                 name: str,
                 primary_zone: str,
                 zones: Sequence[str]):
        """
        :param str name: Name of the region.
        :param str primary_zone: Primary zone of the region.
        :param Sequence[str] zones: List of zones in the region.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_zone", primary_zone)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the region.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryZone")
    def primary_zone(self) -> str:
        """
        Primary zone of the region.
        """
        return pulumi.get(self, "primary_zone")

    @primary_zone.setter
    def primary_zone(self, value: str):
        pulumi.set(self, "primary_zone", value)

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        List of zones in the region.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Sequence[str]):
        pulumi.set(self, "zones", value)


