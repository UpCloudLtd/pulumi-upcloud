# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GatewayAddress',
    'GatewayConnectionLocalRoute',
    'GatewayConnectionRemoteRoute',
    'GatewayConnectionTunnelIpsecAuthPsk',
    'GatewayConnectionTunnelIpsecProperties',
    'GatewayRouter',
    'KubernetesNodeGroupCustomPlan',
    'KubernetesNodeGroupKubeletArg',
    'KubernetesNodeGroupTaint',
    'LoadbalancerBackendProperties',
    'LoadbalancerFrontendNetwork',
    'LoadbalancerFrontendProperties',
    'LoadbalancerFrontendRuleActions',
    'LoadbalancerFrontendRuleActionsHttpRedirect',
    'LoadbalancerFrontendRuleActionsHttpReturn',
    'LoadbalancerFrontendRuleActionsSetForwardedHeader',
    'LoadbalancerFrontendRuleActionsTcpReject',
    'LoadbalancerFrontendRuleActionsUseBackend',
    'LoadbalancerFrontendRuleMatchers',
    'LoadbalancerFrontendRuleMatchersBodySize',
    'LoadbalancerFrontendRuleMatchersBodySizeRange',
    'LoadbalancerFrontendRuleMatchersCookie',
    'LoadbalancerFrontendRuleMatchersHeader',
    'LoadbalancerFrontendRuleMatchersHost',
    'LoadbalancerFrontendRuleMatchersHttpMethod',
    'LoadbalancerFrontendRuleMatchersNumMembersUp',
    'LoadbalancerFrontendRuleMatchersPath',
    'LoadbalancerFrontendRuleMatchersSrcIp',
    'LoadbalancerFrontendRuleMatchersSrcPort',
    'LoadbalancerFrontendRuleMatchersSrcPortRange',
    'LoadbalancerFrontendRuleMatchersUrl',
    'LoadbalancerFrontendRuleMatchersUrlParam',
    'LoadbalancerFrontendRuleMatchersUrlQuery',
    'LoadbalancerNetwork',
    'LoadbalancerNode',
    'LoadbalancerNodeNetwork',
    'LoadbalancerNodeNetworkIpAddress',
    'ManagedDatabaseMysqlComponent',
    'ManagedDatabaseMysqlNetwork',
    'ManagedDatabaseMysqlNodeState',
    'ManagedDatabaseMysqlProperties',
    'ManagedDatabaseMysqlPropertiesMigration',
    'ManagedDatabaseOpensearchComponent',
    'ManagedDatabaseOpensearchNetwork',
    'ManagedDatabaseOpensearchNodeState',
    'ManagedDatabaseOpensearchProperties',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListeners',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting',
    'ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimiting',
    'ManagedDatabaseOpensearchPropertiesAzureMigration',
    'ManagedDatabaseOpensearchPropertiesGcsMigration',
    'ManagedDatabaseOpensearchPropertiesIndexRollup',
    'ManagedDatabaseOpensearchPropertiesIndexTemplate',
    'ManagedDatabaseOpensearchPropertiesOpenid',
    'ManagedDatabaseOpensearchPropertiesOpensearchDashboards',
    'ManagedDatabaseOpensearchPropertiesS3Migration',
    'ManagedDatabaseOpensearchPropertiesSaml',
    'ManagedDatabasePostgresqlComponent',
    'ManagedDatabasePostgresqlNetwork',
    'ManagedDatabasePostgresqlNodeState',
    'ManagedDatabasePostgresqlProperties',
    'ManagedDatabasePostgresqlPropertiesMigration',
    'ManagedDatabasePostgresqlPropertiesPgbouncer',
    'ManagedDatabasePostgresqlPropertiesPglookout',
    'ManagedDatabasePostgresqlPropertiesTimescaledb',
    'ManagedDatabaseRedisComponent',
    'ManagedDatabaseRedisNetwork',
    'ManagedDatabaseRedisNodeState',
    'ManagedDatabaseRedisProperties',
    'ManagedDatabaseRedisPropertiesMigration',
    'ManagedDatabaseUserOpensearchAccessControl',
    'ManagedDatabaseUserOpensearchAccessControlRule',
    'ManagedDatabaseUserPgAccessControl',
    'ManagedDatabaseUserRedisAccessControl',
    'ManagedObjectStorageEndpoint',
    'ManagedObjectStorageNetwork',
    'NetworkIpNetwork',
    'NetworkPeeringNetwork',
    'NetworkPeeringPeerNetwork',
    'ObjectStorageBucket',
    'RouterStaticRoute',
    'ServerFirewallRulesFirewallRule',
    'ServerLogin',
    'ServerNetworkInterface',
    'ServerNetworkInterfaceAdditionalIpAddress',
    'ServerSimpleBackup',
    'ServerStorageDevice',
    'ServerTemplate',
    'ServerTemplateBackupRule',
    'StorageBackupRule',
    'StorageClone',
    'StorageImport',
    'GetHostsHostResult',
    'GetIpAddressesAddressResult',
    'GetManagedDatabaseMysqlSessionsSessionResult',
    'GetManagedDatabaseOpensearchIndicesIndexResult',
    'GetManagedDatabasePostgresqlSessionsSessionResult',
    'GetManagedDatabaseRedisSessionsSessionResult',
    'GetManagedObjectStoragePoliciesPolicyResult',
    'GetManagedObjectStorageRegionsRegionResult',
    'GetNetworksNetworkResult',
    'GetNetworksNetworkIpNetworkResult',
    'GetNetworksNetworkServerResult',
    'GetTagsTagResult',
]

@pulumi.output_type
class GatewayAddress(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str address: IP addresss
        :param str name: Name of the IP address
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        IP addresss
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the IP address
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GatewayConnectionLocalRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticNetwork":
            suggest = "static_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayConnectionLocalRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayConnectionLocalRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayConnectionLocalRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 static_network: str,
                 type: Optional[str] = None):
        """
        :param str name: Name of the route
        :param str static_network: Destination prefix of the route; needs to be a valid IPv4 prefix
        :param str type: Type of route; currently the only supported type is 'static'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "static_network", static_network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="staticNetwork")
    def static_network(self) -> str:
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        return pulumi.get(self, "static_network")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of route; currently the only supported type is 'static'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayConnectionRemoteRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticNetwork":
            suggest = "static_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayConnectionRemoteRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayConnectionRemoteRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayConnectionRemoteRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 static_network: str,
                 type: Optional[str] = None):
        """
        :param str name: Name of the route
        :param str static_network: Destination prefix of the route; needs to be a valid IPv4 prefix
        :param str type: Type of route; currently the only supported type is 'static'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "static_network", static_network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="staticNetwork")
    def static_network(self) -> str:
        """
        Destination prefix of the route; needs to be a valid IPv4 prefix
        """
        return pulumi.get(self, "static_network")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of route; currently the only supported type is 'static'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GatewayConnectionTunnelIpsecAuthPsk(dict):
    def __init__(__self__, *,
                 psk: str):
        """
        :param str psk: The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.
        """
        pulumi.set(__self__, "psk", psk)

    @property
    @pulumi.getter
    def psk(self) -> str:
        """
        The pre-shared key. This value is only used during resource creation and is not returned in the state. It is not possible to update this value. If you need to update it, delete the connection and create a new one.
        """
        return pulumi.get(self, "psk")


@pulumi.output_type
class GatewayConnectionTunnelIpsecProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "childRekeyTime":
            suggest = "child_rekey_time"
        elif key == "dpdDelay":
            suggest = "dpd_delay"
        elif key == "dpdTimeout":
            suggest = "dpd_timeout"
        elif key == "ikeLifetime":
            suggest = "ike_lifetime"
        elif key == "phase1Algorithms":
            suggest = "phase1_algorithms"
        elif key == "phase1DhGroupNumbers":
            suggest = "phase1_dh_group_numbers"
        elif key == "phase1IntegrityAlgorithms":
            suggest = "phase1_integrity_algorithms"
        elif key == "phase2Algorithms":
            suggest = "phase2_algorithms"
        elif key == "phase2DhGroupNumbers":
            suggest = "phase2_dh_group_numbers"
        elif key == "phase2IntegrityAlgorithms":
            suggest = "phase2_integrity_algorithms"
        elif key == "rekeyTime":
            suggest = "rekey_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayConnectionTunnelIpsecProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayConnectionTunnelIpsecProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayConnectionTunnelIpsecProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 child_rekey_time: Optional[int] = None,
                 dpd_delay: Optional[int] = None,
                 dpd_timeout: Optional[int] = None,
                 ike_lifetime: Optional[int] = None,
                 phase1_algorithms: Optional[Sequence[str]] = None,
                 phase1_dh_group_numbers: Optional[Sequence[int]] = None,
                 phase1_integrity_algorithms: Optional[Sequence[str]] = None,
                 phase2_algorithms: Optional[Sequence[str]] = None,
                 phase2_dh_group_numbers: Optional[Sequence[int]] = None,
                 phase2_integrity_algorithms: Optional[Sequence[str]] = None,
                 rekey_time: Optional[int] = None):
        """
        :param int child_rekey_time: IKE child SA rekey time in seconds.
        :param int dpd_delay: Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.
        :param int dpd_timeout: Timeout period for DPD reply before considering the peer to be dead, in seconds.
        :param int ike_lifetime: Maximum IKE SA lifetime in seconds.
        :param Sequence[str] phase1_algorithms: List of Phase 1: Proposal algorithms.
        :param Sequence[int] phase1_dh_group_numbers: List of Phase 1 Diffie-Hellman group numbers.
        :param Sequence[str] phase1_integrity_algorithms: List of Phase 1 integrity algorithms.
        :param Sequence[str] phase2_algorithms: List of Phase 2: Security Association algorithms.
        :param Sequence[int] phase2_dh_group_numbers: List of Phase 2 Diffie-Hellman group numbers.
        :param Sequence[str] phase2_integrity_algorithms: List of Phase 2 integrity algorithms.
        :param int rekey_time: IKE SA rekey time in seconds.
        """
        if child_rekey_time is not None:
            pulumi.set(__self__, "child_rekey_time", child_rekey_time)
        if dpd_delay is not None:
            pulumi.set(__self__, "dpd_delay", dpd_delay)
        if dpd_timeout is not None:
            pulumi.set(__self__, "dpd_timeout", dpd_timeout)
        if ike_lifetime is not None:
            pulumi.set(__self__, "ike_lifetime", ike_lifetime)
        if phase1_algorithms is not None:
            pulumi.set(__self__, "phase1_algorithms", phase1_algorithms)
        if phase1_dh_group_numbers is not None:
            pulumi.set(__self__, "phase1_dh_group_numbers", phase1_dh_group_numbers)
        if phase1_integrity_algorithms is not None:
            pulumi.set(__self__, "phase1_integrity_algorithms", phase1_integrity_algorithms)
        if phase2_algorithms is not None:
            pulumi.set(__self__, "phase2_algorithms", phase2_algorithms)
        if phase2_dh_group_numbers is not None:
            pulumi.set(__self__, "phase2_dh_group_numbers", phase2_dh_group_numbers)
        if phase2_integrity_algorithms is not None:
            pulumi.set(__self__, "phase2_integrity_algorithms", phase2_integrity_algorithms)
        if rekey_time is not None:
            pulumi.set(__self__, "rekey_time", rekey_time)

    @property
    @pulumi.getter(name="childRekeyTime")
    def child_rekey_time(self) -> Optional[int]:
        """
        IKE child SA rekey time in seconds.
        """
        return pulumi.get(self, "child_rekey_time")

    @property
    @pulumi.getter(name="dpdDelay")
    def dpd_delay(self) -> Optional[int]:
        """
        Delay before sending Dead Peer Detection packets if no traffic is detected, in seconds.
        """
        return pulumi.get(self, "dpd_delay")

    @property
    @pulumi.getter(name="dpdTimeout")
    def dpd_timeout(self) -> Optional[int]:
        """
        Timeout period for DPD reply before considering the peer to be dead, in seconds.
        """
        return pulumi.get(self, "dpd_timeout")

    @property
    @pulumi.getter(name="ikeLifetime")
    def ike_lifetime(self) -> Optional[int]:
        """
        Maximum IKE SA lifetime in seconds.
        """
        return pulumi.get(self, "ike_lifetime")

    @property
    @pulumi.getter(name="phase1Algorithms")
    def phase1_algorithms(self) -> Optional[Sequence[str]]:
        """
        List of Phase 1: Proposal algorithms.
        """
        return pulumi.get(self, "phase1_algorithms")

    @property
    @pulumi.getter(name="phase1DhGroupNumbers")
    def phase1_dh_group_numbers(self) -> Optional[Sequence[int]]:
        """
        List of Phase 1 Diffie-Hellman group numbers.
        """
        return pulumi.get(self, "phase1_dh_group_numbers")

    @property
    @pulumi.getter(name="phase1IntegrityAlgorithms")
    def phase1_integrity_algorithms(self) -> Optional[Sequence[str]]:
        """
        List of Phase 1 integrity algorithms.
        """
        return pulumi.get(self, "phase1_integrity_algorithms")

    @property
    @pulumi.getter(name="phase2Algorithms")
    def phase2_algorithms(self) -> Optional[Sequence[str]]:
        """
        List of Phase 2: Security Association algorithms.
        """
        return pulumi.get(self, "phase2_algorithms")

    @property
    @pulumi.getter(name="phase2DhGroupNumbers")
    def phase2_dh_group_numbers(self) -> Optional[Sequence[int]]:
        """
        List of Phase 2 Diffie-Hellman group numbers.
        """
        return pulumi.get(self, "phase2_dh_group_numbers")

    @property
    @pulumi.getter(name="phase2IntegrityAlgorithms")
    def phase2_integrity_algorithms(self) -> Optional[Sequence[str]]:
        """
        List of Phase 2 integrity algorithms.
        """
        return pulumi.get(self, "phase2_integrity_algorithms")

    @property
    @pulumi.getter(name="rekeyTime")
    def rekey_time(self) -> Optional[int]:
        """
        IKE SA rekey time in seconds.
        """
        return pulumi.get(self, "rekey_time")


@pulumi.output_type
class GatewayRouter(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: ID of the router attached to the gateway.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the router attached to the gateway.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KubernetesNodeGroupCustomPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageSize":
            suggest = "storage_size"
        elif key == "storageTier":
            suggest = "storage_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupCustomPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupCustomPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupCustomPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores: int,
                 memory: int,
                 storage_size: int,
                 storage_tier: Optional[str] = None):
        """
        :param int cores: The number of CPU cores dedicated to individual node group nodes when using custom plan
        :param int memory: The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
        :param int storage_size: The size of the storage device in gigabytes.
        :param str storage_tier: The storage tier to use. Defaults to maxiops
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "storage_size", storage_size)
        if storage_tier is not None:
            pulumi.set(__self__, "storage_tier", storage_tier)

    @property
    @pulumi.getter
    def cores(self) -> int:
        """
        The number of CPU cores dedicated to individual node group nodes when using custom plan
        """
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def memory(self) -> int:
        """
        The amount of memory in megabytes to assign to individual node group node when using custom plan. Value needs to be divisible by 1024.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="storageSize")
    def storage_size(self) -> int:
        """
        The size of the storage device in gigabytes.
        """
        return pulumi.get(self, "storage_size")

    @property
    @pulumi.getter(name="storageTier")
    def storage_tier(self) -> Optional[str]:
        """
        The storage tier to use. Defaults to maxiops
        """
        return pulumi.get(self, "storage_tier")


@pulumi.output_type
class KubernetesNodeGroupKubeletArg(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Kubelet argument key.
        :param str value: Kubelet argument value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Kubelet argument key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Kubelet argument value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KubernetesNodeGroupTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        """
        :param str effect: Taint effect.
        :param str key: Taint key.
        :param str value: Taint value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Taint effect.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Taint key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Taint value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadbalancerBackendProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckExpectedStatus":
            suggest = "health_check_expected_status"
        elif key == "healthCheckFall":
            suggest = "health_check_fall"
        elif key == "healthCheckInterval":
            suggest = "health_check_interval"
        elif key == "healthCheckRise":
            suggest = "health_check_rise"
        elif key == "healthCheckTlsVerify":
            suggest = "health_check_tls_verify"
        elif key == "healthCheckType":
            suggest = "health_check_type"
        elif key == "healthCheckUrl":
            suggest = "health_check_url"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "outboundProxyProtocol":
            suggest = "outbound_proxy_protocol"
        elif key == "stickySessionCookieName":
            suggest = "sticky_session_cookie_name"
        elif key == "timeoutServer":
            suggest = "timeout_server"
        elif key == "timeoutTunnel":
            suggest = "timeout_tunnel"
        elif key == "tlsEnabled":
            suggest = "tls_enabled"
        elif key == "tlsUseSystemCa":
            suggest = "tls_use_system_ca"
        elif key == "tlsVerify":
            suggest = "tls_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerBackendProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerBackendProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerBackendProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_expected_status: Optional[int] = None,
                 health_check_fall: Optional[int] = None,
                 health_check_interval: Optional[int] = None,
                 health_check_rise: Optional[int] = None,
                 health_check_tls_verify: Optional[bool] = None,
                 health_check_type: Optional[str] = None,
                 health_check_url: Optional[str] = None,
                 http2_enabled: Optional[bool] = None,
                 outbound_proxy_protocol: Optional[str] = None,
                 sticky_session_cookie_name: Optional[str] = None,
                 timeout_server: Optional[int] = None,
                 timeout_tunnel: Optional[int] = None,
                 tls_enabled: Optional[bool] = None,
                 tls_use_system_ca: Optional[bool] = None,
                 tls_verify: Optional[bool] = None):
        """
        :param int health_check_expected_status: Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.
        :param int health_check_fall: Sets how many failed health checks are allowed until the backend member is taken off from the rotation.
        :param int health_check_interval: Interval between health checks in seconds.
        :param int health_check_rise: Sets how many successful health checks are required to put the backend member back into rotation.
        :param bool health_check_tls_verify: Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.
        :param str health_check_type: Health check type.
        :param str health_check_url: Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.
        :param bool http2_enabled: Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.
        :param str outbound_proxy_protocol: Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.
        :param str sticky_session_cookie_name: Sets sticky session cookie name. Empty string disables sticky session.
        :param int timeout_server: Backend server timeout in seconds.
        :param int timeout_tunnel: Maximum inactivity time on the client and server side for tunnels in seconds.
        :param bool tls_enabled: Enables TLS connection from the load balancer to backend servers.
        :param bool tls_use_system_ca: If enabled, then the system CA certificate bundle will be used for the certificate verification.
        :param bool tls_verify: Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.
        """
        if health_check_expected_status is not None:
            pulumi.set(__self__, "health_check_expected_status", health_check_expected_status)
        if health_check_fall is not None:
            pulumi.set(__self__, "health_check_fall", health_check_fall)
        if health_check_interval is not None:
            pulumi.set(__self__, "health_check_interval", health_check_interval)
        if health_check_rise is not None:
            pulumi.set(__self__, "health_check_rise", health_check_rise)
        if health_check_tls_verify is not None:
            pulumi.set(__self__, "health_check_tls_verify", health_check_tls_verify)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)
        if health_check_url is not None:
            pulumi.set(__self__, "health_check_url", health_check_url)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if outbound_proxy_protocol is not None:
            pulumi.set(__self__, "outbound_proxy_protocol", outbound_proxy_protocol)
        if sticky_session_cookie_name is not None:
            pulumi.set(__self__, "sticky_session_cookie_name", sticky_session_cookie_name)
        if timeout_server is not None:
            pulumi.set(__self__, "timeout_server", timeout_server)
        if timeout_tunnel is not None:
            pulumi.set(__self__, "timeout_tunnel", timeout_tunnel)
        if tls_enabled is not None:
            pulumi.set(__self__, "tls_enabled", tls_enabled)
        if tls_use_system_ca is not None:
            pulumi.set(__self__, "tls_use_system_ca", tls_use_system_ca)
        if tls_verify is not None:
            pulumi.set(__self__, "tls_verify", tls_verify)

    @property
    @pulumi.getter(name="healthCheckExpectedStatus")
    def health_check_expected_status(self) -> Optional[int]:
        """
        Expected HTTP status code returned by the customer application to mark server as healthy. Ignored for `tcp` `health_check_type`.
        """
        return pulumi.get(self, "health_check_expected_status")

    @property
    @pulumi.getter(name="healthCheckFall")
    def health_check_fall(self) -> Optional[int]:
        """
        Sets how many failed health checks are allowed until the backend member is taken off from the rotation.
        """
        return pulumi.get(self, "health_check_fall")

    @property
    @pulumi.getter(name="healthCheckInterval")
    def health_check_interval(self) -> Optional[int]:
        """
        Interval between health checks in seconds.
        """
        return pulumi.get(self, "health_check_interval")

    @property
    @pulumi.getter(name="healthCheckRise")
    def health_check_rise(self) -> Optional[int]:
        """
        Sets how many successful health checks are required to put the backend member back into rotation.
        """
        return pulumi.get(self, "health_check_rise")

    @property
    @pulumi.getter(name="healthCheckTlsVerify")
    def health_check_tls_verify(self) -> Optional[bool]:
        """
        Enables certificate verification with the system CA certificate bundle. Works with https scheme in health_check_url, otherwise ignored.
        """
        return pulumi.get(self, "health_check_tls_verify")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[str]:
        """
        Health check type.
        """
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter(name="healthCheckUrl")
    def health_check_url(self) -> Optional[str]:
        """
        Target path for health check HTTP GET requests. Ignored for `tcp` `health_check_type`.
        """
        return pulumi.get(self, "health_check_url")

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Allow HTTP/2 connections to backend members by utilizing ALPN extension of TLS protocol, therefore it can only be enabled when tls_enabled is set to true. Note: members should support HTTP/2 for this setting to work.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="outboundProxyProtocol")
    def outbound_proxy_protocol(self) -> Optional[str]:
        """
        Enable outbound proxy protocol by setting the desired version. Defaults to empty string. Empty string disables proxy protocol.
        """
        return pulumi.get(self, "outbound_proxy_protocol")

    @property
    @pulumi.getter(name="stickySessionCookieName")
    def sticky_session_cookie_name(self) -> Optional[str]:
        """
        Sets sticky session cookie name. Empty string disables sticky session.
        """
        return pulumi.get(self, "sticky_session_cookie_name")

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> Optional[int]:
        """
        Backend server timeout in seconds.
        """
        return pulumi.get(self, "timeout_server")

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> Optional[int]:
        """
        Maximum inactivity time on the client and server side for tunnels in seconds.
        """
        return pulumi.get(self, "timeout_tunnel")

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> Optional[bool]:
        """
        Enables TLS connection from the load balancer to backend servers.
        """
        return pulumi.get(self, "tls_enabled")

    @property
    @pulumi.getter(name="tlsUseSystemCa")
    def tls_use_system_ca(self) -> Optional[bool]:
        """
        If enabled, then the system CA certificate bundle will be used for the certificate verification.
        """
        return pulumi.get(self, "tls_use_system_ca")

    @property
    @pulumi.getter(name="tlsVerify")
    def tls_verify(self) -> Optional[bool]:
        """
        Enables backend servers certificate verification. Please make sure that TLS config with the certificate bundle of type authority attached to the backend or `tls_use_system_ca` enabled. Note: `tls_verify` has preference over `health_check_tls_verify` when `tls_enabled` in true.
        """
        return pulumi.get(self, "tls_verify")


@pulumi.output_type
class LoadbalancerFrontendNetwork(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the load balancer network.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the load balancer network.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LoadbalancerFrontendProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "inboundProxyProtocol":
            suggest = "inbound_proxy_protocol"
        elif key == "timeoutClient":
            suggest = "timeout_client"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http2_enabled: Optional[bool] = None,
                 inbound_proxy_protocol: Optional[bool] = None,
                 timeout_client: Optional[int] = None):
        """
        :param bool http2_enabled: Enable or disable HTTP/2 support.
        :param bool inbound_proxy_protocol: Enable or disable inbound proxy protocol support.
        :param int timeout_client: Client request timeout in seconds.
        """
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if inbound_proxy_protocol is not None:
            pulumi.set(__self__, "inbound_proxy_protocol", inbound_proxy_protocol)
        if timeout_client is not None:
            pulumi.set(__self__, "timeout_client", timeout_client)

    @property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[bool]:
        """
        Enable or disable HTTP/2 support.
        """
        return pulumi.get(self, "http2_enabled")

    @property
    @pulumi.getter(name="inboundProxyProtocol")
    def inbound_proxy_protocol(self) -> Optional[bool]:
        """
        Enable or disable inbound proxy protocol support.
        """
        return pulumi.get(self, "inbound_proxy_protocol")

    @property
    @pulumi.getter(name="timeoutClient")
    def timeout_client(self) -> Optional[int]:
        """
        Client request timeout in seconds.
        """
        return pulumi.get(self, "timeout_client")


@pulumi.output_type
class LoadbalancerFrontendRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpRedirects":
            suggest = "http_redirects"
        elif key == "httpReturns":
            suggest = "http_returns"
        elif key == "setForwardedHeaders":
            suggest = "set_forwarded_headers"
        elif key == "tcpRejects":
            suggest = "tcp_rejects"
        elif key == "useBackends":
            suggest = "use_backends"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_redirects: Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsHttpRedirect']] = None,
                 http_returns: Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsHttpReturn']] = None,
                 set_forwarded_headers: Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsSetForwardedHeader']] = None,
                 tcp_rejects: Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsTcpReject']] = None,
                 use_backends: Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsUseBackend']] = None):
        """
        :param Sequence['LoadbalancerFrontendRuleActionsHttpRedirectArgs'] http_redirects: Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.
        :param Sequence['LoadbalancerFrontendRuleActionsHttpReturnArgs'] http_returns: Returns HTTP response with specified HTTP status.
        :param Sequence['LoadbalancerFrontendRuleActionsSetForwardedHeaderArgs'] set_forwarded_headers: Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests
        :param Sequence['LoadbalancerFrontendRuleActionsTcpRejectArgs'] tcp_rejects: Terminates a connection.
        :param Sequence['LoadbalancerFrontendRuleActionsUseBackendArgs'] use_backends: Routes traffic to specified `backend`.
        """
        if http_redirects is not None:
            pulumi.set(__self__, "http_redirects", http_redirects)
        if http_returns is not None:
            pulumi.set(__self__, "http_returns", http_returns)
        if set_forwarded_headers is not None:
            pulumi.set(__self__, "set_forwarded_headers", set_forwarded_headers)
        if tcp_rejects is not None:
            pulumi.set(__self__, "tcp_rejects", tcp_rejects)
        if use_backends is not None:
            pulumi.set(__self__, "use_backends", use_backends)

    @property
    @pulumi.getter(name="httpRedirects")
    def http_redirects(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsHttpRedirect']]:
        """
        Redirects HTTP requests to specified location or URL scheme. Only either location or scheme can be defined at a time.
        """
        return pulumi.get(self, "http_redirects")

    @property
    @pulumi.getter(name="httpReturns")
    def http_returns(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsHttpReturn']]:
        """
        Returns HTTP response with specified HTTP status.
        """
        return pulumi.get(self, "http_returns")

    @property
    @pulumi.getter(name="setForwardedHeaders")
    def set_forwarded_headers(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsSetForwardedHeader']]:
        """
        Adds 'X-Forwarded-For / -Proto / -Port' headers in your forwarded requests
        """
        return pulumi.get(self, "set_forwarded_headers")

    @property
    @pulumi.getter(name="tcpRejects")
    def tcp_rejects(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsTcpReject']]:
        """
        Terminates a connection.
        """
        return pulumi.get(self, "tcp_rejects")

    @property
    @pulumi.getter(name="useBackends")
    def use_backends(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleActionsUseBackend']]:
        """
        Routes traffic to specified `backend`.
        """
        return pulumi.get(self, "use_backends")


@pulumi.output_type
class LoadbalancerFrontendRuleActionsHttpRedirect(dict):
    def __init__(__self__, *,
                 location: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str location: Target location.
        :param str scheme: Target scheme.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Target location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Target scheme.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class LoadbalancerFrontendRuleActionsHttpReturn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleActionsHttpReturn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleActionsHttpReturn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleActionsHttpReturn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: str,
                 payload: str,
                 status: int):
        """
        :param str content_type: Content type.
        :param str payload: The payload.
        :param int status: HTTP status code.
        """
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        Content type.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        The payload.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def status(self) -> int:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LoadbalancerFrontendRuleActionsSetForwardedHeader(dict):
    def __init__(__self__, *,
                 active: Optional[bool] = None):
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        return pulumi.get(self, "active")


@pulumi.output_type
class LoadbalancerFrontendRuleActionsTcpReject(dict):
    def __init__(__self__, *,
                 active: Optional[bool] = None):
        """
        :param bool active: Indicates if the rule is active.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        Indicates if the rule is active.
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class LoadbalancerFrontendRuleActionsUseBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendName":
            suggest = "backend_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleActionsUseBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleActionsUseBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleActionsUseBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_name: str):
        """
        :param str backend_name: The name of the backend where traffic will be routed.
        """
        pulumi.set(__self__, "backend_name", backend_name)

    @property
    @pulumi.getter(name="backendName")
    def backend_name(self) -> str:
        """
        The name of the backend where traffic will be routed.
        """
        return pulumi.get(self, "backend_name")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodySizeRanges":
            suggest = "body_size_ranges"
        elif key == "bodySizes":
            suggest = "body_sizes"
        elif key == "httpMethods":
            suggest = "http_methods"
        elif key == "numMembersUps":
            suggest = "num_members_ups"
        elif key == "srcIps":
            suggest = "src_ips"
        elif key == "srcPortRanges":
            suggest = "src_port_ranges"
        elif key == "srcPorts":
            suggest = "src_ports"
        elif key == "urlParams":
            suggest = "url_params"
        elif key == "urlQueries":
            suggest = "url_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_size_ranges: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersBodySizeRange']] = None,
                 body_sizes: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersBodySize']] = None,
                 cookies: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersCookie']] = None,
                 headers: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersHeader']] = None,
                 hosts: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersHost']] = None,
                 http_methods: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersHttpMethod']] = None,
                 num_members_ups: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersNumMembersUp']] = None,
                 paths: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersPath']] = None,
                 src_ips: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersSrcIp']] = None,
                 src_port_ranges: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersSrcPortRange']] = None,
                 src_ports: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersSrcPort']] = None,
                 url_params: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersUrlParam']] = None,
                 url_queries: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersUrlQuery']] = None,
                 urls: Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersUrl']] = None):
        """
        :param Sequence['LoadbalancerFrontendRuleMatchersBodySizeRangeArgs'] body_size_ranges: Matches by range of HTTP request body sizes.
        :param Sequence['LoadbalancerFrontendRuleMatchersBodySizeArgs'] body_sizes: Matches by HTTP request body size.
        :param Sequence['LoadbalancerFrontendRuleMatchersCookieArgs'] cookies: Matches by HTTP cookie value. Cookie name must be provided.
        :param Sequence['LoadbalancerFrontendRuleMatchersHeaderArgs'] headers: Matches by HTTP header value. Header name must be provided.
        :param Sequence['LoadbalancerFrontendRuleMatchersHostArgs'] hosts: Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.
        :param Sequence['LoadbalancerFrontendRuleMatchersHttpMethodArgs'] http_methods: Matches by HTTP method.
        :param Sequence['LoadbalancerFrontendRuleMatchersNumMembersUpArgs'] num_members_ups: Matches by number of healthy backend members.
        :param Sequence['LoadbalancerFrontendRuleMatchersPathArgs'] paths: Matches by URL path.
        :param Sequence['LoadbalancerFrontendRuleMatchersSrcIpArgs'] src_ips: Matches by source IP address.
        :param Sequence['LoadbalancerFrontendRuleMatchersSrcPortRangeArgs'] src_port_ranges: Matches by range of source port numbers.
        :param Sequence['LoadbalancerFrontendRuleMatchersSrcPortArgs'] src_ports: Matches by source port number.
        :param Sequence['LoadbalancerFrontendRuleMatchersUrlParamArgs'] url_params: Matches by URL query parameter value. Query parameter name must be provided
        :param Sequence['LoadbalancerFrontendRuleMatchersUrlQueryArgs'] url_queries: Matches by URL query string.
        :param Sequence['LoadbalancerFrontendRuleMatchersUrlArgs'] urls: Matches by URL without schema, e.g. `example.com/dashboard`.
        """
        if body_size_ranges is not None:
            pulumi.set(__self__, "body_size_ranges", body_size_ranges)
        if body_sizes is not None:
            pulumi.set(__self__, "body_sizes", body_sizes)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if num_members_ups is not None:
            pulumi.set(__self__, "num_members_ups", num_members_ups)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if src_ips is not None:
            pulumi.set(__self__, "src_ips", src_ips)
        if src_port_ranges is not None:
            pulumi.set(__self__, "src_port_ranges", src_port_ranges)
        if src_ports is not None:
            pulumi.set(__self__, "src_ports", src_ports)
        if url_params is not None:
            pulumi.set(__self__, "url_params", url_params)
        if url_queries is not None:
            pulumi.set(__self__, "url_queries", url_queries)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="bodySizeRanges")
    def body_size_ranges(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersBodySizeRange']]:
        """
        Matches by range of HTTP request body sizes.
        """
        return pulumi.get(self, "body_size_ranges")

    @property
    @pulumi.getter(name="bodySizes")
    def body_sizes(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersBodySize']]:
        """
        Matches by HTTP request body size.
        """
        return pulumi.get(self, "body_sizes")

    @property
    @pulumi.getter
    def cookies(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersCookie']]:
        """
        Matches by HTTP cookie value. Cookie name must be provided.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersHeader']]:
        """
        Matches by HTTP header value. Header name must be provided.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersHost']]:
        """
        Matches by hostname. Header extracted from HTTP Headers or from TLS certificate in case of secured connection.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersHttpMethod']]:
        """
        Matches by HTTP method.
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter(name="numMembersUps")
    def num_members_ups(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersNumMembersUp']]:
        """
        Matches by number of healthy backend members.
        """
        return pulumi.get(self, "num_members_ups")

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersPath']]:
        """
        Matches by URL path.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="srcIps")
    def src_ips(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersSrcIp']]:
        """
        Matches by source IP address.
        """
        return pulumi.get(self, "src_ips")

    @property
    @pulumi.getter(name="srcPortRanges")
    def src_port_ranges(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersSrcPortRange']]:
        """
        Matches by range of source port numbers.
        """
        return pulumi.get(self, "src_port_ranges")

    @property
    @pulumi.getter(name="srcPorts")
    def src_ports(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersSrcPort']]:
        """
        Matches by source port number.
        """
        return pulumi.get(self, "src_ports")

    @property
    @pulumi.getter(name="urlParams")
    def url_params(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersUrlParam']]:
        """
        Matches by URL query parameter value. Query parameter name must be provided
        """
        return pulumi.get(self, "url_params")

    @property
    @pulumi.getter(name="urlQueries")
    def url_queries(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersUrlQuery']]:
        """
        Matches by URL query string.
        """
        return pulumi.get(self, "url_queries")

    @property
    @pulumi.getter
    def urls(self) -> Optional[Sequence['outputs.LoadbalancerFrontendRuleMatchersUrl']]:
        """
        Matches by URL without schema, e.g. `example.com/dashboard`.
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersBodySize(dict):
    def __init__(__self__, *,
                 method: str,
                 value: int,
                 inverse: Optional[bool] = None):
        """
        :param str method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param int value: Integer value.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersBodySizeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeEnd":
            suggest = "range_end"
        elif key == "rangeStart":
            suggest = "range_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersBodySizeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersBodySizeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersBodySizeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_end: int,
                 range_start: int,
                 inverse: Optional[bool] = None):
        """
        :param int range_end: Integer value.
        :param int range_start: Integer value.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> int:
        """
        Integer value.
        """
        return pulumi.get(self, "range_end")

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> int:
        """
        Integer value.
        """
        return pulumi.get(self, "range_start")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreCase":
            suggest = "ignore_case"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 name: str,
                 ignore_case: Optional[bool] = None,
                 inverse: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param str method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param str name: Name of the argument.
        :param bool ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param str value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreCase":
            suggest = "ignore_case"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 name: str,
                 ignore_case: Optional[bool] = None,
                 inverse: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param str method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param str name: Name of the argument.
        :param bool ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param str value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersHost(dict):
    def __init__(__self__, *,
                 value: str,
                 inverse: Optional[bool] = None):
        """
        :param str value: String value.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        String value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersHttpMethod(dict):
    def __init__(__self__, *,
                 value: str,
                 inverse: Optional[bool] = None):
        """
        :param str value: String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        String value (`GET`, `HEAD`, `POST`, `PUT`, `PATCH`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`).
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersNumMembersUp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendName":
            suggest = "backend_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersNumMembersUp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersNumMembersUp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersNumMembersUp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_name: str,
                 method: str,
                 value: int,
                 inverse: Optional[bool] = None):
        """
        :param str backend_name: The name of the `backend`.
        :param str method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param int value: Integer value.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "backend_name", backend_name)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="backendName")
    def backend_name(self) -> str:
        """
        The name of the `backend`.
        """
        return pulumi.get(self, "backend_name")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreCase":
            suggest = "ignore_case"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 ignore_case: Optional[bool] = None,
                 inverse: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param str method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param bool ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param str value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersSrcIp(dict):
    def __init__(__self__, *,
                 value: str,
                 inverse: Optional[bool] = None):
        """
        :param str value: IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        IP address. CIDR masks are supported, e.g. `192.168.0.0/24`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersSrcPort(dict):
    def __init__(__self__, *,
                 method: str,
                 value: int,
                 inverse: Optional[bool] = None):
        """
        :param str method: Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        :param int value: Integer value.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "value", value)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`equal`, `greater`, `greater_or_equal`, `less`, `less_or_equal`).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Integer value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersSrcPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeEnd":
            suggest = "range_end"
        elif key == "rangeStart":
            suggest = "range_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersSrcPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersSrcPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersSrcPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_end: int,
                 range_start: int,
                 inverse: Optional[bool] = None):
        """
        :param int range_end: Integer value.
        :param int range_start: Integer value.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        pulumi.set(__self__, "range_end", range_end)
        pulumi.set(__self__, "range_start", range_start)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)

    @property
    @pulumi.getter(name="rangeEnd")
    def range_end(self) -> int:
        """
        Integer value.
        """
        return pulumi.get(self, "range_end")

    @property
    @pulumi.getter(name="rangeStart")
    def range_start(self) -> int:
        """
        Integer value.
        """
        return pulumi.get(self, "range_start")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreCase":
            suggest = "ignore_case"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 ignore_case: Optional[bool] = None,
                 inverse: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param str method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param bool ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param str value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersUrlParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreCase":
            suggest = "ignore_case"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersUrlParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersUrlParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersUrlParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 name: str,
                 ignore_case: Optional[bool] = None,
                 inverse: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param str method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param str name: Name of the argument.
        :param bool ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param str value: String value.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the argument.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadbalancerFrontendRuleMatchersUrlQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreCase":
            suggest = "ignore_case"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerFrontendRuleMatchersUrlQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerFrontendRuleMatchersUrlQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerFrontendRuleMatchersUrlQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 ignore_case: Optional[bool] = None,
                 inverse: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param str method: Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        :param bool ignore_case: Defines if case should be ignored. Defaults to `false`.
        :param bool inverse: Defines if the condition should be inverted. Works similarly to logical NOT operator.
        :param str value: String value.
        """
        pulumi.set(__self__, "method", method)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if inverse is not None:
            pulumi.set(__self__, "inverse", inverse)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        Match method (`exact`, `substring`, `regexp`, `starts`, `ends`, `domain`, `ip`, `exists`). Matcher with `exists` and `ip` methods must be used without `value` and `ignore_case` fields.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[bool]:
        """
        Defines if case should be ignored. Defaults to `false`.
        """
        return pulumi.get(self, "ignore_case")

    @property
    @pulumi.getter
    def inverse(self) -> Optional[bool]:
        """
        Defines if the condition should be inverted. Works similarly to logical NOT operator.
        """
        return pulumi.get(self, "inverse")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadbalancerNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 family: str,
                 name: str,
                 type: str,
                 dns_name: Optional[str] = None,
                 id: Optional[str] = None,
                 network: Optional[str] = None):
        """
        :param str family: Network family. Currently only `IPv4` is supported.
        :param str name: The name of the network must be unique within the service.
        :param str type: The type of the network. Only one public network can be attached and at least one private network must be attached.
        :param str dns_name: DNS name of the load balancer network
        :param str id: Network identifier.
        :param str network: Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the network must be unique within the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the network. Only one public network can be attached and at least one private network must be attached.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        DNS name of the load balancer network
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Network identifier.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        Private network UUID. Required for private networks and must reside in loadbalancer zone. For public network the field should be omitted.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class LoadbalancerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationalState":
            suggest = "operational_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 networks: Optional[Sequence['outputs.LoadbalancerNodeNetwork']] = None,
                 operational_state: Optional[str] = None):
        """
        :param str operational_state: Node's operational state. Managed by the system.
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.LoadbalancerNodeNetwork']]:
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[str]:
        """
        Node's operational state. Managed by the system.
        """
        return pulumi.get(self, "operational_state")


@pulumi.output_type
class LoadbalancerNodeNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadbalancerNodeNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadbalancerNodeNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadbalancerNodeNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addresses: Optional[Sequence['outputs.LoadbalancerNodeNetworkIpAddress']] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the network.
        :param str type: The type of the network.
        """
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence['outputs.LoadbalancerNodeNetworkIpAddress']]:
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the network.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the network.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LoadbalancerNodeNetworkIpAddress(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 listen: Optional[bool] = None):
        """
        :param str address: Node's IP address.
        :param bool listen: Does IP address listen network connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if listen is not None:
            pulumi.set(__self__, "listen", listen)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Node's IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def listen(self) -> Optional[bool]:
        """
        Does IP address listen network connections.
        """
        return pulumi.get(self, "listen")


@pulumi.output_type
class ManagedDatabaseMysqlComponent(dict):
    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 usage: Optional[str] = None):
        """
        :param str component: Type of the component
        :param str host: Hostname of the component
        :param int port: Port number of the component
        :param str route: Component network route type
        :param str usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class ManagedDatabaseMysqlNetwork(dict):
    def __init__(__self__, *,
                 family: str,
                 name: str,
                 type: str,
                 uuid: str):
        """
        :param str family: Network family. Currently only `IPv4` is supported.
        :param str name: The name of the network. Must be unique within the service.
        :param str type: The type of the network. Must be private.
        :param str uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ManagedDatabaseMysqlNodeState(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 role: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str name: Name plus a node iteration
        :param str role: Role of the node
        :param str state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of the node
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ManagedDatabaseMysqlProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "automaticUtilityNetworkIpFilter":
            suggest = "automatic_utility_network_ip_filter"
        elif key == "backupHour":
            suggest = "backup_hour"
        elif key == "backupMinute":
            suggest = "backup_minute"
        elif key == "binlogRetentionPeriod":
            suggest = "binlog_retention_period"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "defaultTimeZone":
            suggest = "default_time_zone"
        elif key == "groupConcatMaxLen":
            suggest = "group_concat_max_len"
        elif key == "informationSchemaStatsExpiry":
            suggest = "information_schema_stats_expiry"
        elif key == "innodbChangeBufferMaxSize":
            suggest = "innodb_change_buffer_max_size"
        elif key == "innodbFlushNeighbors":
            suggest = "innodb_flush_neighbors"
        elif key == "innodbFtMinTokenSize":
            suggest = "innodb_ft_min_token_size"
        elif key == "innodbFtServerStopwordTable":
            suggest = "innodb_ft_server_stopword_table"
        elif key == "innodbLockWaitTimeout":
            suggest = "innodb_lock_wait_timeout"
        elif key == "innodbLogBufferSize":
            suggest = "innodb_log_buffer_size"
        elif key == "innodbOnlineAlterLogMaxSize":
            suggest = "innodb_online_alter_log_max_size"
        elif key == "innodbPrintAllDeadlocks":
            suggest = "innodb_print_all_deadlocks"
        elif key == "innodbReadIoThreads":
            suggest = "innodb_read_io_threads"
        elif key == "innodbRollbackOnTimeout":
            suggest = "innodb_rollback_on_timeout"
        elif key == "innodbThreadConcurrency":
            suggest = "innodb_thread_concurrency"
        elif key == "innodbWriteIoThreads":
            suggest = "innodb_write_io_threads"
        elif key == "interactiveTimeout":
            suggest = "interactive_timeout"
        elif key == "internalTmpMemStorageEngine":
            suggest = "internal_tmp_mem_storage_engine"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "longQueryTime":
            suggest = "long_query_time"
        elif key == "maxAllowedPacket":
            suggest = "max_allowed_packet"
        elif key == "maxHeapTableSize":
            suggest = "max_heap_table_size"
        elif key == "netBufferLength":
            suggest = "net_buffer_length"
        elif key == "netReadTimeout":
            suggest = "net_read_timeout"
        elif key == "netWriteTimeout":
            suggest = "net_write_timeout"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "serviceLog":
            suggest = "service_log"
        elif key == "slowQueryLog":
            suggest = "slow_query_log"
        elif key == "sortBufferSize":
            suggest = "sort_buffer_size"
        elif key == "sqlMode":
            suggest = "sql_mode"
        elif key == "sqlRequirePrimaryKey":
            suggest = "sql_require_primary_key"
        elif key == "tmpTableSize":
            suggest = "tmp_table_size"
        elif key == "waitTimeout":
            suggest = "wait_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseMysqlProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseMysqlProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseMysqlProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 automatic_utility_network_ip_filter: Optional[bool] = None,
                 backup_hour: Optional[int] = None,
                 backup_minute: Optional[int] = None,
                 binlog_retention_period: Optional[int] = None,
                 connect_timeout: Optional[int] = None,
                 default_time_zone: Optional[str] = None,
                 group_concat_max_len: Optional[int] = None,
                 information_schema_stats_expiry: Optional[int] = None,
                 innodb_change_buffer_max_size: Optional[int] = None,
                 innodb_flush_neighbors: Optional[int] = None,
                 innodb_ft_min_token_size: Optional[int] = None,
                 innodb_ft_server_stopword_table: Optional[str] = None,
                 innodb_lock_wait_timeout: Optional[int] = None,
                 innodb_log_buffer_size: Optional[int] = None,
                 innodb_online_alter_log_max_size: Optional[int] = None,
                 innodb_print_all_deadlocks: Optional[bool] = None,
                 innodb_read_io_threads: Optional[int] = None,
                 innodb_rollback_on_timeout: Optional[bool] = None,
                 innodb_thread_concurrency: Optional[int] = None,
                 innodb_write_io_threads: Optional[int] = None,
                 interactive_timeout: Optional[int] = None,
                 internal_tmp_mem_storage_engine: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 long_query_time: Optional[float] = None,
                 max_allowed_packet: Optional[int] = None,
                 max_heap_table_size: Optional[int] = None,
                 migration: Optional['outputs.ManagedDatabaseMysqlPropertiesMigration'] = None,
                 net_buffer_length: Optional[int] = None,
                 net_read_timeout: Optional[int] = None,
                 net_write_timeout: Optional[int] = None,
                 public_access: Optional[bool] = None,
                 service_log: Optional[bool] = None,
                 slow_query_log: Optional[bool] = None,
                 sort_buffer_size: Optional[int] = None,
                 sql_mode: Optional[str] = None,
                 sql_require_primary_key: Optional[bool] = None,
                 tmp_table_size: Optional[int] = None,
                 version: Optional[str] = None,
                 wait_timeout: Optional[int] = None):
        """
        :param str admin_password: Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        :param str admin_username: Custom username for admin user. This must be set only when a new service is being created.
        :param bool automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param int backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param int backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param int binlog_retention_period: The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        :param int connect_timeout: The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
        :param str default_time_zone: Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
        :param int group_concat_max_len: The maximum permitted result length in bytes for the GROUP_CONCAT() function.
        :param int information_schema_stats_expiry: The time, in seconds, before cached statistics expire.
        :param int innodb_change_buffer_max_size: Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
        :param int innodb_flush_neighbors: Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
        :param int innodb_ft_min_token_size: Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
        :param str innodb_ft_server_stopword_table: This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
        :param int innodb_lock_wait_timeout: The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
        :param int innodb_log_buffer_size: The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
        :param int innodb_online_alter_log_max_size: The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
        :param bool innodb_print_all_deadlocks: When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
        :param int innodb_read_io_threads: The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        :param bool innodb_rollback_on_timeout: When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
        :param int innodb_thread_concurrency: Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
        :param int innodb_write_io_threads: The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        :param int interactive_timeout: The number of seconds the server waits for activity on an interactive connection before closing it.
        :param str internal_tmp_mem_storage_engine: The storage engine for in-memory internal temporary tables.
        :param Sequence[str] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param float long_query_time: The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute. Default is 10s.
        :param int max_allowed_packet: Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
        :param int max_heap_table_size: Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
        :param 'ManagedDatabaseMysqlPropertiesMigrationArgs' migration: Migrate data from existing server.
        :param int net_buffer_length: Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
        :param int net_read_timeout: The number of seconds to wait for more data from a connection before aborting the read.
        :param int net_write_timeout: The number of seconds to wait for a block to be written to a connection before aborting the write.
        :param bool public_access: Public Access. Allow access to the service from the public Internet.
        :param bool service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param bool slow_query_log: Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table. Default is off.
        :param int sort_buffer_size: Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
        :param str sql_mode: Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
        :param bool sql_require_primary_key: Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        :param int tmp_table_size: Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        :param str version: MySQL major version.
        :param int wait_timeout: The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if binlog_retention_period is not None:
            pulumi.set(__self__, "binlog_retention_period", binlog_retention_period)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if default_time_zone is not None:
            pulumi.set(__self__, "default_time_zone", default_time_zone)
        if group_concat_max_len is not None:
            pulumi.set(__self__, "group_concat_max_len", group_concat_max_len)
        if information_schema_stats_expiry is not None:
            pulumi.set(__self__, "information_schema_stats_expiry", information_schema_stats_expiry)
        if innodb_change_buffer_max_size is not None:
            pulumi.set(__self__, "innodb_change_buffer_max_size", innodb_change_buffer_max_size)
        if innodb_flush_neighbors is not None:
            pulumi.set(__self__, "innodb_flush_neighbors", innodb_flush_neighbors)
        if innodb_ft_min_token_size is not None:
            pulumi.set(__self__, "innodb_ft_min_token_size", innodb_ft_min_token_size)
        if innodb_ft_server_stopword_table is not None:
            pulumi.set(__self__, "innodb_ft_server_stopword_table", innodb_ft_server_stopword_table)
        if innodb_lock_wait_timeout is not None:
            pulumi.set(__self__, "innodb_lock_wait_timeout", innodb_lock_wait_timeout)
        if innodb_log_buffer_size is not None:
            pulumi.set(__self__, "innodb_log_buffer_size", innodb_log_buffer_size)
        if innodb_online_alter_log_max_size is not None:
            pulumi.set(__self__, "innodb_online_alter_log_max_size", innodb_online_alter_log_max_size)
        if innodb_print_all_deadlocks is not None:
            pulumi.set(__self__, "innodb_print_all_deadlocks", innodb_print_all_deadlocks)
        if innodb_read_io_threads is not None:
            pulumi.set(__self__, "innodb_read_io_threads", innodb_read_io_threads)
        if innodb_rollback_on_timeout is not None:
            pulumi.set(__self__, "innodb_rollback_on_timeout", innodb_rollback_on_timeout)
        if innodb_thread_concurrency is not None:
            pulumi.set(__self__, "innodb_thread_concurrency", innodb_thread_concurrency)
        if innodb_write_io_threads is not None:
            pulumi.set(__self__, "innodb_write_io_threads", innodb_write_io_threads)
        if interactive_timeout is not None:
            pulumi.set(__self__, "interactive_timeout", interactive_timeout)
        if internal_tmp_mem_storage_engine is not None:
            pulumi.set(__self__, "internal_tmp_mem_storage_engine", internal_tmp_mem_storage_engine)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if long_query_time is not None:
            pulumi.set(__self__, "long_query_time", long_query_time)
        if max_allowed_packet is not None:
            pulumi.set(__self__, "max_allowed_packet", max_allowed_packet)
        if max_heap_table_size is not None:
            pulumi.set(__self__, "max_heap_table_size", max_heap_table_size)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if net_buffer_length is not None:
            pulumi.set(__self__, "net_buffer_length", net_buffer_length)
        if net_read_timeout is not None:
            pulumi.set(__self__, "net_read_timeout", net_read_timeout)
        if net_write_timeout is not None:
            pulumi.set(__self__, "net_write_timeout", net_write_timeout)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if slow_query_log is not None:
            pulumi.set(__self__, "slow_query_log", slow_query_log)
        if sort_buffer_size is not None:
            pulumi.set(__self__, "sort_buffer_size", sort_buffer_size)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if sql_require_primary_key is not None:
            pulumi.set(__self__, "sql_require_primary_key", sql_require_primary_key)
        if tmp_table_size is not None:
            pulumi.set(__self__, "tmp_table_size", tmp_table_size)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if wait_timeout is not None:
            pulumi.set(__self__, "wait_timeout", wait_timeout)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[bool]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[int]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[int]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="binlogRetentionPeriod")
    def binlog_retention_period(self) -> Optional[int]:
        """
        The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
        """
        return pulumi.get(self, "binlog_retention_period")

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[int]:
        """
        The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="defaultTimeZone")
    def default_time_zone(self) -> Optional[str]:
        """
        Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or 'SYSTEM' to use the MySQL server default.
        """
        return pulumi.get(self, "default_time_zone")

    @property
    @pulumi.getter(name="groupConcatMaxLen")
    def group_concat_max_len(self) -> Optional[int]:
        """
        The maximum permitted result length in bytes for the GROUP_CONCAT() function.
        """
        return pulumi.get(self, "group_concat_max_len")

    @property
    @pulumi.getter(name="informationSchemaStatsExpiry")
    def information_schema_stats_expiry(self) -> Optional[int]:
        """
        The time, in seconds, before cached statistics expire.
        """
        return pulumi.get(self, "information_schema_stats_expiry")

    @property
    @pulumi.getter(name="innodbChangeBufferMaxSize")
    def innodb_change_buffer_max_size(self) -> Optional[int]:
        """
        Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25.
        """
        return pulumi.get(self, "innodb_change_buffer_max_size")

    @property
    @pulumi.getter(name="innodbFlushNeighbors")
    def innodb_flush_neighbors(self) -> Optional[int]:
        """
        Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed, 1 - flush contiguous dirty pages in the same extent, 2 - flush dirty pages in the same extent.
        """
        return pulumi.get(self, "innodb_flush_neighbors")

    @property
    @pulumi.getter(name="innodbFtMinTokenSize")
    def innodb_ft_min_token_size(self) -> Optional[int]:
        """
        Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_ft_min_token_size")

    @property
    @pulumi.getter(name="innodbFtServerStopwordTable")
    def innodb_ft_server_stopword_table(self) -> Optional[str]:
        """
        This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
        """
        return pulumi.get(self, "innodb_ft_server_stopword_table")

    @property
    @pulumi.getter(name="innodbLockWaitTimeout")
    def innodb_lock_wait_timeout(self) -> Optional[int]:
        """
        The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
        """
        return pulumi.get(self, "innodb_lock_wait_timeout")

    @property
    @pulumi.getter(name="innodbLogBufferSize")
    def innodb_log_buffer_size(self) -> Optional[int]:
        """
        The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
        """
        return pulumi.get(self, "innodb_log_buffer_size")

    @property
    @pulumi.getter(name="innodbOnlineAlterLogMaxSize")
    def innodb_online_alter_log_max_size(self) -> Optional[int]:
        """
        The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
        """
        return pulumi.get(self, "innodb_online_alter_log_max_size")

    @property
    @pulumi.getter(name="innodbPrintAllDeadlocks")
    def innodb_print_all_deadlocks(self) -> Optional[bool]:
        """
        When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
        """
        return pulumi.get(self, "innodb_print_all_deadlocks")

    @property
    @pulumi.getter(name="innodbReadIoThreads")
    def innodb_read_io_threads(self) -> Optional[int]:
        """
        The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_read_io_threads")

    @property
    @pulumi.getter(name="innodbRollbackOnTimeout")
    def innodb_rollback_on_timeout(self) -> Optional[bool]:
        """
        When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_rollback_on_timeout")

    @property
    @pulumi.getter(name="innodbThreadConcurrency")
    def innodb_thread_concurrency(self) -> Optional[int]:
        """
        Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit).
        """
        return pulumi.get(self, "innodb_thread_concurrency")

    @property
    @pulumi.getter(name="innodbWriteIoThreads")
    def innodb_write_io_threads(self) -> Optional[int]:
        """
        The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "innodb_write_io_threads")

    @property
    @pulumi.getter(name="interactiveTimeout")
    def interactive_timeout(self) -> Optional[int]:
        """
        The number of seconds the server waits for activity on an interactive connection before closing it.
        """
        return pulumi.get(self, "interactive_timeout")

    @property
    @pulumi.getter(name="internalTmpMemStorageEngine")
    def internal_tmp_mem_storage_engine(self) -> Optional[str]:
        """
        The storage engine for in-memory internal temporary tables.
        """
        return pulumi.get(self, "internal_tmp_mem_storage_engine")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="longQueryTime")
    def long_query_time(self) -> Optional[float]:
        """
        The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute. Default is 10s.
        """
        return pulumi.get(self, "long_query_time")

    @property
    @pulumi.getter(name="maxAllowedPacket")
    def max_allowed_packet(self) -> Optional[int]:
        """
        Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M).
        """
        return pulumi.get(self, "max_allowed_packet")

    @property
    @pulumi.getter(name="maxHeapTableSize")
    def max_heap_table_size(self) -> Optional[int]:
        """
        Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M).
        """
        return pulumi.get(self, "max_heap_table_size")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.ManagedDatabaseMysqlPropertiesMigration']:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter(name="netBufferLength")
    def net_buffer_length(self) -> Optional[int]:
        """
        Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
        """
        return pulumi.get(self, "net_buffer_length")

    @property
    @pulumi.getter(name="netReadTimeout")
    def net_read_timeout(self) -> Optional[int]:
        """
        The number of seconds to wait for more data from a connection before aborting the read.
        """
        return pulumi.get(self, "net_read_timeout")

    @property
    @pulumi.getter(name="netWriteTimeout")
    def net_write_timeout(self) -> Optional[int]:
        """
        The number of seconds to wait for a block to be written to a connection before aborting the write.
        """
        return pulumi.get(self, "net_write_timeout")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[bool]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[bool]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @property
    @pulumi.getter(name="slowQueryLog")
    def slow_query_log(self) -> Optional[bool]:
        """
        Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table. Default is off.
        """
        return pulumi.get(self, "slow_query_log")

    @property
    @pulumi.getter(name="sortBufferSize")
    def sort_buffer_size(self) -> Optional[int]:
        """
        Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K).
        """
        return pulumi.get(self, "sort_buffer_size")

    @property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[str]:
        """
        Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
        """
        return pulumi.get(self, "sql_mode")

    @property
    @pulumi.getter(name="sqlRequirePrimaryKey")
    def sql_require_primary_key(self) -> Optional[bool]:
        """
        Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
        """
        return pulumi.get(self, "sql_require_primary_key")

    @property
    @pulumi.getter(name="tmpTableSize")
    def tmp_table_size(self) -> Optional[int]:
        """
        Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M).
        """
        return pulumi.get(self, "tmp_table_size")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        MySQL major version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="waitTimeout")
    def wait_timeout(self) -> Optional[int]:
        """
        The number of seconds the server waits for activity on a noninteractive connection before closing it.
        """
        return pulumi.get(self, "wait_timeout")


@pulumi.output_type
class ManagedDatabaseMysqlPropertiesMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"
        elif key == "ignoreRoles":
            suggest = "ignore_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseMysqlPropertiesMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseMysqlPropertiesMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseMysqlPropertiesMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 ignore_roles: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 ssl: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str dbname: Database name for bootstrapping the initial connection.
        :param str host: Hostname or IP address of the server where to migrate data from.
        :param str ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param str ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param str method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param str password: Password for authentication with the server where to migrate data from.
        :param int port: Port number of the server where to migrate data from.
        :param bool ssl: The server where to migrate data from is secured with SSL.
        :param str username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[str]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ManagedDatabaseOpensearchComponent(dict):
    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 usage: Optional[str] = None):
        """
        :param str component: Type of the component
        :param str host: Hostname of the component
        :param int port: Port number of the component
        :param str route: Component network route type
        :param str usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class ManagedDatabaseOpensearchNetwork(dict):
    def __init__(__self__, *,
                 family: str,
                 name: str,
                 type: str,
                 uuid: str):
        """
        :param str family: Network family. Currently only `IPv4` is supported.
        :param str name: The name of the network. Must be unique within the service.
        :param str type: The type of the network. Must be private.
        :param str uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ManagedDatabaseOpensearchNodeState(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 role: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str name: Name plus a node iteration
        :param str role: Role of the node
        :param str state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of the node
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ManagedDatabaseOpensearchProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionAutoCreateIndexEnabled":
            suggest = "action_auto_create_index_enabled"
        elif key == "actionDestructiveRequiresName":
            suggest = "action_destructive_requires_name"
        elif key == "authFailureListeners":
            suggest = "auth_failure_listeners"
        elif key == "automaticUtilityNetworkIpFilter":
            suggest = "automatic_utility_network_ip_filter"
        elif key == "azureMigration":
            suggest = "azure_migration"
        elif key == "clusterMaxShardsPerNode":
            suggest = "cluster_max_shards_per_node"
        elif key == "clusterRoutingAllocationNodeConcurrentRecoveries":
            suggest = "cluster_routing_allocation_node_concurrent_recoveries"
        elif key == "customDomain":
            suggest = "custom_domain"
        elif key == "emailSenderName":
            suggest = "email_sender_name"
        elif key == "emailSenderPassword":
            suggest = "email_sender_password"
        elif key == "emailSenderUsername":
            suggest = "email_sender_username"
        elif key == "enableSecurityAudit":
            suggest = "enable_security_audit"
        elif key == "gcsMigration":
            suggest = "gcs_migration"
        elif key == "httpMaxContentLength":
            suggest = "http_max_content_length"
        elif key == "httpMaxHeaderSize":
            suggest = "http_max_header_size"
        elif key == "httpMaxInitialLineLength":
            suggest = "http_max_initial_line_length"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexRollup":
            suggest = "index_rollup"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "indicesFielddataCacheSize":
            suggest = "indices_fielddata_cache_size"
        elif key == "indicesMemoryIndexBufferSize":
            suggest = "indices_memory_index_buffer_size"
        elif key == "indicesMemoryMaxIndexBufferSize":
            suggest = "indices_memory_max_index_buffer_size"
        elif key == "indicesMemoryMinIndexBufferSize":
            suggest = "indices_memory_min_index_buffer_size"
        elif key == "indicesQueriesCacheSize":
            suggest = "indices_queries_cache_size"
        elif key == "indicesQueryBoolMaxClauseCount":
            suggest = "indices_query_bool_max_clause_count"
        elif key == "indicesRecoveryMaxBytesPerSec":
            suggest = "indices_recovery_max_bytes_per_sec"
        elif key == "indicesRecoveryMaxConcurrentFileChunks":
            suggest = "indices_recovery_max_concurrent_file_chunks"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "ismEnabled":
            suggest = "ism_enabled"
        elif key == "ismHistoryEnabled":
            suggest = "ism_history_enabled"
        elif key == "ismHistoryMaxAge":
            suggest = "ism_history_max_age"
        elif key == "ismHistoryMaxDocs":
            suggest = "ism_history_max_docs"
        elif key == "ismHistoryRolloverCheckPeriod":
            suggest = "ism_history_rollover_check_period"
        elif key == "ismHistoryRolloverRetentionPeriod":
            suggest = "ism_history_rollover_retention_period"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "knnMemoryCircuitBreakerEnabled":
            suggest = "knn_memory_circuit_breaker_enabled"
        elif key == "knnMemoryCircuitBreakerLimit":
            suggest = "knn_memory_circuit_breaker_limit"
        elif key == "opensearchDashboards":
            suggest = "opensearch_dashboards"
        elif key == "overrideMainResponseVersion":
            suggest = "override_main_response_version"
        elif key == "pluginsAlertingFilterByBackendRoles":
            suggest = "plugins_alerting_filter_by_backend_roles"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "reindexRemoteWhitelists":
            suggest = "reindex_remote_whitelists"
        elif key == "s3Migration":
            suggest = "s3_migration"
        elif key == "scriptMaxCompilationsRate":
            suggest = "script_max_compilations_rate"
        elif key == "searchMaxBuckets":
            suggest = "search_max_buckets"
        elif key == "serviceLog":
            suggest = "service_log"
        elif key == "threadPoolAnalyzeQueueSize":
            suggest = "thread_pool_analyze_queue_size"
        elif key == "threadPoolAnalyzeSize":
            suggest = "thread_pool_analyze_size"
        elif key == "threadPoolForceMergeSize":
            suggest = "thread_pool_force_merge_size"
        elif key == "threadPoolGetQueueSize":
            suggest = "thread_pool_get_queue_size"
        elif key == "threadPoolGetSize":
            suggest = "thread_pool_get_size"
        elif key == "threadPoolSearchQueueSize":
            suggest = "thread_pool_search_queue_size"
        elif key == "threadPoolSearchSize":
            suggest = "thread_pool_search_size"
        elif key == "threadPoolSearchThrottledQueueSize":
            suggest = "thread_pool_search_throttled_queue_size"
        elif key == "threadPoolSearchThrottledSize":
            suggest = "thread_pool_search_throttled_size"
        elif key == "threadPoolWriteQueueSize":
            suggest = "thread_pool_write_queue_size"
        elif key == "threadPoolWriteSize":
            suggest = "thread_pool_write_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_auto_create_index_enabled: Optional[bool] = None,
                 action_destructive_requires_name: Optional[bool] = None,
                 auth_failure_listeners: Optional['outputs.ManagedDatabaseOpensearchPropertiesAuthFailureListeners'] = None,
                 automatic_utility_network_ip_filter: Optional[bool] = None,
                 azure_migration: Optional['outputs.ManagedDatabaseOpensearchPropertiesAzureMigration'] = None,
                 cluster_max_shards_per_node: Optional[int] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[int] = None,
                 custom_domain: Optional[str] = None,
                 email_sender_name: Optional[str] = None,
                 email_sender_password: Optional[str] = None,
                 email_sender_username: Optional[str] = None,
                 enable_security_audit: Optional[bool] = None,
                 gcs_migration: Optional['outputs.ManagedDatabaseOpensearchPropertiesGcsMigration'] = None,
                 http_max_content_length: Optional[int] = None,
                 http_max_header_size: Optional[int] = None,
                 http_max_initial_line_length: Optional[int] = None,
                 index_patterns: Optional[Sequence[str]] = None,
                 index_rollup: Optional['outputs.ManagedDatabaseOpensearchPropertiesIndexRollup'] = None,
                 index_template: Optional['outputs.ManagedDatabaseOpensearchPropertiesIndexTemplate'] = None,
                 indices_fielddata_cache_size: Optional[int] = None,
                 indices_memory_index_buffer_size: Optional[int] = None,
                 indices_memory_max_index_buffer_size: Optional[int] = None,
                 indices_memory_min_index_buffer_size: Optional[int] = None,
                 indices_queries_cache_size: Optional[int] = None,
                 indices_query_bool_max_clause_count: Optional[int] = None,
                 indices_recovery_max_bytes_per_sec: Optional[int] = None,
                 indices_recovery_max_concurrent_file_chunks: Optional[int] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 ism_enabled: Optional[bool] = None,
                 ism_history_enabled: Optional[bool] = None,
                 ism_history_max_age: Optional[int] = None,
                 ism_history_max_docs: Optional[int] = None,
                 ism_history_rollover_check_period: Optional[int] = None,
                 ism_history_rollover_retention_period: Optional[int] = None,
                 keep_index_refresh_interval: Optional[bool] = None,
                 knn_memory_circuit_breaker_enabled: Optional[bool] = None,
                 knn_memory_circuit_breaker_limit: Optional[int] = None,
                 openid: Optional['outputs.ManagedDatabaseOpensearchPropertiesOpenid'] = None,
                 opensearch_dashboards: Optional['outputs.ManagedDatabaseOpensearchPropertiesOpensearchDashboards'] = None,
                 override_main_response_version: Optional[bool] = None,
                 plugins_alerting_filter_by_backend_roles: Optional[bool] = None,
                 public_access: Optional[bool] = None,
                 reindex_remote_whitelists: Optional[Sequence[str]] = None,
                 s3_migration: Optional['outputs.ManagedDatabaseOpensearchPropertiesS3Migration'] = None,
                 saml: Optional['outputs.ManagedDatabaseOpensearchPropertiesSaml'] = None,
                 script_max_compilations_rate: Optional[str] = None,
                 search_max_buckets: Optional[int] = None,
                 service_log: Optional[bool] = None,
                 thread_pool_analyze_queue_size: Optional[int] = None,
                 thread_pool_analyze_size: Optional[int] = None,
                 thread_pool_force_merge_size: Optional[int] = None,
                 thread_pool_get_queue_size: Optional[int] = None,
                 thread_pool_get_size: Optional[int] = None,
                 thread_pool_search_queue_size: Optional[int] = None,
                 thread_pool_search_size: Optional[int] = None,
                 thread_pool_search_throttled_queue_size: Optional[int] = None,
                 thread_pool_search_throttled_size: Optional[int] = None,
                 thread_pool_write_queue_size: Optional[int] = None,
                 thread_pool_write_size: Optional[int] = None,
                 version: Optional[str] = None):
        """
        :param bool action_auto_create_index_enabled: action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.
        :param bool action_destructive_requires_name: Require explicit index names when deleting.
        :param 'ManagedDatabaseOpensearchPropertiesAuthFailureListenersArgs' auth_failure_listeners: Opensearch Security Plugin Settings.
        :param bool automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param int cluster_max_shards_per_node: Controls the number of shards allowed in the cluster per data node.
        :param int cluster_routing_allocation_node_concurrent_recoveries: Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
        :param str custom_domain: Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
        :param str email_sender_name: Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.
        :param str email_sender_password: Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.
        :param str email_sender_username: Sender username for Opensearch alerts.
        :param bool enable_security_audit: Enable/Disable security audit.
        :param int http_max_content_length: Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
        :param int http_max_header_size: The max size of allowed headers, in bytes.
        :param int http_max_initial_line_length: The max length of an HTTP URL, in bytes.
        :param Sequence[str] index_patterns: Index patterns.
        :param 'ManagedDatabaseOpensearchPropertiesIndexRollupArgs' index_rollup: Index rollup settings.
        :param 'ManagedDatabaseOpensearchPropertiesIndexTemplateArgs' index_template: Template settings for all new indexes.
        :param int indices_fielddata_cache_size: Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
        :param int indices_memory_index_buffer_size: Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
        :param int indices_memory_max_index_buffer_size: Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.
        :param int indices_memory_min_index_buffer_size: Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.
        :param int indices_queries_cache_size: Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
        :param int indices_query_bool_max_clause_count: Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
        :param int indices_recovery_max_bytes_per_sec: Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.
        :param int indices_recovery_max_concurrent_file_chunks: Number of file chunks sent in parallel for each recovery. Defaults to 2.
        :param Sequence[str] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param bool ism_enabled: Specifies whether ISM is enabled or not.
        :param bool ism_history_enabled: Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.
        :param int ism_history_max_age: The maximum age before rolling over the audit history index in hours.
        :param int ism_history_max_docs: The maximum number of documents before rolling over the audit history index.
        :param int ism_history_rollover_check_period: The time between rollover checks for the audit history index in hours.
        :param int ism_history_rollover_retention_period: How long audit history indices are kept in days.
        :param bool keep_index_refresh_interval: Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param bool knn_memory_circuit_breaker_enabled: Enable or disable KNN memory circuit breaker. Defaults to true.
        :param int knn_memory_circuit_breaker_limit: Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.
        :param 'ManagedDatabaseOpensearchPropertiesOpenidArgs' openid: OpenSearch OpenID Connect Configuration.
        :param 'ManagedDatabaseOpensearchPropertiesOpensearchDashboardsArgs' opensearch_dashboards: OpenSearch Dashboards settings.
        :param bool override_main_response_version: Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.
        :param bool plugins_alerting_filter_by_backend_roles: Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.
        :param bool public_access: Public Access. Allow access to the service from the public Internet.
        :param Sequence[str] reindex_remote_whitelists: Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
        :param 'ManagedDatabaseOpensearchPropertiesSamlArgs' saml: OpenSearch SAML configuration.
        :param str script_max_compilations_rate: Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.
        :param int search_max_buckets: Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
        :param bool service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param int thread_pool_analyze_queue_size: analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param int thread_pool_analyze_size: analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param int thread_pool_force_merge_size: force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param int thread_pool_get_queue_size: get thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param int thread_pool_get_size: get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param int thread_pool_search_queue_size: search thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param int thread_pool_search_size: search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param int thread_pool_search_throttled_queue_size: search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param int thread_pool_search_throttled_size: search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param int thread_pool_write_queue_size: write thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        :param int thread_pool_write_size: write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        :param str version: OpenSearch major version.
        """
        if action_auto_create_index_enabled is not None:
            pulumi.set(__self__, "action_auto_create_index_enabled", action_auto_create_index_enabled)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if auth_failure_listeners is not None:
            pulumi.set(__self__, "auth_failure_listeners", auth_failure_listeners)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if azure_migration is not None:
            pulumi.set(__self__, "azure_migration", azure_migration)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if email_sender_name is not None:
            pulumi.set(__self__, "email_sender_name", email_sender_name)
        if email_sender_password is not None:
            pulumi.set(__self__, "email_sender_password", email_sender_password)
        if email_sender_username is not None:
            pulumi.set(__self__, "email_sender_username", email_sender_username)
        if enable_security_audit is not None:
            pulumi.set(__self__, "enable_security_audit", enable_security_audit)
        if gcs_migration is not None:
            pulumi.set(__self__, "gcs_migration", gcs_migration)
        if http_max_content_length is not None:
            pulumi.set(__self__, "http_max_content_length", http_max_content_length)
        if http_max_header_size is not None:
            pulumi.set(__self__, "http_max_header_size", http_max_header_size)
        if http_max_initial_line_length is not None:
            pulumi.set(__self__, "http_max_initial_line_length", http_max_initial_line_length)
        if index_patterns is not None:
            pulumi.set(__self__, "index_patterns", index_patterns)
        if index_rollup is not None:
            pulumi.set(__self__, "index_rollup", index_rollup)
        if index_template is not None:
            pulumi.set(__self__, "index_template", index_template)
        if indices_fielddata_cache_size is not None:
            pulumi.set(__self__, "indices_fielddata_cache_size", indices_fielddata_cache_size)
        if indices_memory_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_index_buffer_size", indices_memory_index_buffer_size)
        if indices_memory_max_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_max_index_buffer_size", indices_memory_max_index_buffer_size)
        if indices_memory_min_index_buffer_size is not None:
            pulumi.set(__self__, "indices_memory_min_index_buffer_size", indices_memory_min_index_buffer_size)
        if indices_queries_cache_size is not None:
            pulumi.set(__self__, "indices_queries_cache_size", indices_queries_cache_size)
        if indices_query_bool_max_clause_count is not None:
            pulumi.set(__self__, "indices_query_bool_max_clause_count", indices_query_bool_max_clause_count)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if indices_recovery_max_concurrent_file_chunks is not None:
            pulumi.set(__self__, "indices_recovery_max_concurrent_file_chunks", indices_recovery_max_concurrent_file_chunks)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if ism_enabled is not None:
            pulumi.set(__self__, "ism_enabled", ism_enabled)
        if ism_history_enabled is not None:
            pulumi.set(__self__, "ism_history_enabled", ism_history_enabled)
        if ism_history_max_age is not None:
            pulumi.set(__self__, "ism_history_max_age", ism_history_max_age)
        if ism_history_max_docs is not None:
            pulumi.set(__self__, "ism_history_max_docs", ism_history_max_docs)
        if ism_history_rollover_check_period is not None:
            pulumi.set(__self__, "ism_history_rollover_check_period", ism_history_rollover_check_period)
        if ism_history_rollover_retention_period is not None:
            pulumi.set(__self__, "ism_history_rollover_retention_period", ism_history_rollover_retention_period)
        if keep_index_refresh_interval is not None:
            pulumi.set(__self__, "keep_index_refresh_interval", keep_index_refresh_interval)
        if knn_memory_circuit_breaker_enabled is not None:
            pulumi.set(__self__, "knn_memory_circuit_breaker_enabled", knn_memory_circuit_breaker_enabled)
        if knn_memory_circuit_breaker_limit is not None:
            pulumi.set(__self__, "knn_memory_circuit_breaker_limit", knn_memory_circuit_breaker_limit)
        if openid is not None:
            pulumi.set(__self__, "openid", openid)
        if opensearch_dashboards is not None:
            pulumi.set(__self__, "opensearch_dashboards", opensearch_dashboards)
        if override_main_response_version is not None:
            pulumi.set(__self__, "override_main_response_version", override_main_response_version)
        if plugins_alerting_filter_by_backend_roles is not None:
            pulumi.set(__self__, "plugins_alerting_filter_by_backend_roles", plugins_alerting_filter_by_backend_roles)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if reindex_remote_whitelists is not None:
            pulumi.set(__self__, "reindex_remote_whitelists", reindex_remote_whitelists)
        if s3_migration is not None:
            pulumi.set(__self__, "s3_migration", s3_migration)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_max_buckets is not None:
            pulumi.set(__self__, "search_max_buckets", search_max_buckets)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if thread_pool_analyze_queue_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_queue_size", thread_pool_analyze_queue_size)
        if thread_pool_analyze_size is not None:
            pulumi.set(__self__, "thread_pool_analyze_size", thread_pool_analyze_size)
        if thread_pool_force_merge_size is not None:
            pulumi.set(__self__, "thread_pool_force_merge_size", thread_pool_force_merge_size)
        if thread_pool_get_queue_size is not None:
            pulumi.set(__self__, "thread_pool_get_queue_size", thread_pool_get_queue_size)
        if thread_pool_get_size is not None:
            pulumi.set(__self__, "thread_pool_get_size", thread_pool_get_size)
        if thread_pool_search_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_queue_size", thread_pool_search_queue_size)
        if thread_pool_search_size is not None:
            pulumi.set(__self__, "thread_pool_search_size", thread_pool_search_size)
        if thread_pool_search_throttled_queue_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_queue_size", thread_pool_search_throttled_queue_size)
        if thread_pool_search_throttled_size is not None:
            pulumi.set(__self__, "thread_pool_search_throttled_size", thread_pool_search_throttled_size)
        if thread_pool_write_queue_size is not None:
            pulumi.set(__self__, "thread_pool_write_queue_size", thread_pool_write_queue_size)
        if thread_pool_write_size is not None:
            pulumi.set(__self__, "thread_pool_write_size", thread_pool_write_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="actionAutoCreateIndexEnabled")
    def action_auto_create_index_enabled(self) -> Optional[bool]:
        """
        action.auto_create_index. Explicitly allow or block automatic creation of indices. Defaults to true.
        """
        return pulumi.get(self, "action_auto_create_index_enabled")

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[bool]:
        """
        Require explicit index names when deleting.
        """
        return pulumi.get(self, "action_destructive_requires_name")

    @property
    @pulumi.getter(name="authFailureListeners")
    def auth_failure_listeners(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesAuthFailureListeners']:
        """
        Opensearch Security Plugin Settings.
        """
        return pulumi.get(self, "auth_failure_listeners")

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[bool]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @property
    @pulumi.getter(name="azureMigration")
    def azure_migration(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesAzureMigration']:
        return pulumi.get(self, "azure_migration")

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[int]:
        """
        Controls the number of shards allowed in the cluster per data node.
        """
        return pulumi.get(self, "cluster_max_shards_per_node")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[int]:
        """
        Concurrent incoming/outgoing shard recoveries per node. How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[str]:
        """
        Custom domain. Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.
        """
        return pulumi.get(self, "custom_domain")

    @property
    @pulumi.getter(name="emailSenderName")
    def email_sender_name(self) -> Optional[str]:
        """
        Sender name placeholder to be used in Opensearch Dashboards and Opensearch keystore. This should be identical to the Sender name defined in Opensearch dashboards.
        """
        return pulumi.get(self, "email_sender_name")

    @property
    @pulumi.getter(name="emailSenderPassword")
    def email_sender_password(self) -> Optional[str]:
        """
        Sender password for Opensearch alerts to authenticate with SMTP server. Sender password for Opensearch alerts to authenticate with SMTP server.
        """
        return pulumi.get(self, "email_sender_password")

    @property
    @pulumi.getter(name="emailSenderUsername")
    def email_sender_username(self) -> Optional[str]:
        """
        Sender username for Opensearch alerts.
        """
        return pulumi.get(self, "email_sender_username")

    @property
    @pulumi.getter(name="enableSecurityAudit")
    def enable_security_audit(self) -> Optional[bool]:
        """
        Enable/Disable security audit.
        """
        return pulumi.get(self, "enable_security_audit")

    @property
    @pulumi.getter(name="gcsMigration")
    def gcs_migration(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesGcsMigration']:
        return pulumi.get(self, "gcs_migration")

    @property
    @pulumi.getter(name="httpMaxContentLength")
    def http_max_content_length(self) -> Optional[int]:
        """
        Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
        """
        return pulumi.get(self, "http_max_content_length")

    @property
    @pulumi.getter(name="httpMaxHeaderSize")
    def http_max_header_size(self) -> Optional[int]:
        """
        The max size of allowed headers, in bytes.
        """
        return pulumi.get(self, "http_max_header_size")

    @property
    @pulumi.getter(name="httpMaxInitialLineLength")
    def http_max_initial_line_length(self) -> Optional[int]:
        """
        The max length of an HTTP URL, in bytes.
        """
        return pulumi.get(self, "http_max_initial_line_length")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence[str]]:
        """
        Index patterns.
        """
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexRollup")
    def index_rollup(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesIndexRollup']:
        """
        Index rollup settings.
        """
        return pulumi.get(self, "index_rollup")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesIndexTemplate']:
        """
        Template settings for all new indexes.
        """
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="indicesFielddataCacheSize")
    def indices_fielddata_cache_size(self) -> Optional[int]:
        """
        Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
        """
        return pulumi.get(self, "indices_fielddata_cache_size")

    @property
    @pulumi.getter(name="indicesMemoryIndexBufferSize")
    def indices_memory_index_buffer_size(self) -> Optional[int]:
        """
        Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
        """
        return pulumi.get(self, "indices_memory_index_buffer_size")

    @property
    @pulumi.getter(name="indicesMemoryMaxIndexBufferSize")
    def indices_memory_max_index_buffer_size(self) -> Optional[int]:
        """
        Absolute value. Default is unbound. Doesn't work without indices.memory.index_buffer_size. Maximum amount of heap used for query cache, an absolute indices.memory.index_buffer_size maximum hard limit.
        """
        return pulumi.get(self, "indices_memory_max_index_buffer_size")

    @property
    @pulumi.getter(name="indicesMemoryMinIndexBufferSize")
    def indices_memory_min_index_buffer_size(self) -> Optional[int]:
        """
        Absolute value. Default is 48mb. Doesn't work without indices.memory.index_buffer_size. Minimum amount of heap used for query cache, an absolute indices.memory.index_buffer_size minimal hard limit.
        """
        return pulumi.get(self, "indices_memory_min_index_buffer_size")

    @property
    @pulumi.getter(name="indicesQueriesCacheSize")
    def indices_queries_cache_size(self) -> Optional[int]:
        """
        Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
        """
        return pulumi.get(self, "indices_queries_cache_size")

    @property
    @pulumi.getter(name="indicesQueryBoolMaxClauseCount")
    def indices_query_bool_max_clause_count(self) -> Optional[int]:
        """
        Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
        """
        return pulumi.get(self, "indices_query_bool_max_clause_count")

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[int]:
        """
        Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb.
        """
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @property
    @pulumi.getter(name="indicesRecoveryMaxConcurrentFileChunks")
    def indices_recovery_max_concurrent_file_chunks(self) -> Optional[int]:
        """
        Number of file chunks sent in parallel for each recovery. Defaults to 2.
        """
        return pulumi.get(self, "indices_recovery_max_concurrent_file_chunks")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="ismEnabled")
    def ism_enabled(self) -> Optional[bool]:
        """
        Specifies whether ISM is enabled or not.
        """
        return pulumi.get(self, "ism_enabled")

    @property
    @pulumi.getter(name="ismHistoryEnabled")
    def ism_history_enabled(self) -> Optional[bool]:
        """
        Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.
        """
        return pulumi.get(self, "ism_history_enabled")

    @property
    @pulumi.getter(name="ismHistoryMaxAge")
    def ism_history_max_age(self) -> Optional[int]:
        """
        The maximum age before rolling over the audit history index in hours.
        """
        return pulumi.get(self, "ism_history_max_age")

    @property
    @pulumi.getter(name="ismHistoryMaxDocs")
    def ism_history_max_docs(self) -> Optional[int]:
        """
        The maximum number of documents before rolling over the audit history index.
        """
        return pulumi.get(self, "ism_history_max_docs")

    @property
    @pulumi.getter(name="ismHistoryRolloverCheckPeriod")
    def ism_history_rollover_check_period(self) -> Optional[int]:
        """
        The time between rollover checks for the audit history index in hours.
        """
        return pulumi.get(self, "ism_history_rollover_check_period")

    @property
    @pulumi.getter(name="ismHistoryRolloverRetentionPeriod")
    def ism_history_rollover_retention_period(self) -> Optional[int]:
        """
        How long audit history indices are kept in days.
        """
        return pulumi.get(self, "ism_history_rollover_retention_period")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[bool]:
        """
        Don't reset index.refresh_interval to the default value. Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="knnMemoryCircuitBreakerEnabled")
    def knn_memory_circuit_breaker_enabled(self) -> Optional[bool]:
        """
        Enable or disable KNN memory circuit breaker. Defaults to true.
        """
        return pulumi.get(self, "knn_memory_circuit_breaker_enabled")

    @property
    @pulumi.getter(name="knnMemoryCircuitBreakerLimit")
    def knn_memory_circuit_breaker_limit(self) -> Optional[int]:
        """
        Maximum amount of memory that can be used for KNN index. Defaults to 50% of the JVM heap size.
        """
        return pulumi.get(self, "knn_memory_circuit_breaker_limit")

    @property
    @pulumi.getter
    def openid(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesOpenid']:
        """
        OpenSearch OpenID Connect Configuration.
        """
        return pulumi.get(self, "openid")

    @property
    @pulumi.getter(name="opensearchDashboards")
    def opensearch_dashboards(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesOpensearchDashboards']:
        """
        OpenSearch Dashboards settings.
        """
        return pulumi.get(self, "opensearch_dashboards")

    @property
    @pulumi.getter(name="overrideMainResponseVersion")
    def override_main_response_version(self) -> Optional[bool]:
        """
        Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false.
        """
        return pulumi.get(self, "override_main_response_version")

    @property
    @pulumi.getter(name="pluginsAlertingFilterByBackendRoles")
    def plugins_alerting_filter_by_backend_roles(self) -> Optional[bool]:
        """
        Enable or disable filtering of alerting by backend roles. Requires Security plugin. Defaults to false.
        """
        return pulumi.get(self, "plugins_alerting_filter_by_backend_roles")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[bool]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="reindexRemoteWhitelists")
    def reindex_remote_whitelists(self) -> Optional[Sequence[str]]:
        """
        Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
        """
        return pulumi.get(self, "reindex_remote_whitelists")

    @property
    @pulumi.getter(name="s3Migration")
    def s3_migration(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesS3Migration']:
        return pulumi.get(self, "s3_migration")

    @property
    @pulumi.getter
    def saml(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesSaml']:
        """
        OpenSearch SAML configuration.
        """
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[str]:
        """
        Script max compilation rate - circuit breaker to prevent/minimize OOMs. Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context.
        """
        return pulumi.get(self, "script_max_compilations_rate")

    @property
    @pulumi.getter(name="searchMaxBuckets")
    def search_max_buckets(self) -> Optional[int]:
        """
        Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
        """
        return pulumi.get(self, "search_max_buckets")

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[bool]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @property
    @pulumi.getter(name="threadPoolAnalyzeQueueSize")
    def thread_pool_analyze_queue_size(self) -> Optional[int]:
        """
        analyze thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_analyze_queue_size")

    @property
    @pulumi.getter(name="threadPoolAnalyzeSize")
    def thread_pool_analyze_size(self) -> Optional[int]:
        """
        analyze thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_analyze_size")

    @property
    @pulumi.getter(name="threadPoolForceMergeSize")
    def thread_pool_force_merge_size(self) -> Optional[int]:
        """
        force_merge thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_force_merge_size")

    @property
    @pulumi.getter(name="threadPoolGetQueueSize")
    def thread_pool_get_queue_size(self) -> Optional[int]:
        """
        get thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_get_queue_size")

    @property
    @pulumi.getter(name="threadPoolGetSize")
    def thread_pool_get_size(self) -> Optional[int]:
        """
        get thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_get_size")

    @property
    @pulumi.getter(name="threadPoolSearchQueueSize")
    def thread_pool_search_queue_size(self) -> Optional[int]:
        """
        search thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_search_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchSize")
    def thread_pool_search_size(self) -> Optional[int]:
        """
        search thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_search_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledQueueSize")
    def thread_pool_search_throttled_queue_size(self) -> Optional[int]:
        """
        search_throttled thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_search_throttled_queue_size")

    @property
    @pulumi.getter(name="threadPoolSearchThrottledSize")
    def thread_pool_search_throttled_size(self) -> Optional[int]:
        """
        search_throttled thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_search_throttled_size")

    @property
    @pulumi.getter(name="threadPoolWriteQueueSize")
    def thread_pool_write_queue_size(self) -> Optional[int]:
        """
        write thread pool queue size. Size for the thread pool queue. See documentation for exact details.
        """
        return pulumi.get(self, "thread_pool_write_queue_size")

    @property
    @pulumi.getter(name="threadPoolWriteSize")
    def thread_pool_write_size(self) -> Optional[int]:
        """
        write thread pool size. Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
        """
        return pulumi.get(self, "thread_pool_write_size")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        OpenSearch major version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesAuthFailureListeners(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalAuthenticationBackendLimiting":
            suggest = "internal_authentication_backend_limiting"
        elif key == "ipRateLimiting":
            suggest = "ip_rate_limiting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesAuthFailureListeners. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesAuthFailureListeners.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesAuthFailureListeners.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internal_authentication_backend_limiting: Optional['outputs.ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting'] = None,
                 ip_rate_limiting: Optional['outputs.ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimiting'] = None):
        """
        :param 'ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimitingArgs' ip_rate_limiting: IP address rate limiting settings.
        """
        if internal_authentication_backend_limiting is not None:
            pulumi.set(__self__, "internal_authentication_backend_limiting", internal_authentication_backend_limiting)
        if ip_rate_limiting is not None:
            pulumi.set(__self__, "ip_rate_limiting", ip_rate_limiting)

    @property
    @pulumi.getter(name="internalAuthenticationBackendLimiting")
    def internal_authentication_backend_limiting(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting']:
        return pulumi.get(self, "internal_authentication_backend_limiting")

    @property
    @pulumi.getter(name="ipRateLimiting")
    def ip_rate_limiting(self) -> Optional['outputs.ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimiting']:
        """
        IP address rate limiting settings.
        """
        return pulumi.get(self, "ip_rate_limiting")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedTries":
            suggest = "allowed_tries"
        elif key == "authenticationBackend":
            suggest = "authentication_backend"
        elif key == "blockExpirySeconds":
            suggest = "block_expiry_seconds"
        elif key == "maxBlockedClients":
            suggest = "max_blocked_clients"
        elif key == "maxTrackedClients":
            suggest = "max_tracked_clients"
        elif key == "timeWindowSeconds":
            suggest = "time_window_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesAuthFailureListenersInternalAuthenticationBackendLimiting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_tries: Optional[int] = None,
                 authentication_backend: Optional[str] = None,
                 block_expiry_seconds: Optional[int] = None,
                 max_blocked_clients: Optional[int] = None,
                 max_tracked_clients: Optional[int] = None,
                 time_window_seconds: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int allowed_tries: The number of login attempts allowed before login is blocked.
        :param str authentication_backend: The internal backend. Enter `internal`.
        :param int block_expiry_seconds: The duration of time that login remains blocked after a failed login.
        :param int max_blocked_clients: The maximum number of blocked IP addresses.
        :param int max_tracked_clients: The maximum number of tracked IP addresses that have failed login.
        :param int time_window_seconds: The window of time in which the value for `allowed_tries` is enforced.
        :param str type: The type of rate limiting.
        """
        if allowed_tries is not None:
            pulumi.set(__self__, "allowed_tries", allowed_tries)
        if authentication_backend is not None:
            pulumi.set(__self__, "authentication_backend", authentication_backend)
        if block_expiry_seconds is not None:
            pulumi.set(__self__, "block_expiry_seconds", block_expiry_seconds)
        if max_blocked_clients is not None:
            pulumi.set(__self__, "max_blocked_clients", max_blocked_clients)
        if max_tracked_clients is not None:
            pulumi.set(__self__, "max_tracked_clients", max_tracked_clients)
        if time_window_seconds is not None:
            pulumi.set(__self__, "time_window_seconds", time_window_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedTries")
    def allowed_tries(self) -> Optional[int]:
        """
        The number of login attempts allowed before login is blocked.
        """
        return pulumi.get(self, "allowed_tries")

    @property
    @pulumi.getter(name="authenticationBackend")
    def authentication_backend(self) -> Optional[str]:
        """
        The internal backend. Enter `internal`.
        """
        return pulumi.get(self, "authentication_backend")

    @property
    @pulumi.getter(name="blockExpirySeconds")
    def block_expiry_seconds(self) -> Optional[int]:
        """
        The duration of time that login remains blocked after a failed login.
        """
        return pulumi.get(self, "block_expiry_seconds")

    @property
    @pulumi.getter(name="maxBlockedClients")
    def max_blocked_clients(self) -> Optional[int]:
        """
        The maximum number of blocked IP addresses.
        """
        return pulumi.get(self, "max_blocked_clients")

    @property
    @pulumi.getter(name="maxTrackedClients")
    def max_tracked_clients(self) -> Optional[int]:
        """
        The maximum number of tracked IP addresses that have failed login.
        """
        return pulumi.get(self, "max_tracked_clients")

    @property
    @pulumi.getter(name="timeWindowSeconds")
    def time_window_seconds(self) -> Optional[int]:
        """
        The window of time in which the value for `allowed_tries` is enforced.
        """
        return pulumi.get(self, "time_window_seconds")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of rate limiting.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimiting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedTries":
            suggest = "allowed_tries"
        elif key == "blockExpirySeconds":
            suggest = "block_expiry_seconds"
        elif key == "maxBlockedClients":
            suggest = "max_blocked_clients"
        elif key == "maxTrackedClients":
            suggest = "max_tracked_clients"
        elif key == "timeWindowSeconds":
            suggest = "time_window_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimiting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimiting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesAuthFailureListenersIpRateLimiting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_tries: Optional[int] = None,
                 block_expiry_seconds: Optional[int] = None,
                 max_blocked_clients: Optional[int] = None,
                 max_tracked_clients: Optional[int] = None,
                 time_window_seconds: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int allowed_tries: The number of login attempts allowed before login is blocked.
        :param int block_expiry_seconds: The duration of time that login remains blocked after a failed login.
        :param int max_blocked_clients: The maximum number of blocked IP addresses.
        :param int max_tracked_clients: The maximum number of tracked IP addresses that have failed login.
        :param int time_window_seconds: The window of time in which the value for `allowed_tries` is enforced.
        :param str type: The type of rate limiting.
        """
        if allowed_tries is not None:
            pulumi.set(__self__, "allowed_tries", allowed_tries)
        if block_expiry_seconds is not None:
            pulumi.set(__self__, "block_expiry_seconds", block_expiry_seconds)
        if max_blocked_clients is not None:
            pulumi.set(__self__, "max_blocked_clients", max_blocked_clients)
        if max_tracked_clients is not None:
            pulumi.set(__self__, "max_tracked_clients", max_tracked_clients)
        if time_window_seconds is not None:
            pulumi.set(__self__, "time_window_seconds", time_window_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedTries")
    def allowed_tries(self) -> Optional[int]:
        """
        The number of login attempts allowed before login is blocked.
        """
        return pulumi.get(self, "allowed_tries")

    @property
    @pulumi.getter(name="blockExpirySeconds")
    def block_expiry_seconds(self) -> Optional[int]:
        """
        The duration of time that login remains blocked after a failed login.
        """
        return pulumi.get(self, "block_expiry_seconds")

    @property
    @pulumi.getter(name="maxBlockedClients")
    def max_blocked_clients(self) -> Optional[int]:
        """
        The maximum number of blocked IP addresses.
        """
        return pulumi.get(self, "max_blocked_clients")

    @property
    @pulumi.getter(name="maxTrackedClients")
    def max_tracked_clients(self) -> Optional[int]:
        """
        The maximum number of tracked IP addresses that have failed login.
        """
        return pulumi.get(self, "max_tracked_clients")

    @property
    @pulumi.getter(name="timeWindowSeconds")
    def time_window_seconds(self) -> Optional[int]:
        """
        The window of time in which the value for `allowed_tries` is enforced.
        """
        return pulumi.get(self, "time_window_seconds")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of rate limiting.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesAzureMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basePath":
            suggest = "base_path"
        elif key == "chunkSize":
            suggest = "chunk_size"
        elif key == "endpointSuffix":
            suggest = "endpoint_suffix"
        elif key == "sasToken":
            suggest = "sas_token"
        elif key == "snapshotName":
            suggest = "snapshot_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesAzureMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesAzureMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesAzureMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: Optional[str] = None,
                 base_path: Optional[str] = None,
                 chunk_size: Optional[str] = None,
                 compress: Optional[bool] = None,
                 container: Optional[str] = None,
                 endpoint_suffix: Optional[str] = None,
                 key: Optional[str] = None,
                 sas_token: Optional[str] = None,
                 snapshot_name: Optional[str] = None):
        """
        :param str account: Account name. Azure account name.
        :param str base_path: The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        :param str chunk_size: Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        :param bool compress: Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        :param str container: Azure container name. Azure container name.
        :param str endpoint_suffix: Endpoint suffix. Defines the DNS suffix for Azure Storage endpoints.
        :param str key: Account secret key. Azure account secret key. One of key or sas_token should be specified.
        :param str sas_token: SAS token. A shared access signatures (SAS) token. One of key or sas_token should be specified.
        :param str snapshot_name: The snapshot name to restore from. The snapshot name to restore from.
        """
        if account is not None:
            pulumi.set(__self__, "account", account)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if endpoint_suffix is not None:
            pulumi.set(__self__, "endpoint_suffix", endpoint_suffix)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if snapshot_name is not None:
            pulumi.set(__self__, "snapshot_name", snapshot_name)

    @property
    @pulumi.getter
    def account(self) -> Optional[str]:
        """
        Account name. Azure account name.
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[str]:
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        return pulumi.get(self, "base_path")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter
    def container(self) -> Optional[str]:
        """
        Azure container name. Azure container name.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="endpointSuffix")
    def endpoint_suffix(self) -> Optional[str]:
        """
        Endpoint suffix. Defines the DNS suffix for Azure Storage endpoints.
        """
        return pulumi.get(self, "endpoint_suffix")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Account secret key. Azure account secret key. One of key or sas_token should be specified.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[str]:
        """
        SAS token. A shared access signatures (SAS) token. One of key or sas_token should be specified.
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[str]:
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
        return pulumi.get(self, "snapshot_name")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesGcsMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basePath":
            suggest = "base_path"
        elif key == "chunkSize":
            suggest = "chunk_size"
        elif key == "snapshotName":
            suggest = "snapshot_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesGcsMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesGcsMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesGcsMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_path: Optional[str] = None,
                 bucket: Optional[str] = None,
                 chunk_size: Optional[str] = None,
                 compress: Optional[bool] = None,
                 credentials: Optional[str] = None,
                 snapshot_name: Optional[str] = None):
        """
        :param str base_path: The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        :param str bucket: The path to the repository data within its container. Google Cloud Storage bucket name.
        :param str chunk_size: Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        :param bool compress: Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        :param str credentials: Credentials. Google Cloud Storage credentials file content.
        :param str snapshot_name: The snapshot name to restore from. The snapshot name to restore from.
        """
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if snapshot_name is not None:
            pulumi.set(__self__, "snapshot_name", snapshot_name)

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[str]:
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        return pulumi.get(self, "base_path")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The path to the repository data within its container. Google Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        """
        Credentials. Google Cloud Storage credentials file content.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[str]:
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
        return pulumi.get(self, "snapshot_name")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesIndexRollup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollupDashboardsEnabled":
            suggest = "rollup_dashboards_enabled"
        elif key == "rollupEnabled":
            suggest = "rollup_enabled"
        elif key == "rollupSearchBackoffCount":
            suggest = "rollup_search_backoff_count"
        elif key == "rollupSearchBackoffMillis":
            suggest = "rollup_search_backoff_millis"
        elif key == "rollupSearchSearchAllJobs":
            suggest = "rollup_search_search_all_jobs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesIndexRollup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesIndexRollup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesIndexRollup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rollup_dashboards_enabled: Optional[bool] = None,
                 rollup_enabled: Optional[bool] = None,
                 rollup_search_backoff_count: Optional[int] = None,
                 rollup_search_backoff_millis: Optional[int] = None,
                 rollup_search_search_all_jobs: Optional[bool] = None):
        """
        :param bool rollup_dashboards_enabled: plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.
        :param bool rollup_enabled: plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.
        :param int rollup_search_backoff_count: plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.
        :param int rollup_search_backoff_millis: plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.
        :param bool rollup_search_search_all_jobs: plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.
        """
        if rollup_dashboards_enabled is not None:
            pulumi.set(__self__, "rollup_dashboards_enabled", rollup_dashboards_enabled)
        if rollup_enabled is not None:
            pulumi.set(__self__, "rollup_enabled", rollup_enabled)
        if rollup_search_backoff_count is not None:
            pulumi.set(__self__, "rollup_search_backoff_count", rollup_search_backoff_count)
        if rollup_search_backoff_millis is not None:
            pulumi.set(__self__, "rollup_search_backoff_millis", rollup_search_backoff_millis)
        if rollup_search_search_all_jobs is not None:
            pulumi.set(__self__, "rollup_search_search_all_jobs", rollup_search_search_all_jobs)

    @property
    @pulumi.getter(name="rollupDashboardsEnabled")
    def rollup_dashboards_enabled(self) -> Optional[bool]:
        """
        plugins.rollup.dashboards.enabled. Whether rollups are enabled in OpenSearch Dashboards. Defaults to true.
        """
        return pulumi.get(self, "rollup_dashboards_enabled")

    @property
    @pulumi.getter(name="rollupEnabled")
    def rollup_enabled(self) -> Optional[bool]:
        """
        plugins.rollup.enabled. Whether the rollup plugin is enabled. Defaults to true.
        """
        return pulumi.get(self, "rollup_enabled")

    @property
    @pulumi.getter(name="rollupSearchBackoffCount")
    def rollup_search_backoff_count(self) -> Optional[int]:
        """
        plugins.rollup.search.backoff_count. How many retries the plugin should attempt for failed rollup jobs. Defaults to 5.
        """
        return pulumi.get(self, "rollup_search_backoff_count")

    @property
    @pulumi.getter(name="rollupSearchBackoffMillis")
    def rollup_search_backoff_millis(self) -> Optional[int]:
        """
        plugins.rollup.search.backoff_millis. The backoff time between retries for failed rollup jobs. Defaults to 1000ms.
        """
        return pulumi.get(self, "rollup_search_backoff_millis")

    @property
    @pulumi.getter(name="rollupSearchSearchAllJobs")
    def rollup_search_search_all_jobs(self) -> Optional[bool]:
        """
        plugins.rollup.search.all_jobs. Whether OpenSearch should return all jobs that match all specified search terms. If disabled, OpenSearch returns just one, as opposed to all, of the jobs that matches the search terms. Defaults to false.
        """
        return pulumi.get(self, "rollup_search_search_all_jobs")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[int] = None,
                 number_of_replicas: Optional[int] = None,
                 number_of_shards: Optional[int] = None):
        """
        :param int mapping_nested_objects_limit: index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
        :param int number_of_replicas: The number of replicas each primary shard has.
        :param int number_of_shards: The number of primary shards that an index should have.
        """
        if mapping_nested_objects_limit is not None:
            pulumi.set(__self__, "mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[int]:
        """
        index.mapping.nested_objects.limit. The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[int]:
        """
        The number of replicas each primary shard has.
        """
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[int]:
        """
        The number of primary shards that an index should have.
        """
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesOpenid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "connectUrl":
            suggest = "connect_url"
        elif key == "jwtHeader":
            suggest = "jwt_header"
        elif key == "jwtUrlParameter":
            suggest = "jwt_url_parameter"
        elif key == "refreshRateLimitCount":
            suggest = "refresh_rate_limit_count"
        elif key == "refreshRateLimitTimeWindowMs":
            suggest = "refresh_rate_limit_time_window_ms"
        elif key == "rolesKey":
            suggest = "roles_key"
        elif key == "subjectKey":
            suggest = "subject_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesOpenid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesOpenid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesOpenid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 connect_url: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 header: Optional[str] = None,
                 jwt_header: Optional[str] = None,
                 jwt_url_parameter: Optional[str] = None,
                 refresh_rate_limit_count: Optional[int] = None,
                 refresh_rate_limit_time_window_ms: Optional[int] = None,
                 roles_key: Optional[str] = None,
                 scope: Optional[str] = None,
                 subject_key: Optional[str] = None):
        """
        :param str client_id: The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.
        :param str client_secret: The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.
        :param str connect_url: OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.
        :param bool enabled: Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.
        :param str header: HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.
        :param str jwt_header: The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer <token>. Optional. Default is Authorization.
        :param str jwt_url_parameter: URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.
        :param int refresh_rate_limit_count: The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.
        :param int refresh_rate_limit_time_window_ms: The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).
        :param str roles_key: The key in the JSON payload that stores the user’s roles. The key in the JSON payload that stores the user’s roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.
        :param str scope: The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.
        :param str subject_key: The key in the JSON payload that stores the user’s name. The key in the JSON payload that stores the user’s name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if connect_url is not None:
            pulumi.set(__self__, "connect_url", connect_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if jwt_header is not None:
            pulumi.set(__self__, "jwt_header", jwt_header)
        if jwt_url_parameter is not None:
            pulumi.set(__self__, "jwt_url_parameter", jwt_url_parameter)
        if refresh_rate_limit_count is not None:
            pulumi.set(__self__, "refresh_rate_limit_count", refresh_rate_limit_count)
        if refresh_rate_limit_time_window_ms is not None:
            pulumi.set(__self__, "refresh_rate_limit_time_window_ms", refresh_rate_limit_time_window_ms)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The ID of the OpenID Connect client. The ID of the OpenID Connect client configured in your IdP. Required.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret of the OpenID Connect. The client secret of the OpenID Connect client configured in your IdP. Required.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="connectUrl")
    def connect_url(self) -> Optional[str]:
        """
        OpenID Connect metadata/configuration URL. The URL of your IdP where the Security plugin can find the OpenID Connect metadata/configuration settings.
        """
        return pulumi.get(self, "connect_url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable or disable OpenSearch OpenID Connect authentication. Enables or disables OpenID Connect authentication for OpenSearch. When enabled, users can authenticate using OpenID Connect with an Identity Provider.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def header(self) -> Optional[str]:
        """
        HTTP header name of the JWT token. HTTP header name of the JWT token. Optional. Default is Authorization.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="jwtHeader")
    def jwt_header(self) -> Optional[str]:
        """
        The HTTP header that stores the token. The HTTP header that stores the token. Typically the Authorization header with the Bearer schema: Authorization: Bearer <token>. Optional. Default is Authorization.
        """
        return pulumi.get(self, "jwt_header")

    @property
    @pulumi.getter(name="jwtUrlParameter")
    def jwt_url_parameter(self) -> Optional[str]:
        """
        URL JWT token. If the token is not transmitted in the HTTP header, but as an URL parameter, define the name of the parameter here. Optional.
        """
        return pulumi.get(self, "jwt_url_parameter")

    @property
    @pulumi.getter(name="refreshRateLimitCount")
    def refresh_rate_limit_count(self) -> Optional[int]:
        """
        The maximum number of unknown key IDs in the time frame. The maximum number of unknown key IDs in the time frame. Default is 10. Optional.
        """
        return pulumi.get(self, "refresh_rate_limit_count")

    @property
    @pulumi.getter(name="refreshRateLimitTimeWindowMs")
    def refresh_rate_limit_time_window_ms(self) -> Optional[int]:
        """
        The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. The time frame to use when checking the maximum number of unknown key IDs, in milliseconds. Optional.Default is 10000 (10 seconds).
        """
        return pulumi.get(self, "refresh_rate_limit_time_window_ms")

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[str]:
        """
        The key in the JSON payload that stores the user’s roles. The key in the JSON payload that stores the user’s roles. The value of this key must be a comma-separated list of roles. Required only if you want to use roles in the JWT.
        """
        return pulumi.get(self, "roles_key")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope of the identity token issued by the IdP. The scope of the identity token issued by the IdP. Optional. Default is openid profile email address phone.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[str]:
        """
        The key in the JSON payload that stores the user’s name. The key in the JSON payload that stores the user’s name. If not defined, the subject registered claim is used. Most IdP providers use the preferred_username claim. Optional.
        """
        return pulumi.get(self, "subject_key")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "opensearchRequestTimeout":
            suggest = "opensearch_request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 max_old_space_size: Optional[int] = None,
                 opensearch_request_timeout: Optional[int] = None):
        """
        :param bool enabled: Enable or disable OpenSearch Dashboards.
        :param int max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.
        :param int opensearch_request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_old_space_size is not None:
            pulumi.set(__self__, "max_old_space_size", max_old_space_size)
        if opensearch_request_timeout is not None:
            pulumi.set(__self__, "opensearch_request_timeout", opensearch_request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable or disable OpenSearch Dashboards.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[int]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch.
        """
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="opensearchRequestTimeout")
    def opensearch_request_timeout(self) -> Optional[int]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch.
        """
        return pulumi.get(self, "opensearch_request_timeout")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesS3Migration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "basePath":
            suggest = "base_path"
        elif key == "chunkSize":
            suggest = "chunk_size"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "serverSideEncryption":
            suggest = "server_side_encryption"
        elif key == "snapshotName":
            suggest = "snapshot_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesS3Migration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesS3Migration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesS3Migration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 base_path: Optional[str] = None,
                 bucket: Optional[str] = None,
                 chunk_size: Optional[str] = None,
                 compress: Optional[bool] = None,
                 endpoint: Optional[str] = None,
                 region: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 server_side_encryption: Optional[bool] = None,
                 snapshot_name: Optional[str] = None):
        """
        :param str access_key: AWS Access key. AWS Access key.
        :param str base_path: The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        :param str bucket: S3 bucket name. S3 bucket name.
        :param str chunk_size: Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        :param bool compress: Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        :param str endpoint: The S3 service endpoint to connect. The S3 service endpoint to connect to. If you are using an S3-compatible service then you should set this to the service’s endpoint.
        :param str region: S3 region. S3 region.
        :param str secret_key: AWS secret key. AWS secret key.
        :param bool server_side_encryption: Server side encryption. When set to true files are encrypted on server side.
        :param str snapshot_name: The snapshot name to restore from. The snapshot name to restore from.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if server_side_encryption is not None:
            pulumi.set(__self__, "server_side_encryption", server_side_encryption)
        if snapshot_name is not None:
            pulumi.set(__self__, "snapshot_name", snapshot_name)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        AWS Access key. AWS Access key.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[str]:
        """
        The path to the repository data within its container. The path to the repository data within its container. The value of this setting should not start or end with a /.
        """
        return pulumi.get(self, "base_path")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        S3 bucket name. S3 bucket name.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Chunk size. Big files can be broken down into chunks during snapshotting if needed. Should be the same as for the 3rd party repository.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        Metadata files are stored in compressed format. when set to true metadata files are stored in compressed format.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The S3 service endpoint to connect. The S3 service endpoint to connect to. If you are using an S3-compatible service then you should set this to the service’s endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        S3 region. S3 region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        AWS secret key. AWS secret key.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[bool]:
        """
        Server side encryption. When set to true files are encrypted on server side.
        """
        return pulumi.get(self, "server_side_encryption")

    @property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[str]:
        """
        The snapshot name to restore from. The snapshot name to restore from.
        """
        return pulumi.get(self, "snapshot_name")


@pulumi.output_type
class ManagedDatabaseOpensearchPropertiesSaml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idpEntityId":
            suggest = "idp_entity_id"
        elif key == "idpMetadataUrl":
            suggest = "idp_metadata_url"
        elif key == "idpPemtrustedcasContent":
            suggest = "idp_pemtrustedcas_content"
        elif key == "rolesKey":
            suggest = "roles_key"
        elif key == "spEntityId":
            suggest = "sp_entity_id"
        elif key == "subjectKey":
            suggest = "subject_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseOpensearchPropertiesSaml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseOpensearchPropertiesSaml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseOpensearchPropertiesSaml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 idp_entity_id: Optional[str] = None,
                 idp_metadata_url: Optional[str] = None,
                 idp_pemtrustedcas_content: Optional[str] = None,
                 roles_key: Optional[str] = None,
                 sp_entity_id: Optional[str] = None,
                 subject_key: Optional[str] = None):
        """
        :param bool enabled: Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.
        :param str idp_entity_id: Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.
        :param str idp_metadata_url: Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.
        :param str idp_pemtrustedcas_content: PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.
        :param str roles_key: SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.
        :param str sp_entity_id: Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.
        :param str subject_key: SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if idp_metadata_url is not None:
            pulumi.set(__self__, "idp_metadata_url", idp_metadata_url)
        if idp_pemtrustedcas_content is not None:
            pulumi.set(__self__, "idp_pemtrustedcas_content", idp_pemtrustedcas_content)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable or disable OpenSearch SAML authentication. Enables or disables SAML-based authentication for OpenSearch. When enabled, users can authenticate using SAML with an Identity Provider.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[str]:
        """
        Identity Provider Entity ID. The unique identifier for the Identity Provider (IdP) entity that is used for SAML authentication. This value is typically provided by the IdP.
        """
        return pulumi.get(self, "idp_entity_id")

    @property
    @pulumi.getter(name="idpMetadataUrl")
    def idp_metadata_url(self) -> Optional[str]:
        """
        Identity Provider (IdP) SAML metadata URL. The URL of the SAML metadata for the Identity Provider (IdP). This is used to configure SAML-based authentication with the IdP.
        """
        return pulumi.get(self, "idp_metadata_url")

    @property
    @pulumi.getter(name="idpPemtrustedcasContent")
    def idp_pemtrustedcas_content(self) -> Optional[str]:
        """
        PEM-encoded root CA Content for SAML IdP server verification. This parameter specifies the PEM-encoded root certificate authority (CA) content for the SAML identity provider (IdP) server verification. The root CA content is used to verify the SSL/TLS certificate presented by the server.
        """
        return pulumi.get(self, "idp_pemtrustedcas_content")

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[str]:
        """
        SAML response role attribute. Optional. Specifies the attribute in the SAML response where role information is stored, if available. Role attributes are not required for SAML authentication, but can be included in SAML assertions by most Identity Providers (IdPs) to determine user access levels or permissions.
        """
        return pulumi.get(self, "roles_key")

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[str]:
        """
        Service Provider Entity ID. The unique identifier for the Service Provider (SP) entity that is used for SAML authentication. This value is typically provided by the SP.
        """
        return pulumi.get(self, "sp_entity_id")

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[str]:
        """
        SAML response subject attribute. Optional. Specifies the attribute in the SAML response where the subject identifier is stored. If not configured, the NameID attribute is used by default.
        """
        return pulumi.get(self, "subject_key")


@pulumi.output_type
class ManagedDatabasePostgresqlComponent(dict):
    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 usage: Optional[str] = None):
        """
        :param str component: Type of the component
        :param str host: Hostname of the component
        :param int port: Port number of the component
        :param str route: Component network route type
        :param str usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class ManagedDatabasePostgresqlNetwork(dict):
    def __init__(__self__, *,
                 family: str,
                 name: str,
                 type: str,
                 uuid: str):
        """
        :param str family: Network family. Currently only `IPv4` is supported.
        :param str name: The name of the network. Must be unique within the service.
        :param str type: The type of the network. Must be private.
        :param str uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ManagedDatabasePostgresqlNodeState(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 role: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str name: Name plus a node iteration
        :param str role: Role of the node
        :param str state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of the node
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ManagedDatabasePostgresqlProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "automaticUtilityNetworkIpFilter":
            suggest = "automatic_utility_network_ip_filter"
        elif key == "autovacuumAnalyzeScaleFactor":
            suggest = "autovacuum_analyze_scale_factor"
        elif key == "autovacuumAnalyzeThreshold":
            suggest = "autovacuum_analyze_threshold"
        elif key == "autovacuumFreezeMaxAge":
            suggest = "autovacuum_freeze_max_age"
        elif key == "autovacuumMaxWorkers":
            suggest = "autovacuum_max_workers"
        elif key == "autovacuumNaptime":
            suggest = "autovacuum_naptime"
        elif key == "autovacuumVacuumCostDelay":
            suggest = "autovacuum_vacuum_cost_delay"
        elif key == "autovacuumVacuumCostLimit":
            suggest = "autovacuum_vacuum_cost_limit"
        elif key == "autovacuumVacuumScaleFactor":
            suggest = "autovacuum_vacuum_scale_factor"
        elif key == "autovacuumVacuumThreshold":
            suggest = "autovacuum_vacuum_threshold"
        elif key == "backupHour":
            suggest = "backup_hour"
        elif key == "backupMinute":
            suggest = "backup_minute"
        elif key == "bgwriterDelay":
            suggest = "bgwriter_delay"
        elif key == "bgwriterFlushAfter":
            suggest = "bgwriter_flush_after"
        elif key == "bgwriterLruMaxpages":
            suggest = "bgwriter_lru_maxpages"
        elif key == "bgwriterLruMultiplier":
            suggest = "bgwriter_lru_multiplier"
        elif key == "deadlockTimeout":
            suggest = "deadlock_timeout"
        elif key == "defaultToastCompression":
            suggest = "default_toast_compression"
        elif key == "idleInTransactionSessionTimeout":
            suggest = "idle_in_transaction_session_timeout"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "logAutovacuumMinDuration":
            suggest = "log_autovacuum_min_duration"
        elif key == "logErrorVerbosity":
            suggest = "log_error_verbosity"
        elif key == "logLinePrefix":
            suggest = "log_line_prefix"
        elif key == "logMinDurationStatement":
            suggest = "log_min_duration_statement"
        elif key == "logTempFiles":
            suggest = "log_temp_files"
        elif key == "maxFilesPerProcess":
            suggest = "max_files_per_process"
        elif key == "maxLocksPerTransaction":
            suggest = "max_locks_per_transaction"
        elif key == "maxLogicalReplicationWorkers":
            suggest = "max_logical_replication_workers"
        elif key == "maxParallelWorkers":
            suggest = "max_parallel_workers"
        elif key == "maxParallelWorkersPerGather":
            suggest = "max_parallel_workers_per_gather"
        elif key == "maxPredLocksPerTransaction":
            suggest = "max_pred_locks_per_transaction"
        elif key == "maxPreparedTransactions":
            suggest = "max_prepared_transactions"
        elif key == "maxReplicationSlots":
            suggest = "max_replication_slots"
        elif key == "maxSlotWalKeepSize":
            suggest = "max_slot_wal_keep_size"
        elif key == "maxStackDepth":
            suggest = "max_stack_depth"
        elif key == "maxStandbyArchiveDelay":
            suggest = "max_standby_archive_delay"
        elif key == "maxStandbyStreamingDelay":
            suggest = "max_standby_streaming_delay"
        elif key == "maxWalSenders":
            suggest = "max_wal_senders"
        elif key == "maxWorkerProcesses":
            suggest = "max_worker_processes"
        elif key == "pgPartmanBgwInterval":
            suggest = "pg_partman_bgw_interval"
        elif key == "pgPartmanBgwRole":
            suggest = "pg_partman_bgw_role"
        elif key == "pgStatMonitorEnable":
            suggest = "pg_stat_monitor_enable"
        elif key == "pgStatMonitorPgsmEnableQueryPlan":
            suggest = "pg_stat_monitor_pgsm_enable_query_plan"
        elif key == "pgStatMonitorPgsmMaxBuckets":
            suggest = "pg_stat_monitor_pgsm_max_buckets"
        elif key == "pgStatStatementsTrack":
            suggest = "pg_stat_statements_track"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "serviceLog":
            suggest = "service_log"
        elif key == "sharedBuffersPercentage":
            suggest = "shared_buffers_percentage"
        elif key == "synchronousReplication":
            suggest = "synchronous_replication"
        elif key == "tempFileLimit":
            suggest = "temp_file_limit"
        elif key == "trackActivityQuerySize":
            suggest = "track_activity_query_size"
        elif key == "trackCommitTimestamp":
            suggest = "track_commit_timestamp"
        elif key == "trackFunctions":
            suggest = "track_functions"
        elif key == "trackIoTiming":
            suggest = "track_io_timing"
        elif key == "walSenderTimeout":
            suggest = "wal_sender_timeout"
        elif key == "walWriterDelay":
            suggest = "wal_writer_delay"
        elif key == "workMem":
            suggest = "work_mem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabasePostgresqlProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabasePostgresqlProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabasePostgresqlProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 automatic_utility_network_ip_filter: Optional[bool] = None,
                 autovacuum_analyze_scale_factor: Optional[float] = None,
                 autovacuum_analyze_threshold: Optional[int] = None,
                 autovacuum_freeze_max_age: Optional[int] = None,
                 autovacuum_max_workers: Optional[int] = None,
                 autovacuum_naptime: Optional[int] = None,
                 autovacuum_vacuum_cost_delay: Optional[int] = None,
                 autovacuum_vacuum_cost_limit: Optional[int] = None,
                 autovacuum_vacuum_scale_factor: Optional[float] = None,
                 autovacuum_vacuum_threshold: Optional[int] = None,
                 backup_hour: Optional[int] = None,
                 backup_minute: Optional[int] = None,
                 bgwriter_delay: Optional[int] = None,
                 bgwriter_flush_after: Optional[int] = None,
                 bgwriter_lru_maxpages: Optional[int] = None,
                 bgwriter_lru_multiplier: Optional[float] = None,
                 deadlock_timeout: Optional[int] = None,
                 default_toast_compression: Optional[str] = None,
                 idle_in_transaction_session_timeout: Optional[int] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 jit: Optional[bool] = None,
                 log_autovacuum_min_duration: Optional[int] = None,
                 log_error_verbosity: Optional[str] = None,
                 log_line_prefix: Optional[str] = None,
                 log_min_duration_statement: Optional[int] = None,
                 log_temp_files: Optional[int] = None,
                 max_files_per_process: Optional[int] = None,
                 max_locks_per_transaction: Optional[int] = None,
                 max_logical_replication_workers: Optional[int] = None,
                 max_parallel_workers: Optional[int] = None,
                 max_parallel_workers_per_gather: Optional[int] = None,
                 max_pred_locks_per_transaction: Optional[int] = None,
                 max_prepared_transactions: Optional[int] = None,
                 max_replication_slots: Optional[int] = None,
                 max_slot_wal_keep_size: Optional[int] = None,
                 max_stack_depth: Optional[int] = None,
                 max_standby_archive_delay: Optional[int] = None,
                 max_standby_streaming_delay: Optional[int] = None,
                 max_wal_senders: Optional[int] = None,
                 max_worker_processes: Optional[int] = None,
                 migration: Optional['outputs.ManagedDatabasePostgresqlPropertiesMigration'] = None,
                 pg_partman_bgw_interval: Optional[int] = None,
                 pg_partman_bgw_role: Optional[str] = None,
                 pg_stat_monitor_enable: Optional[bool] = None,
                 pg_stat_monitor_pgsm_enable_query_plan: Optional[bool] = None,
                 pg_stat_monitor_pgsm_max_buckets: Optional[int] = None,
                 pg_stat_statements_track: Optional[str] = None,
                 pgbouncer: Optional['outputs.ManagedDatabasePostgresqlPropertiesPgbouncer'] = None,
                 pglookout: Optional['outputs.ManagedDatabasePostgresqlPropertiesPglookout'] = None,
                 public_access: Optional[bool] = None,
                 service_log: Optional[bool] = None,
                 shared_buffers_percentage: Optional[float] = None,
                 synchronous_replication: Optional[str] = None,
                 temp_file_limit: Optional[int] = None,
                 timescaledb: Optional['outputs.ManagedDatabasePostgresqlPropertiesTimescaledb'] = None,
                 timezone: Optional[str] = None,
                 track_activity_query_size: Optional[int] = None,
                 track_commit_timestamp: Optional[str] = None,
                 track_functions: Optional[str] = None,
                 track_io_timing: Optional[str] = None,
                 variant: Optional[str] = None,
                 version: Optional[str] = None,
                 wal_sender_timeout: Optional[int] = None,
                 wal_writer_delay: Optional[int] = None,
                 work_mem: Optional[int] = None):
        """
        :param str admin_password: Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        :param str admin_username: Custom username for admin user. This must be set only when a new service is being created.
        :param bool automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param float autovacuum_analyze_scale_factor: Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        :param int autovacuum_analyze_threshold: Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        :param int autovacuum_freeze_max_age: Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        :param int autovacuum_max_workers: Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        :param int autovacuum_naptime: Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.
        :param int autovacuum_vacuum_cost_delay: Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.
        :param int autovacuum_vacuum_cost_limit: Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        :param float autovacuum_vacuum_scale_factor: Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        :param int autovacuum_vacuum_threshold: Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        :param int backup_hour: The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        :param int backup_minute: The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        :param int bgwriter_delay: Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
        :param int bgwriter_flush_after: Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
        :param int bgwriter_lru_maxpages: In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
        :param float bgwriter_lru_multiplier: The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        :param int deadlock_timeout: This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        :param str default_toast_compression: Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        :param int idle_in_transaction_session_timeout: Time out sessions with open transactions after this number of milliseconds.
        :param Sequence[str] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param bool jit: Controls system-wide use of Just-in-Time Compilation (JIT).
        :param int log_autovacuum_min_duration: Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        :param str log_error_verbosity: Controls the amount of detail written in the server log for each message that is logged.
        :param str log_line_prefix: Choose from one of the available log formats.
        :param int log_min_duration_statement: Log statements that take more than this number of milliseconds to run, -1 disables.
        :param int log_temp_files: Log statements for each temporary file created larger than this number of kilobytes, -1 disables.
        :param int max_files_per_process: PostgreSQL maximum number of files that can be open per process.
        :param int max_locks_per_transaction: PostgreSQL maximum locks per transaction.
        :param int max_logical_replication_workers: PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        :param int max_parallel_workers: Sets the maximum number of workers that the system can support for parallel queries.
        :param int max_parallel_workers_per_gather: Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        :param int max_pred_locks_per_transaction: PostgreSQL maximum predicate locks per transaction.
        :param int max_prepared_transactions: PostgreSQL maximum prepared transactions.
        :param int max_replication_slots: PostgreSQL maximum replication slots.
        :param int max_slot_wal_keep_size: PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
        :param int max_stack_depth: Maximum depth of the stack in bytes.
        :param int max_standby_archive_delay: Max standby archive delay in milliseconds.
        :param int max_standby_streaming_delay: Max standby streaming delay in milliseconds.
        :param int max_wal_senders: PostgreSQL maximum WAL senders.
        :param int max_worker_processes: Sets the maximum number of background processes that the system can support.
        :param 'ManagedDatabasePostgresqlPropertiesMigrationArgs' migration: Migrate data from existing server.
        :param int pg_partman_bgw_interval: Sets the time interval to run pg_partman's scheduled tasks.
        :param str pg_partman_bgw_role: Controls which role to use for pg_partman's scheduled background tasks.
        :param bool pg_stat_monitor_enable: Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        :param bool pg_stat_monitor_pgsm_enable_query_plan: Enables or disables query plan monitoring.
        :param int pg_stat_monitor_pgsm_max_buckets: Sets the maximum number of buckets.
        :param str pg_stat_statements_track: Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
        :param 'ManagedDatabasePostgresqlPropertiesPgbouncerArgs' pgbouncer: PGBouncer connection pooling settings. System-wide settings for pgbouncer.
        :param 'ManagedDatabasePostgresqlPropertiesPglookoutArgs' pglookout: PGLookout settings. System-wide settings for pglookout.
        :param bool public_access: Public Access. Allow access to the service from the public Internet.
        :param bool service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        :param float shared_buffers_percentage: Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
        :param str synchronous_replication: Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        :param int temp_file_limit: PostgreSQL temporary file limit in KiB, -1 for unlimited.
        :param 'ManagedDatabasePostgresqlPropertiesTimescaledbArgs' timescaledb: TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.
        :param str timezone: PostgreSQL service timezone.
        :param int track_activity_query_size: Specifies the number of bytes reserved to track the currently executing command for each active session.
        :param str track_commit_timestamp: Record commit time of transactions.
        :param str track_functions: Enables tracking of function call counts and time used.
        :param str track_io_timing: Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        :param str variant: Variant of the PostgreSQL service, may affect the features that are exposed by default.
        :param str version: PostgreSQL major version.
        :param int wal_sender_timeout: Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
        :param int wal_writer_delay: WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
        :param int work_mem: Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_analyze_threshold is not None:
            pulumi.set(__self__, "autovacuum_analyze_threshold", autovacuum_analyze_threshold)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if backup_hour is not None:
            pulumi.set(__self__, "backup_hour", backup_hour)
        if backup_minute is not None:
            pulumi.set(__self__, "backup_minute", backup_minute)
        if bgwriter_delay is not None:
            pulumi.set(__self__, "bgwriter_delay", bgwriter_delay)
        if bgwriter_flush_after is not None:
            pulumi.set(__self__, "bgwriter_flush_after", bgwriter_flush_after)
        if bgwriter_lru_maxpages is not None:
            pulumi.set(__self__, "bgwriter_lru_maxpages", bgwriter_lru_maxpages)
        if bgwriter_lru_multiplier is not None:
            pulumi.set(__self__, "bgwriter_lru_multiplier", bgwriter_lru_multiplier)
        if deadlock_timeout is not None:
            pulumi.set(__self__, "deadlock_timeout", deadlock_timeout)
        if default_toast_compression is not None:
            pulumi.set(__self__, "default_toast_compression", default_toast_compression)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if jit is not None:
            pulumi.set(__self__, "jit", jit)
        if log_autovacuum_min_duration is not None:
            pulumi.set(__self__, "log_autovacuum_min_duration", log_autovacuum_min_duration)
        if log_error_verbosity is not None:
            pulumi.set(__self__, "log_error_verbosity", log_error_verbosity)
        if log_line_prefix is not None:
            pulumi.set(__self__, "log_line_prefix", log_line_prefix)
        if log_min_duration_statement is not None:
            pulumi.set(__self__, "log_min_duration_statement", log_min_duration_statement)
        if log_temp_files is not None:
            pulumi.set(__self__, "log_temp_files", log_temp_files)
        if max_files_per_process is not None:
            pulumi.set(__self__, "max_files_per_process", max_files_per_process)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_logical_replication_workers is not None:
            pulumi.set(__self__, "max_logical_replication_workers", max_logical_replication_workers)
        if max_parallel_workers is not None:
            pulumi.set(__self__, "max_parallel_workers", max_parallel_workers)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_pred_locks_per_transaction is not None:
            pulumi.set(__self__, "max_pred_locks_per_transaction", max_pred_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_slot_wal_keep_size is not None:
            pulumi.set(__self__, "max_slot_wal_keep_size", max_slot_wal_keep_size)
        if max_stack_depth is not None:
            pulumi.set(__self__, "max_stack_depth", max_stack_depth)
        if max_standby_archive_delay is not None:
            pulumi.set(__self__, "max_standby_archive_delay", max_standby_archive_delay)
        if max_standby_streaming_delay is not None:
            pulumi.set(__self__, "max_standby_streaming_delay", max_standby_streaming_delay)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if pg_partman_bgw_interval is not None:
            pulumi.set(__self__, "pg_partman_bgw_interval", pg_partman_bgw_interval)
        if pg_partman_bgw_role is not None:
            pulumi.set(__self__, "pg_partman_bgw_role", pg_partman_bgw_role)
        if pg_stat_monitor_enable is not None:
            pulumi.set(__self__, "pg_stat_monitor_enable", pg_stat_monitor_enable)
        if pg_stat_monitor_pgsm_enable_query_plan is not None:
            pulumi.set(__self__, "pg_stat_monitor_pgsm_enable_query_plan", pg_stat_monitor_pgsm_enable_query_plan)
        if pg_stat_monitor_pgsm_max_buckets is not None:
            pulumi.set(__self__, "pg_stat_monitor_pgsm_max_buckets", pg_stat_monitor_pgsm_max_buckets)
        if pg_stat_statements_track is not None:
            pulumi.set(__self__, "pg_stat_statements_track", pg_stat_statements_track)
        if pgbouncer is not None:
            pulumi.set(__self__, "pgbouncer", pgbouncer)
        if pglookout is not None:
            pulumi.set(__self__, "pglookout", pglookout)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)
        if shared_buffers_percentage is not None:
            pulumi.set(__self__, "shared_buffers_percentage", shared_buffers_percentage)
        if synchronous_replication is not None:
            pulumi.set(__self__, "synchronous_replication", synchronous_replication)
        if temp_file_limit is not None:
            pulumi.set(__self__, "temp_file_limit", temp_file_limit)
        if timescaledb is not None:
            pulumi.set(__self__, "timescaledb", timescaledb)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if track_activity_query_size is not None:
            pulumi.set(__self__, "track_activity_query_size", track_activity_query_size)
        if track_commit_timestamp is not None:
            pulumi.set(__self__, "track_commit_timestamp", track_commit_timestamp)
        if track_functions is not None:
            pulumi.set(__self__, "track_functions", track_functions)
        if track_io_timing is not None:
            pulumi.set(__self__, "track_io_timing", track_io_timing)
        if variant is not None:
            pulumi.set(__self__, "variant", variant)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if wal_sender_timeout is not None:
            pulumi.set(__self__, "wal_sender_timeout", wal_sender_timeout)
        if wal_writer_delay is not None:
            pulumi.set(__self__, "wal_writer_delay", wal_writer_delay)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        Custom username for admin user. This must be set only when a new service is being created.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[bool]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[float]:
        """
        Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size).
        """
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @property
    @pulumi.getter(name="autovacuumAnalyzeThreshold")
    def autovacuum_analyze_threshold(self) -> Optional[int]:
        """
        Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples.
        """
        return pulumi.get(self, "autovacuum_analyze_threshold")

    @property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[int]:
        """
        Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
        """
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[int]:
        """
        Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
        """
        return pulumi.get(self, "autovacuum_max_workers")

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[int]:
        """
        Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute.
        """
        return pulumi.get(self, "autovacuum_naptime")

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[int]:
        """
        Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[int]:
        """
        Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[float]:
        """
        Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size).
        """
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[int]:
        """
        Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples.
        """
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @property
    @pulumi.getter(name="backupHour")
    def backup_hour(self) -> Optional[int]:
        """
        The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_hour")

    @property
    @pulumi.getter(name="backupMinute")
    def backup_minute(self) -> Optional[int]:
        """
        The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
        """
        return pulumi.get(self, "backup_minute")

    @property
    @pulumi.getter(name="bgwriterDelay")
    def bgwriter_delay(self) -> Optional[int]:
        """
        Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
        """
        return pulumi.get(self, "bgwriter_delay")

    @property
    @pulumi.getter(name="bgwriterFlushAfter")
    def bgwriter_flush_after(self) -> Optional[int]:
        """
        Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
        """
        return pulumi.get(self, "bgwriter_flush_after")

    @property
    @pulumi.getter(name="bgwriterLruMaxpages")
    def bgwriter_lru_maxpages(self) -> Optional[int]:
        """
        In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
        """
        return pulumi.get(self, "bgwriter_lru_maxpages")

    @property
    @pulumi.getter(name="bgwriterLruMultiplier")
    def bgwriter_lru_multiplier(self) -> Optional[float]:
        """
        The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
        """
        return pulumi.get(self, "bgwriter_lru_multiplier")

    @property
    @pulumi.getter(name="deadlockTimeout")
    def deadlock_timeout(self) -> Optional[int]:
        """
        This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
        """
        return pulumi.get(self, "deadlock_timeout")

    @property
    @pulumi.getter(name="defaultToastCompression")
    def default_toast_compression(self) -> Optional[str]:
        """
        Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
        """
        return pulumi.get(self, "default_toast_compression")

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[int]:
        """
        Time out sessions with open transactions after this number of milliseconds.
        """
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def jit(self) -> Optional[bool]:
        """
        Controls system-wide use of Just-in-Time Compilation (JIT).
        """
        return pulumi.get(self, "jit")

    @property
    @pulumi.getter(name="logAutovacuumMinDuration")
    def log_autovacuum_min_duration(self) -> Optional[int]:
        """
        Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
        """
        return pulumi.get(self, "log_autovacuum_min_duration")

    @property
    @pulumi.getter(name="logErrorVerbosity")
    def log_error_verbosity(self) -> Optional[str]:
        """
        Controls the amount of detail written in the server log for each message that is logged.
        """
        return pulumi.get(self, "log_error_verbosity")

    @property
    @pulumi.getter(name="logLinePrefix")
    def log_line_prefix(self) -> Optional[str]:
        """
        Choose from one of the available log formats.
        """
        return pulumi.get(self, "log_line_prefix")

    @property
    @pulumi.getter(name="logMinDurationStatement")
    def log_min_duration_statement(self) -> Optional[int]:
        """
        Log statements that take more than this number of milliseconds to run, -1 disables.
        """
        return pulumi.get(self, "log_min_duration_statement")

    @property
    @pulumi.getter(name="logTempFiles")
    def log_temp_files(self) -> Optional[int]:
        """
        Log statements for each temporary file created larger than this number of kilobytes, -1 disables.
        """
        return pulumi.get(self, "log_temp_files")

    @property
    @pulumi.getter(name="maxFilesPerProcess")
    def max_files_per_process(self) -> Optional[int]:
        """
        PostgreSQL maximum number of files that can be open per process.
        """
        return pulumi.get(self, "max_files_per_process")

    @property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[int]:
        """
        PostgreSQL maximum locks per transaction.
        """
        return pulumi.get(self, "max_locks_per_transaction")

    @property
    @pulumi.getter(name="maxLogicalReplicationWorkers")
    def max_logical_replication_workers(self) -> Optional[int]:
        """
        PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers).
        """
        return pulumi.get(self, "max_logical_replication_workers")

    @property
    @pulumi.getter(name="maxParallelWorkers")
    def max_parallel_workers(self) -> Optional[int]:
        """
        Sets the maximum number of workers that the system can support for parallel queries.
        """
        return pulumi.get(self, "max_parallel_workers")

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[int]:
        """
        Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.
        """
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @property
    @pulumi.getter(name="maxPredLocksPerTransaction")
    def max_pred_locks_per_transaction(self) -> Optional[int]:
        """
        PostgreSQL maximum predicate locks per transaction.
        """
        return pulumi.get(self, "max_pred_locks_per_transaction")

    @property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[int]:
        """
        PostgreSQL maximum prepared transactions.
        """
        return pulumi.get(self, "max_prepared_transactions")

    @property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[int]:
        """
        PostgreSQL maximum replication slots.
        """
        return pulumi.get(self, "max_replication_slots")

    @property
    @pulumi.getter(name="maxSlotWalKeepSize")
    def max_slot_wal_keep_size(self) -> Optional[int]:
        """
        PostgreSQL maximum WAL size (MB) reserved for replication slots. Default is -1 (unlimited). wal_keep_size minimum WAL size setting takes precedence over this.
        """
        return pulumi.get(self, "max_slot_wal_keep_size")

    @property
    @pulumi.getter(name="maxStackDepth")
    def max_stack_depth(self) -> Optional[int]:
        """
        Maximum depth of the stack in bytes.
        """
        return pulumi.get(self, "max_stack_depth")

    @property
    @pulumi.getter(name="maxStandbyArchiveDelay")
    def max_standby_archive_delay(self) -> Optional[int]:
        """
        Max standby archive delay in milliseconds.
        """
        return pulumi.get(self, "max_standby_archive_delay")

    @property
    @pulumi.getter(name="maxStandbyStreamingDelay")
    def max_standby_streaming_delay(self) -> Optional[int]:
        """
        Max standby streaming delay in milliseconds.
        """
        return pulumi.get(self, "max_standby_streaming_delay")

    @property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[int]:
        """
        PostgreSQL maximum WAL senders.
        """
        return pulumi.get(self, "max_wal_senders")

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[int]:
        """
        Sets the maximum number of background processes that the system can support.
        """
        return pulumi.get(self, "max_worker_processes")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.ManagedDatabasePostgresqlPropertiesMigration']:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter(name="pgPartmanBgwInterval")
    def pg_partman_bgw_interval(self) -> Optional[int]:
        """
        Sets the time interval to run pg_partman's scheduled tasks.
        """
        return pulumi.get(self, "pg_partman_bgw_interval")

    @property
    @pulumi.getter(name="pgPartmanBgwRole")
    def pg_partman_bgw_role(self) -> Optional[str]:
        """
        Controls which role to use for pg_partman's scheduled background tasks.
        """
        return pulumi.get(self, "pg_partman_bgw_role")

    @property
    @pulumi.getter(name="pgStatMonitorEnable")
    def pg_stat_monitor_enable(self) -> Optional[bool]:
        """
        Enable pg_stat_monitor extension if available for the current cluster. Enable the pg_stat_monitor extension. Enabling this extension will cause the cluster to be restarted.When this extension is enabled, pg_stat_statements results for utility commands are unreliable.
        """
        return pulumi.get(self, "pg_stat_monitor_enable")

    @property
    @pulumi.getter(name="pgStatMonitorPgsmEnableQueryPlan")
    def pg_stat_monitor_pgsm_enable_query_plan(self) -> Optional[bool]:
        """
        Enables or disables query plan monitoring.
        """
        return pulumi.get(self, "pg_stat_monitor_pgsm_enable_query_plan")

    @property
    @pulumi.getter(name="pgStatMonitorPgsmMaxBuckets")
    def pg_stat_monitor_pgsm_max_buckets(self) -> Optional[int]:
        """
        Sets the maximum number of buckets.
        """
        return pulumi.get(self, "pg_stat_monitor_pgsm_max_buckets")

    @property
    @pulumi.getter(name="pgStatStatementsTrack")
    def pg_stat_statements_track(self) -> Optional[str]:
        """
        Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
        """
        return pulumi.get(self, "pg_stat_statements_track")

    @property
    @pulumi.getter
    def pgbouncer(self) -> Optional['outputs.ManagedDatabasePostgresqlPropertiesPgbouncer']:
        """
        PGBouncer connection pooling settings. System-wide settings for pgbouncer.
        """
        return pulumi.get(self, "pgbouncer")

    @property
    @pulumi.getter
    def pglookout(self) -> Optional['outputs.ManagedDatabasePostgresqlPropertiesPglookout']:
        """
        PGLookout settings. System-wide settings for pglookout.
        """
        return pulumi.get(self, "pglookout")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[bool]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[bool]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")

    @property
    @pulumi.getter(name="sharedBuffersPercentage")
    def shared_buffers_percentage(self) -> Optional[float]:
        """
        Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
        """
        return pulumi.get(self, "shared_buffers_percentage")

    @property
    @pulumi.getter(name="synchronousReplication")
    def synchronous_replication(self) -> Optional[str]:
        """
        Synchronous replication type. Note that the service plan also needs to support synchronous replication.
        """
        return pulumi.get(self, "synchronous_replication")

    @property
    @pulumi.getter(name="tempFileLimit")
    def temp_file_limit(self) -> Optional[int]:
        """
        PostgreSQL temporary file limit in KiB, -1 for unlimited.
        """
        return pulumi.get(self, "temp_file_limit")

    @property
    @pulumi.getter
    def timescaledb(self) -> Optional['outputs.ManagedDatabasePostgresqlPropertiesTimescaledb']:
        """
        TimescaleDB extension configuration values. System-wide settings for the timescaledb extension.
        """
        return pulumi.get(self, "timescaledb")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        PostgreSQL service timezone.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="trackActivityQuerySize")
    def track_activity_query_size(self) -> Optional[int]:
        """
        Specifies the number of bytes reserved to track the currently executing command for each active session.
        """
        return pulumi.get(self, "track_activity_query_size")

    @property
    @pulumi.getter(name="trackCommitTimestamp")
    def track_commit_timestamp(self) -> Optional[str]:
        """
        Record commit time of transactions.
        """
        return pulumi.get(self, "track_commit_timestamp")

    @property
    @pulumi.getter(name="trackFunctions")
    def track_functions(self) -> Optional[str]:
        """
        Enables tracking of function call counts and time used.
        """
        return pulumi.get(self, "track_functions")

    @property
    @pulumi.getter(name="trackIoTiming")
    def track_io_timing(self) -> Optional[str]:
        """
        Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
        """
        return pulumi.get(self, "track_io_timing")

    @property
    @pulumi.getter
    def variant(self) -> Optional[str]:
        """
        Variant of the PostgreSQL service, may affect the features that are exposed by default.
        """
        return pulumi.get(self, "variant")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        PostgreSQL major version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="walSenderTimeout")
    def wal_sender_timeout(self) -> Optional[int]:
        """
        Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to zero disables the timeout.
        """
        return pulumi.get(self, "wal_sender_timeout")

    @property
    @pulumi.getter(name="walWriterDelay")
    def wal_writer_delay(self) -> Optional[int]:
        """
        WAL flush interval in milliseconds. Note that setting this value to lower than the default 200ms may negatively impact performance.
        """
        return pulumi.get(self, "wal_writer_delay")

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[int]:
        """
        Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
        """
        return pulumi.get(self, "work_mem")


@pulumi.output_type
class ManagedDatabasePostgresqlPropertiesMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"
        elif key == "ignoreRoles":
            suggest = "ignore_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabasePostgresqlPropertiesMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabasePostgresqlPropertiesMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabasePostgresqlPropertiesMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 ignore_roles: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 ssl: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str dbname: Database name for bootstrapping the initial connection.
        :param str host: Hostname or IP address of the server where to migrate data from.
        :param str ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param str ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param str method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param str password: Password for authentication with the server where to migrate data from.
        :param int port: Port number of the server where to migrate data from.
        :param bool ssl: The server where to migrate data from is secured with SSL.
        :param str username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[str]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ManagedDatabasePostgresqlPropertiesPgbouncer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autodbIdleTimeout":
            suggest = "autodb_idle_timeout"
        elif key == "autodbMaxDbConnections":
            suggest = "autodb_max_db_connections"
        elif key == "autodbPoolMode":
            suggest = "autodb_pool_mode"
        elif key == "autodbPoolSize":
            suggest = "autodb_pool_size"
        elif key == "ignoreStartupParameters":
            suggest = "ignore_startup_parameters"
        elif key == "maxPreparedStatements":
            suggest = "max_prepared_statements"
        elif key == "minPoolSize":
            suggest = "min_pool_size"
        elif key == "serverIdleTimeout":
            suggest = "server_idle_timeout"
        elif key == "serverLifetime":
            suggest = "server_lifetime"
        elif key == "serverResetQueryAlways":
            suggest = "server_reset_query_always"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabasePostgresqlPropertiesPgbouncer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabasePostgresqlPropertiesPgbouncer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabasePostgresqlPropertiesPgbouncer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[int] = None,
                 autodb_max_db_connections: Optional[int] = None,
                 autodb_pool_mode: Optional[str] = None,
                 autodb_pool_size: Optional[int] = None,
                 ignore_startup_parameters: Optional[Sequence[str]] = None,
                 max_prepared_statements: Optional[int] = None,
                 min_pool_size: Optional[int] = None,
                 server_idle_timeout: Optional[int] = None,
                 server_lifetime: Optional[int] = None,
                 server_reset_query_always: Optional[bool] = None):
        """
        :param int autodb_idle_timeout: If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].
        :param int autodb_max_db_connections: Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
        :param str autodb_pool_mode: PGBouncer pool mode.
        :param int autodb_pool_size: If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
        :param Sequence[str] ignore_startup_parameters: List of parameters to ignore when given in startup packet.
        :param int max_prepared_statements: PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.
        :param int min_pool_size: Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        :param int server_idle_timeout: If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].
        :param int server_lifetime: The pooler will close an unused server connection that has been connected longer than this. [seconds].
        :param bool server_reset_query_always: Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if max_prepared_statements is not None:
            pulumi.set(__self__, "max_prepared_statements", max_prepared_statements)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[int]:
        """
        If the automatically created database pools have been unused this many seconds, they are freed. If 0 then timeout is disabled. [seconds].
        """
        return pulumi.get(self, "autodb_idle_timeout")

    @property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[int]:
        """
        Do not allow more than this many server connections per database (regardless of user). Setting it to 0 means unlimited.
        """
        return pulumi.get(self, "autodb_max_db_connections")

    @property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[str]:
        """
        PGBouncer pool mode.
        """
        return pulumi.get(self, "autodb_pool_mode")

    @property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[int]:
        """
        If non-zero then create automatically a pool of that size per user when a pool doesn't exist.
        """
        return pulumi.get(self, "autodb_pool_size")

    @property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[Sequence[str]]:
        """
        List of parameters to ignore when given in startup packet.
        """
        return pulumi.get(self, "ignore_startup_parameters")

    @property
    @pulumi.getter(name="maxPreparedStatements")
    def max_prepared_statements(self) -> Optional[int]:
        """
        PgBouncer tracks protocol-level named prepared statements related commands sent by the client in transaction and statement pooling modes when max_prepared_statements is set to a non-zero value. Setting it to 0 disables prepared statements. max_prepared_statements defaults to 100, and its maximum is 3000.
        """
        return pulumi.get(self, "max_prepared_statements")

    @property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[int]:
        """
        Add more server connections to pool if below this number. Improves behavior when usual load comes suddenly back after period of total inactivity. The value is effectively capped at the pool size.
        """
        return pulumi.get(self, "min_pool_size")

    @property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[int]:
        """
        If a server connection has been idle more than this many seconds it will be dropped. If 0 then timeout is disabled. [seconds].
        """
        return pulumi.get(self, "server_idle_timeout")

    @property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[int]:
        """
        The pooler will close an unused server connection that has been connected longer than this. [seconds].
        """
        return pulumi.get(self, "server_lifetime")

    @property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[bool]:
        """
        Run server_reset_query (DISCARD ALL) in all pooling modes.
        """
        return pulumi.get(self, "server_reset_query_always")


@pulumi.output_type
class ManagedDatabasePostgresqlPropertiesPglookout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxFailoverReplicationTimeLag":
            suggest = "max_failover_replication_time_lag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabasePostgresqlPropertiesPglookout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabasePostgresqlPropertiesPglookout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabasePostgresqlPropertiesPglookout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_failover_replication_time_lag: Optional[int] = None):
        """
        :param int max_failover_replication_time_lag: Number of seconds of master unavailability before triggering database failover to standby.
        """
        if max_failover_replication_time_lag is not None:
            pulumi.set(__self__, "max_failover_replication_time_lag", max_failover_replication_time_lag)

    @property
    @pulumi.getter(name="maxFailoverReplicationTimeLag")
    def max_failover_replication_time_lag(self) -> Optional[int]:
        """
        Number of seconds of master unavailability before triggering database failover to standby.
        """
        return pulumi.get(self, "max_failover_replication_time_lag")


@pulumi.output_type
class ManagedDatabasePostgresqlPropertiesTimescaledb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBackgroundWorkers":
            suggest = "max_background_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabasePostgresqlPropertiesTimescaledb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabasePostgresqlPropertiesTimescaledb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabasePostgresqlPropertiesTimescaledb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_background_workers: Optional[int] = None):
        """
        :param int max_background_workers: The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[int]:
        """
        The number of background workers for timescaledb operations. You should configure this setting to the sum of your number of databases and the total number of concurrent background workers you want running at any given point in time.
        """
        return pulumi.get(self, "max_background_workers")


@pulumi.output_type
class ManagedDatabaseRedisComponent(dict):
    def __init__(__self__, *,
                 component: Optional[str] = None,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 route: Optional[str] = None,
                 usage: Optional[str] = None):
        """
        :param str component: Type of the component
        :param str host: Hostname of the component
        :param int port: Port number of the component
        :param str route: Component network route type
        :param str usage: Usage of the component
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        """
        Type of the component
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Hostname of the component
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number of the component
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        """
        Component network route type
        """
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def usage(self) -> Optional[str]:
        """
        Usage of the component
        """
        return pulumi.get(self, "usage")


@pulumi.output_type
class ManagedDatabaseRedisNetwork(dict):
    def __init__(__self__, *,
                 family: str,
                 name: str,
                 type: str,
                 uuid: str):
        """
        :param str family: Network family. Currently only `IPv4` is supported.
        :param str name: The name of the network. Must be unique within the service.
        :param str type: The type of the network. Must be private.
        :param str uuid: Private network UUID. Must reside in the same zone as the database.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        Network family. Currently only `IPv4` is supported.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the network. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the network. Must be private.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        Private network UUID. Must reside in the same zone as the database.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ManagedDatabaseRedisNodeState(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 role: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str name: Name plus a node iteration
        :param str role: Role of the node
        :param str state: State of the node
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name plus a node iteration
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role of the node
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of the node
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ManagedDatabaseRedisProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticUtilityNetworkIpFilter":
            suggest = "automatic_utility_network_ip_filter"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "redisAclChannelsDefault":
            suggest = "redis_acl_channels_default"
        elif key == "redisIoThreads":
            suggest = "redis_io_threads"
        elif key == "redisLfuDecayTime":
            suggest = "redis_lfu_decay_time"
        elif key == "redisLfuLogFactor":
            suggest = "redis_lfu_log_factor"
        elif key == "redisMaxmemoryPolicy":
            suggest = "redis_maxmemory_policy"
        elif key == "redisNotifyKeyspaceEvents":
            suggest = "redis_notify_keyspace_events"
        elif key == "redisNumberOfDatabases":
            suggest = "redis_number_of_databases"
        elif key == "redisPersistence":
            suggest = "redis_persistence"
        elif key == "redisPubsubClientOutputBufferLimit":
            suggest = "redis_pubsub_client_output_buffer_limit"
        elif key == "redisSsl":
            suggest = "redis_ssl"
        elif key == "redisTimeout":
            suggest = "redis_timeout"
        elif key == "redisVersion":
            suggest = "redis_version"
        elif key == "serviceLog":
            suggest = "service_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseRedisProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseRedisProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseRedisProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_utility_network_ip_filter: Optional[bool] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 migration: Optional['outputs.ManagedDatabaseRedisPropertiesMigration'] = None,
                 public_access: Optional[bool] = None,
                 redis_acl_channels_default: Optional[str] = None,
                 redis_io_threads: Optional[int] = None,
                 redis_lfu_decay_time: Optional[int] = None,
                 redis_lfu_log_factor: Optional[int] = None,
                 redis_maxmemory_policy: Optional[str] = None,
                 redis_notify_keyspace_events: Optional[str] = None,
                 redis_number_of_databases: Optional[int] = None,
                 redis_persistence: Optional[str] = None,
                 redis_pubsub_client_output_buffer_limit: Optional[int] = None,
                 redis_ssl: Optional[bool] = None,
                 redis_timeout: Optional[int] = None,
                 redis_version: Optional[str] = None,
                 service_log: Optional[bool] = None):
        """
        :param bool automatic_utility_network_ip_filter: Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        :param Sequence[str] ip_filters: IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        :param 'ManagedDatabaseRedisPropertiesMigrationArgs' migration: Migrate data from existing server.
        :param bool public_access: Public Access. Allow access to the service from the public Internet.
        :param str redis_acl_channels_default: Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        :param int redis_io_threads: Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.
        :param int redis_lfu_decay_time: LFU maxmemory-policy counter decay time in minutes.
        :param int redis_lfu_log_factor: Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        :param str redis_maxmemory_policy: Redis maxmemory-policy.
        :param str redis_notify_keyspace_events: Set notify-keyspace-events option.
        :param int redis_number_of_databases: Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.
        :param str redis_persistence: Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.
        :param int redis_pubsub_client_output_buffer_limit: Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        :param bool redis_ssl: Require SSL to access Redis.
        :param int redis_timeout: Redis idle connection timeout in seconds.
        :param str redis_version: Redis major version.
        :param bool service_log: Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        if automatic_utility_network_ip_filter is not None:
            pulumi.set(__self__, "automatic_utility_network_ip_filter", automatic_utility_network_ip_filter)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if redis_acl_channels_default is not None:
            pulumi.set(__self__, "redis_acl_channels_default", redis_acl_channels_default)
        if redis_io_threads is not None:
            pulumi.set(__self__, "redis_io_threads", redis_io_threads)
        if redis_lfu_decay_time is not None:
            pulumi.set(__self__, "redis_lfu_decay_time", redis_lfu_decay_time)
        if redis_lfu_log_factor is not None:
            pulumi.set(__self__, "redis_lfu_log_factor", redis_lfu_log_factor)
        if redis_maxmemory_policy is not None:
            pulumi.set(__self__, "redis_maxmemory_policy", redis_maxmemory_policy)
        if redis_notify_keyspace_events is not None:
            pulumi.set(__self__, "redis_notify_keyspace_events", redis_notify_keyspace_events)
        if redis_number_of_databases is not None:
            pulumi.set(__self__, "redis_number_of_databases", redis_number_of_databases)
        if redis_persistence is not None:
            pulumi.set(__self__, "redis_persistence", redis_persistence)
        if redis_pubsub_client_output_buffer_limit is not None:
            pulumi.set(__self__, "redis_pubsub_client_output_buffer_limit", redis_pubsub_client_output_buffer_limit)
        if redis_ssl is not None:
            pulumi.set(__self__, "redis_ssl", redis_ssl)
        if redis_timeout is not None:
            pulumi.set(__self__, "redis_timeout", redis_timeout)
        if redis_version is not None:
            pulumi.set(__self__, "redis_version", redis_version)
        if service_log is not None:
            pulumi.set(__self__, "service_log", service_log)

    @property
    @pulumi.getter(name="automaticUtilityNetworkIpFilter")
    def automatic_utility_network_ip_filter(self) -> Optional[bool]:
        """
        Automatic utility network IP Filter. Automatically allow connections from servers in the utility network within the same zone.
        """
        return pulumi.get(self, "automatic_utility_network_ip_filter")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        IP filter. Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.ManagedDatabaseRedisPropertiesMigration']:
        """
        Migrate data from existing server.
        """
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[bool]:
        """
        Public Access. Allow access to the service from the public Internet.
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter(name="redisAclChannelsDefault")
    def redis_acl_channels_default(self) -> Optional[str]:
        """
        Default ACL for pub/sub channels used when Redis user is created. Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
        """
        return pulumi.get(self, "redis_acl_channels_default")

    @property
    @pulumi.getter(name="redisIoThreads")
    def redis_io_threads(self) -> Optional[int]:
        """
        Redis IO thread count. Set Redis IO thread count. Changing this will cause a restart of the Redis service.
        """
        return pulumi.get(self, "redis_io_threads")

    @property
    @pulumi.getter(name="redisLfuDecayTime")
    def redis_lfu_decay_time(self) -> Optional[int]:
        """
        LFU maxmemory-policy counter decay time in minutes.
        """
        return pulumi.get(self, "redis_lfu_decay_time")

    @property
    @pulumi.getter(name="redisLfuLogFactor")
    def redis_lfu_log_factor(self) -> Optional[int]:
        """
        Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies.
        """
        return pulumi.get(self, "redis_lfu_log_factor")

    @property
    @pulumi.getter(name="redisMaxmemoryPolicy")
    def redis_maxmemory_policy(self) -> Optional[str]:
        """
        Redis maxmemory-policy.
        """
        return pulumi.get(self, "redis_maxmemory_policy")

    @property
    @pulumi.getter(name="redisNotifyKeyspaceEvents")
    def redis_notify_keyspace_events(self) -> Optional[str]:
        """
        Set notify-keyspace-events option.
        """
        return pulumi.get(self, "redis_notify_keyspace_events")

    @property
    @pulumi.getter(name="redisNumberOfDatabases")
    def redis_number_of_databases(self) -> Optional[int]:
        """
        Number of Redis databases. Set number of Redis databases. Changing this will cause a restart of the Redis service.
        """
        return pulumi.get(self, "redis_number_of_databases")

    @property
    @pulumi.getter(name="redisPersistence")
    def redis_persistence(self) -> Optional[str]:
        """
        Redis persistence. When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to the backup schedule for backup purposes. When persistence is 'off', no RDB dumps or backups are done, so data can be lost at any moment if the service is restarted for any reason, or if the service is powered off. Also, the service can't be forked.
        """
        return pulumi.get(self, "redis_persistence")

    @property
    @pulumi.getter(name="redisPubsubClientOutputBufferLimit")
    def redis_pubsub_client_output_buffer_limit(self) -> Optional[int]:
        """
        Pub/sub client output buffer hard limit in MB. Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
        """
        return pulumi.get(self, "redis_pubsub_client_output_buffer_limit")

    @property
    @pulumi.getter(name="redisSsl")
    def redis_ssl(self) -> Optional[bool]:
        """
        Require SSL to access Redis.
        """
        return pulumi.get(self, "redis_ssl")

    @property
    @pulumi.getter(name="redisTimeout")
    def redis_timeout(self) -> Optional[int]:
        """
        Redis idle connection timeout in seconds.
        """
        return pulumi.get(self, "redis_timeout")

    @property
    @pulumi.getter(name="redisVersion")
    def redis_version(self) -> Optional[str]:
        """
        Redis major version.
        """
        return pulumi.get(self, "redis_version")

    @property
    @pulumi.getter(name="serviceLog")
    def service_log(self) -> Optional[bool]:
        """
        Service logging. Store logs for the service so that they are available in the HTTP API and console.
        """
        return pulumi.get(self, "service_log")


@pulumi.output_type
class ManagedDatabaseRedisPropertiesMigration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDbs":
            suggest = "ignore_dbs"
        elif key == "ignoreRoles":
            suggest = "ignore_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseRedisPropertiesMigration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseRedisPropertiesMigration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseRedisPropertiesMigration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbname: Optional[str] = None,
                 host: Optional[str] = None,
                 ignore_dbs: Optional[str] = None,
                 ignore_roles: Optional[str] = None,
                 method: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 ssl: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str dbname: Database name for bootstrapping the initial connection.
        :param str host: Hostname or IP address of the server where to migrate data from.
        :param str ignore_dbs: Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        :param str ignore_roles: Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        :param str method: The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        :param str password: Password for authentication with the server where to migrate data from.
        :param int port: Port number of the server where to migrate data from.
        :param bool ssl: The server where to migrate data from is secured with SSL.
        :param str username: User name for authentication with the server where to migrate data from.
        """
        if dbname is not None:
            pulumi.set(__self__, "dbname", dbname)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ignore_dbs is not None:
            pulumi.set(__self__, "ignore_dbs", ignore_dbs)
        if ignore_roles is not None:
            pulumi.set(__self__, "ignore_roles", ignore_roles)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def dbname(self) -> Optional[str]:
        """
        Database name for bootstrapping the initial connection.
        """
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Hostname or IP address of the server where to migrate data from.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="ignoreDbs")
    def ignore_dbs(self) -> Optional[str]:
        """
        Comma-separated list of databases, which should be ignored during migration (supported by MySQL and PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_dbs")

    @property
    @pulumi.getter(name="ignoreRoles")
    def ignore_roles(self) -> Optional[str]:
        """
        Comma-separated list of database roles, which should be ignored during migration (supported by PostgreSQL only at the moment).
        """
        return pulumi.get(self, "ignore_roles")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The migration method to be used (currently supported only by Redis, Dragonfly, MySQL and PostgreSQL service types).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number of the server where to migrate data from.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        """
        The server where to migrate data from is secured with SSL.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        User name for authentication with the server where to migrate data from.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ManagedDatabaseUserOpensearchAccessControl(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.ManagedDatabaseUserOpensearchAccessControlRule']):
        """
        :param Sequence['ManagedDatabaseUserOpensearchAccessControlRuleArgs'] rules: Set user access control rules.
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ManagedDatabaseUserOpensearchAccessControlRule']:
        """
        Set user access control rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ManagedDatabaseUserOpensearchAccessControlRule(dict):
    def __init__(__self__, *,
                 index: str,
                 permission: str):
        """
        :param str index: Set index name, pattern or top level API.
        :param str permission: Set permission access.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Set index name, pattern or top level API.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def permission(self) -> str:
        """
        Set permission access.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class ManagedDatabaseUserPgAccessControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowReplication":
            suggest = "allow_replication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedDatabaseUserPgAccessControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedDatabaseUserPgAccessControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedDatabaseUserPgAccessControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_replication: Optional[bool] = None):
        """
        :param bool allow_replication: Grant replication privilege
        """
        if allow_replication is not None:
            pulumi.set(__self__, "allow_replication", allow_replication)

    @property
    @pulumi.getter(name="allowReplication")
    def allow_replication(self) -> Optional[bool]:
        """
        Grant replication privilege
        """
        return pulumi.get(self, "allow_replication")


@pulumi.output_type
class ManagedDatabaseUserRedisAccessControl(dict):
    def __init__(__self__, *,
                 categories: Optional[str] = None,
                 channels: Optional[str] = None,
                 commands: Optional[str] = None,
                 keys: Optional[str] = None):
        """
        :param str categories: Set access control to all commands in specified categories.
        :param str channels: Set access control to Pub/Sub channels.
        :param str commands: Set access control to commands.
        :param str keys: Set access control to keys.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def categories(self) -> Optional[str]:
        """
        Set access control to all commands in specified categories.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def channels(self) -> Optional[str]:
        """
        Set access control to Pub/Sub channels.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def commands(self) -> Optional[str]:
        """
        Set access control to commands.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def keys(self) -> Optional[str]:
        """
        Set access control to keys.
        """
        return pulumi.get(self, "keys")


@pulumi.output_type
class ManagedObjectStorageEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "iamUrl":
            suggest = "iam_url"
        elif key == "stsUrl":
            suggest = "sts_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedObjectStorageEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedObjectStorageEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedObjectStorageEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: Optional[str] = None,
                 iam_url: Optional[str] = None,
                 sts_url: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str domain_name: Domain name of the endpoint.
        :param str iam_url: URL for IAM.
        :param str sts_url: URL for STS.
        :param str type: Type of the endpoint (`private` / `public`).
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if iam_url is not None:
            pulumi.set(__self__, "iam_url", iam_url)
        if sts_url is not None:
            pulumi.set(__self__, "sts_url", sts_url)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        Domain name of the endpoint.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="iamUrl")
    def iam_url(self) -> Optional[str]:
        """
        URL for IAM.
        """
        return pulumi.get(self, "iam_url")

    @property
    @pulumi.getter(name="stsUrl")
    def sts_url(self) -> Optional[str]:
        """
        URL for STS.
        """
        return pulumi.get(self, "sts_url")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the endpoint (`private` / `public`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagedObjectStorageNetwork(dict):
    def __init__(__self__, *,
                 family: str,
                 name: str,
                 type: str,
                 uuid: Optional[str] = None):
        """
        :param str family: Network family. IPv6 currently not supported.
        :param str name: Network name. Must be unique within the service.
        :param str type: Network type.
        :param str uuid: Private network uuid. For public networks the field should be omitted.
        """
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        Network family. IPv6 currently not supported.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Network name. Must be unique within the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        Private network uuid. For public networks the field should be omitted.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class NetworkIpNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dhcpDefaultRoute":
            suggest = "dhcp_default_route"
        elif key == "dhcpDns":
            suggest = "dhcp_dns"
        elif key == "dhcpRoutes":
            suggest = "dhcp_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkIpNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkIpNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkIpNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 dhcp: bool,
                 family: str,
                 dhcp_default_route: Optional[bool] = None,
                 dhcp_dns: Optional[Sequence[str]] = None,
                 dhcp_routes: Optional[Sequence[str]] = None,
                 gateway: Optional[str] = None):
        """
        :param str address: The CIDR range of the subnet
        :param bool dhcp: Is DHCP enabled?
        :param str family: IP address family
        :param bool dhcp_default_route: Is the gateway the DHCP default route?
        :param Sequence[str] dhcp_dns: The DNS servers given by DHCP
        :param Sequence[str] dhcp_routes: The additional DHCP classless static routes given by DHCP
        :param str gateway: Gateway address given by DHCP
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "family", family)
        if dhcp_default_route is not None:
            pulumi.set(__self__, "dhcp_default_route", dhcp_default_route)
        if dhcp_dns is not None:
            pulumi.set(__self__, "dhcp_dns", dhcp_dns)
        if dhcp_routes is not None:
            pulumi.set(__self__, "dhcp_routes", dhcp_routes)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The CIDR range of the subnet
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        """
        Is DHCP enabled?
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        IP address family
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter(name="dhcpDefaultRoute")
    def dhcp_default_route(self) -> Optional[bool]:
        """
        Is the gateway the DHCP default route?
        """
        return pulumi.get(self, "dhcp_default_route")

    @property
    @pulumi.getter(name="dhcpDns")
    def dhcp_dns(self) -> Optional[Sequence[str]]:
        """
        The DNS servers given by DHCP
        """
        return pulumi.get(self, "dhcp_dns")

    @property
    @pulumi.getter(name="dhcpRoutes")
    def dhcp_routes(self) -> Optional[Sequence[str]]:
        """
        The additional DHCP classless static routes given by DHCP
        """
        return pulumi.get(self, "dhcp_routes")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        Gateway address given by DHCP
        """
        return pulumi.get(self, "gateway")


@pulumi.output_type
class NetworkPeeringNetwork(dict):
    def __init__(__self__, *,
                 uuid: str):
        """
        :param str uuid: The UUID of the network.
        """
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        The UUID of the network.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class NetworkPeeringPeerNetwork(dict):
    def __init__(__self__, *,
                 uuid: str):
        """
        :param str uuid: The UUID of the network.
        """
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        The UUID of the network.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class ObjectStorageBucket(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the bucket
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the bucket
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RouterStaticRoute(dict):
    def __init__(__self__, *,
                 name: str,
                 nexthop: str,
                 route: str,
                 type: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nexthop", nexthop)
        pulumi.set(__self__, "route", route)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def nexthop(self) -> str:
        return pulumi.get(self, "nexthop")

    @property
    @pulumi.getter
    def route(self) -> str:
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerFirewallRulesFirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddressEnd":
            suggest = "destination_address_end"
        elif key == "destinationAddressStart":
            suggest = "destination_address_start"
        elif key == "destinationPortEnd":
            suggest = "destination_port_end"
        elif key == "destinationPortStart":
            suggest = "destination_port_start"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "sourceAddressEnd":
            suggest = "source_address_end"
        elif key == "sourceAddressStart":
            suggest = "source_address_start"
        elif key == "sourcePortEnd":
            suggest = "source_port_end"
        elif key == "sourcePortStart":
            suggest = "source_port_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerFirewallRulesFirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerFirewallRulesFirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerFirewallRulesFirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 direction: str,
                 comment: Optional[str] = None,
                 destination_address_end: Optional[str] = None,
                 destination_address_start: Optional[str] = None,
                 destination_port_end: Optional[str] = None,
                 destination_port_start: Optional[str] = None,
                 family: Optional[str] = None,
                 icmp_type: Optional[str] = None,
                 protocol: Optional[str] = None,
                 source_address_end: Optional[str] = None,
                 source_address_start: Optional[str] = None,
                 source_port_end: Optional[str] = None,
                 source_port_start: Optional[str] = None):
        """
        :param str action: Action to take if the rule conditions are met
        :param str direction: The direction of network traffic this rule will be applied to
        :param str comment: Freeform comment string for the rule
        :param str destination_address_end: The destination address range ends from this address
        :param str destination_address_start: The destination address range starts from this address
        :param str destination_port_end: The destination port range ends from this port number
        :param str destination_port_start: The destination port range starts from this port number
        :param str family: The address family of new firewall rule
        :param str icmp_type: The ICMP type
        :param str protocol: The protocol this rule will be applied to
        :param str source_address_end: The source address range ends from this address
        :param str source_address_start: The source address range starts from this address
        :param str source_port_end: The source port range ends from this port number
        :param str source_port_start: The source port range starts from this port number
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "direction", direction)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if destination_address_end is not None:
            pulumi.set(__self__, "destination_address_end", destination_address_end)
        if destination_address_start is not None:
            pulumi.set(__self__, "destination_address_start", destination_address_start)
        if destination_port_end is not None:
            pulumi.set(__self__, "destination_port_end", destination_port_end)
        if destination_port_start is not None:
            pulumi.set(__self__, "destination_port_start", destination_port_start)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_address_end is not None:
            pulumi.set(__self__, "source_address_end", source_address_end)
        if source_address_start is not None:
            pulumi.set(__self__, "source_address_start", source_address_start)
        if source_port_end is not None:
            pulumi.set(__self__, "source_port_end", source_port_end)
        if source_port_start is not None:
            pulumi.set(__self__, "source_port_start", source_port_start)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to take if the rule conditions are met
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction of network traffic this rule will be applied to
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Freeform comment string for the rule
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="destinationAddressEnd")
    def destination_address_end(self) -> Optional[str]:
        """
        The destination address range ends from this address
        """
        return pulumi.get(self, "destination_address_end")

    @property
    @pulumi.getter(name="destinationAddressStart")
    def destination_address_start(self) -> Optional[str]:
        """
        The destination address range starts from this address
        """
        return pulumi.get(self, "destination_address_start")

    @property
    @pulumi.getter(name="destinationPortEnd")
    def destination_port_end(self) -> Optional[str]:
        """
        The destination port range ends from this port number
        """
        return pulumi.get(self, "destination_port_end")

    @property
    @pulumi.getter(name="destinationPortStart")
    def destination_port_start(self) -> Optional[str]:
        """
        The destination port range starts from this port number
        """
        return pulumi.get(self, "destination_port_start")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        The address family of new firewall rule
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[str]:
        """
        The ICMP type
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol this rule will be applied to
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddressEnd")
    def source_address_end(self) -> Optional[str]:
        """
        The source address range ends from this address
        """
        return pulumi.get(self, "source_address_end")

    @property
    @pulumi.getter(name="sourceAddressStart")
    def source_address_start(self) -> Optional[str]:
        """
        The source address range starts from this address
        """
        return pulumi.get(self, "source_address_start")

    @property
    @pulumi.getter(name="sourcePortEnd")
    def source_port_end(self) -> Optional[str]:
        """
        The source port range ends from this port number
        """
        return pulumi.get(self, "source_port_end")

    @property
    @pulumi.getter(name="sourcePortStart")
    def source_port_start(self) -> Optional[str]:
        """
        The source port range starts from this port number
        """
        return pulumi.get(self, "source_port_start")


@pulumi.output_type
class ServerLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createPassword":
            suggest = "create_password"
        elif key == "passwordDelivery":
            suggest = "password_delivery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_password: Optional[bool] = None,
                 keys: Optional[Sequence[str]] = None,
                 password_delivery: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param bool create_password: Indicates a password should be create to allow access
        :param Sequence[str] keys: A list of ssh keys to access the server
        :param str password_delivery: The delivery method for the server's root password (one of `none`, `email` or `sms`)
        :param str user: Username to be create to access the server
        """
        if create_password is not None:
            pulumi.set(__self__, "create_password", create_password)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if password_delivery is not None:
            pulumi.set(__self__, "password_delivery", password_delivery)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="createPassword")
    def create_password(self) -> Optional[bool]:
        """
        Indicates a password should be create to allow access
        """
        return pulumi.get(self, "create_password")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[str]]:
        """
        A list of ssh keys to access the server
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter(name="passwordDelivery")
    def password_delivery(self) -> Optional[str]:
        """
        The delivery method for the server's root password (one of `none`, `email` or `sms`)
        """
        return pulumi.get(self, "password_delivery")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        Username to be create to access the server
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ServerNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalIpAddresses":
            suggest = "additional_ip_addresses"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipAddressFamily":
            suggest = "ip_address_family"
        elif key == "ipAddressFloating":
            suggest = "ip_address_floating"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "sourceIpFiltering":
            suggest = "source_ip_filtering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 additional_ip_addresses: Optional[Sequence['outputs.ServerNetworkInterfaceAdditionalIpAddress']] = None,
                 bootable: Optional[bool] = None,
                 ip_address: Optional[str] = None,
                 ip_address_family: Optional[str] = None,
                 ip_address_floating: Optional[bool] = None,
                 mac_address: Optional[str] = None,
                 network: Optional[str] = None,
                 source_ip_filtering: Optional[bool] = None):
        """
        :param str type: Network interface type. For private network interfaces, a network must be specified with an existing network id.
        :param Sequence['ServerNetworkInterfaceAdditionalIpAddressArgs'] additional_ip_addresses: 0-4 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`
        :param bool bootable: `true` if this interface should be used for network booting.
        :param str ip_address: The assigned primary IP address.
        :param str ip_address_family: The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).
        :param bool ip_address_floating: `true` indicates that the primary IP address is a floating IP address.
        :param str mac_address: The assigned MAC address.
        :param str network: The unique ID of a network to attach this network to.
        :param bool source_ip_filtering: `true` if source IP should be filtered.
        """
        pulumi.set(__self__, "type", type)
        if additional_ip_addresses is not None:
            pulumi.set(__self__, "additional_ip_addresses", additional_ip_addresses)
        if bootable is not None:
            pulumi.set(__self__, "bootable", bootable)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_address_family is not None:
            pulumi.set(__self__, "ip_address_family", ip_address_family)
        if ip_address_floating is not None:
            pulumi.set(__self__, "ip_address_floating", ip_address_floating)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if source_ip_filtering is not None:
            pulumi.set(__self__, "source_ip_filtering", source_ip_filtering)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network interface type. For private network interfaces, a network must be specified with an existing network id.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalIpAddresses")
    def additional_ip_addresses(self) -> Optional[Sequence['outputs.ServerNetworkInterfaceAdditionalIpAddress']]:
        """
        0-4 blocks of additional IP addresses to assign to this interface. Allowed only with network interfaces of type `private`
        """
        return pulumi.get(self, "additional_ip_addresses")

    @property
    @pulumi.getter
    def bootable(self) -> Optional[bool]:
        """
        `true` if this interface should be used for network booting.
        """
        return pulumi.get(self, "bootable")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The assigned primary IP address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="ipAddressFamily")
    def ip_address_family(self) -> Optional[str]:
        """
        The type of the primary IP address of this interface (one of `IPv4` or `IPv6`).
        """
        return pulumi.get(self, "ip_address_family")

    @property
    @pulumi.getter(name="ipAddressFloating")
    def ip_address_floating(self) -> Optional[bool]:
        """
        `true` indicates that the primary IP address is a floating IP address.
        """
        return pulumi.get(self, "ip_address_floating")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        The assigned MAC address.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        """
        The unique ID of a network to attach this network to.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="sourceIpFiltering")
    def source_ip_filtering(self) -> Optional[bool]:
        """
        `true` if source IP should be filtered.
        """
        return pulumi.get(self, "source_ip_filtering")


@pulumi.output_type
class ServerNetworkInterfaceAdditionalIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipAddressFamily":
            suggest = "ip_address_family"
        elif key == "ipAddressFloating":
            suggest = "ip_address_floating"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNetworkInterfaceAdditionalIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNetworkInterfaceAdditionalIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNetworkInterfaceAdditionalIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: Optional[str] = None,
                 ip_address_family: Optional[str] = None,
                 ip_address_floating: Optional[bool] = None):
        """
        :param str ip_address: The assigned additional IP address.
        :param str ip_address_family: The type of this additional IP address of this interface (one of `IPv4` or `IPv6`).
        :param bool ip_address_floating: `true` indicates that the additional IP address is a floating IP address.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_address_family is not None:
            pulumi.set(__self__, "ip_address_family", ip_address_family)
        if ip_address_floating is not None:
            pulumi.set(__self__, "ip_address_floating", ip_address_floating)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The assigned additional IP address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="ipAddressFamily")
    def ip_address_family(self) -> Optional[str]:
        """
        The type of this additional IP address of this interface (one of `IPv4` or `IPv6`).
        """
        return pulumi.get(self, "ip_address_family")

    @property
    @pulumi.getter(name="ipAddressFloating")
    def ip_address_floating(self) -> Optional[bool]:
        """
        `true` indicates that the additional IP address is a floating IP address.
        """
        return pulumi.get(self, "ip_address_floating")


@pulumi.output_type
class ServerSimpleBackup(dict):
    def __init__(__self__, *,
                 plan: str,
                 time: str):
        """
        :param str plan: Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.
        :param str time: Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).
        """
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Simple backup plan. Accepted values: daily, dailies, weeklies, monthlies.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        Time of the day at which backup will be taken. Should be provided in a hhmm format (e.g. 2230).
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class ServerStorageDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPosition":
            suggest = "address_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerStorageDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerStorageDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerStorageDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage: str,
                 address: Optional[str] = None,
                 address_position: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str storage: A valid storage UUID
        :param str address: The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        :param str address_position: The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.
        :param str type: The device type the storage will be attached as
        """
        pulumi.set(__self__, "storage", storage)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_position is not None:
            pulumi.set(__self__, "address_position", address_position)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def storage(self) -> str:
        """
        A valid storage UUID
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="addressPosition")
    def address_position(self) -> Optional[str]:
        """
        The device position in the given bus (defined via field `address`). Valid values for address `virtio` are `0-15` (`0`, for example). Valid values for `scsi` or `ide` are `0-1:0-1` (`0:0`, for example). Leave empty to auto-select next available address in the given bus.
        """
        return pulumi.get(self, "address_position")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The device type the storage will be attached as
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPosition":
            suggest = "address_position"
        elif key == "backupRule":
            suggest = "backup_rule"
        elif key == "deleteAutoresizeBackup":
            suggest = "delete_autoresize_backup"
        elif key == "filesystemAutoresize":
            suggest = "filesystem_autoresize"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage: str,
                 address: Optional[str] = None,
                 address_position: Optional[str] = None,
                 backup_rule: Optional['outputs.ServerTemplateBackupRule'] = None,
                 delete_autoresize_backup: Optional[bool] = None,
                 encrypt: Optional[bool] = None,
                 filesystem_autoresize: Optional[bool] = None,
                 id: Optional[str] = None,
                 size: Optional[int] = None,
                 tier: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str storage: A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.
        :param str address: The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        :param str address_position: The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.
        :param bool delete_autoresize_backup: If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
        :param bool encrypt: Sets if the storage is encrypted at rest
        :param bool filesystem_autoresize: If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.
               							Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used
               							to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).
               							Taking and keeping backups incure costs.
        :param str id: The unique identifier for the storage
        :param int size: The size of the storage in gigabytes
        :param str tier: The storage tier to use
        :param str title: A short, informative description
        """
        pulumi.set(__self__, "storage", storage)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_position is not None:
            pulumi.set(__self__, "address_position", address_position)
        if backup_rule is not None:
            pulumi.set(__self__, "backup_rule", backup_rule)
        if delete_autoresize_backup is not None:
            pulumi.set(__self__, "delete_autoresize_backup", delete_autoresize_backup)
        if encrypt is not None:
            pulumi.set(__self__, "encrypt", encrypt)
        if filesystem_autoresize is not None:
            pulumi.set(__self__, "filesystem_autoresize", filesystem_autoresize)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def storage(self) -> str:
        """
        A valid storage UUID or template name. You can list available public templates with `upctl storage list --public --template` and available private templates with `upctl storage list --template`.
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The device address the storage will be attached to (`scsi`|`virtio`|`ide`). Leave `address_position` field empty to auto-select next available address from that bus.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="addressPosition")
    def address_position(self) -> Optional[str]:
        """
        The device position in the given bus (defined via field `address`). For example `0:0`, or `0`. Leave empty to auto-select next available address in the given bus.
        """
        return pulumi.get(self, "address_position")

    @property
    @pulumi.getter(name="backupRule")
    def backup_rule(self) -> Optional['outputs.ServerTemplateBackupRule']:
        return pulumi.get(self, "backup_rule")

    @property
    @pulumi.getter(name="deleteAutoresizeBackup")
    def delete_autoresize_backup(self) -> Optional[bool]:
        """
        If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
        """
        return pulumi.get(self, "delete_autoresize_backup")

    @property
    @pulumi.getter
    def encrypt(self) -> Optional[bool]:
        """
        Sets if the storage is encrypted at rest
        """
        return pulumi.get(self, "encrypt")

    @property
    @pulumi.getter(name="filesystemAutoresize")
    def filesystem_autoresize(self) -> Optional[bool]:
        """
        If set to true, provider will attempt to resize partition and filesystem when the size of template storage changes.
        							Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used
        							to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless delete_autoresize_backup option is set to true).
        							Taking and keeping backups incure costs.
        """
        return pulumi.get(self, "filesystem_autoresize")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The unique identifier for the storage
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the storage in gigabytes
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        The storage tier to use
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        A short, informative description
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class ServerTemplateBackupRule(dict):
    def __init__(__self__, *,
                 interval: str,
                 retention: int,
                 time: str):
        """
        :param str interval: The weekday when the backup is created
        :param int retention: The number of days before a backup is automatically deleted
        :param str time: The time of day when the backup is created
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "retention", retention)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The weekday when the backup is created
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def retention(self) -> int:
        """
        The number of days before a backup is automatically deleted
        """
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The time of day when the backup is created
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class StorageBackupRule(dict):
    def __init__(__self__, *,
                 interval: str,
                 retention: int,
                 time: str):
        """
        :param str interval: The weekday when the backup is created
        :param int retention: The number of days before a backup is automatically deleted
        :param str time: The time of day when the backup is created
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "retention", retention)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The weekday when the backup is created
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def retention(self) -> int:
        """
        The number of days before a backup is automatically deleted
        """
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The time of day when the backup is created
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class StorageClone(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The unique identifier of the storage/template to clone.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the storage/template to clone.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class StorageImport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceLocation":
            suggest = "source_location"
        elif key == "sourceHash":
            suggest = "source_hash"
        elif key == "writtenBytes":
            suggest = "written_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageImport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageImport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageImport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: str,
                 source_location: str,
                 sha256sum: Optional[str] = None,
                 source_hash: Optional[str] = None,
                 written_bytes: Optional[int] = None):
        """
        :param str source: The mode of the import task. One of `http_import` or `direct_upload`.
        :param str source_location: The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).
        :param str sha256sum: sha256 sum of the imported data
        :param str source_hash: SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.
        :param int written_bytes: Number of bytes imported
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_location", source_location)
        if sha256sum is not None:
            pulumi.set(__self__, "sha256sum", sha256sum)
        if source_hash is not None:
            pulumi.set(__self__, "source_hash", source_hash)
        if written_bytes is not None:
            pulumi.set(__self__, "written_bytes", written_bytes)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The mode of the import task. One of `http_import` or `direct_upload`.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceLocation")
    def source_location(self) -> str:
        """
        The location of the file to import. For `http_import` an accessible URL. For `direct_upload` a local file. When direct uploading a compressed image, `Content-Type` header of the PUT request is set automatically based on the file extension (`.gz` or `.xz`, case-insensitive).
        """
        return pulumi.get(self, "source_location")

    @property
    @pulumi.getter
    def sha256sum(self) -> Optional[str]:
        """
        sha256 sum of the imported data
        """
        return pulumi.get(self, "sha256sum")

    @property
    @pulumi.getter(name="sourceHash")
    def source_hash(self) -> Optional[str]:
        """
        SHA256 hash of the source content. This hash is used to verify the integrity of the imported data by comparing it to `sha256sum` after the import has completed. Possible filename is automatically removed from the hash before comparison.
        """
        return pulumi.get(self, "source_hash")

    @property
    @pulumi.getter(name="writtenBytes")
    def written_bytes(self) -> Optional[int]:
        """
        Number of bytes imported
        """
        return pulumi.get(self, "written_bytes")


@pulumi.output_type
class GetHostsHostResult(dict):
    def __init__(__self__, *,
                 description: str,
                 host_id: int,
                 zone: str):
        """
        :param str description: Free form text describing the host
        :param int host_id: The unique id of the host
        :param str zone: The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host_id", host_id)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Free form text describing the host
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> int:
        """
        The unique id of the host
        """
        return pulumi.get(self, "host_id")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The zone the host is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetIpAddressesAddressResult(dict):
    def __init__(__self__, *,
                 access: str,
                 address: str,
                 family: str,
                 floating: bool,
                 mac: str,
                 part_of_plan: bool,
                 ptr_record: str,
                 server: str,
                 zone: str):
        """
        :param str access: Is address for utility or public network
        :param str address: An UpCloud assigned IP Address
        :param str family: IP address family
        :param bool floating: Does the IP Address represents a floating IP Address
        :param str mac: MAC address of server interface to assign address to
        :param bool part_of_plan: Is the address a part of a plan
        :param str ptr_record: A reverse DNS record entry
        :param str server: The unique identifier for a server
        :param str zone: Zone of address, required when assigning a detached floating IP address, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "floating", floating)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "part_of_plan", part_of_plan)
        pulumi.set(__self__, "ptr_record", ptr_record)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Is address for utility or public network
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        An UpCloud assigned IP Address
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        IP address family
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def floating(self) -> bool:
        """
        Does the IP Address represents a floating IP Address
        """
        return pulumi.get(self, "floating")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        MAC address of server interface to assign address to
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter(name="partOfPlan")
    def part_of_plan(self) -> bool:
        """
        Is the address a part of a plan
        """
        return pulumi.get(self, "part_of_plan")

    @property
    @pulumi.getter(name="ptrRecord")
    def ptr_record(self) -> str:
        """
        A reverse DNS record entry
        """
        return pulumi.get(self, "ptr_record")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The unique identifier for a server
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        Zone of address, required when assigning a detached floating IP address, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetManagedDatabaseMysqlSessionsSessionResult(dict):
    def __init__(__self__, *,
                 application_name: str,
                 client_addr: str,
                 datname: str,
                 id: str,
                 query: str,
                 query_duration: str,
                 state: str,
                 usename: str):
        """
        :param str application_name: Name of the application that is connected to this service.
        :param str client_addr: IP address of the client connected to this service.
        :param str datname: Name of the database this service is connected to.
        :param str id: Process ID of this service.
        :param str query: Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.
        :param str query_duration: The active query current duration.
        :param str state: Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        :param str usename: Name of the user logged into this service.
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "datname", datname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_duration", query_duration)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "usename", usename)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> str:
        """
        IP address of the client connected to this service.
        """
        return pulumi.get(self, "client_addr")

    @property
    @pulumi.getter
    def datname(self) -> str:
        """
        Name of the database this service is connected to.
        """
        return pulumi.get(self, "datname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Process ID of this service.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows an empty string.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="queryDuration")
    def query_duration(self) -> str:
        """
        The active query current duration.
        """
        return pulumi.get(self, "query_duration")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def usename(self) -> str:
        """
        Name of the user logged into this service.
        """
        return pulumi.get(self, "usename")


@pulumi.output_type
class GetManagedDatabaseOpensearchIndicesIndexResult(dict):
    def __init__(__self__, *,
                 create_time: str,
                 docs: int,
                 health: str,
                 index_name: str,
                 number_of_replicas: int,
                 number_of_shards: int,
                 read_only_allow_delete: bool,
                 size: int,
                 status: str):
        """
        :param str create_time: Timestamp indicating the creation time of the index.
        :param int docs: Number of documents stored in the index.
        :param str health: Health status of the index e.g. `green`, `yellow`, or `red`.
        :param str index_name: Name of the index.
        :param int number_of_replicas: Number of replicas configured for the index.
        :param int number_of_shards: Number of shards configured & used by the index.
        :param bool read_only_allow_delete: Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.
        :param int size: Size of the index in bytes.
        :param str status: Status of the index e.g. `open` or `closed`.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "docs", docs)
        pulumi.set(__self__, "health", health)
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        pulumi.set(__self__, "number_of_shards", number_of_shards)
        pulumi.set(__self__, "read_only_allow_delete", read_only_allow_delete)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Timestamp indicating the creation time of the index.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def docs(self) -> int:
        """
        Number of documents stored in the index.
        """
        return pulumi.get(self, "docs")

    @property
    @pulumi.getter
    def health(self) -> str:
        """
        Health status of the index e.g. `green`, `yellow`, or `red`.
        """
        return pulumi.get(self, "health")

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> int:
        """
        Number of replicas configured for the index.
        """
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> int:
        """
        Number of shards configured & used by the index.
        """
        return pulumi.get(self, "number_of_shards")

    @property
    @pulumi.getter(name="readOnlyAllowDelete")
    def read_only_allow_delete(self) -> bool:
        """
        Indicates whether the index is in a read-only state that permits deletion of the entire index. This attribute can be automatically set to true in certain scenarios where the node disk space exceeds the flood stage.
        """
        return pulumi.get(self, "read_only_allow_delete")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the index in bytes.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the index e.g. `open` or `closed`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetManagedDatabasePostgresqlSessionsSessionResult(dict):
    def __init__(__self__, *,
                 application_name: str,
                 backend_start: str,
                 backend_type: str,
                 backend_xid: int,
                 backend_xmin: int,
                 client_addr: str,
                 client_hostname: str,
                 client_port: int,
                 datid: int,
                 datname: str,
                 id: str,
                 query: str,
                 query_duration: str,
                 query_start: str,
                 state: str,
                 state_change: str,
                 usename: str,
                 usesysid: int,
                 wait_event: str,
                 wait_event_type: str,
                 xact_start: str):
        """
        :param str application_name: Name of the application that is connected to this service.
        :param str backend_start: Time when this process was started, i.e., when the client connected to the server.
        :param str backend_type: Type of current service.
        :param int backend_xid: Top-level transaction identifier of this service, if any.
        :param int backend_xmin: The current service's xmin horizon.
        :param str client_addr: IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
        :param str client_hostname: Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.
        :param int client_port: TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.
        :param int datid: OID of the database this service is connected to.
        :param str datname: Name of the database this service is connected to.
        :param str id: Process ID of this service.
        :param str query: Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
        :param str query_duration: The active query current duration.
        :param str query_start: Time when the currently active query was started, or if state is not active, when the last query was started.
        :param str state: Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        :param str state_change: Time when the state was last changed.
        :param str usename: Name of the user logged into this service.
        :param int usesysid: OID of the user logged into this service.
        :param str wait_event: Wait event name if service is currently waiting.
        :param str wait_event_type: The type of event for which the service is waiting, if any; otherwise NULL.
        :param str xact_start: Time when this process' current transaction was started, or null if no transaction is active.
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "backend_start", backend_start)
        pulumi.set(__self__, "backend_type", backend_type)
        pulumi.set(__self__, "backend_xid", backend_xid)
        pulumi.set(__self__, "backend_xmin", backend_xmin)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "client_hostname", client_hostname)
        pulumi.set(__self__, "client_port", client_port)
        pulumi.set(__self__, "datid", datid)
        pulumi.set(__self__, "datname", datname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_duration", query_duration)
        pulumi.set(__self__, "query_start", query_start)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_change", state_change)
        pulumi.set(__self__, "usename", usename)
        pulumi.set(__self__, "usesysid", usesysid)
        pulumi.set(__self__, "wait_event", wait_event)
        pulumi.set(__self__, "wait_event_type", wait_event_type)
        pulumi.set(__self__, "xact_start", xact_start)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="backendStart")
    def backend_start(self) -> str:
        """
        Time when this process was started, i.e., when the client connected to the server.
        """
        return pulumi.get(self, "backend_start")

    @property
    @pulumi.getter(name="backendType")
    def backend_type(self) -> str:
        """
        Type of current service.
        """
        return pulumi.get(self, "backend_type")

    @property
    @pulumi.getter(name="backendXid")
    def backend_xid(self) -> int:
        """
        Top-level transaction identifier of this service, if any.
        """
        return pulumi.get(self, "backend_xid")

    @property
    @pulumi.getter(name="backendXmin")
    def backend_xmin(self) -> int:
        """
        The current service's xmin horizon.
        """
        return pulumi.get(self, "backend_xmin")

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> str:
        """
        IP address of the client connected to this service. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
        """
        return pulumi.get(self, "client_addr")

    @property
    @pulumi.getter(name="clientHostname")
    def client_hostname(self) -> str:
        """
        Host name of the connected client, as reported by a reverse DNS lookup of `client_addr`.
        """
        return pulumi.get(self, "client_hostname")

    @property
    @pulumi.getter(name="clientPort")
    def client_port(self) -> int:
        """
        TCP port number that the client is using for communication with this service, or -1 if a Unix socket is used.
        """
        return pulumi.get(self, "client_port")

    @property
    @pulumi.getter
    def datid(self) -> int:
        """
        OID of the database this service is connected to.
        """
        return pulumi.get(self, "datid")

    @property
    @pulumi.getter
    def datname(self) -> str:
        """
        Name of the database this service is connected to.
        """
        return pulumi.get(self, "datname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Process ID of this service.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Text of this service's most recent query. If state is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="queryDuration")
    def query_duration(self) -> str:
        """
        The active query current duration.
        """
        return pulumi.get(self, "query_duration")

    @property
    @pulumi.getter(name="queryStart")
    def query_start(self) -> str:
        """
        Time when the currently active query was started, or if state is not active, when the last query was started.
        """
        return pulumi.get(self, "query_start")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current overall state of this service: active: The service is executing a query, idle: The service is waiting for a new client command.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateChange")
    def state_change(self) -> str:
        """
        Time when the state was last changed.
        """
        return pulumi.get(self, "state_change")

    @property
    @pulumi.getter
    def usename(self) -> str:
        """
        Name of the user logged into this service.
        """
        return pulumi.get(self, "usename")

    @property
    @pulumi.getter
    def usesysid(self) -> int:
        """
        OID of the user logged into this service.
        """
        return pulumi.get(self, "usesysid")

    @property
    @pulumi.getter(name="waitEvent")
    def wait_event(self) -> str:
        """
        Wait event name if service is currently waiting.
        """
        return pulumi.get(self, "wait_event")

    @property
    @pulumi.getter(name="waitEventType")
    def wait_event_type(self) -> str:
        """
        The type of event for which the service is waiting, if any; otherwise NULL.
        """
        return pulumi.get(self, "wait_event_type")

    @property
    @pulumi.getter(name="xactStart")
    def xact_start(self) -> str:
        """
        Time when this process' current transaction was started, or null if no transaction is active.
        """
        return pulumi.get(self, "xact_start")


@pulumi.output_type
class GetManagedDatabaseRedisSessionsSessionResult(dict):
    def __init__(__self__, *,
                 active_channel_subscriptions: int,
                 active_database: str,
                 active_pattern_matching_channel_subscriptions: int,
                 application_name: str,
                 client_addr: str,
                 connection_age: int,
                 connection_idle: int,
                 flags: Sequence[str],
                 flags_raw: str,
                 id: str,
                 multi_exec_commands: int,
                 output_buffer: int,
                 output_buffer_memory: int,
                 output_list_length: int,
                 query: str,
                 query_buffer: int,
                 query_buffer_free: int):
        """
        :param int active_channel_subscriptions: Number of active channel subscriptions
        :param str active_database: Current database ID
        :param int active_pattern_matching_channel_subscriptions: Number of pattern matching subscriptions.
        :param str application_name: Name of the application that is connected to this service.
        :param str client_addr: Number of pattern matching subscriptions.
        :param int connection_age: Total duration of the connection in nanoseconds.
        :param int connection_idle: Idle time of the connection in nanoseconds.
        :param Sequence[str] flags: A set containing flags' descriptions.
        :param str flags_raw: Client connection flags in raw string format.
        :param str id: Process ID of this session.
        :param int multi_exec_commands: Number of commands in a MULTI/EXEC context.
        :param int output_buffer: Output buffer length.
        :param int output_buffer_memory: Output buffer memory usage.
        :param int output_list_length: Output list length (replies are queued in this list when the buffer is full).
        :param str query: The last executed command.
        :param int query_buffer: Query buffer length (0 means no query pending).
        :param int query_buffer_free: Free space of the query buffer (0 means the buffer is full).
        """
        pulumi.set(__self__, "active_channel_subscriptions", active_channel_subscriptions)
        pulumi.set(__self__, "active_database", active_database)
        pulumi.set(__self__, "active_pattern_matching_channel_subscriptions", active_pattern_matching_channel_subscriptions)
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "client_addr", client_addr)
        pulumi.set(__self__, "connection_age", connection_age)
        pulumi.set(__self__, "connection_idle", connection_idle)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "flags_raw", flags_raw)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "multi_exec_commands", multi_exec_commands)
        pulumi.set(__self__, "output_buffer", output_buffer)
        pulumi.set(__self__, "output_buffer_memory", output_buffer_memory)
        pulumi.set(__self__, "output_list_length", output_list_length)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "query_buffer", query_buffer)
        pulumi.set(__self__, "query_buffer_free", query_buffer_free)

    @property
    @pulumi.getter(name="activeChannelSubscriptions")
    def active_channel_subscriptions(self) -> int:
        """
        Number of active channel subscriptions
        """
        return pulumi.get(self, "active_channel_subscriptions")

    @property
    @pulumi.getter(name="activeDatabase")
    def active_database(self) -> str:
        """
        Current database ID
        """
        return pulumi.get(self, "active_database")

    @property
    @pulumi.getter(name="activePatternMatchingChannelSubscriptions")
    def active_pattern_matching_channel_subscriptions(self) -> int:
        """
        Number of pattern matching subscriptions.
        """
        return pulumi.get(self, "active_pattern_matching_channel_subscriptions")

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        Name of the application that is connected to this service.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="clientAddr")
    def client_addr(self) -> str:
        """
        Number of pattern matching subscriptions.
        """
        return pulumi.get(self, "client_addr")

    @property
    @pulumi.getter(name="connectionAge")
    def connection_age(self) -> int:
        """
        Total duration of the connection in nanoseconds.
        """
        return pulumi.get(self, "connection_age")

    @property
    @pulumi.getter(name="connectionIdle")
    def connection_idle(self) -> int:
        """
        Idle time of the connection in nanoseconds.
        """
        return pulumi.get(self, "connection_idle")

    @property
    @pulumi.getter
    def flags(self) -> Sequence[str]:
        """
        A set containing flags' descriptions.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="flagsRaw")
    def flags_raw(self) -> str:
        """
        Client connection flags in raw string format.
        """
        return pulumi.get(self, "flags_raw")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Process ID of this session.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="multiExecCommands")
    def multi_exec_commands(self) -> int:
        """
        Number of commands in a MULTI/EXEC context.
        """
        return pulumi.get(self, "multi_exec_commands")

    @property
    @pulumi.getter(name="outputBuffer")
    def output_buffer(self) -> int:
        """
        Output buffer length.
        """
        return pulumi.get(self, "output_buffer")

    @property
    @pulumi.getter(name="outputBufferMemory")
    def output_buffer_memory(self) -> int:
        """
        Output buffer memory usage.
        """
        return pulumi.get(self, "output_buffer_memory")

    @property
    @pulumi.getter(name="outputListLength")
    def output_list_length(self) -> int:
        """
        Output list length (replies are queued in this list when the buffer is full).
        """
        return pulumi.get(self, "output_list_length")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The last executed command.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="queryBuffer")
    def query_buffer(self) -> int:
        """
        Query buffer length (0 means no query pending).
        """
        return pulumi.get(self, "query_buffer")

    @property
    @pulumi.getter(name="queryBufferFree")
    def query_buffer_free(self) -> int:
        """
        Free space of the query buffer (0 means the buffer is full).
        """
        return pulumi.get(self, "query_buffer_free")


@pulumi.output_type
class GetManagedObjectStoragePoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 attachment_count: int,
                 created_at: str,
                 default_version_id: str,
                 document: str,
                 name: str,
                 service_uuid: str,
                 system: bool,
                 updated_at: str,
                 description: Optional[str] = None):
        """
        :param str arn: Policy ARN.
        :param int attachment_count: Attachment count.
        :param str created_at: Creation time.
        :param str default_version_id: Default version id.
        :param str document: Policy document, URL-encoded compliant with RFC 3986.
        :param str name: Policy name.
        :param str service_uuid: Managed Object Storage service UUID.
        :param bool system: Defines whether the policy was set up by the system.
        :param str updated_at: Update time.
        :param str description: Description of the policy.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "attachment_count", attachment_count)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "default_version_id", default_version_id)
        pulumi.set(__self__, "document", document)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_uuid", service_uuid)
        pulumi.set(__self__, "system", system)
        pulumi.set(__self__, "updated_at", updated_at)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        Policy ARN.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="attachmentCount")
    def attachment_count(self) -> int:
        """
        Attachment count.
        """
        return pulumi.get(self, "attachment_count")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Creation time.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="defaultVersionId")
    def default_version_id(self) -> str:
        """
        Default version id.
        """
        return pulumi.get(self, "default_version_id")

    @property
    @pulumi.getter
    def document(self) -> str:
        """
        Policy document, URL-encoded compliant with RFC 3986.
        """
        return pulumi.get(self, "document")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Policy name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceUuid")
    def service_uuid(self) -> str:
        """
        Managed Object Storage service UUID.
        """
        return pulumi.get(self, "service_uuid")

    @property
    @pulumi.getter
    def system(self) -> bool:
        """
        Defines whether the policy was set up by the system.
        """
        return pulumi.get(self, "system")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Update time.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the policy.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetManagedObjectStorageRegionsRegionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 primary_zone: str,
                 zones: Sequence[str]):
        """
        :param str name: Name of the region.
        :param str primary_zone: Primary zone of the region.
        :param Sequence[str] zones: List of zones in the region.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_zone", primary_zone)
        pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the region.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryZone")
    def primary_zone(self) -> str:
        """
        Primary zone of the region.
        """
        return pulumi.get(self, "primary_zone")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        List of zones in the region.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetNetworksNetworkResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip_networks: Sequence['outputs.GetNetworksNetworkIpNetworkResult'],
                 name: str,
                 servers: Sequence['outputs.GetNetworksNetworkServerResult'],
                 type: str,
                 zone: str):
        """
        :param str id: The UUID of the network
        :param Sequence['GetNetworksNetworkIpNetworkArgs'] ip_networks: A list of IP subnets within the network
        :param str name: A valid name for the network
        :param Sequence['GetNetworksNetworkServerArgs'] servers: A list of attached servers
        :param str type: The network type
        :param str zone: The zone the network is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_networks", ip_networks)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "servers", servers)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID of the network
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipNetworks")
    def ip_networks(self) -> Sequence['outputs.GetNetworksNetworkIpNetworkResult']:
        """
        A list of IP subnets within the network
        """
        return pulumi.get(self, "ip_networks")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A valid name for the network
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetNetworksNetworkServerResult']:
        """
        A list of attached servers
        """
        return pulumi.get(self, "servers")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The network type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The zone the network is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetNetworksNetworkIpNetworkResult(dict):
    def __init__(__self__, *,
                 address: str,
                 dhcp: bool,
                 dhcp_default_route: bool,
                 dhcp_dns: Sequence[str],
                 dhcp_routes: Sequence[str],
                 family: str,
                 gateway: str):
        """
        :param str address: The CIDR range of the subnet
        :param bool dhcp: Is DHCP enabled?
        :param bool dhcp_default_route: Is the gateway the DHCP default route?
        :param Sequence[str] dhcp_dns: The DNS servers given by DHCP
        :param Sequence[str] dhcp_routes: The additional DHCP classless static routes given by DHCP
        :param str family: IP address family
        :param str gateway: Gateway address given by DHCP
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "dhcp", dhcp)
        pulumi.set(__self__, "dhcp_default_route", dhcp_default_route)
        pulumi.set(__self__, "dhcp_dns", dhcp_dns)
        pulumi.set(__self__, "dhcp_routes", dhcp_routes)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The CIDR range of the subnet
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def dhcp(self) -> bool:
        """
        Is DHCP enabled?
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter(name="dhcpDefaultRoute")
    def dhcp_default_route(self) -> bool:
        """
        Is the gateway the DHCP default route?
        """
        return pulumi.get(self, "dhcp_default_route")

    @property
    @pulumi.getter(name="dhcpDns")
    def dhcp_dns(self) -> Sequence[str]:
        """
        The DNS servers given by DHCP
        """
        return pulumi.get(self, "dhcp_dns")

    @property
    @pulumi.getter(name="dhcpRoutes")
    def dhcp_routes(self) -> Sequence[str]:
        """
        The additional DHCP classless static routes given by DHCP
        """
        return pulumi.get(self, "dhcp_routes")

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        IP address family
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address given by DHCP
        """
        return pulumi.get(self, "gateway")


@pulumi.output_type
class GetNetworksNetworkServerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 title: str):
        """
        :param str id: The UUID of the server
        :param str title: The short description of the server
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID of the server
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The short description of the server
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetTagsTagResult(dict):
    def __init__(__self__, *,
                 description: str,
                 name: str,
                 servers: Sequence[str]):
        """
        :param str description: Free form text representing the meaning of the tag
        :param str name: The value representing the tag
        :param Sequence[str] servers: A collection of servers that have been assigned the tag
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Free form text representing the meaning of the tag
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The value representing the tag
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def servers(self) -> Sequence[str]:
        """
        A collection of servers that have been assigned the tag
        """
        return pulumi.get(self, "servers")


