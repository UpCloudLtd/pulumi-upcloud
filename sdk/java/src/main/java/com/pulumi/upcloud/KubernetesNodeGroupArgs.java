// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.upcloud;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.upcloud.inputs.KubernetesNodeGroupCustomPlanArgs;
import com.pulumi.upcloud.inputs.KubernetesNodeGroupKubeletArgArgs;
import com.pulumi.upcloud.inputs.KubernetesNodeGroupTaintArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class KubernetesNodeGroupArgs extends com.pulumi.resources.ResourceArgs {

    public static final KubernetesNodeGroupArgs Empty = new KubernetesNodeGroupArgs();

    /**
     * If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is
     * considered &#39;best effort&#39; and enabling it does not fully guarantee that the nodes will end up on different hardware.
     * 
     */
    @Import(name="antiAffinity")
    private @Nullable Output<Boolean> antiAffinity;

    /**
     * @return If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is
     * considered &#39;best effort&#39; and enabling it does not fully guarantee that the nodes will end up on different hardware.
     * 
     */
    public Optional<Output<Boolean>> antiAffinity() {
        return Optional.ofNullable(this.antiAffinity);
    }

    /**
     * UUID of the cluster.
     * 
     */
    @Import(name="cluster", required=true)
    private Output<String> cluster;

    /**
     * @return UUID of the cluster.
     * 
     */
    public Output<String> cluster() {
        return this.cluster;
    }

    /**
     * Resource properties for custom plan
     * 
     */
    @Import(name="customPlan")
    private @Nullable Output<KubernetesNodeGroupCustomPlanArgs> customPlan;

    /**
     * @return Resource properties for custom plan
     * 
     */
    public Optional<Output<KubernetesNodeGroupCustomPlanArgs>> customPlan() {
        return Optional.ofNullable(this.customPlan);
    }

    /**
     * Additional arguments for kubelet for the nodes in this group. WARNING - those arguments will be passed directly to
     * kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra
     * careful when adding kubelet args.
     * 
     */
    @Import(name="kubeletArgs")
    private @Nullable Output<List<KubernetesNodeGroupKubeletArgArgs>> kubeletArgs;

    /**
     * @return Additional arguments for kubelet for the nodes in this group. WARNING - those arguments will be passed directly to
     * kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra
     * careful when adding kubelet args.
     * 
     */
    public Optional<Output<List<KubernetesNodeGroupKubeletArgArgs>>> kubeletArgs() {
        return Optional.ofNullable(this.kubeletArgs);
    }

    /**
     * User defined key-value pairs to classify the node_group.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return User defined key-value pairs to classify the node_group.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * The name of the node group. Needs to be unique within a cluster.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the node group. Needs to be unique within a cluster.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Amount of nodes to provision in the node group.
     * 
     */
    @Import(name="nodeCount", required=true)
    private Output<Integer> nodeCount;

    /**
     * @return Amount of nodes to provision in the node group.
     * 
     */
    public Output<Integer> nodeCount() {
        return this.nodeCount;
    }

    /**
     * The server plan used for the node group. You can list available plans with `upctl server plans`
     * 
     */
    @Import(name="plan", required=true)
    private Output<String> plan;

    /**
     * @return The server plan used for the node group. You can list available plans with `upctl server plans`
     * 
     */
    public Output<String> plan() {
        return this.plan;
    }

    /**
     * You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to
     * connect to the nodes via SSH once they are running.
     * 
     */
    @Import(name="sshKeys")
    private @Nullable Output<List<String>> sshKeys;

    /**
     * @return You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to
     * connect to the nodes via SSH once they are running.
     * 
     */
    public Optional<Output<List<String>>> sshKeys() {
        return Optional.ofNullable(this.sshKeys);
    }

    /**
     * The storage encryption strategy to use for the nodes in this group. If not set, the cluster&#39;s storage encryption
     * strategy will be used, if applicable.
     * 
     */
    @Import(name="storageEncryption")
    private @Nullable Output<String> storageEncryption;

    /**
     * @return The storage encryption strategy to use for the nodes in this group. If not set, the cluster&#39;s storage encryption
     * strategy will be used, if applicable.
     * 
     */
    public Optional<Output<String>> storageEncryption() {
        return Optional.ofNullable(this.storageEncryption);
    }

    /**
     * Taints for the nodes in this group.
     * 
     */
    @Import(name="taints")
    private @Nullable Output<List<KubernetesNodeGroupTaintArgs>> taints;

    /**
     * @return Taints for the nodes in this group.
     * 
     */
    public Optional<Output<List<KubernetesNodeGroupTaintArgs>>> taints() {
        return Optional.ofNullable(this.taints);
    }

    /**
     * If set to false, nodes in this group will not have access to utility network.
     * 
     */
    @Import(name="utilityNetworkAccess")
    private @Nullable Output<Boolean> utilityNetworkAccess;

    /**
     * @return If set to false, nodes in this group will not have access to utility network.
     * 
     */
    public Optional<Output<Boolean>> utilityNetworkAccess() {
        return Optional.ofNullable(this.utilityNetworkAccess);
    }

    private KubernetesNodeGroupArgs() {}

    private KubernetesNodeGroupArgs(KubernetesNodeGroupArgs $) {
        this.antiAffinity = $.antiAffinity;
        this.cluster = $.cluster;
        this.customPlan = $.customPlan;
        this.kubeletArgs = $.kubeletArgs;
        this.labels = $.labels;
        this.name = $.name;
        this.nodeCount = $.nodeCount;
        this.plan = $.plan;
        this.sshKeys = $.sshKeys;
        this.storageEncryption = $.storageEncryption;
        this.taints = $.taints;
        this.utilityNetworkAccess = $.utilityNetworkAccess;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(KubernetesNodeGroupArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private KubernetesNodeGroupArgs $;

        public Builder() {
            $ = new KubernetesNodeGroupArgs();
        }

        public Builder(KubernetesNodeGroupArgs defaults) {
            $ = new KubernetesNodeGroupArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param antiAffinity If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is
         * considered &#39;best effort&#39; and enabling it does not fully guarantee that the nodes will end up on different hardware.
         * 
         * @return builder
         * 
         */
        public Builder antiAffinity(@Nullable Output<Boolean> antiAffinity) {
            $.antiAffinity = antiAffinity;
            return this;
        }

        /**
         * @param antiAffinity If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is
         * considered &#39;best effort&#39; and enabling it does not fully guarantee that the nodes will end up on different hardware.
         * 
         * @return builder
         * 
         */
        public Builder antiAffinity(Boolean antiAffinity) {
            return antiAffinity(Output.of(antiAffinity));
        }

        /**
         * @param cluster UUID of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder cluster(Output<String> cluster) {
            $.cluster = cluster;
            return this;
        }

        /**
         * @param cluster UUID of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder cluster(String cluster) {
            return cluster(Output.of(cluster));
        }

        /**
         * @param customPlan Resource properties for custom plan
         * 
         * @return builder
         * 
         */
        public Builder customPlan(@Nullable Output<KubernetesNodeGroupCustomPlanArgs> customPlan) {
            $.customPlan = customPlan;
            return this;
        }

        /**
         * @param customPlan Resource properties for custom plan
         * 
         * @return builder
         * 
         */
        public Builder customPlan(KubernetesNodeGroupCustomPlanArgs customPlan) {
            return customPlan(Output.of(customPlan));
        }

        /**
         * @param kubeletArgs Additional arguments for kubelet for the nodes in this group. WARNING - those arguments will be passed directly to
         * kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra
         * careful when adding kubelet args.
         * 
         * @return builder
         * 
         */
        public Builder kubeletArgs(@Nullable Output<List<KubernetesNodeGroupKubeletArgArgs>> kubeletArgs) {
            $.kubeletArgs = kubeletArgs;
            return this;
        }

        /**
         * @param kubeletArgs Additional arguments for kubelet for the nodes in this group. WARNING - those arguments will be passed directly to
         * kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra
         * careful when adding kubelet args.
         * 
         * @return builder
         * 
         */
        public Builder kubeletArgs(List<KubernetesNodeGroupKubeletArgArgs> kubeletArgs) {
            return kubeletArgs(Output.of(kubeletArgs));
        }

        /**
         * @param kubeletArgs Additional arguments for kubelet for the nodes in this group. WARNING - those arguments will be passed directly to
         * kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra
         * careful when adding kubelet args.
         * 
         * @return builder
         * 
         */
        public Builder kubeletArgs(KubernetesNodeGroupKubeletArgArgs... kubeletArgs) {
            return kubeletArgs(List.of(kubeletArgs));
        }

        /**
         * @param labels User defined key-value pairs to classify the node_group.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels User defined key-value pairs to classify the node_group.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param name The name of the node group. Needs to be unique within a cluster.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the node group. Needs to be unique within a cluster.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param nodeCount Amount of nodes to provision in the node group.
         * 
         * @return builder
         * 
         */
        public Builder nodeCount(Output<Integer> nodeCount) {
            $.nodeCount = nodeCount;
            return this;
        }

        /**
         * @param nodeCount Amount of nodes to provision in the node group.
         * 
         * @return builder
         * 
         */
        public Builder nodeCount(Integer nodeCount) {
            return nodeCount(Output.of(nodeCount));
        }

        /**
         * @param plan The server plan used for the node group. You can list available plans with `upctl server plans`
         * 
         * @return builder
         * 
         */
        public Builder plan(Output<String> plan) {
            $.plan = plan;
            return this;
        }

        /**
         * @param plan The server plan used for the node group. You can list available plans with `upctl server plans`
         * 
         * @return builder
         * 
         */
        public Builder plan(String plan) {
            return plan(Output.of(plan));
        }

        /**
         * @param sshKeys You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to
         * connect to the nodes via SSH once they are running.
         * 
         * @return builder
         * 
         */
        public Builder sshKeys(@Nullable Output<List<String>> sshKeys) {
            $.sshKeys = sshKeys;
            return this;
        }

        /**
         * @param sshKeys You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to
         * connect to the nodes via SSH once they are running.
         * 
         * @return builder
         * 
         */
        public Builder sshKeys(List<String> sshKeys) {
            return sshKeys(Output.of(sshKeys));
        }

        /**
         * @param sshKeys You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to
         * connect to the nodes via SSH once they are running.
         * 
         * @return builder
         * 
         */
        public Builder sshKeys(String... sshKeys) {
            return sshKeys(List.of(sshKeys));
        }

        /**
         * @param storageEncryption The storage encryption strategy to use for the nodes in this group. If not set, the cluster&#39;s storage encryption
         * strategy will be used, if applicable.
         * 
         * @return builder
         * 
         */
        public Builder storageEncryption(@Nullable Output<String> storageEncryption) {
            $.storageEncryption = storageEncryption;
            return this;
        }

        /**
         * @param storageEncryption The storage encryption strategy to use for the nodes in this group. If not set, the cluster&#39;s storage encryption
         * strategy will be used, if applicable.
         * 
         * @return builder
         * 
         */
        public Builder storageEncryption(String storageEncryption) {
            return storageEncryption(Output.of(storageEncryption));
        }

        /**
         * @param taints Taints for the nodes in this group.
         * 
         * @return builder
         * 
         */
        public Builder taints(@Nullable Output<List<KubernetesNodeGroupTaintArgs>> taints) {
            $.taints = taints;
            return this;
        }

        /**
         * @param taints Taints for the nodes in this group.
         * 
         * @return builder
         * 
         */
        public Builder taints(List<KubernetesNodeGroupTaintArgs> taints) {
            return taints(Output.of(taints));
        }

        /**
         * @param taints Taints for the nodes in this group.
         * 
         * @return builder
         * 
         */
        public Builder taints(KubernetesNodeGroupTaintArgs... taints) {
            return taints(List.of(taints));
        }

        /**
         * @param utilityNetworkAccess If set to false, nodes in this group will not have access to utility network.
         * 
         * @return builder
         * 
         */
        public Builder utilityNetworkAccess(@Nullable Output<Boolean> utilityNetworkAccess) {
            $.utilityNetworkAccess = utilityNetworkAccess;
            return this;
        }

        /**
         * @param utilityNetworkAccess If set to false, nodes in this group will not have access to utility network.
         * 
         * @return builder
         * 
         */
        public Builder utilityNetworkAccess(Boolean utilityNetworkAccess) {
            return utilityNetworkAccess(Output.of(utilityNetworkAccess));
        }

        public KubernetesNodeGroupArgs build() {
            if ($.cluster == null) {
                throw new MissingRequiredPropertyException("KubernetesNodeGroupArgs", "cluster");
            }
            if ($.nodeCount == null) {
                throw new MissingRequiredPropertyException("KubernetesNodeGroupArgs", "nodeCount");
            }
            if ($.plan == null) {
                throw new MissingRequiredPropertyException("KubernetesNodeGroupArgs", "plan");
            }
            return $;
        }
    }

}
