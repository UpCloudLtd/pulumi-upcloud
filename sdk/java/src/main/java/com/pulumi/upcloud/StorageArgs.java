// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.upcloud;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.upcloud.inputs.StorageBackupRuleArgs;
import com.pulumi.upcloud.inputs.StorageCloneArgs;
import com.pulumi.upcloud.inputs.StorageImportArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class StorageArgs extends com.pulumi.resources.ResourceArgs {

    public static final StorageArgs Empty = new StorageArgs();

    @Import(name="backupRule")
    private @Nullable Output<StorageBackupRuleArgs> backupRule;

    public Optional<Output<StorageBackupRuleArgs>> backupRule() {
        return Optional.ofNullable(this.backupRule);
    }

    /**
     * Block defining another storage/template to clone to storage.
     * 
     */
    @Import(name="clone")
    private @Nullable Output<StorageCloneArgs> clone;

    /**
     * @return Block defining another storage/template to clone to storage.
     * 
     */
    public Optional<Output<StorageCloneArgs>> clone_() {
        return Optional.ofNullable(this.clone);
    }

    /**
     * If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
     * 
     */
    @Import(name="deleteAutoresizeBackup")
    private @Nullable Output<Boolean> deleteAutoresizeBackup;

    /**
     * @return If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
     * 
     */
    public Optional<Output<Boolean>> deleteAutoresizeBackup() {
        return Optional.ofNullable(this.deleteAutoresizeBackup);
    }

    /**
     * Sets if the storage is encrypted at rest.
     * 
     */
    @Import(name="encrypt")
    private @Nullable Output<Boolean> encrypt;

    /**
     * @return Sets if the storage is encrypted at rest.
     * 
     */
    public Optional<Output<Boolean>> encrypt() {
        return Optional.ofNullable(this.encrypt);
    }

    /**
     * If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `delete_autoresize_backup` option is set to true).
     * 				Taking and keeping backups incure costs.
     * 
     */
    @Import(name="filesystemAutoresize")
    private @Nullable Output<Boolean> filesystemAutoresize;

    /**
     * @return If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `delete_autoresize_backup` option is set to true).
     * 				Taking and keeping backups incure costs.
     * 
     */
    public Optional<Output<Boolean>> filesystemAutoresize() {
        return Optional.ofNullable(this.filesystemAutoresize);
    }

    /**
     * Block defining external data to import to storage
     * 
     */
    @Import(name="import")
    private @Nullable Output<StorageImportArgs> import_;

    /**
     * @return Block defining external data to import to storage
     * 
     */
    public Optional<Output<StorageImportArgs>> import_() {
        return Optional.ofNullable(this.import_);
    }

    /**
     * User defined key-value pairs to classify the storage.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return User defined key-value pairs to classify the storage.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * The size of the storage in gigabytes.
     * 
     */
    @Import(name="size", required=true)
    private Output<Integer> size;

    /**
     * @return The size of the storage in gigabytes.
     * 
     */
    public Output<Integer> size() {
        return this.size;
    }

    /**
     * The tier of the storage.
     * 
     */
    @Import(name="tier")
    private @Nullable Output<String> tier;

    /**
     * @return The tier of the storage.
     * 
     */
    public Optional<Output<String>> tier() {
        return Optional.ofNullable(this.tier);
    }

    /**
     * The title of the storage.
     * 
     */
    @Import(name="title", required=true)
    private Output<String> title;

    /**
     * @return The title of the storage.
     * 
     */
    public Output<String> title() {
        return this.title;
    }

    /**
     * The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
     * 
     */
    @Import(name="zone", required=true)
    private Output<String> zone;

    /**
     * @return The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
     * 
     */
    public Output<String> zone() {
        return this.zone;
    }

    private StorageArgs() {}

    private StorageArgs(StorageArgs $) {
        this.backupRule = $.backupRule;
        this.clone = $.clone;
        this.deleteAutoresizeBackup = $.deleteAutoresizeBackup;
        this.encrypt = $.encrypt;
        this.filesystemAutoresize = $.filesystemAutoresize;
        this.import_ = $.import_;
        this.labels = $.labels;
        this.size = $.size;
        this.tier = $.tier;
        this.title = $.title;
        this.zone = $.zone;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(StorageArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private StorageArgs $;

        public Builder() {
            $ = new StorageArgs();
        }

        public Builder(StorageArgs defaults) {
            $ = new StorageArgs(Objects.requireNonNull(defaults));
        }

        public Builder backupRule(@Nullable Output<StorageBackupRuleArgs> backupRule) {
            $.backupRule = backupRule;
            return this;
        }

        public Builder backupRule(StorageBackupRuleArgs backupRule) {
            return backupRule(Output.of(backupRule));
        }

        /**
         * @param clone Block defining another storage/template to clone to storage.
         * 
         * @return builder
         * 
         */
        public Builder clone_(@Nullable Output<StorageCloneArgs> clone) {
            $.clone = clone;
            return this;
        }

        /**
         * @param clone Block defining another storage/template to clone to storage.
         * 
         * @return builder
         * 
         */
        public Builder clone_(StorageCloneArgs clone) {
            return clone_(Output.of(clone));
        }

        /**
         * @param deleteAutoresizeBackup If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
         * 
         * @return builder
         * 
         */
        public Builder deleteAutoresizeBackup(@Nullable Output<Boolean> deleteAutoresizeBackup) {
            $.deleteAutoresizeBackup = deleteAutoresizeBackup;
            return this;
        }

        /**
         * @param deleteAutoresizeBackup If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
         * 
         * @return builder
         * 
         */
        public Builder deleteAutoresizeBackup(Boolean deleteAutoresizeBackup) {
            return deleteAutoresizeBackup(Output.of(deleteAutoresizeBackup));
        }

        /**
         * @param encrypt Sets if the storage is encrypted at rest.
         * 
         * @return builder
         * 
         */
        public Builder encrypt(@Nullable Output<Boolean> encrypt) {
            $.encrypt = encrypt;
            return this;
        }

        /**
         * @param encrypt Sets if the storage is encrypted at rest.
         * 
         * @return builder
         * 
         */
        public Builder encrypt(Boolean encrypt) {
            return encrypt(Output.of(encrypt));
        }

        /**
         * @param filesystemAutoresize If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `delete_autoresize_backup` option is set to true).
         * 				Taking and keeping backups incure costs.
         * 
         * @return builder
         * 
         */
        public Builder filesystemAutoresize(@Nullable Output<Boolean> filesystemAutoresize) {
            $.filesystemAutoresize = filesystemAutoresize;
            return this;
        }

        /**
         * @param filesystemAutoresize If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `delete_autoresize_backup` option is set to true).
         * 				Taking and keeping backups incure costs.
         * 
         * @return builder
         * 
         */
        public Builder filesystemAutoresize(Boolean filesystemAutoresize) {
            return filesystemAutoresize(Output.of(filesystemAutoresize));
        }

        /**
         * @param import_ Block defining external data to import to storage
         * 
         * @return builder
         * 
         */
        public Builder import_(@Nullable Output<StorageImportArgs> import_) {
            $.import_ = import_;
            return this;
        }

        /**
         * @param import_ Block defining external data to import to storage
         * 
         * @return builder
         * 
         */
        public Builder import_(StorageImportArgs import_) {
            return import_(Output.of(import_));
        }

        /**
         * @param labels User defined key-value pairs to classify the storage.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels User defined key-value pairs to classify the storage.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param size The size of the storage in gigabytes.
         * 
         * @return builder
         * 
         */
        public Builder size(Output<Integer> size) {
            $.size = size;
            return this;
        }

        /**
         * @param size The size of the storage in gigabytes.
         * 
         * @return builder
         * 
         */
        public Builder size(Integer size) {
            return size(Output.of(size));
        }

        /**
         * @param tier The tier of the storage.
         * 
         * @return builder
         * 
         */
        public Builder tier(@Nullable Output<String> tier) {
            $.tier = tier;
            return this;
        }

        /**
         * @param tier The tier of the storage.
         * 
         * @return builder
         * 
         */
        public Builder tier(String tier) {
            return tier(Output.of(tier));
        }

        /**
         * @param title The title of the storage.
         * 
         * @return builder
         * 
         */
        public Builder title(Output<String> title) {
            $.title = title;
            return this;
        }

        /**
         * @param title The title of the storage.
         * 
         * @return builder
         * 
         */
        public Builder title(String title) {
            return title(Output.of(title));
        }

        /**
         * @param zone The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
         * 
         * @return builder
         * 
         */
        public Builder zone(Output<String> zone) {
            $.zone = zone;
            return this;
        }

        /**
         * @param zone The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
         * 
         * @return builder
         * 
         */
        public Builder zone(String zone) {
            return zone(Output.of(zone));
        }

        public StorageArgs build() {
            if ($.size == null) {
                throw new MissingRequiredPropertyException("StorageArgs", "size");
            }
            if ($.title == null) {
                throw new MissingRequiredPropertyException("StorageArgs", "title");
            }
            if ($.zone == null) {
                throw new MissingRequiredPropertyException("StorageArgs", "zone");
            }
            return $;
        }
    }

}
