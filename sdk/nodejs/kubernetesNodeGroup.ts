// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * This resource represents a [Managed Kubernetes](https://upcloud.com/products/managed-kubernetes) cluster.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as upcloud from "@upcloud/pulumi-upcloud";
 *
 * // Create a network for the Kubernetes cluster
 * const example = new upcloud.Network("example", {
 *     name: "example-network",
 *     zone: "de-fra1",
 *     ipNetwork: {
 *         address: "172.16.1.0/24",
 *         dhcp: true,
 *         family: "IPv4",
 *     },
 * });
 * // Create a Kubernetes cluster
 * const exampleKubernetesCluster = new upcloud.KubernetesCluster("example", {
 *     controlPlaneIpFilters: ["0.0.0.0/0"],
 *     name: "exampleapp",
 *     network: example.id,
 *     zone: "de-fra1",
 * });
 * // Create a Kubernetes cluster node group
 * const group = new upcloud.KubernetesNodeGroup("group", {
 *     cluster: upcloudKubernetesCluster.example.id,
 *     nodeCount: 2,
 *     name: "medium",
 *     plan: "2xCPU-4GB",
 *     labels: {
 *         managedBy: "terraform",
 *     },
 *     taints: [{
 *         effect: "NoExecute",
 *         key: "taintKey",
 *         value: "taintValue",
 *     }],
 * });
 * // Create a Kubernetes cluster node group with a GPU plan, with a custom storage size
 * const groupGpu = new upcloud.KubernetesNodeGroup("group_gpu", {
 *     cluster: upcloudKubernetesCluster.example.id,
 *     nodeCount: 2,
 *     name: "gpu-workers",
 *     plan: "GPU-8xCPU-64GB-1xL40S",
 *     gpuPlan: {
 *         storageSize: 250,
 *     },
 *     labels: {
 *         gpu: "NVIDIA-L40S",
 *     },
 * });
 * // Create a Kubernetes cluster node group with a Cloud Native plan, with a custom storage size and tier
 * const groupCloudNative = new upcloud.KubernetesNodeGroup("group_cloud_native", {
 *     cluster: upcloudKubernetesCluster.example.id,
 *     nodeCount: 4,
 *     name: "cloud-native-workers",
 *     plan: "CLOUDNATIVE-4xCPU-8GB",
 *     cloudNativePlan: {
 *         storageSize: 100,
 *         storageTier: "standard",
 *     },
 * });
 * ```
 */
export class KubernetesNodeGroup extends pulumi.CustomResource {
    /**
     * Get an existing KubernetesNodeGroup resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: KubernetesNodeGroupState, opts?: pulumi.CustomResourceOptions): KubernetesNodeGroup {
        return new KubernetesNodeGroup(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'upcloud:index/kubernetesNodeGroup:KubernetesNodeGroup';

    /**
     * Returns true if the given object is an instance of KubernetesNodeGroup.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is KubernetesNodeGroup {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === KubernetesNodeGroup.__pulumiType;
    }

    /**
     * If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
     */
    declare public readonly antiAffinity: pulumi.Output<boolean>;
    /**
     * Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans.
     */
    declare public readonly cloudNativePlan: pulumi.Output<outputs.KubernetesNodeGroupCloudNativePlan | undefined>;
    /**
     * UUID of the cluster.
     */
    declare public readonly cluster: pulumi.Output<string>;
    /**
     * Resource properties for custom plan. This block is required for `custom` plans only.
     */
    declare public readonly customPlan: pulumi.Output<outputs.KubernetesNodeGroupCustomPlan | undefined>;
    /**
     * Resource properties for GPU plan storage configuration. This block is optional for GPU plans.
     */
    declare public readonly gpuPlan: pulumi.Output<outputs.KubernetesNodeGroupGpuPlan | undefined>;
    /**
     * Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will prefix the arguments with `--` when preparing kubelet call.
     *
     *     Note that these arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
     */
    declare public readonly kubeletArgs: pulumi.Output<outputs.KubernetesNodeGroupKubeletArg[] | undefined>;
    /**
     * User defined key-value pairs to classify the node_group.
     */
    declare public readonly labels: pulumi.Output<{[key: string]: string}>;
    /**
     * The name of the node group. Needs to be unique within a cluster.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Amount of nodes to provision in the node group.
     */
    declare public readonly nodeCount: pulumi.Output<number>;
    /**
     * The server plan used for the node group. You can list available plans with `upctl server plans`
     */
    declare public readonly plan: pulumi.Output<string>;
    /**
     * You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
     */
    declare public readonly sshKeys: pulumi.Output<string[]>;
    /**
     * The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption strategy will be used, if applicable. Valid values are `data-at-rest` and `none`.
     */
    declare public readonly storageEncryption: pulumi.Output<string>;
    /**
     * Taints for the nodes in this group.
     */
    declare public readonly taints: pulumi.Output<outputs.KubernetesNodeGroupTaint[] | undefined>;
    /**
     * If set to false, nodes in this group will not have access to utility network.
     */
    declare public readonly utilityNetworkAccess: pulumi.Output<boolean>;

    /**
     * Create a KubernetesNodeGroup resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: KubernetesNodeGroupArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: KubernetesNodeGroupArgs | KubernetesNodeGroupState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as KubernetesNodeGroupState | undefined;
            resourceInputs["antiAffinity"] = state?.antiAffinity;
            resourceInputs["cloudNativePlan"] = state?.cloudNativePlan;
            resourceInputs["cluster"] = state?.cluster;
            resourceInputs["customPlan"] = state?.customPlan;
            resourceInputs["gpuPlan"] = state?.gpuPlan;
            resourceInputs["kubeletArgs"] = state?.kubeletArgs;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["name"] = state?.name;
            resourceInputs["nodeCount"] = state?.nodeCount;
            resourceInputs["plan"] = state?.plan;
            resourceInputs["sshKeys"] = state?.sshKeys;
            resourceInputs["storageEncryption"] = state?.storageEncryption;
            resourceInputs["taints"] = state?.taints;
            resourceInputs["utilityNetworkAccess"] = state?.utilityNetworkAccess;
        } else {
            const args = argsOrState as KubernetesNodeGroupArgs | undefined;
            if (args?.cluster === undefined && !opts.urn) {
                throw new Error("Missing required property 'cluster'");
            }
            if (args?.nodeCount === undefined && !opts.urn) {
                throw new Error("Missing required property 'nodeCount'");
            }
            if (args?.plan === undefined && !opts.urn) {
                throw new Error("Missing required property 'plan'");
            }
            resourceInputs["antiAffinity"] = args?.antiAffinity;
            resourceInputs["cloudNativePlan"] = args?.cloudNativePlan;
            resourceInputs["cluster"] = args?.cluster;
            resourceInputs["customPlan"] = args?.customPlan;
            resourceInputs["gpuPlan"] = args?.gpuPlan;
            resourceInputs["kubeletArgs"] = args?.kubeletArgs;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["name"] = args?.name;
            resourceInputs["nodeCount"] = args?.nodeCount;
            resourceInputs["plan"] = args?.plan;
            resourceInputs["sshKeys"] = args?.sshKeys;
            resourceInputs["storageEncryption"] = args?.storageEncryption;
            resourceInputs["taints"] = args?.taints;
            resourceInputs["utilityNetworkAccess"] = args?.utilityNetworkAccess;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(KubernetesNodeGroup.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering KubernetesNodeGroup resources.
 */
export interface KubernetesNodeGroupState {
    /**
     * If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
     */
    antiAffinity?: pulumi.Input<boolean>;
    /**
     * Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans.
     */
    cloudNativePlan?: pulumi.Input<inputs.KubernetesNodeGroupCloudNativePlan>;
    /**
     * UUID of the cluster.
     */
    cluster?: pulumi.Input<string>;
    /**
     * Resource properties for custom plan. This block is required for `custom` plans only.
     */
    customPlan?: pulumi.Input<inputs.KubernetesNodeGroupCustomPlan>;
    /**
     * Resource properties for GPU plan storage configuration. This block is optional for GPU plans.
     */
    gpuPlan?: pulumi.Input<inputs.KubernetesNodeGroupGpuPlan>;
    /**
     * Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will prefix the arguments with `--` when preparing kubelet call.
     *
     *     Note that these arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
     */
    kubeletArgs?: pulumi.Input<pulumi.Input<inputs.KubernetesNodeGroupKubeletArg>[]>;
    /**
     * User defined key-value pairs to classify the node_group.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The name of the node group. Needs to be unique within a cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * Amount of nodes to provision in the node group.
     */
    nodeCount?: pulumi.Input<number>;
    /**
     * The server plan used for the node group. You can list available plans with `upctl server plans`
     */
    plan?: pulumi.Input<string>;
    /**
     * You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
     */
    sshKeys?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption strategy will be used, if applicable. Valid values are `data-at-rest` and `none`.
     */
    storageEncryption?: pulumi.Input<string>;
    /**
     * Taints for the nodes in this group.
     */
    taints?: pulumi.Input<pulumi.Input<inputs.KubernetesNodeGroupTaint>[]>;
    /**
     * If set to false, nodes in this group will not have access to utility network.
     */
    utilityNetworkAccess?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a KubernetesNodeGroup resource.
 */
export interface KubernetesNodeGroupArgs {
    /**
     * If set to true, nodes in this group will be placed on separate compute hosts. Please note that anti-affinity policy is considered 'best effort' and enabling it does not fully guarantee that the nodes will end up on different hardware.
     */
    antiAffinity?: pulumi.Input<boolean>;
    /**
     * Resource properties for Cloud Native plan storage configuration. This block is optional for Cloud Native plans.
     */
    cloudNativePlan?: pulumi.Input<inputs.KubernetesNodeGroupCloudNativePlan>;
    /**
     * UUID of the cluster.
     */
    cluster: pulumi.Input<string>;
    /**
     * Resource properties for custom plan. This block is required for `custom` plans only.
     */
    customPlan?: pulumi.Input<inputs.KubernetesNodeGroupCustomPlan>;
    /**
     * Resource properties for GPU plan storage configuration. This block is optional for GPU plans.
     */
    gpuPlan?: pulumi.Input<inputs.KubernetesNodeGroupGpuPlan>;
    /**
     * Additional arguments for kubelet for the nodes in this group. Configure the arguments without leading `--`. The API will prefix the arguments with `--` when preparing kubelet call.
     *
     *     Note that these arguments will be passed directly to kubelet CLI on each worker node without any validation. Passing invalid arguments can break your whole cluster. Be extra careful when adding kubelet args.
     */
    kubeletArgs?: pulumi.Input<pulumi.Input<inputs.KubernetesNodeGroupKubeletArg>[]>;
    /**
     * User defined key-value pairs to classify the node_group.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The name of the node group. Needs to be unique within a cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * Amount of nodes to provision in the node group.
     */
    nodeCount: pulumi.Input<number>;
    /**
     * The server plan used for the node group. You can list available plans with `upctl server plans`
     */
    plan: pulumi.Input<string>;
    /**
     * You can optionally select SSH keys to be added as authorized keys to the nodes in this node group. This allows you to connect to the nodes via SSH once they are running.
     */
    sshKeys?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The storage encryption strategy to use for the nodes in this group. If not set, the cluster's storage encryption strategy will be used, if applicable. Valid values are `data-at-rest` and `none`.
     */
    storageEncryption?: pulumi.Input<string>;
    /**
     * Taints for the nodes in this group.
     */
    taints?: pulumi.Input<pulumi.Input<inputs.KubernetesNodeGroupTaint>[]>;
    /**
     * If set to false, nodes in this group will not have access to utility network.
     */
    utilityNetworkAccess?: pulumi.Input<boolean>;
}
