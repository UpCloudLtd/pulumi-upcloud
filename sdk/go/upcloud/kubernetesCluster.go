// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package upcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource represents a [Managed Kubernetes](https://upcloud.com/products/managed-kubernetes) cluster.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a network for the Kubernetes cluster
//			example, err := upcloud.NewNetwork(ctx, "example", &upcloud.NetworkArgs{
//				Name: pulumi.String("example-network"),
//				Zone: pulumi.String("de-fra1"),
//				IpNetwork: &upcloud.NetworkIpNetworkArgs{
//					Address: pulumi.String("172.16.1.0/24"),
//					Dhcp:    pulumi.Bool(true),
//					Family:  pulumi.String("IPv4"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Create a Kubernetes cluster
//			_, err = upcloud.NewKubernetesCluster(ctx, "example", &upcloud.KubernetesClusterArgs{
//				ControlPlaneIpFilters: pulumi.StringArray{
//					pulumi.String("0.0.0.0/0"),
//				},
//				Name:    pulumi.String("exampleapp"),
//				Network: example.ID(),
//				Zone:    pulumi.String("de-fra1"),
//			})
//			if err != nil {
//				return err
//			}
//			// Kubernetes cluster with private node groups requires a network that is routed through NAT gateway.
//			example2, err := upcloud.NewRouter(ctx, "example2", &upcloud.RouterArgs{
//				Name: pulumi.String("example2-router"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = upcloud.NewGateway(ctx, "example2", &upcloud.GatewayArgs{
//				Name: pulumi.String("example2-nat-gateway"),
//				Zone: pulumi.String("de-fra1"),
//				Features: pulumi.StringArray{
//					pulumi.String("nat"),
//				},
//				Router: &upcloud.GatewayRouterArgs{
//					Id: example2.ID(),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			example2Network, err := upcloud.NewNetwork(ctx, "example2", &upcloud.NetworkArgs{
//				Name: pulumi.String("example2-network"),
//				Zone: pulumi.String("de-fra1"),
//				IpNetwork: &upcloud.NetworkIpNetworkArgs{
//					Address:          pulumi.String("10.10.0.0/24"),
//					Dhcp:             pulumi.Bool(true),
//					Family:           pulumi.String("IPv4"),
//					DhcpDefaultRoute: pulumi.Bool(true),
//				},
//				Router: example2.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = upcloud.NewKubernetesCluster(ctx, "example2", &upcloud.KubernetesClusterArgs{
//				ControlPlaneIpFilters: pulumi.StringArray{
//					pulumi.String("0.0.0.0/0"),
//				},
//				Name:              pulumi.String("example2-cluster"),
//				Network:           example2Network.ID(),
//				Zone:              pulumi.String("de-fra1"),
//				Plan:              pulumi.String("prod-md"),
//				PrivateNodeGroups: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type KubernetesCluster struct {
	pulumi.CustomResourceState

	// IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any
	// source, use `["0.0.0.0/0"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node
	// groups or exposed Kubernetes services.
	ControlPlaneIpFilters pulumi.StringArrayOutput `pulumi:"controlPlaneIpFilters"`
	// User defined key-value pairs to classify the cluster.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Cluster name. Needs to be unique within the account.
	Name pulumi.StringOutput `pulumi:"name"`
	// Network ID for the cluster to run in.
	Network pulumi.StringOutput `pulumi:"network"`
	// Network CIDR for the given network. Computed automatically.
	NetworkCidr pulumi.StringOutput `pulumi:"networkCidr"`
	// Names of the node groups configured to cluster
	NodeGroups pulumi.StringArrayOutput `pulumi:"nodeGroups"`
	// The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.
	Plan pulumi.StringOutput `pulumi:"plan"`
	// Enable private node groups. Private node groups requires a network that is routed through NAT gateway.
	PrivateNodeGroups pulumi.BoolOutput `pulumi:"privateNodeGroups"`
	// Operational state of the cluster.
	State pulumi.StringOutput `pulumi:"state"`
	// Set default storage encryption strategy for all nodes in the cluster.
	StorageEncryption pulumi.StringPtrOutput `pulumi:"storageEncryption"`
	// The upgrade strategy to use when changing the cluster `version`. If not set, `manual` strategy will be used by default.
	// When using `manual` strategy, you must replace the existing node-groups to update them.
	UpgradeStrategyType pulumi.StringPtrOutput `pulumi:"upgradeStrategyType"`
	// Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`. Note that when
	// changing the cluster version, `upgradeStrategy` will be taken into account.
	Version pulumi.StringOutput `pulumi:"version"`
	// Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone
	// list`.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewKubernetesCluster registers a new resource with the given unique name, arguments, and options.
func NewKubernetesCluster(ctx *pulumi.Context,
	name string, args *KubernetesClusterArgs, opts ...pulumi.ResourceOption) (*KubernetesCluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ControlPlaneIpFilters == nil {
		return nil, errors.New("invalid value for required argument 'ControlPlaneIpFilters'")
	}
	if args.Network == nil {
		return nil, errors.New("invalid value for required argument 'Network'")
	}
	if args.Zone == nil {
		return nil, errors.New("invalid value for required argument 'Zone'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KubernetesCluster
	err := ctx.RegisterResource("upcloud:index/kubernetesCluster:KubernetesCluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKubernetesCluster gets an existing KubernetesCluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKubernetesCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KubernetesClusterState, opts ...pulumi.ResourceOption) (*KubernetesCluster, error) {
	var resource KubernetesCluster
	err := ctx.ReadResource("upcloud:index/kubernetesCluster:KubernetesCluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KubernetesCluster resources.
type kubernetesClusterState struct {
	// IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any
	// source, use `["0.0.0.0/0"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node
	// groups or exposed Kubernetes services.
	ControlPlaneIpFilters []string `pulumi:"controlPlaneIpFilters"`
	// User defined key-value pairs to classify the cluster.
	Labels map[string]string `pulumi:"labels"`
	// Cluster name. Needs to be unique within the account.
	Name *string `pulumi:"name"`
	// Network ID for the cluster to run in.
	Network *string `pulumi:"network"`
	// Network CIDR for the given network. Computed automatically.
	NetworkCidr *string `pulumi:"networkCidr"`
	// Names of the node groups configured to cluster
	NodeGroups []string `pulumi:"nodeGroups"`
	// The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.
	Plan *string `pulumi:"plan"`
	// Enable private node groups. Private node groups requires a network that is routed through NAT gateway.
	PrivateNodeGroups *bool `pulumi:"privateNodeGroups"`
	// Operational state of the cluster.
	State *string `pulumi:"state"`
	// Set default storage encryption strategy for all nodes in the cluster.
	StorageEncryption *string `pulumi:"storageEncryption"`
	// The upgrade strategy to use when changing the cluster `version`. If not set, `manual` strategy will be used by default.
	// When using `manual` strategy, you must replace the existing node-groups to update them.
	UpgradeStrategyType *string `pulumi:"upgradeStrategyType"`
	// Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`. Note that when
	// changing the cluster version, `upgradeStrategy` will be taken into account.
	Version *string `pulumi:"version"`
	// Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone
	// list`.
	Zone *string `pulumi:"zone"`
}

type KubernetesClusterState struct {
	// IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any
	// source, use `["0.0.0.0/0"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node
	// groups or exposed Kubernetes services.
	ControlPlaneIpFilters pulumi.StringArrayInput
	// User defined key-value pairs to classify the cluster.
	Labels pulumi.StringMapInput
	// Cluster name. Needs to be unique within the account.
	Name pulumi.StringPtrInput
	// Network ID for the cluster to run in.
	Network pulumi.StringPtrInput
	// Network CIDR for the given network. Computed automatically.
	NetworkCidr pulumi.StringPtrInput
	// Names of the node groups configured to cluster
	NodeGroups pulumi.StringArrayInput
	// The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.
	Plan pulumi.StringPtrInput
	// Enable private node groups. Private node groups requires a network that is routed through NAT gateway.
	PrivateNodeGroups pulumi.BoolPtrInput
	// Operational state of the cluster.
	State pulumi.StringPtrInput
	// Set default storage encryption strategy for all nodes in the cluster.
	StorageEncryption pulumi.StringPtrInput
	// The upgrade strategy to use when changing the cluster `version`. If not set, `manual` strategy will be used by default.
	// When using `manual` strategy, you must replace the existing node-groups to update them.
	UpgradeStrategyType pulumi.StringPtrInput
	// Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`. Note that when
	// changing the cluster version, `upgradeStrategy` will be taken into account.
	Version pulumi.StringPtrInput
	// Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone
	// list`.
	Zone pulumi.StringPtrInput
}

func (KubernetesClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*kubernetesClusterState)(nil)).Elem()
}

type kubernetesClusterArgs struct {
	// IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any
	// source, use `["0.0.0.0/0"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node
	// groups or exposed Kubernetes services.
	ControlPlaneIpFilters []string `pulumi:"controlPlaneIpFilters"`
	// User defined key-value pairs to classify the cluster.
	Labels map[string]string `pulumi:"labels"`
	// Cluster name. Needs to be unique within the account.
	Name *string `pulumi:"name"`
	// Network ID for the cluster to run in.
	Network string `pulumi:"network"`
	// The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.
	Plan *string `pulumi:"plan"`
	// Enable private node groups. Private node groups requires a network that is routed through NAT gateway.
	PrivateNodeGroups *bool `pulumi:"privateNodeGroups"`
	// Set default storage encryption strategy for all nodes in the cluster.
	StorageEncryption *string `pulumi:"storageEncryption"`
	// The upgrade strategy to use when changing the cluster `version`. If not set, `manual` strategy will be used by default.
	// When using `manual` strategy, you must replace the existing node-groups to update them.
	UpgradeStrategyType *string `pulumi:"upgradeStrategyType"`
	// Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`. Note that when
	// changing the cluster version, `upgradeStrategy` will be taken into account.
	Version *string `pulumi:"version"`
	// Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone
	// list`.
	Zone string `pulumi:"zone"`
}

// The set of arguments for constructing a KubernetesCluster resource.
type KubernetesClusterArgs struct {
	// IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any
	// source, use `["0.0.0.0/0"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node
	// groups or exposed Kubernetes services.
	ControlPlaneIpFilters pulumi.StringArrayInput
	// User defined key-value pairs to classify the cluster.
	Labels pulumi.StringMapInput
	// Cluster name. Needs to be unique within the account.
	Name pulumi.StringPtrInput
	// Network ID for the cluster to run in.
	Network pulumi.StringInput
	// The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.
	Plan pulumi.StringPtrInput
	// Enable private node groups. Private node groups requires a network that is routed through NAT gateway.
	PrivateNodeGroups pulumi.BoolPtrInput
	// Set default storage encryption strategy for all nodes in the cluster.
	StorageEncryption pulumi.StringPtrInput
	// The upgrade strategy to use when changing the cluster `version`. If not set, `manual` strategy will be used by default.
	// When using `manual` strategy, you must replace the existing node-groups to update them.
	UpgradeStrategyType pulumi.StringPtrInput
	// Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`. Note that when
	// changing the cluster version, `upgradeStrategy` will be taken into account.
	Version pulumi.StringPtrInput
	// Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone
	// list`.
	Zone pulumi.StringInput
}

func (KubernetesClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kubernetesClusterArgs)(nil)).Elem()
}

type KubernetesClusterInput interface {
	pulumi.Input

	ToKubernetesClusterOutput() KubernetesClusterOutput
	ToKubernetesClusterOutputWithContext(ctx context.Context) KubernetesClusterOutput
}

func (*KubernetesCluster) ElementType() reflect.Type {
	return reflect.TypeOf((**KubernetesCluster)(nil)).Elem()
}

func (i *KubernetesCluster) ToKubernetesClusterOutput() KubernetesClusterOutput {
	return i.ToKubernetesClusterOutputWithContext(context.Background())
}

func (i *KubernetesCluster) ToKubernetesClusterOutputWithContext(ctx context.Context) KubernetesClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesClusterOutput)
}

// KubernetesClusterArrayInput is an input type that accepts KubernetesClusterArray and KubernetesClusterArrayOutput values.
// You can construct a concrete instance of `KubernetesClusterArrayInput` via:
//
//	KubernetesClusterArray{ KubernetesClusterArgs{...} }
type KubernetesClusterArrayInput interface {
	pulumi.Input

	ToKubernetesClusterArrayOutput() KubernetesClusterArrayOutput
	ToKubernetesClusterArrayOutputWithContext(context.Context) KubernetesClusterArrayOutput
}

type KubernetesClusterArray []KubernetesClusterInput

func (KubernetesClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KubernetesCluster)(nil)).Elem()
}

func (i KubernetesClusterArray) ToKubernetesClusterArrayOutput() KubernetesClusterArrayOutput {
	return i.ToKubernetesClusterArrayOutputWithContext(context.Background())
}

func (i KubernetesClusterArray) ToKubernetesClusterArrayOutputWithContext(ctx context.Context) KubernetesClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesClusterArrayOutput)
}

// KubernetesClusterMapInput is an input type that accepts KubernetesClusterMap and KubernetesClusterMapOutput values.
// You can construct a concrete instance of `KubernetesClusterMapInput` via:
//
//	KubernetesClusterMap{ "key": KubernetesClusterArgs{...} }
type KubernetesClusterMapInput interface {
	pulumi.Input

	ToKubernetesClusterMapOutput() KubernetesClusterMapOutput
	ToKubernetesClusterMapOutputWithContext(context.Context) KubernetesClusterMapOutput
}

type KubernetesClusterMap map[string]KubernetesClusterInput

func (KubernetesClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KubernetesCluster)(nil)).Elem()
}

func (i KubernetesClusterMap) ToKubernetesClusterMapOutput() KubernetesClusterMapOutput {
	return i.ToKubernetesClusterMapOutputWithContext(context.Background())
}

func (i KubernetesClusterMap) ToKubernetesClusterMapOutputWithContext(ctx context.Context) KubernetesClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KubernetesClusterMapOutput)
}

type KubernetesClusterOutput struct{ *pulumi.OutputState }

func (KubernetesClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KubernetesCluster)(nil)).Elem()
}

func (o KubernetesClusterOutput) ToKubernetesClusterOutput() KubernetesClusterOutput {
	return o
}

func (o KubernetesClusterOutput) ToKubernetesClusterOutputWithContext(ctx context.Context) KubernetesClusterOutput {
	return o
}

// IP addresses or IP ranges in CIDR format which are allowed to access the cluster control plane. To allow access from any
// source, use `["0.0.0.0/0"]`. To deny access from all sources, use `[]`. Values set here do not restrict access to node
// groups or exposed Kubernetes services.
func (o KubernetesClusterOutput) ControlPlaneIpFilters() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringArrayOutput { return v.ControlPlaneIpFilters }).(pulumi.StringArrayOutput)
}

// User defined key-value pairs to classify the cluster.
func (o KubernetesClusterOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Cluster name. Needs to be unique within the account.
func (o KubernetesClusterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Network ID for the cluster to run in.
func (o KubernetesClusterOutput) Network() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringOutput { return v.Network }).(pulumi.StringOutput)
}

// Network CIDR for the given network. Computed automatically.
func (o KubernetesClusterOutput) NetworkCidr() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringOutput { return v.NetworkCidr }).(pulumi.StringOutput)
}

// Names of the node groups configured to cluster
func (o KubernetesClusterOutput) NodeGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringArrayOutput { return v.NodeGroups }).(pulumi.StringArrayOutput)
}

// The pricing plan used for the cluster. You can list available plans with `upctl kubernetes plans`.
func (o KubernetesClusterOutput) Plan() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringOutput { return v.Plan }).(pulumi.StringOutput)
}

// Enable private node groups. Private node groups requires a network that is routed through NAT gateway.
func (o KubernetesClusterOutput) PrivateNodeGroups() pulumi.BoolOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.BoolOutput { return v.PrivateNodeGroups }).(pulumi.BoolOutput)
}

// Operational state of the cluster.
func (o KubernetesClusterOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Set default storage encryption strategy for all nodes in the cluster.
func (o KubernetesClusterOutput) StorageEncryption() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringPtrOutput { return v.StorageEncryption }).(pulumi.StringPtrOutput)
}

// The upgrade strategy to use when changing the cluster `version`. If not set, `manual` strategy will be used by default.
// When using `manual` strategy, you must replace the existing node-groups to update them.
func (o KubernetesClusterOutput) UpgradeStrategyType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringPtrOutput { return v.UpgradeStrategyType }).(pulumi.StringPtrOutput)
}

// Kubernetes version ID, e.g. `1.31`. You can list available version IDs with `upctl kubernetes versions`. Note that when
// changing the cluster version, `upgradeStrategy` will be taken into account.
func (o KubernetesClusterOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringOutput { return v.Version }).(pulumi.StringOutput)
}

// Zone in which the Kubernetes cluster will be hosted, e.g. `de-fra1`. You can list available zones with `upctl zone
// list`.
func (o KubernetesClusterOutput) Zone() pulumi.StringOutput {
	return o.ApplyT(func(v *KubernetesCluster) pulumi.StringOutput { return v.Zone }).(pulumi.StringOutput)
}

type KubernetesClusterArrayOutput struct{ *pulumi.OutputState }

func (KubernetesClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KubernetesCluster)(nil)).Elem()
}

func (o KubernetesClusterArrayOutput) ToKubernetesClusterArrayOutput() KubernetesClusterArrayOutput {
	return o
}

func (o KubernetesClusterArrayOutput) ToKubernetesClusterArrayOutputWithContext(ctx context.Context) KubernetesClusterArrayOutput {
	return o
}

func (o KubernetesClusterArrayOutput) Index(i pulumi.IntInput) KubernetesClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KubernetesCluster {
		return vs[0].([]*KubernetesCluster)[vs[1].(int)]
	}).(KubernetesClusterOutput)
}

type KubernetesClusterMapOutput struct{ *pulumi.OutputState }

func (KubernetesClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KubernetesCluster)(nil)).Elem()
}

func (o KubernetesClusterMapOutput) ToKubernetesClusterMapOutput() KubernetesClusterMapOutput {
	return o
}

func (o KubernetesClusterMapOutput) ToKubernetesClusterMapOutputWithContext(ctx context.Context) KubernetesClusterMapOutput {
	return o
}

func (o KubernetesClusterMapOutput) MapIndex(k pulumi.StringInput) KubernetesClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KubernetesCluster {
		return vs[0].(map[string]*KubernetesCluster)[vs[1].(string)]
	}).(KubernetesClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesClusterInput)(nil)).Elem(), &KubernetesCluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesClusterArrayInput)(nil)).Elem(), KubernetesClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KubernetesClusterMapInput)(nil)).Elem(), KubernetesClusterMap{})
	pulumi.RegisterOutputType(KubernetesClusterOutput{})
	pulumi.RegisterOutputType(KubernetesClusterArrayOutput{})
	pulumi.RegisterOutputType(KubernetesClusterMapOutput{})
}
