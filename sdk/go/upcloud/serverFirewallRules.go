// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package upcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Firewall rules are used to control network access of UpCloud servers. Each server has its own firewall rules and there should be only one `ServerFirewallRules` resource per server.
// The firewall is enabled on public and utility network interfaces.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// The following example defines a server and then links the server to a single firewall rule.
//			// The list of firewall rules applied to the server can be expanded by providing additional server_firewall_rules blocks.
//			example, err := upcloud.NewServer(ctx, "example", &upcloud.ServerArgs{
//				Firewall: pulumi.Bool(true),
//				Hostname: pulumi.String("terraform.example.tld"),
//				Zone:     pulumi.String("de-fra1"),
//				Plan:     pulumi.String("1xCPU-1GB"),
//				Metadata: pulumi.Bool(true),
//				Login: &upcloud.ServerLoginArgs{
//					PasswordDelivery: pulumi.String("none"),
//				},
//				Template: &upcloud.ServerTemplateArgs{
//					Storage: pulumi.String("Ubuntu Server 24.04 LTS (Noble Numbat)"),
//				},
//				NetworkInterfaces: upcloud.ServerNetworkInterfaceArray{
//					&upcloud.ServerNetworkInterfaceArgs{
//						Type: pulumi.String("utility"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = upcloud.NewServerFirewallRules(ctx, "example", &upcloud.ServerFirewallRulesArgs{
//				ServerId: example.ID(),
//				FirewallRules: upcloud.ServerFirewallRulesFirewallRuleArray{
//					&upcloud.ServerFirewallRulesFirewallRuleArgs{
//						Action:               pulumi.String("accept"),
//						Comment:              pulumi.String("Allow SSH from this network"),
//						DestinationPortEnd:   pulumi.String("22"),
//						DestinationPortStart: pulumi.String("22"),
//						Direction:            pulumi.String("in"),
//						Family:               pulumi.String("IPv4"),
//						Protocol:             pulumi.String("tcp"),
//						SourceAddressEnd:     pulumi.String("192.168.1.255"),
//						SourceAddressStart:   pulumi.String("192.168.1.1"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The `pulumi import` command can be used, for example:
//
// ```sh
// $ pulumi import upcloud:index/serverFirewallRules:ServerFirewallRules my_example_rules 049d7ca2-757e-4fb1-a833-f87ee056547a
// ```
type ServerFirewallRules struct {
	pulumi.CustomResourceState

	// A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.
	//
	//     Typical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one destination/source-address/port range.
	//
	//     A default rule can be created by providing only `action` and `direction` attributes. Default rule should be defined last.
	//
	//     If used, IP address and port ranges must have both start and end values specified. These can be the same value if only one IP address or port number is specified.
	//     Source and destination port numbers can only be set if the protocol is TCP or UDP.
	//     The ICMP type may only be set if the protocol is ICMP.
	FirewallRules ServerFirewallRulesFirewallRuleArrayOutput `pulumi:"firewallRules"`
	// The UUID of the server to be protected with the firewall rules.
	ServerId pulumi.StringOutput `pulumi:"serverId"`
}

// NewServerFirewallRules registers a new resource with the given unique name, arguments, and options.
func NewServerFirewallRules(ctx *pulumi.Context,
	name string, args *ServerFirewallRulesArgs, opts ...pulumi.ResourceOption) (*ServerFirewallRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ServerId == nil {
		return nil, errors.New("invalid value for required argument 'ServerId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ServerFirewallRules
	err := ctx.RegisterResource("upcloud:index/serverFirewallRules:ServerFirewallRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServerFirewallRules gets an existing ServerFirewallRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServerFirewallRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServerFirewallRulesState, opts ...pulumi.ResourceOption) (*ServerFirewallRules, error) {
	var resource ServerFirewallRules
	err := ctx.ReadResource("upcloud:index/serverFirewallRules:ServerFirewallRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ServerFirewallRules resources.
type serverFirewallRulesState struct {
	// A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.
	//
	//     Typical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one destination/source-address/port range.
	//
	//     A default rule can be created by providing only `action` and `direction` attributes. Default rule should be defined last.
	//
	//     If used, IP address and port ranges must have both start and end values specified. These can be the same value if only one IP address or port number is specified.
	//     Source and destination port numbers can only be set if the protocol is TCP or UDP.
	//     The ICMP type may only be set if the protocol is ICMP.
	FirewallRules []ServerFirewallRulesFirewallRule `pulumi:"firewallRules"`
	// The UUID of the server to be protected with the firewall rules.
	ServerId *string `pulumi:"serverId"`
}

type ServerFirewallRulesState struct {
	// A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.
	//
	//     Typical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one destination/source-address/port range.
	//
	//     A default rule can be created by providing only `action` and `direction` attributes. Default rule should be defined last.
	//
	//     If used, IP address and port ranges must have both start and end values specified. These can be the same value if only one IP address or port number is specified.
	//     Source and destination port numbers can only be set if the protocol is TCP or UDP.
	//     The ICMP type may only be set if the protocol is ICMP.
	FirewallRules ServerFirewallRulesFirewallRuleArrayInput
	// The UUID of the server to be protected with the firewall rules.
	ServerId pulumi.StringPtrInput
}

func (ServerFirewallRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*serverFirewallRulesState)(nil)).Elem()
}

type serverFirewallRulesArgs struct {
	// A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.
	//
	//     Typical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one destination/source-address/port range.
	//
	//     A default rule can be created by providing only `action` and `direction` attributes. Default rule should be defined last.
	//
	//     If used, IP address and port ranges must have both start and end values specified. These can be the same value if only one IP address or port number is specified.
	//     Source and destination port numbers can only be set if the protocol is TCP or UDP.
	//     The ICMP type may only be set if the protocol is ICMP.
	FirewallRules []ServerFirewallRulesFirewallRule `pulumi:"firewallRules"`
	// The UUID of the server to be protected with the firewall rules.
	ServerId string `pulumi:"serverId"`
}

// The set of arguments for constructing a ServerFirewallRules resource.
type ServerFirewallRulesArgs struct {
	// A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.
	//
	//     Typical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one destination/source-address/port range.
	//
	//     A default rule can be created by providing only `action` and `direction` attributes. Default rule should be defined last.
	//
	//     If used, IP address and port ranges must have both start and end values specified. These can be the same value if only one IP address or port number is specified.
	//     Source and destination port numbers can only be set if the protocol is TCP or UDP.
	//     The ICMP type may only be set if the protocol is ICMP.
	FirewallRules ServerFirewallRulesFirewallRuleArrayInput
	// The UUID of the server to be protected with the firewall rules.
	ServerId pulumi.StringInput
}

func (ServerFirewallRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serverFirewallRulesArgs)(nil)).Elem()
}

type ServerFirewallRulesInput interface {
	pulumi.Input

	ToServerFirewallRulesOutput() ServerFirewallRulesOutput
	ToServerFirewallRulesOutputWithContext(ctx context.Context) ServerFirewallRulesOutput
}

func (*ServerFirewallRules) ElementType() reflect.Type {
	return reflect.TypeOf((**ServerFirewallRules)(nil)).Elem()
}

func (i *ServerFirewallRules) ToServerFirewallRulesOutput() ServerFirewallRulesOutput {
	return i.ToServerFirewallRulesOutputWithContext(context.Background())
}

func (i *ServerFirewallRules) ToServerFirewallRulesOutputWithContext(ctx context.Context) ServerFirewallRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerFirewallRulesOutput)
}

// ServerFirewallRulesArrayInput is an input type that accepts ServerFirewallRulesArray and ServerFirewallRulesArrayOutput values.
// You can construct a concrete instance of `ServerFirewallRulesArrayInput` via:
//
//	ServerFirewallRulesArray{ ServerFirewallRulesArgs{...} }
type ServerFirewallRulesArrayInput interface {
	pulumi.Input

	ToServerFirewallRulesArrayOutput() ServerFirewallRulesArrayOutput
	ToServerFirewallRulesArrayOutputWithContext(context.Context) ServerFirewallRulesArrayOutput
}

type ServerFirewallRulesArray []ServerFirewallRulesInput

func (ServerFirewallRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServerFirewallRules)(nil)).Elem()
}

func (i ServerFirewallRulesArray) ToServerFirewallRulesArrayOutput() ServerFirewallRulesArrayOutput {
	return i.ToServerFirewallRulesArrayOutputWithContext(context.Background())
}

func (i ServerFirewallRulesArray) ToServerFirewallRulesArrayOutputWithContext(ctx context.Context) ServerFirewallRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerFirewallRulesArrayOutput)
}

// ServerFirewallRulesMapInput is an input type that accepts ServerFirewallRulesMap and ServerFirewallRulesMapOutput values.
// You can construct a concrete instance of `ServerFirewallRulesMapInput` via:
//
//	ServerFirewallRulesMap{ "key": ServerFirewallRulesArgs{...} }
type ServerFirewallRulesMapInput interface {
	pulumi.Input

	ToServerFirewallRulesMapOutput() ServerFirewallRulesMapOutput
	ToServerFirewallRulesMapOutputWithContext(context.Context) ServerFirewallRulesMapOutput
}

type ServerFirewallRulesMap map[string]ServerFirewallRulesInput

func (ServerFirewallRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServerFirewallRules)(nil)).Elem()
}

func (i ServerFirewallRulesMap) ToServerFirewallRulesMapOutput() ServerFirewallRulesMapOutput {
	return i.ToServerFirewallRulesMapOutputWithContext(context.Background())
}

func (i ServerFirewallRulesMap) ToServerFirewallRulesMapOutputWithContext(ctx context.Context) ServerFirewallRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerFirewallRulesMapOutput)
}

type ServerFirewallRulesOutput struct{ *pulumi.OutputState }

func (ServerFirewallRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServerFirewallRules)(nil)).Elem()
}

func (o ServerFirewallRulesOutput) ToServerFirewallRulesOutput() ServerFirewallRulesOutput {
	return o
}

func (o ServerFirewallRulesOutput) ToServerFirewallRulesOutputWithContext(ctx context.Context) ServerFirewallRulesOutput {
	return o
}

// A single firewall rule. The rules are evaluated in order. The maximum number of firewall rules per server is 1000.
//
//	Typical firewall rule should have `action`, `direction`, `protocol`, `family` and at least one destination/source-address/port range.
//
//	A default rule can be created by providing only `action` and `direction` attributes. Default rule should be defined last.
//
//	If used, IP address and port ranges must have both start and end values specified. These can be the same value if only one IP address or port number is specified.
//	Source and destination port numbers can only be set if the protocol is TCP or UDP.
//	The ICMP type may only be set if the protocol is ICMP.
func (o ServerFirewallRulesOutput) FirewallRules() ServerFirewallRulesFirewallRuleArrayOutput {
	return o.ApplyT(func(v *ServerFirewallRules) ServerFirewallRulesFirewallRuleArrayOutput { return v.FirewallRules }).(ServerFirewallRulesFirewallRuleArrayOutput)
}

// The UUID of the server to be protected with the firewall rules.
func (o ServerFirewallRulesOutput) ServerId() pulumi.StringOutput {
	return o.ApplyT(func(v *ServerFirewallRules) pulumi.StringOutput { return v.ServerId }).(pulumi.StringOutput)
}

type ServerFirewallRulesArrayOutput struct{ *pulumi.OutputState }

func (ServerFirewallRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ServerFirewallRules)(nil)).Elem()
}

func (o ServerFirewallRulesArrayOutput) ToServerFirewallRulesArrayOutput() ServerFirewallRulesArrayOutput {
	return o
}

func (o ServerFirewallRulesArrayOutput) ToServerFirewallRulesArrayOutputWithContext(ctx context.Context) ServerFirewallRulesArrayOutput {
	return o
}

func (o ServerFirewallRulesArrayOutput) Index(i pulumi.IntInput) ServerFirewallRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ServerFirewallRules {
		return vs[0].([]*ServerFirewallRules)[vs[1].(int)]
	}).(ServerFirewallRulesOutput)
}

type ServerFirewallRulesMapOutput struct{ *pulumi.OutputState }

func (ServerFirewallRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ServerFirewallRules)(nil)).Elem()
}

func (o ServerFirewallRulesMapOutput) ToServerFirewallRulesMapOutput() ServerFirewallRulesMapOutput {
	return o
}

func (o ServerFirewallRulesMapOutput) ToServerFirewallRulesMapOutputWithContext(ctx context.Context) ServerFirewallRulesMapOutput {
	return o
}

func (o ServerFirewallRulesMapOutput) MapIndex(k pulumi.StringInput) ServerFirewallRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ServerFirewallRules {
		return vs[0].(map[string]*ServerFirewallRules)[vs[1].(string)]
	}).(ServerFirewallRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServerFirewallRulesInput)(nil)).Elem(), &ServerFirewallRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerFirewallRulesArrayInput)(nil)).Elem(), ServerFirewallRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerFirewallRulesMapInput)(nil)).Elem(), ServerFirewallRulesMap{})
	pulumi.RegisterOutputType(ServerFirewallRulesOutput{})
	pulumi.RegisterOutputType(ServerFirewallRulesArrayOutput{})
	pulumi.RegisterOutputType(ServerFirewallRulesMapOutput{})
}
