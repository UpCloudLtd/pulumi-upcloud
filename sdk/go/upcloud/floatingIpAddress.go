// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package upcloud

import (
	"context"
	"reflect"

	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource represents a UpCloud floating IP address resource.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a detached floating IP address.
//			_, err := upcloud.NewFloatingIpAddress(ctx, "myFloatingAddress", &upcloud.FloatingIpAddressArgs{
//				Zone: pulumi.String("de-fra1"),
//			})
//			if err != nil {
//				return err
//			}
//			// Floating IP address assigned to a server resource.
//			example, err := upcloud.NewServer(ctx, "example", &upcloud.ServerArgs{
//				Hostname: pulumi.String("terraform.example.tld"),
//				Zone:     pulumi.String("de-fra1"),
//				Plan:     pulumi.String("1xCPU-1GB"),
//				Template: &upcloud.ServerTemplateArgs{
//					Storage: pulumi.String("Ubuntu Server 20.04 LTS (Focal Fossa)"),
//					Size:    pulumi.Int(25),
//				},
//				NetworkInterfaces: upcloud.ServerNetworkInterfaceArray{
//					&upcloud.ServerNetworkInterfaceArgs{
//						Type: pulumi.String("public"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = upcloud.NewFloatingIpAddress(ctx, "myNewFloatingAddress", &upcloud.FloatingIpAddressArgs{
//				MacAddress: pulumi.String(example.NetworkInterfaces.ApplyT(func(networkInterfaces []upcloud.ServerNetworkInterface) (*string, error) {
//					return &networkInterfaces[0].MacAddress, nil
//				}).(pulumi.StringPtrOutput)),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import upcloud:index/floatingIpAddress:FloatingIpAddress my_new_floating_address 94.237.114.205
// ```
type FloatingIpAddress struct {
	pulumi.CustomResourceState

	// Network access for the floating IP address. Supported value: `public`.
	Access pulumi.StringOutput `pulumi:"access"`
	// The address family of the floating IP address.
	Family pulumi.StringOutput `pulumi:"family"`
	// An UpCloud assigned IP Address.
	IpAddress pulumi.StringOutput `pulumi:"ipAddress"`
	// MAC address of a server interface to assign address to.
	MacAddress pulumi.StringPtrOutput `pulumi:"macAddress"`
	// Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available
	// zones with `upctl zone list`.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewFloatingIpAddress registers a new resource with the given unique name, arguments, and options.
func NewFloatingIpAddress(ctx *pulumi.Context,
	name string, args *FloatingIpAddressArgs, opts ...pulumi.ResourceOption) (*FloatingIpAddress, error) {
	if args == nil {
		args = &FloatingIpAddressArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FloatingIpAddress
	err := ctx.RegisterResource("upcloud:index/floatingIpAddress:FloatingIpAddress", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFloatingIpAddress gets an existing FloatingIpAddress resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFloatingIpAddress(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FloatingIpAddressState, opts ...pulumi.ResourceOption) (*FloatingIpAddress, error) {
	var resource FloatingIpAddress
	err := ctx.ReadResource("upcloud:index/floatingIpAddress:FloatingIpAddress", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FloatingIpAddress resources.
type floatingIpAddressState struct {
	// Network access for the floating IP address. Supported value: `public`.
	Access *string `pulumi:"access"`
	// The address family of the floating IP address.
	Family *string `pulumi:"family"`
	// An UpCloud assigned IP Address.
	IpAddress *string `pulumi:"ipAddress"`
	// MAC address of a server interface to assign address to.
	MacAddress *string `pulumi:"macAddress"`
	// Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available
	// zones with `upctl zone list`.
	Zone *string `pulumi:"zone"`
}

type FloatingIpAddressState struct {
	// Network access for the floating IP address. Supported value: `public`.
	Access pulumi.StringPtrInput
	// The address family of the floating IP address.
	Family pulumi.StringPtrInput
	// An UpCloud assigned IP Address.
	IpAddress pulumi.StringPtrInput
	// MAC address of a server interface to assign address to.
	MacAddress pulumi.StringPtrInput
	// Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available
	// zones with `upctl zone list`.
	Zone pulumi.StringPtrInput
}

func (FloatingIpAddressState) ElementType() reflect.Type {
	return reflect.TypeOf((*floatingIpAddressState)(nil)).Elem()
}

type floatingIpAddressArgs struct {
	// Network access for the floating IP address. Supported value: `public`.
	Access *string `pulumi:"access"`
	// The address family of the floating IP address.
	Family *string `pulumi:"family"`
	// MAC address of a server interface to assign address to.
	MacAddress *string `pulumi:"macAddress"`
	// Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available
	// zones with `upctl zone list`.
	Zone *string `pulumi:"zone"`
}

// The set of arguments for constructing a FloatingIpAddress resource.
type FloatingIpAddressArgs struct {
	// Network access for the floating IP address. Supported value: `public`.
	Access pulumi.StringPtrInput
	// The address family of the floating IP address.
	Family pulumi.StringPtrInput
	// MAC address of a server interface to assign address to.
	MacAddress pulumi.StringPtrInput
	// Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available
	// zones with `upctl zone list`.
	Zone pulumi.StringPtrInput
}

func (FloatingIpAddressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*floatingIpAddressArgs)(nil)).Elem()
}

type FloatingIpAddressInput interface {
	pulumi.Input

	ToFloatingIpAddressOutput() FloatingIpAddressOutput
	ToFloatingIpAddressOutputWithContext(ctx context.Context) FloatingIpAddressOutput
}

func (*FloatingIpAddress) ElementType() reflect.Type {
	return reflect.TypeOf((**FloatingIpAddress)(nil)).Elem()
}

func (i *FloatingIpAddress) ToFloatingIpAddressOutput() FloatingIpAddressOutput {
	return i.ToFloatingIpAddressOutputWithContext(context.Background())
}

func (i *FloatingIpAddress) ToFloatingIpAddressOutputWithContext(ctx context.Context) FloatingIpAddressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FloatingIpAddressOutput)
}

// FloatingIpAddressArrayInput is an input type that accepts FloatingIpAddressArray and FloatingIpAddressArrayOutput values.
// You can construct a concrete instance of `FloatingIpAddressArrayInput` via:
//
//	FloatingIpAddressArray{ FloatingIpAddressArgs{...} }
type FloatingIpAddressArrayInput interface {
	pulumi.Input

	ToFloatingIpAddressArrayOutput() FloatingIpAddressArrayOutput
	ToFloatingIpAddressArrayOutputWithContext(context.Context) FloatingIpAddressArrayOutput
}

type FloatingIpAddressArray []FloatingIpAddressInput

func (FloatingIpAddressArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FloatingIpAddress)(nil)).Elem()
}

func (i FloatingIpAddressArray) ToFloatingIpAddressArrayOutput() FloatingIpAddressArrayOutput {
	return i.ToFloatingIpAddressArrayOutputWithContext(context.Background())
}

func (i FloatingIpAddressArray) ToFloatingIpAddressArrayOutputWithContext(ctx context.Context) FloatingIpAddressArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FloatingIpAddressArrayOutput)
}

// FloatingIpAddressMapInput is an input type that accepts FloatingIpAddressMap and FloatingIpAddressMapOutput values.
// You can construct a concrete instance of `FloatingIpAddressMapInput` via:
//
//	FloatingIpAddressMap{ "key": FloatingIpAddressArgs{...} }
type FloatingIpAddressMapInput interface {
	pulumi.Input

	ToFloatingIpAddressMapOutput() FloatingIpAddressMapOutput
	ToFloatingIpAddressMapOutputWithContext(context.Context) FloatingIpAddressMapOutput
}

type FloatingIpAddressMap map[string]FloatingIpAddressInput

func (FloatingIpAddressMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FloatingIpAddress)(nil)).Elem()
}

func (i FloatingIpAddressMap) ToFloatingIpAddressMapOutput() FloatingIpAddressMapOutput {
	return i.ToFloatingIpAddressMapOutputWithContext(context.Background())
}

func (i FloatingIpAddressMap) ToFloatingIpAddressMapOutputWithContext(ctx context.Context) FloatingIpAddressMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FloatingIpAddressMapOutput)
}

type FloatingIpAddressOutput struct{ *pulumi.OutputState }

func (FloatingIpAddressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FloatingIpAddress)(nil)).Elem()
}

func (o FloatingIpAddressOutput) ToFloatingIpAddressOutput() FloatingIpAddressOutput {
	return o
}

func (o FloatingIpAddressOutput) ToFloatingIpAddressOutputWithContext(ctx context.Context) FloatingIpAddressOutput {
	return o
}

// Network access for the floating IP address. Supported value: `public`.
func (o FloatingIpAddressOutput) Access() pulumi.StringOutput {
	return o.ApplyT(func(v *FloatingIpAddress) pulumi.StringOutput { return v.Access }).(pulumi.StringOutput)
}

// The address family of the floating IP address.
func (o FloatingIpAddressOutput) Family() pulumi.StringOutput {
	return o.ApplyT(func(v *FloatingIpAddress) pulumi.StringOutput { return v.Family }).(pulumi.StringOutput)
}

// An UpCloud assigned IP Address.
func (o FloatingIpAddressOutput) IpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *FloatingIpAddress) pulumi.StringOutput { return v.IpAddress }).(pulumi.StringOutput)
}

// MAC address of a server interface to assign address to.
func (o FloatingIpAddressOutput) MacAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FloatingIpAddress) pulumi.StringPtrOutput { return v.MacAddress }).(pulumi.StringPtrOutput)
}

// Zone of the address, e.g. `de-fra1`. Required when assigning a detached floating IP address. You can list available
// zones with `upctl zone list`.
func (o FloatingIpAddressOutput) Zone() pulumi.StringOutput {
	return o.ApplyT(func(v *FloatingIpAddress) pulumi.StringOutput { return v.Zone }).(pulumi.StringOutput)
}

type FloatingIpAddressArrayOutput struct{ *pulumi.OutputState }

func (FloatingIpAddressArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FloatingIpAddress)(nil)).Elem()
}

func (o FloatingIpAddressArrayOutput) ToFloatingIpAddressArrayOutput() FloatingIpAddressArrayOutput {
	return o
}

func (o FloatingIpAddressArrayOutput) ToFloatingIpAddressArrayOutputWithContext(ctx context.Context) FloatingIpAddressArrayOutput {
	return o
}

func (o FloatingIpAddressArrayOutput) Index(i pulumi.IntInput) FloatingIpAddressOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FloatingIpAddress {
		return vs[0].([]*FloatingIpAddress)[vs[1].(int)]
	}).(FloatingIpAddressOutput)
}

type FloatingIpAddressMapOutput struct{ *pulumi.OutputState }

func (FloatingIpAddressMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FloatingIpAddress)(nil)).Elem()
}

func (o FloatingIpAddressMapOutput) ToFloatingIpAddressMapOutput() FloatingIpAddressMapOutput {
	return o
}

func (o FloatingIpAddressMapOutput) ToFloatingIpAddressMapOutputWithContext(ctx context.Context) FloatingIpAddressMapOutput {
	return o
}

func (o FloatingIpAddressMapOutput) MapIndex(k pulumi.StringInput) FloatingIpAddressOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FloatingIpAddress {
		return vs[0].(map[string]*FloatingIpAddress)[vs[1].(string)]
	}).(FloatingIpAddressOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FloatingIpAddressInput)(nil)).Elem(), &FloatingIpAddress{})
	pulumi.RegisterInputType(reflect.TypeOf((*FloatingIpAddressArrayInput)(nil)).Elem(), FloatingIpAddressArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FloatingIpAddressMapInput)(nil)).Elem(), FloatingIpAddressMap{})
	pulumi.RegisterOutputType(FloatingIpAddressOutput{})
	pulumi.RegisterOutputType(FloatingIpAddressArrayOutput{})
	pulumi.RegisterOutputType(FloatingIpAddressMapOutput{})
}
