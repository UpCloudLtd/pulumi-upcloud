// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package upcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Network peerings can be used to connect networks across accounts. For the network peering to become active, the peering must be made from both directions.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Network peering requires the networks to have routers attached to them.
//			_, err := upcloud.NewRouter(ctx, "this", &upcloud.RouterArgs{
//				Name: pulumi.String("network-peering-example-router"),
//			})
//			if err != nil {
//				return err
//			}
//			example, err := upcloud.NewNetwork(ctx, "example", &upcloud.NetworkArgs{
//				Name:   pulumi.String("network-peering-example-net"),
//				Zone:   pulumi.String("nl-ams1"),
//				Router: pulumi.Any(exampleUpcloudRouter.Id),
//				IpNetwork: &upcloud.NetworkIpNetworkArgs{
//					Address: pulumi.String("10.0.0.0/24"),
//					Dhcp:    pulumi.Bool(true),
//					Family:  pulumi.String("IPv4"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			var thisNetworkPeering []*upcloud.NetworkPeering
//			for index := 0; index < 1; index++ {
//				key0 := index
//				_ := index
//				__res, err := upcloud.NewNetworkPeering(ctx, fmt.Sprintf("this-%v", key0), &upcloud.NetworkPeeringArgs{
//					Name: pulumi.String("network-peering-example-peering"),
//					Network: &upcloud.NetworkPeeringNetworkArgs{
//						Uuid: example.ID(),
//					},
//					PeerNetwork: &upcloud.NetworkPeeringPeerNetworkArgs{
//						Uuid: pulumi.String("0305723a-e5cb-4ef6-985d-e36ed44d133a"),
//					},
//				})
//				if err != nil {
//					return err
//				}
//				thisNetworkPeering = append(thisNetworkPeering, __res)
//			}
//			return nil
//		})
//	}
//
// ```
type NetworkPeering struct {
	pulumi.CustomResourceState

	// Configured status of the network peering.
	ConfiguredStatus pulumi.StringOutput `pulumi:"configuredStatus"`
	// User defined key-value pairs to classify the network peering.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Name of the network peering.
	Name pulumi.StringOutput `pulumi:"name"`
	// Local network of the network peering.
	Network NetworkPeeringNetworkOutput `pulumi:"network"`
	// Peer network of the network peering.
	PeerNetwork NetworkPeeringPeerNetworkOutput `pulumi:"peerNetwork"`
}

// NewNetworkPeering registers a new resource with the given unique name, arguments, and options.
func NewNetworkPeering(ctx *pulumi.Context,
	name string, args *NetworkPeeringArgs, opts ...pulumi.ResourceOption) (*NetworkPeering, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Network == nil {
		return nil, errors.New("invalid value for required argument 'Network'")
	}
	if args.PeerNetwork == nil {
		return nil, errors.New("invalid value for required argument 'PeerNetwork'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NetworkPeering
	err := ctx.RegisterResource("upcloud:index/networkPeering:NetworkPeering", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetworkPeering gets an existing NetworkPeering resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetworkPeering(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkPeeringState, opts ...pulumi.ResourceOption) (*NetworkPeering, error) {
	var resource NetworkPeering
	err := ctx.ReadResource("upcloud:index/networkPeering:NetworkPeering", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NetworkPeering resources.
type networkPeeringState struct {
	// Configured status of the network peering.
	ConfiguredStatus *string `pulumi:"configuredStatus"`
	// User defined key-value pairs to classify the network peering.
	Labels map[string]string `pulumi:"labels"`
	// Name of the network peering.
	Name *string `pulumi:"name"`
	// Local network of the network peering.
	Network *NetworkPeeringNetwork `pulumi:"network"`
	// Peer network of the network peering.
	PeerNetwork *NetworkPeeringPeerNetwork `pulumi:"peerNetwork"`
}

type NetworkPeeringState struct {
	// Configured status of the network peering.
	ConfiguredStatus pulumi.StringPtrInput
	// User defined key-value pairs to classify the network peering.
	Labels pulumi.StringMapInput
	// Name of the network peering.
	Name pulumi.StringPtrInput
	// Local network of the network peering.
	Network NetworkPeeringNetworkPtrInput
	// Peer network of the network peering.
	PeerNetwork NetworkPeeringPeerNetworkPtrInput
}

func (NetworkPeeringState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkPeeringState)(nil)).Elem()
}

type networkPeeringArgs struct {
	// Configured status of the network peering.
	ConfiguredStatus *string `pulumi:"configuredStatus"`
	// User defined key-value pairs to classify the network peering.
	Labels map[string]string `pulumi:"labels"`
	// Name of the network peering.
	Name *string `pulumi:"name"`
	// Local network of the network peering.
	Network NetworkPeeringNetwork `pulumi:"network"`
	// Peer network of the network peering.
	PeerNetwork NetworkPeeringPeerNetwork `pulumi:"peerNetwork"`
}

// The set of arguments for constructing a NetworkPeering resource.
type NetworkPeeringArgs struct {
	// Configured status of the network peering.
	ConfiguredStatus pulumi.StringPtrInput
	// User defined key-value pairs to classify the network peering.
	Labels pulumi.StringMapInput
	// Name of the network peering.
	Name pulumi.StringPtrInput
	// Local network of the network peering.
	Network NetworkPeeringNetworkInput
	// Peer network of the network peering.
	PeerNetwork NetworkPeeringPeerNetworkInput
}

func (NetworkPeeringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkPeeringArgs)(nil)).Elem()
}

type NetworkPeeringInput interface {
	pulumi.Input

	ToNetworkPeeringOutput() NetworkPeeringOutput
	ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput
}

func (*NetworkPeering) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkPeering)(nil)).Elem()
}

func (i *NetworkPeering) ToNetworkPeeringOutput() NetworkPeeringOutput {
	return i.ToNetworkPeeringOutputWithContext(context.Background())
}

func (i *NetworkPeering) ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringOutput)
}

// NetworkPeeringArrayInput is an input type that accepts NetworkPeeringArray and NetworkPeeringArrayOutput values.
// You can construct a concrete instance of `NetworkPeeringArrayInput` via:
//
//	NetworkPeeringArray{ NetworkPeeringArgs{...} }
type NetworkPeeringArrayInput interface {
	pulumi.Input

	ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput
	ToNetworkPeeringArrayOutputWithContext(context.Context) NetworkPeeringArrayOutput
}

type NetworkPeeringArray []NetworkPeeringInput

func (NetworkPeeringArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkPeering)(nil)).Elem()
}

func (i NetworkPeeringArray) ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput {
	return i.ToNetworkPeeringArrayOutputWithContext(context.Background())
}

func (i NetworkPeeringArray) ToNetworkPeeringArrayOutputWithContext(ctx context.Context) NetworkPeeringArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringArrayOutput)
}

// NetworkPeeringMapInput is an input type that accepts NetworkPeeringMap and NetworkPeeringMapOutput values.
// You can construct a concrete instance of `NetworkPeeringMapInput` via:
//
//	NetworkPeeringMap{ "key": NetworkPeeringArgs{...} }
type NetworkPeeringMapInput interface {
	pulumi.Input

	ToNetworkPeeringMapOutput() NetworkPeeringMapOutput
	ToNetworkPeeringMapOutputWithContext(context.Context) NetworkPeeringMapOutput
}

type NetworkPeeringMap map[string]NetworkPeeringInput

func (NetworkPeeringMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkPeering)(nil)).Elem()
}

func (i NetworkPeeringMap) ToNetworkPeeringMapOutput() NetworkPeeringMapOutput {
	return i.ToNetworkPeeringMapOutputWithContext(context.Background())
}

func (i NetworkPeeringMap) ToNetworkPeeringMapOutputWithContext(ctx context.Context) NetworkPeeringMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringMapOutput)
}

type NetworkPeeringOutput struct{ *pulumi.OutputState }

func (NetworkPeeringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringOutput) ToNetworkPeeringOutput() NetworkPeeringOutput {
	return o
}

func (o NetworkPeeringOutput) ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput {
	return o
}

// Configured status of the network peering.
func (o NetworkPeeringOutput) ConfiguredStatus() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringOutput { return v.ConfiguredStatus }).(pulumi.StringOutput)
}

// User defined key-value pairs to classify the network peering.
func (o NetworkPeeringOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// Name of the network peering.
func (o NetworkPeeringOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkPeering) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Local network of the network peering.
func (o NetworkPeeringOutput) Network() NetworkPeeringNetworkOutput {
	return o.ApplyT(func(v *NetworkPeering) NetworkPeeringNetworkOutput { return v.Network }).(NetworkPeeringNetworkOutput)
}

// Peer network of the network peering.
func (o NetworkPeeringOutput) PeerNetwork() NetworkPeeringPeerNetworkOutput {
	return o.ApplyT(func(v *NetworkPeering) NetworkPeeringPeerNetworkOutput { return v.PeerNetwork }).(NetworkPeeringPeerNetworkOutput)
}

type NetworkPeeringArrayOutput struct{ *pulumi.OutputState }

func (NetworkPeeringArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringArrayOutput) ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput {
	return o
}

func (o NetworkPeeringArrayOutput) ToNetworkPeeringArrayOutputWithContext(ctx context.Context) NetworkPeeringArrayOutput {
	return o
}

func (o NetworkPeeringArrayOutput) Index(i pulumi.IntInput) NetworkPeeringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NetworkPeering {
		return vs[0].([]*NetworkPeering)[vs[1].(int)]
	}).(NetworkPeeringOutput)
}

type NetworkPeeringMapOutput struct{ *pulumi.OutputState }

func (NetworkPeeringMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringMapOutput) ToNetworkPeeringMapOutput() NetworkPeeringMapOutput {
	return o
}

func (o NetworkPeeringMapOutput) ToNetworkPeeringMapOutputWithContext(ctx context.Context) NetworkPeeringMapOutput {
	return o
}

func (o NetworkPeeringMapOutput) MapIndex(k pulumi.StringInput) NetworkPeeringOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NetworkPeering {
		return vs[0].(map[string]*NetworkPeering)[vs[1].(string)]
	}).(NetworkPeeringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringInput)(nil)).Elem(), &NetworkPeering{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringArrayInput)(nil)).Elem(), NetworkPeeringArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringMapInput)(nil)).Elem(), NetworkPeeringMap{})
	pulumi.RegisterOutputType(NetworkPeeringOutput{})
	pulumi.RegisterOutputType(NetworkPeeringArrayOutput{})
	pulumi.RegisterOutputType(NetworkPeeringMapOutput{})
}
