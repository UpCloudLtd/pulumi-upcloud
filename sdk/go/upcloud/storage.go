// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package upcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/UpCloudLtd/pulumi-upcloud/sdk/go/upcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages UpCloud [Block Storage](https://upcloud.com/products/block-storage) devices.
//
// ## Import
//
// ```sh
// $ pulumi import upcloud:index/storage:Storage example_storage 0128ae5a-91dd-4ebf-bd1e-304c47f2c652
// ```
type Storage struct {
	pulumi.CustomResourceState

	BackupRule StorageBackupRulePtrOutput `pulumi:"backupRule"`
	// Block defining another storage/template to clone to storage.
	Clone StorageClonePtrOutput `pulumi:"clone"`
	// If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
	DeleteAutoresizeBackup pulumi.BoolOutput `pulumi:"deleteAutoresizeBackup"`
	// Sets if the storage is encrypted at rest.
	Encrypt pulumi.BoolOutput `pulumi:"encrypt"`
	// If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `deleteAutoresizeBackup` option is set to true).
	// 				Taking and keeping backups incure costs.
	FilesystemAutoresize pulumi.BoolOutput `pulumi:"filesystemAutoresize"`
	// Block defining external data to import to storage
	Import StorageImportPtrOutput `pulumi:"import"`
	// User defined key-value pairs to classify the storage.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The size of the storage in gigabytes.
	Size pulumi.IntOutput `pulumi:"size"`
	// System defined key-value pairs to classify the storage. The keys of system defined labels are prefixed with underscore and can not be modified by the user.
	SystemLabels pulumi.StringMapOutput `pulumi:"systemLabels"`
	// The tier of the storage.
	Tier pulumi.StringOutput `pulumi:"tier"`
	// The title of the storage.
	Title pulumi.StringOutput `pulumi:"title"`
	// The type of the storage.
	Type pulumi.StringOutput `pulumi:"type"`
	// The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewStorage registers a new resource with the given unique name, arguments, and options.
func NewStorage(ctx *pulumi.Context,
	name string, args *StorageArgs, opts ...pulumi.ResourceOption) (*Storage, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Size == nil {
		return nil, errors.New("invalid value for required argument 'Size'")
	}
	if args.Title == nil {
		return nil, errors.New("invalid value for required argument 'Title'")
	}
	if args.Zone == nil {
		return nil, errors.New("invalid value for required argument 'Zone'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Storage
	err := ctx.RegisterResource("upcloud:index/storage:Storage", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetStorage gets an existing Storage resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetStorage(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *StorageState, opts ...pulumi.ResourceOption) (*Storage, error) {
	var resource Storage
	err := ctx.ReadResource("upcloud:index/storage:Storage", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Storage resources.
type storageState struct {
	BackupRule *StorageBackupRule `pulumi:"backupRule"`
	// Block defining another storage/template to clone to storage.
	Clone *StorageClone `pulumi:"clone"`
	// If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
	DeleteAutoresizeBackup *bool `pulumi:"deleteAutoresizeBackup"`
	// Sets if the storage is encrypted at rest.
	Encrypt *bool `pulumi:"encrypt"`
	// If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `deleteAutoresizeBackup` option is set to true).
	// 				Taking and keeping backups incure costs.
	FilesystemAutoresize *bool `pulumi:"filesystemAutoresize"`
	// Block defining external data to import to storage
	Import *StorageImport `pulumi:"import"`
	// User defined key-value pairs to classify the storage.
	Labels map[string]string `pulumi:"labels"`
	// The size of the storage in gigabytes.
	Size *int `pulumi:"size"`
	// System defined key-value pairs to classify the storage. The keys of system defined labels are prefixed with underscore and can not be modified by the user.
	SystemLabels map[string]string `pulumi:"systemLabels"`
	// The tier of the storage.
	Tier *string `pulumi:"tier"`
	// The title of the storage.
	Title *string `pulumi:"title"`
	// The type of the storage.
	Type *string `pulumi:"type"`
	// The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
	Zone *string `pulumi:"zone"`
}

type StorageState struct {
	BackupRule StorageBackupRulePtrInput
	// Block defining another storage/template to clone to storage.
	Clone StorageClonePtrInput
	// If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
	DeleteAutoresizeBackup pulumi.BoolPtrInput
	// Sets if the storage is encrypted at rest.
	Encrypt pulumi.BoolPtrInput
	// If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `deleteAutoresizeBackup` option is set to true).
	// 				Taking and keeping backups incure costs.
	FilesystemAutoresize pulumi.BoolPtrInput
	// Block defining external data to import to storage
	Import StorageImportPtrInput
	// User defined key-value pairs to classify the storage.
	Labels pulumi.StringMapInput
	// The size of the storage in gigabytes.
	Size pulumi.IntPtrInput
	// System defined key-value pairs to classify the storage. The keys of system defined labels are prefixed with underscore and can not be modified by the user.
	SystemLabels pulumi.StringMapInput
	// The tier of the storage.
	Tier pulumi.StringPtrInput
	// The title of the storage.
	Title pulumi.StringPtrInput
	// The type of the storage.
	Type pulumi.StringPtrInput
	// The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
	Zone pulumi.StringPtrInput
}

func (StorageState) ElementType() reflect.Type {
	return reflect.TypeOf((*storageState)(nil)).Elem()
}

type storageArgs struct {
	BackupRule *StorageBackupRule `pulumi:"backupRule"`
	// Block defining another storage/template to clone to storage.
	Clone *StorageClone `pulumi:"clone"`
	// If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
	DeleteAutoresizeBackup *bool `pulumi:"deleteAutoresizeBackup"`
	// Sets if the storage is encrypted at rest.
	Encrypt *bool `pulumi:"encrypt"`
	// If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `deleteAutoresizeBackup` option is set to true).
	// 				Taking and keeping backups incure costs.
	FilesystemAutoresize *bool `pulumi:"filesystemAutoresize"`
	// Block defining external data to import to storage
	Import *StorageImport `pulumi:"import"`
	// User defined key-value pairs to classify the storage.
	Labels map[string]string `pulumi:"labels"`
	// The size of the storage in gigabytes.
	Size int `pulumi:"size"`
	// The tier of the storage.
	Tier *string `pulumi:"tier"`
	// The title of the storage.
	Title string `pulumi:"title"`
	// The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
	Zone string `pulumi:"zone"`
}

// The set of arguments for constructing a Storage resource.
type StorageArgs struct {
	BackupRule StorageBackupRulePtrInput
	// Block defining another storage/template to clone to storage.
	Clone StorageClonePtrInput
	// If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
	DeleteAutoresizeBackup pulumi.BoolPtrInput
	// Sets if the storage is encrypted at rest.
	Encrypt pulumi.BoolPtrInput
	// If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `deleteAutoresizeBackup` option is set to true).
	// 				Taking and keeping backups incure costs.
	FilesystemAutoresize pulumi.BoolPtrInput
	// Block defining external data to import to storage
	Import StorageImportPtrInput
	// User defined key-value pairs to classify the storage.
	Labels pulumi.StringMapInput
	// The size of the storage in gigabytes.
	Size pulumi.IntInput
	// The tier of the storage.
	Tier pulumi.StringPtrInput
	// The title of the storage.
	Title pulumi.StringInput
	// The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
	Zone pulumi.StringInput
}

func (StorageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*storageArgs)(nil)).Elem()
}

type StorageInput interface {
	pulumi.Input

	ToStorageOutput() StorageOutput
	ToStorageOutputWithContext(ctx context.Context) StorageOutput
}

func (*Storage) ElementType() reflect.Type {
	return reflect.TypeOf((**Storage)(nil)).Elem()
}

func (i *Storage) ToStorageOutput() StorageOutput {
	return i.ToStorageOutputWithContext(context.Background())
}

func (i *Storage) ToStorageOutputWithContext(ctx context.Context) StorageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageOutput)
}

// StorageArrayInput is an input type that accepts StorageArray and StorageArrayOutput values.
// You can construct a concrete instance of `StorageArrayInput` via:
//
//	StorageArray{ StorageArgs{...} }
type StorageArrayInput interface {
	pulumi.Input

	ToStorageArrayOutput() StorageArrayOutput
	ToStorageArrayOutputWithContext(context.Context) StorageArrayOutput
}

type StorageArray []StorageInput

func (StorageArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Storage)(nil)).Elem()
}

func (i StorageArray) ToStorageArrayOutput() StorageArrayOutput {
	return i.ToStorageArrayOutputWithContext(context.Background())
}

func (i StorageArray) ToStorageArrayOutputWithContext(ctx context.Context) StorageArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageArrayOutput)
}

// StorageMapInput is an input type that accepts StorageMap and StorageMapOutput values.
// You can construct a concrete instance of `StorageMapInput` via:
//
//	StorageMap{ "key": StorageArgs{...} }
type StorageMapInput interface {
	pulumi.Input

	ToStorageMapOutput() StorageMapOutput
	ToStorageMapOutputWithContext(context.Context) StorageMapOutput
}

type StorageMap map[string]StorageInput

func (StorageMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Storage)(nil)).Elem()
}

func (i StorageMap) ToStorageMapOutput() StorageMapOutput {
	return i.ToStorageMapOutputWithContext(context.Background())
}

func (i StorageMap) ToStorageMapOutputWithContext(ctx context.Context) StorageMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageMapOutput)
}

type StorageOutput struct{ *pulumi.OutputState }

func (StorageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Storage)(nil)).Elem()
}

func (o StorageOutput) ToStorageOutput() StorageOutput {
	return o
}

func (o StorageOutput) ToStorageOutputWithContext(ctx context.Context) StorageOutput {
	return o
}

func (o StorageOutput) BackupRule() StorageBackupRulePtrOutput {
	return o.ApplyT(func(v *Storage) StorageBackupRulePtrOutput { return v.BackupRule }).(StorageBackupRulePtrOutput)
}

// Block defining another storage/template to clone to storage.
func (o StorageOutput) Clone() StorageClonePtrOutput {
	return o.ApplyT(func(v *Storage) StorageClonePtrOutput { return v.Clone }).(StorageClonePtrOutput)
}

// If set to true, the backup taken before the partition and filesystem resize attempt will be deleted immediately after success.
func (o StorageOutput) DeleteAutoresizeBackup() pulumi.BoolOutput {
	return o.ApplyT(func(v *Storage) pulumi.BoolOutput { return v.DeleteAutoresizeBackup }).(pulumi.BoolOutput)
}

// Sets if the storage is encrypted at rest.
func (o StorageOutput) Encrypt() pulumi.BoolOutput {
	return o.ApplyT(func(v *Storage) pulumi.BoolOutput { return v.Encrypt }).(pulumi.BoolOutput)
}

// If set to true, provider will attempt to resize partition and filesystem when the size of the storage changes. Please note that before the resize attempt is made, backup of the storage will be taken. If the resize attempt fails, the backup will be used to restore the storage and then deleted. If the resize attempt succeeds, backup will be kept (unless `deleteAutoresizeBackup` option is set to true).
//
//	Taking and keeping backups incure costs.
func (o StorageOutput) FilesystemAutoresize() pulumi.BoolOutput {
	return o.ApplyT(func(v *Storage) pulumi.BoolOutput { return v.FilesystemAutoresize }).(pulumi.BoolOutput)
}

// Block defining external data to import to storage
func (o StorageOutput) Import() StorageImportPtrOutput {
	return o.ApplyT(func(v *Storage) StorageImportPtrOutput { return v.Import }).(StorageImportPtrOutput)
}

// User defined key-value pairs to classify the storage.
func (o StorageOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Storage) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The size of the storage in gigabytes.
func (o StorageOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v *Storage) pulumi.IntOutput { return v.Size }).(pulumi.IntOutput)
}

// System defined key-value pairs to classify the storage. The keys of system defined labels are prefixed with underscore and can not be modified by the user.
func (o StorageOutput) SystemLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Storage) pulumi.StringMapOutput { return v.SystemLabels }).(pulumi.StringMapOutput)
}

// The tier of the storage.
func (o StorageOutput) Tier() pulumi.StringOutput {
	return o.ApplyT(func(v *Storage) pulumi.StringOutput { return v.Tier }).(pulumi.StringOutput)
}

// The title of the storage.
func (o StorageOutput) Title() pulumi.StringOutput {
	return o.ApplyT(func(v *Storage) pulumi.StringOutput { return v.Title }).(pulumi.StringOutput)
}

// The type of the storage.
func (o StorageOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Storage) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The zone the storage is in, e.g. `de-fra1`. You can list available zones with `upctl zone list`.
func (o StorageOutput) Zone() pulumi.StringOutput {
	return o.ApplyT(func(v *Storage) pulumi.StringOutput { return v.Zone }).(pulumi.StringOutput)
}

type StorageArrayOutput struct{ *pulumi.OutputState }

func (StorageArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Storage)(nil)).Elem()
}

func (o StorageArrayOutput) ToStorageArrayOutput() StorageArrayOutput {
	return o
}

func (o StorageArrayOutput) ToStorageArrayOutputWithContext(ctx context.Context) StorageArrayOutput {
	return o
}

func (o StorageArrayOutput) Index(i pulumi.IntInput) StorageOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Storage {
		return vs[0].([]*Storage)[vs[1].(int)]
	}).(StorageOutput)
}

type StorageMapOutput struct{ *pulumi.OutputState }

func (StorageMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Storage)(nil)).Elem()
}

func (o StorageMapOutput) ToStorageMapOutput() StorageMapOutput {
	return o
}

func (o StorageMapOutput) ToStorageMapOutputWithContext(ctx context.Context) StorageMapOutput {
	return o
}

func (o StorageMapOutput) MapIndex(k pulumi.StringInput) StorageOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Storage {
		return vs[0].(map[string]*Storage)[vs[1].(string)]
	}).(StorageOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*StorageInput)(nil)).Elem(), &Storage{})
	pulumi.RegisterInputType(reflect.TypeOf((*StorageArrayInput)(nil)).Elem(), StorageArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StorageMapInput)(nil)).Elem(), StorageMap{})
	pulumi.RegisterOutputType(StorageOutput{})
	pulumi.RegisterOutputType(StorageArrayOutput{})
	pulumi.RegisterOutputType(StorageMapOutput{})
}
